{"date": "2024-10-19 16:31", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 84.20223252621882, "dps_norm": 78.67511770954597, "pass@1": 80.23728813559322}, "eval": {"HumanEval/9": {"dps": 66.1489929628731, "dps_norm": 63.24786324786325, "pass@1": 13.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_so_far:\n            max_so_far = numbers[i]\n        rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    for i in range(1, len(numbers)):\n      max_so_far = max(max_so_far, numbers[i])\n      rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] > current_max:\n            current_max = numbers[i]\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for i in range(1, len(numbers)):\n      max_so_far = max(max_so_far, numbers[i])\n      rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n\n    rolling_max_list = [numbers[0]] \n    for i in range(1, len(numbers)):\n      rolling_max_list.append(max(rolling_max_list[-1], numbers[i]))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [numbers[0]]\n    for i in range(1, len(numbers)):\n      if numbers[i] > max_so_far:\n        max_so_far = numbers[i]\n      rolling_max_list.append(max_so_far)\n    return rolling_max_list", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n    \n    rolling_max_list = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_max_list.append(max(rolling_max_list[-1],numbers[i]))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_so_far = max(max_so_far, numbers[i])\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    for i in range(1, len(numbers)):\n      current_max = max(current_max, numbers[i])\n      rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    rolling_max_list = [numbers[0]] \n    for i in range(1, len(numbers)):\n        rolling_max_list.append(max(rolling_max_list[-1], numbers[i]))\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_maxes = [numbers[0]]\n    for i in range(1, len(numbers)):\n        rolling_maxes.append(max(rolling_maxes[-1], numbers[i]))\n    return rolling_maxes", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n      return []\n    \n    rolling_maximums = []\n    current_max = numbers[0]\n    for number in numbers:\n      current_max = max(current_max, number)\n      rolling_maximums.append(current_max)\n    return rolling_maximums", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    for i in range(1, len(numbers)):\n        max_so_far = max(max_so_far, numbers[i])\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n      for j in range(i+1, len(numbers)):\n        if abs(numbers[i] - numbers[j]) < threshold:\n          return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n      for j in range(i + 1, len(numbers)):\n        if abs(numbers[i] - numbers[j]) < threshold:\n          return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n      for j in range(i + 1, len(numbers)):\n        if abs(numbers[i] - numbers[j]) < threshold:\n          return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n      for j in range(i+1, len(numbers)):\n        if abs(numbers[i] - numbers[j]) < threshold:\n          return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n          if abs(numbers[i] - numbers[j]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n      for j in range(i+1, len(numbers)):\n        if abs(numbers[i] - numbers[j]) < threshold:\n          return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n      for j in range(i+1, len(numbers)):\n        if abs(numbers[i]-numbers[j]) < threshold:\n          return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 18.37025316455696, "dps_norm": 62.5, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(numbers)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(number - mean) for number in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n      return 0\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum([abs(x - mean) for x in numbers]) / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    data_mean = mean(numbers)\n    absolute_deviations = [abs(x - data_mean) for x in numbers]\n    return mean(absolute_deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum([abs(x - mean) for x in numbers]) / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_val = mean(numbers)\n    return sum(abs(x - mean_val) for x in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom typing import Any\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(numbers)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = statistics.mean(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return statistics.mean(absolute_deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n      return 0\n    mean = sum(numbers) / n\n    return sum([abs(x - mean) for x in numbers]) / n", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n      return 0\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n      return 0\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "matching_cluster_idx": 3}]}, "HumanEval/16": {"dps": 79.06976744186046, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(c.lower() for c in string))", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(char.lower() for char in string))", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(char.lower() for char in string))", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(c.lower() for c in string))", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    string = string.lower()\n    return len(set(string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set(string.lower())\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(char.lower() for char in string))", "matching_cluster_idx": 2}]}, "HumanEval/20": {"dps": 84.21307506053269, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    smallest_difference = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers) - 1):\n      difference = numbers[i + 1] - numbers[i]\n      if difference < smallest_difference:\n        smallest_difference = difference\n        closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1]) if numbers[0] < numbers[1] else (numbers[1], numbers[0])\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j]) if numbers[i] < numbers[j] else (numbers[j], numbers[i])\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    closest_pair = (float('inf'), float('inf'))\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1]) \n    for i in range(len(numbers)-1):\n      diff = numbers[i+1]-numbers[i]\n      if diff < min_diff:\n        min_diff = diff\n        closest_pair = (numbers[i],numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers) -1):\n      diff = numbers[i+1] - numbers[i]\n      if diff < min_diff:\n        min_diff = diff\n        closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_difference = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        difference = numbers[i + 1] - numbers[i]\n        if difference < min_difference:\n            min_difference = difference\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    \n    min_difference = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            difference = abs(numbers[i] - numbers[j])\n            if difference < min_difference:\n                min_difference = difference\n                closest_pair = (numbers[i], numbers[j])\n    \n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1]) \n    for i in range(len(numbers) - 1):\n      diff = numbers[i+1] - numbers[i]\n      if diff < min_diff:\n        min_diff = diff\n        closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    smallest_difference = float('inf')\n    closest_pair = (numbers[0], numbers[1]) \n\n    for i in range(len(numbers) - 1):\n        difference = numbers[i + 1] - numbers[i]\n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers) -1):\n      diff = numbers[i+1]-numbers[i]\n      if diff < min_diff:\n        min_diff = diff\n        closest_pair = (numbers[i],numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    closest_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n      diff = numbers[i+1] - numbers[i]\n      if diff < closest_diff:\n        closest_diff = diff\n        closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    closest_elements = (numbers[0], numbers[1])\n    min_distance = abs(numbers[0] - numbers[1])\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            distance = abs(numbers[i] - numbers[j])\n            if distance < min_distance:\n                min_distance = distance\n                closest_elements = (numbers[i], numbers[j])\n                \n    return tuple(sorted(closest_elements))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 88.70748299319729, "dps_norm": 56.875, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2,0, -1):\n        if n % i == 0:\n          return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n          return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n      if n % i == 0:\n        return i", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/31": {"dps": 52.9746835443038, "dps_norm": 75.625, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    # Check if n is divisible by 2\n    if n % 2 == 0:\n        return False\n    # Check for divisibility by odd numbers from 3 to the square root of n\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n      return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    # 2 is the only even prime number\n    if n <= 3:\n        return True\n\n    # Check if n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n      return False\n    for i in range(2, int(n**0.5) + 1):\n      if n % i == 0:\n        return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    # Check if n is divisible by any number from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n      return False\n    for i in range(2, int(n**0.5) + 1):\n      if n % i == 0:\n        return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    # Check if n is divisible by any number from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n      return False\n    for i in range(2, int(n**0.5) + 1):\n      if n % i == 0:\n        return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return False\n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 46.67824074074074, "dps_norm": 76.81818181818181, "pass@1": 79.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    sorted_third_values = sorted([l[i] for i in third_indices])\n    result = l.copy()\n    for i, index in enumerate(third_indices):\n        result[index] = sorted_third_values[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(l_sorted[j])\n            j += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    result = l[:]\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_values = [l[i] for i in third_indices]\n    third_values.sort()\n    for i, index in enumerate(third_indices):\n        result[index] = third_values[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    sorted_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = l.copy()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements.pop(0)\n    return result", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    new_list = l[:]  # Create a copy of the input list to avoid modifying the original\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            new_list[i] = third_elements.pop(0)\n    return new_list", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(l_sorted[j])\n            j += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    sorted_third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 3 == 0:\n        result.append(sorted_third_elements.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    new_list = []\n    for i in range(len(l)):\n      if i % 3 == 0:\n        new_list.append(l_sorted.pop(0))\n      else:\n        new_list.append(l[i])\n    return new_list", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    new_list = l.copy()\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_values = [l[i] for i in third_indices]\n    third_values.sort()\n    for i, index in enumerate(third_indices):\n      new_list[index] = third_values[i]\n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_prime = l[:] \n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    values = [l[i] for i in third_indices]\n    values.sort()\n    for i, index in enumerate(third_indices):\n        l_prime[index] = values[i]\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    result = l[:] # Create a copy of the input list\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n    for i in range(len(l)):\n        if i % 3 == 0:\n          result[i] = third_elements.pop(0)\n    return result", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    result = l[:]  # Create a copy of the list\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = third_elements.pop(0)\n    return result", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(l_sorted[j])\n            j += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_prime = l.copy()\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime[i] = third_elements.pop(0)\n    return l_prime", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    j = 0\n    for i in range(len(l)):\n      if i % 3 == 0:\n        result.append(l_sorted[j])\n        j += 1\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_prime = l.copy()\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n    for i in range(len(l)):\n      if i % 3 == 0:\n        l_prime[i] = third_elements.pop(0)\n    return l_prime", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    j = 0\n    for i in range(len(l)):\n      if i % 3 == 0:\n        result.append(l_sorted[j])\n        j += 1\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_indices = [i for i in range(len(l)) if i % 3 == 0]\n    third_values = [l[i] for i in third_indices]\n    third_values.sort()\n    l_sorted = [l[i] if i % 3 != 0 else third_values.pop(0) for i in range(len(l))]\n    return l_sorted", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_sorted = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    l_result = [l[i] if i % 3 != 0 else l_sorted.pop(0) for i in range(len(l))]\n    return l_result", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    new_list = l[:]\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n    for i in range(len(l)):\n      if i % 3 == 0:\n        new_list[i] = third_elements.pop(0)\n    return new_list", "matching_cluster_idx": 7}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\") \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n        count += str(i).count('7') \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if i % 11 == 0 or i % 13 == 0:\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n          count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n          count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            for digit in str(i):\n                if digit == '7':\n                    count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7') \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if (i % 11 == 0 or i % 13 == 0):\n        count += str(i).count('7')  \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if i % 11 == 0 or i % 13 == 0:\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if i % 11 == 0 or i % 13 == 0:\n        for digit in str(i):\n          if digit == '7':\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if i % 11 == 0 or i % 13 == 0:\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\") \n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    count = 0\n    for i in range(n):\n      if i % 11 == 0 or i % 13 == 0:\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    count = 0\n    for i in range(n):\n      if (i % 11 == 0 or i % 13 == 0):\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n      if i % 11 == 0 or i % 13 == 0:\n        count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = [None] * len(l)\n    result[::2] = even_nums\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    even_indices.sort()\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n          result.append(even_indices.pop(0))\n        else:\n          result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    l_prime = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        l_prime.append(even_nums.pop(0))\n      else:\n        l_prime.append(l[i])\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i%2 == 0])\n    result = []\n    j = 0\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_nums[j])\n        j += 1\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = [None] * len(l)\n    result[::2] = even_elements\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = [None] * len(l)\n    result[::2] = even_nums \n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_nums.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    even_indices.sort()\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices.pop(0))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_indices.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    new_list = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        new_list.append(even_indices.pop(0))\n      else:\n        new_list.append(l[i])\n    return new_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_indices.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = [None] * len(l)\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result[i] = even_nums.pop(0)\n        else:\n            result[i] = l[i]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = l[::2]\n    even_indices.sort()\n    sorted_list = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        sorted_list.append(even_indices.pop(0))\n      else:\n        sorted_list.append(l[i])\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_nums.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_numbers = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_numbers.pop(0))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i%2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_nums.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = [None] * len(l)\n    result[::2] = even_nums\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_indices.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n      if i % 2 == 0:\n        result.append(even_indices.pop(0))\n      else:\n        result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_nums = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_nums.pop(0))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([letter for letter in text if letter not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''.join([letter for letter in text if letter not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = []\n    for char in text:\n        if char not in vowels:\n            result.append(char)\n    return \"\".join(result)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([letter for letter in text if letter not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result = \"\".join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 79.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = list(set(l1) & set(l2))\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = list(set(l1) & set(l2))  # Using set intersection for efficiency\n    common_elements.sort() # Sorting the common elements\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n      largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n      if n % i:\n        i += 1\n      else:\n        n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i \n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:  # handle the case where n itself is prime\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n\n    # Divide by 2 until n is odd\n    while n % 2 == 0:\n      largest_factor = 2\n      n //= 2\n\n    # Check odd divisors from 3 up to the square root of n\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 2\n    \n    # If n is greater than 1 at this point, it's the largest prime factor\n    if n > 1:\n        largest_factor = n\n        \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            largest_factor = i\n            n //= i\n        else:\n            i += 1\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 77.20779220779221, "dps_norm": 58.125, "pass@1": 25.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n      if letter in vowels:\n        count += 1\n    if s.lower().endswith('y'):\n      count+=1\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n      count += 1    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    count = 0\n    for i, char in enumerate(s.lower()):\n      if char in vowels:\n        count += 1\n      elif char == 'y' and i == len(s) - 1:\n        count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n      count +=1\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n      if char in vowels:\n        count +=1\n    if s.lower().endswith('y'):\n      count+=1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n      if letter in vowels:\n        count += 1\n    if s.lower().endswith('y'):\n      count +=1 \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for i in s.lower():\n        if i in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n      count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    count = 0\n    for i in range(len(s)):\n      if s[i].lower() in vowels:\n        count += 1\n    if s.lower().endswith('y'):\n      count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    count = 0\n    for letter in s.lower():\n      if letter in vowels:\n        count += 1\n    if s.lower().endswith('y'):\n      count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n      if char in vowels:\n        count += 1\n    if s.lower().endswith('y'):\n      count+=1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n      count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n        if letter in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n      count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for letter in s.lower():\n      if letter in vowels:\n        count += 1\n    if s.lower().endswith('y'):\n      count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for letter in s:\n        if letter in vowels:\n          count += 1\n    if s.lower().endswith('y'):\n      count += 1 \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 99.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n\n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n\n    if total_chars1 < total_chars2:\n      return lst1\n    elif total_chars2 < total_chars1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum([len(s) for s in lst1])\n    len2 = sum([len(s) for s in lst2])\n\n    if len1 < len2:\n      return lst1\n    elif len2 < len1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n\n    if len1 < len2:\n      return lst1\n    elif len2 < len1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum([len(x) for x in lst1])\n    total2 = sum([len(x) for x in lst2])\n\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_len1 = sum(len(word) for word in lst1)\n    total_len2 = sum(len(word) for word in lst2)\n\n    if total_len1 < total_len2:\n      return lst1\n    elif total_len2 < total_len1:\n      return lst2\n    else: \n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n\n    total_len1 = sum(len(s) for s in lst1)\n    total_len2 = sum(len(s) for s in lst2)\n    if total_len1 < total_len2:\n        return lst1\n    elif total_len2 < total_len1:\n        return lst2\n    else: \n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    total1 = sum(len(x) for x in lst1)\n    total2 = sum(len(x) for x in lst2)\n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(x) for x in lst1)\n    total2 = sum(len(x) for x in lst2)\n    \n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    if total_chars_lst1 < total_chars_lst2:\n      return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_length1 = sum(len(s) for s in lst1)\n    total_length2 = sum(len(s) for s in lst2)\n    if total_length1 < total_length2:\n      return lst1\n    elif total_length2 < total_length1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n\n    return lst1 if total1 <= total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n\n    if total1 < total2:\n      return lst1\n    elif total2 < total1:\n      return lst2\n    else:\n      return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 96.36138613861385, "dps_norm": 65.83333333333334, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2): \n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n        total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum = 0\n    for i in range(1,len(lst),2):\n        if lst[i]%2 == 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n        total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i]%2==0:\n        total+= lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1,len(lst),2):\n      if lst[i]%2 == 0:\n        total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i]%2==0:\n          sum += lst[i]\n    return sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    sum = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n        sum += lst[i]\n    return sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n          total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n        total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n        total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n        total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n      if lst[i] % 2 == 0:\n          total += lst[i]\n    return total", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/87": {"dps": 78.19884726224784, "dps_norm": 52.85714285714286, "pass@1": 57.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, value in enumerate(row):\n        if value == x:\n          result.append((row_index, col_index))\n\n    result.sort(key=lambda item: (item[0], -item[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                result.append((i, j))\n\n    result.sort(key=lambda item: (item[0], -item[1]))  \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n      for j, num in enumerate(row):\n        if num == x:\n          result.append((i, j))\n    result.sort() #Sort by rows\n    for i in range(len(result)):\n      for j in range(len(result)-1):\n        if result[j][0] == result[j+1][0] and result[j][1] < result[j+1][1]:\n          result[j], result[j+1] = result[j+1], result[j] #Sort by column (descending)\n\n    return result", "matching_cluster_idx": 0}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, element in enumerate(row):\n            if element == x:\n                result.append((row_index, col_index))\n    \n    result.sort(key=lambda x: (x[0], -x[1])) # Sort by row, then column in descending order\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, value in enumerate(row):\n        if value == x:\n          result.append((row_index, col_index))\n    \n    result.sort(key=lambda x: (x[0], -x[1])) # sort by row, then by column (descending)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, element in enumerate(row):\n        if element == x:\n          result.append((row_index, col_index))\n    \n    result.sort(key=lambda tup: (tup[0], -tup[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, value in enumerate(row):\n        if value == x:\n          result.append((row_index, col_index))\n\n    result.sort()\n    for i in range(len(result)):\n      for j in range(i+1, len(result)):\n        if result[i][0] == result[j][0] and result[i][1] < result[j][1]:\n          result[i], result[j] = result[j], result[i]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, val in enumerate(row):\n            if val == x:\n                result.append((row_index, col_index))\n\n    result.sort(key=lambda coord: (coord[0], -coord[1]))  \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, val in enumerate(row):\n        if val == x:\n          result.append((row_index, col_index))\n\n    result.sort(key=lambda item: (item[0], -item[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, value in enumerate(row):\n        if value == x:\n          result.append((row_index, col_index))\n    result.sort(key=lambda item: (item[0], -item[1])) # Sort by row then descending column\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, val in enumerate(row):\n            if val == x:\n                result.append((row_index, col_index))\n    result.sort()\n    for i in range(len(result)):\n        for j in range(i + 1, len(result)):\n            if result[i][0] == result[j][0] and result[i][1] < result[j][1]:\n                result[i], result[j] = result[j], result[i]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n\n    result.sort(key=lambda coord: (coord[0], -coord[1]))  # Sort by row then column (descending)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n      for j, element in enumerate(row):\n        if element == x:\n          result.append((i,j))\n    return sorted(result, key=lambda x: (x[0], -x[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    result.sort(key=lambda x: (x[0], -x[1])) \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n\n    result.sort(key=lambda item: (item[0], -item[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, val in enumerate(row):\n            if val == x:\n                result.append((row_index, col_index))\n    \n    result.sort(key=lambda item: (item[0], -item[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, val in enumerate(row):\n            if val == x:\n                result.append((row_index, col_index))\n    \n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n      for j, num in enumerate(row):\n        if num == x:\n          result.append((i, j))\n\n    result.sort()\n    for i in range(len(result)):\n      for j in range(i + 1, len(result)):\n        if result[i][0] == result[j][0] and result[i][1] < result[j][1]:\n          result[i], result[j] = result[j], result[i]\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n      for col_index, value in enumerate(row):\n        if value == x:\n          result.append((row_index, col_index))\n    result.sort(key=lambda item: (item[0], -item[1]))  \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)  \n        else:\n            shifted_char = char\n        result.append(shifted_char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n  \"\"\"Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  \"\"\"\n  result = []\n  for char in s:\n    if char.isalpha():\n      start = ord('a') if char.islower() else ord('A')\n      shifted_char = chr((ord(char) - start + 4) % 26 + start) \n      result.append(shifted_char)\n    else:\n      result.append(char)\n  return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for letter in s:\n        if letter.isalpha():\n            start = ord('a') if letter.islower() else ord('A')\n            shifted_letter = chr((ord(letter) - start + 4) % 26 + start)\n        else:\n            shifted_letter = letter\n        result.append(shifted_letter)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + (2 * 2)) % 26 + start)\n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n      if char.isalpha():\n        start = ord('a') if char.islower() else ord('A')\n        shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        result.append(shifted_char)\n      else:\n        result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n      if char.isalpha():\n        start = ord('a') if char.islower() else ord('A')\n        shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        result.append(shifted_char)\n      else:\n        result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n      if char.isalpha():\n        start = ord('a') if char.islower() else ord('A')\n        shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        result.append(shifted_char)\n      else:\n        result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n      if char.isalpha():\n        start = ord('a') if char.islower() else ord('A')\n        shifted_char = chr((ord(char) - start + (2*2)) % 26 + start)\n      else:\n        shifted_char = char \n      result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)  \n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n  \"\"\"Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  \"\"\"\n  result = []\n  for char in s:\n    if char.isalpha():\n      start = ord('a') if char.islower() else ord('A')\n      shifted_char = chr((ord(char) - start + 4) % 26 + start) \n    else:\n      shifted_char = char\n    result.append(shifted_char)\n  return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)  \n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n          start = ord('a') if char.islower() else ord('A')\n          shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        else:\n          shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n          start = ord('a') if char.islower() else ord('A')\n          shifted_char = chr((ord(char) - start + 4) % 26 + start) \n        else:\n          shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n          start = ord('a') if char.islower() else ord('A')\n          shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        else:\n          shifted_char = char\n        result.append(shifted_char)\n    return \"\".join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start) \n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        else:\n            shifted_char = char\n        result.append(shifted_char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n      if char.isalpha():\n        start = ord('a') if char.islower() else ord('A')\n        shifted_char = chr((ord(char) - start + 4) % 26 + start)\n        result.append(shifted_char)\n      else:\n        result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 72.68482490272373, "dps_norm": 56.66666666666667, "pass@1": 74.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(set(lst))  # Remove duplicates and sort\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_sorted_lst = sorted(set(lst))\n    if len(unique_sorted_lst) < 2:\n      return None\n    \n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n    \n    # Find the smallest element\n    smallest = min(lst)\n\n    # Find the second smallest element \n    second_smallest = float('inf')  # Initialize with a large value\n    for num in lst:\n        if num != smallest and num < second_smallest:\n            second_smallest = num\n    \n    if second_smallest == float('inf'):\n      return None\n    else:\n      return second_smallest", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_elements = sorted(set(lst)) \n    return unique_elements[1] if len(unique_elements) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    #Find the smallest and second smallest elements\n    smallest = min(lst)\n    second_smallest = float('inf') \n    for num in lst:\n        if num != smallest and num < second_smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n      return None\n\n    return second_smallest", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n    \n    unique_lst = sorted(set(lst))  \n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n    if len(lst) < 2:\n        return None\n    \n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n    \n    # Find the smallest element\n    smallest = sorted_lst[0]\n    \n    # Find the next smallest element\n    for i in range(1, len(sorted_lst)):\n        if sorted_lst[i] != smallest:\n            return sorted_lst[i]\n    \n    return None", "matching_cluster_idx": 10}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n    \n    unique_lst = sorted(set(lst))\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n    \n    unique_lst = sorted(set(lst))\n    \n    if len(unique_lst) < 2:\n      return None\n    \n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n\n    smallest = min(lst)\n    second_smallest = float('inf')\n    for num in lst:\n      if num != smallest and num < second_smallest:\n        second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = sorted(set(lst))\n\n    if len(unique_lst) < 2:\n        return None\n\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(set(lst))\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n      return None\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Find the smallest and second smallest elements\n    smallest = min(lst)\n    second_smallest = float('inf') \n    for num in lst:\n        if num != smallest and num < second_smallest:\n            second_smallest = num\n    \n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n      return None\n    \n    unique_lst = sorted(set(lst))\n\n    if len(unique_lst) < 2:\n      return None\n    \n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n    if len(lst) < 2:  \n      return None\n\n    # Sort a copy of the list to avoid modifying the original\n    sorted_lst = sorted(lst)\n\n    # Find the second smallest element (skipping duplicates)\n    second_smallest = None\n    for i in range(1, len(sorted_lst)):\n        if sorted_lst[i] != sorted_lst[0]:\n            second_smallest = sorted_lst[i]\n            break \n\n    return second_smallest", "matching_cluster_idx": 10}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 94.32048681541582, "dps_norm": 64.16666666666667, "pass@1": 82.0, "profiled": [{"solution": "def odd_count(lst):\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0) \n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\") \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for s in lst:\n        odd_count = sum(int(d) % 2 for d in s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n  result = []\n  for s in lst:\n    odd_digits = sum(int(d)%2 !=0 for d in s)\n    result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n  return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(\"the number of odd elements \" + str(odd_count) + \"n the str\" + str(odd_count) + \"ng \" + str(odd_count) + \" of the \" + str(odd_count) + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\") \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for s in lst:\n      odd_count = sum(int(digit) % 2 for digit in s) \n      result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(int(digit) % 2 for digit in s)\n    return [\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n        count_odds(s), count_odds(s), count_odds(s), count_odds(s)) for s in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for s in lst:\n        odd_count = sum(int(digit) % 2 for digit in s)\n        result.append(\"the number of odd elements \" + str(odd_count) + \"n the str\" + str(odd_count) + \"ng \" + str(odd_count) + \" of the \" + str(odd_count) + \"nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n      odd_count = sum(1 for d in s if int(d) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n  \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> odd_count(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> odd_count(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  \"\"\"\n  output = []\n  for string in lst:\n    odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n    output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\") \n  return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n      odd_digits = sum(1 for d in s if int(d) % 2 != 0)\n      result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits, odd_digits, odd_digits, odd_digits))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for s in lst:\n      odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n      result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 95.0, "dps_norm": 95.0, "pass@1": 60.0, "profiled": [{"solution": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n    str1, str2 = lst\n    for combination in [str1 + str2, str2 + str1]:\n      balance = 0\n      for char in combination:\n        if char == '(':\n          balance += 1\n        elif char == ')':\n          balance -= 1\n        if balance < 0:\n          break\n      if balance == 0:\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    \"\"\"\n    s1, s2 = lst\n    for s in [s1 + s2, s2 + s1]:\n      balance = 0\n      for char in s:\n        if char == '(':\n          balance += 1\n        else:\n          balance -= 1\n        if balance < 0:\n          break\n      if balance == 0:\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    def is_balanced(s):\n      count = 0\n      for char in s:\n        if char == '(':\n          count += 1\n        elif char == ')':\n          count -= 1\n        if count < 0:\n          return False\n      return count == 0\n\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    for comb in [s1 + s2, s2 + s1]:\n        balance = 0\n        for paren in comb:\n            if paren == '(':\n                balance += 1\n            elif paren == ')':\n                balance -= 1\n            if balance < 0:\n                break  \n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    for s1, s2 in [(lst[0] + lst[1], ''), (lst[1] + lst[0], '')]:\n        if is_balanced(s1):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    s1, s2 = lst\n    for combined in [s1+s2, s2+s1]:\n      count = 0\n      for char in combined:\n        if char == '(':\n          count += 1\n        else:\n          count -= 1\n        if count < 0:  \n          break\n      if count == 0:\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst[0], lst[1]\n    for s in [s1 + s2, s2 + s1]:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:  # Close paren without matching open paren\n                break\n        if balance == 0:  # Balanced\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst[0], lst[1]\n    for s in [s1 + s2, s2 + s1]:\n      count = 0\n      for c in s:\n        if c == '(':\n          count += 1\n        elif c == ')':\n          count -= 1\n        if count < 0:\n          break\n      if count == 0:\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    for perm in [s1 + s2, s2 + s1]:\n        count = 0\n        for char in perm:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                break\n        if count == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    \n    # Helper function to check if a string is balanced\n    def is_balanced(s):\n      count = 0\n      for char in s:\n        if char == '(':\n          count += 1\n        elif char == ')':\n          count -= 1\n        if count < 0:  \n          return False\n      return count == 0\n\n    # Try concatenating in both orders\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    s1, s2 = lst\n    for comb in [s1 + s2, s2 + s1]:\n        balance = 0\n        for paren in comb:\n            if paren == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst[0], lst[1]\n    for s in [s1 + s2, s2 + s1]:\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                break\n        if count == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    s1, s2 = lst\n    for s in [s1 + s2, s2 + s1]:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    for combined in [s1 + s2, s2 + s1]:\n      count = 0\n      for char in combined:\n        if char == '(':\n          count += 1\n        elif char == ')':\n          count -= 1\n        if count < 0:\n          break\n      if count == 0:\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    s1, s2 = lst\n    for comb in [s1 + s2, s2 + s1]:\n      count = 0\n      for char in comb:\n        if char == '(':\n          count += 1\n        else:\n          count -= 1\n        if count < 0:\n          break\n      if count == 0:\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    for perm in [s1 + s2, s2 + s1]:\n        balance = 0\n        for char in perm:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    s1, s2 = lst\n    for s in [s1 + s2, s2 + s1]:\n      count = 0\n      for char in s:\n        if char == '(':\n          count += 1\n        elif char == ')':\n          count -= 1\n        if count < 0:\n          break\n      if count == 0:\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n    for s in [s1 + s2, s2 + s1]:\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:  # Close parenthesis without matching open one\n                break\n        if count == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst[0], lst[1]\n    for s in [s1 + s2, s2 + s1]:\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                break\n        if count == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    from collections import deque\n    s1 = deque(lst[0])\n    s2 = deque(lst[1])\n    \n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    for _ in range(2): # Try both concatenations\n        combined = s1 + s2\n        if is_balanced(combined):\n            return 'Yes'\n        s1, s2 = s2, s1  # Swap the strings for the second attempt\n\n    return 'No'", "matching_cluster_idx": -1}]}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/121": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 73.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    result = [word for word in lst if len(word) % 2 == 0]\n    result.sort(key=lambda x: (len(x), x))\n    return result", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n  \"\"\"Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  \"\"\"\n  return sorted([word for word in lst if len(word) % 2 == 0], key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n\n    result = [word for word in lst if len(word) % 2 == 0]\n    result.sort(key=lambda x: (len(x), x))\n    return result", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n  \"\"\"Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  \"\"\"\n\n  return sorted([word for word in lst if len(word) % 2 == 0], key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    result = [word for word in lst if len(word) % 2 == 0]\n    return sorted(result, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n  \"\"\"Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  \"\"\"\n  return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    return sorted(even_length_words, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    \n    #Filter for even length strings\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort by length then alphabetically\n    return sorted(even_length_words, key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda word: (len(word), word))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda word: (len(word), word))", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 60.33898305084745, "dps_norm": 77.5, "pass@1": 99.0, "profiled": [{"solution": "def is_not_prime(number):\n  \"\"\"\n  This function checks if a given number is not a prime number.\n\n  Args:\n      number: The number to be checked.\n\n  Returns:\n      True if the number is not prime, False otherwise.\n  \"\"\"\n  # Prime numbers are greater than 1\n  if number <= 1:\n    return True\n  # Check for divisibility from 2 to the square root of the number\n  for i in range(2, int(number**0.5) + 1):\n    if number % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(number):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n      number: The number to check.\n\n    Returns:\n      True if the number is not prime, False otherwise.\n    \"\"\"\n\n    if number <= 1:\n        return True\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(number):\n  \"\"\"\n  This function determines if a number is not prime.\n\n  Args:\n    number: An integer.\n\n  Returns:\n    True if the number is not prime, False otherwise.\n  \"\"\"\n  # Prime numbers are greater than 1\n  if number <= 1:\n    return True\n  # Check if the number is divisible by any number from 2 to the square root of the number\n  for i in range(2, int(number**0.5) + 1):\n    if number % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(n):\n  \"\"\"\n  Checks if a number is not prime.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    True if n is not prime, False otherwise.\n  \"\"\"\n  if n <= 1:\n    return True\n  for i in range(2, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(n):\n  \"\"\"\n  This function determines if a number is not prime.\n\n  Args:\n    n: The number to be checked.\n\n  Returns:\n    True if n is not prime, False otherwise.\n  \"\"\"\n  # Prime numbers are greater than 1\n  if n <= 1:\n    return True\n  # Check for divisibility from 2 to the square root of n\n  for i in range(2, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n      return True\n  return False  # If no divisors found, it's prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(number):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n      number: The number to check.\n\n    Returns:\n      True if the number is not prime, False otherwise.\n    \"\"\"\n    # Prime numbers are greater than 1\n    if number <= 1:\n      return True\n    # Check if number is divisible by any number from 2 to the square root of the number\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(number):\n  \"\"\"\n  This function checks if a given number is not a prime number.\n\n  Args:\n      number: An integer\n\n  Returns:\n      True if the number is not prime, False otherwise.\n  \"\"\"\n  if number <= 1:\n    return True\n  if number <= 3:\n    return False\n  if number % 2 == 0 or number % 3 == 0:\n    return True\n  i = 5\n  while i * i <= number:\n    if number % i == 0 or number % (i + 2) == 0:\n      return True\n    i += 6\n  return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  Checks if a number is not prime.\n\n  Args:\n    n: The number to check.\n\n  Returns:\n    True if the number is not prime, False otherwise.\n  \"\"\"\n\n  if n <= 1:\n    return True\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(num):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    Args:\n    num: An integer.\n    \n    Returns:\n    True if the number is not prime, False otherwise.\n\n    Note: This function considers 1 to be not prime.\n    \"\"\"\n    if num <= 1:\n      return True\n    for i in range(2, int(math.sqrt(num)) + 1):\n      if num % i == 0:\n        return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"Returns True if n is not a prime number, False otherwise.\"\"\"\n  if n <= 1:\n    return True\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(number):\n    \"\"\"\n    Checks if a number is not a prime number.\n\n    Args:\n      number: An integer.\n\n    Returns:\n      True if the number is not prime, False otherwise.\n    \"\"\"\n    # Prime numbers are greater than 1\n    if number <= 1:\n      return True\n    # Check if number is divisible by any number from 2 to the square root of the number\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  Identifies if a number is not prime.\n\n  Args:\n      n: An integer.\n\n  Returns:\n      True if n is not prime, False otherwise.\n  \"\"\"\n  if n <= 1:\n    return True\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  Determines if a number is not prime.\n\n  Args:\n    n: The number to check.\n\n  Returns:\n    True if n is not prime, False otherwise.\n  \"\"\"\n  if n <= 1:\n    return True\n  if n <= 3:\n    return False\n  if n % 2 == 0 or n % 3 == 0:\n    return True\n  i = 5\n  while i * i <= n:\n    if n % i == 0 or n % (i + 2) == 0:\n      return True\n    i += 6\n  return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  Determines if a number is not prime.\n\n  Args:\n    n: The number to check.\n\n  Returns:\n    True if the number is not prime, False otherwise.\n  \"\"\"\n  if n <= 1:\n    return True\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n\n    Args:\n        n: The number to check.\n\n    Returns:\n        True if the number is not prime, False otherwise.\n    \"\"\"\n    # Prime numbers are greater than 1\n    if n <= 1:\n        return True\n    # 2 is the only even prime number\n    if n == 2:\n        return False\n    # Check if divisible by 2\n    if n % 2 == 0:\n        return True\n    # Iterate from 3 to the square root of n, checking divisibility\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 2\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  Determines if a given number is not prime.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    True if n is not prime, False otherwise.\n  \"\"\"\n\n  if n <= 1:\n    return True\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  This function determines if a number is not prime.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    True if n is not prime, False otherwise.\n  \"\"\"\n\n  # Prime numbers are greater than 1\n  if n <= 1:\n    return True\n\n  # Check for divisibility from 2 to the square root of n\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  \n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  Determines if a number is not a prime number.\n\n  Args:\n      n: The number to check.\n\n  Returns:\n      True if n is not a prime number, False otherwise.\n  \"\"\"\n  if n <= 1:\n    return True\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n  \"\"\"\n  This function checks if a given number is not a prime number.\n\n  Args:\n    n: The number to be checked.\n\n  Returns:\n    True if the number is not prime, False otherwise.\n  \"\"\"\n  # Prime numbers are greater than 1\n  if n <= 1:\n    return True\n  # Check if n is divisible by any number from 2 to the square root of n\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      return True\n  return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Find the n largest integers from a list of numbers, returned in descending order.\n  \n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list containing the n largest integers from nums in descending order.\n  \"\"\"\n\n  return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list of the n largest integers in descending order.\n  \"\"\"\n\n  return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n      nums: A list of numbers.\n      n: The number of largest integers to return.\n\n  Returns:\n      A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of integers.\n        n: The number of largest integers to return.\n\n    Returns:\n        A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Find the n largest integers from a list, returned in descending order.\n\n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of integers.\n        n: The number of largest integers to return.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n    nums: A list of numbers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list of the n largest integers in descending order.\n  \"\"\"\n  return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n      numbers: A list of integers.\n      n: The number of largest integers to return.\n\n  Returns:\n      A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, numbers)\nnumbers = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n      nums: A list of numbers.\n      n: The number of largest integers to return.\n\n  Returns:\n      A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n  \"\"\"\n  return sorted(heapq.nlargest(n, nums), reverse=True)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"Finds the n largest integers from a list, returned in descending order.\n\n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to return.\n\n  Returns:\n    A list of the n largest integers from nums, sorted in descending order.\n  \"\"\"\n\n  return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Find the n largest integers from a given list of numbers, returned in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of integers.\n        n: The number of largest integers to return.\n\n    Returns:\n        A list containing the n largest integers from nums, in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums: A list of numbers.\n        n: The number of largest integers to return.\n\n    Returns:\n        A list of the n largest integers in descending order.\n    \"\"\"\n\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"Finds the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        nums: A list of integers.\n        n: The number of largest integers to return.\n\n    Returns:\n        A list of the n largest integers, in descending order.\n\n    Raises:\n        ValueError: If n is less than 1 or greater than the length of nums.\n    \"\"\"\n    if n < 1 or n > len(nums):\n        raise ValueError(\"n must be between 1 and the length of nums\")\n\n    return sorted(heapq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Finds the n largest integers from a given list of numbers, returned in descending order.\n  Args:\n      nums: A list of integers.\n      n: The number of largest integers to return.\n  Returns:\n      A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  \"\"\"\n  Find the n largest integers from a given list of numbers, returned in descending order.\n\n  Args:\n    nums: A list of integers.\n    n: The number of largest integers to find.\n\n  Returns:\n    A list of the n largest integers in descending order.\n  \"\"\"\n  return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n      nums: A list of integers.\n      n: The number of largest integers to return.\n\n    Returns:\n      A list of the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 42.7891156462585, "dps_norm": 42.5, "pass@1": 36.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    For example:\n    find_Rotations(\"aaaa\") == 1\n    \"\"\"\n\n    n = len(s)\n    for i in range(1, n):\n      if s == s[i:] + s[:i]:\n        return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]  \n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n  \"\"\"Find the minimum number of rotations (greater than 0) required to get the same string.\"\"\"\n\n  n = len(s)\n  for i in range(1, n):\n    temp = s[i:] + s[:i]\n    if temp == s:\n      return i\n  return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations required.\n    \"\"\"\n\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required. Returns 1 if no rotations are needed.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n  # If no rotations result in the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    For example:\n    find_Rotations(\"aaaa\") == 1\n    find_Rotations(\"abcabc\") == 3\n    find_Rotations(\"abcd\") == 4\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(text):\n    \"\"\"Finds the minimum number of rotations required to get the same string.\"\"\"\n    n = len(text)\n    for i in range(1, n):\n        temp = text[i:] + text[:i]  \n        if temp == text:\n            return i\n    return n  # If no rotation results in the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      The minimum number of rotations.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n  \"\"\"\n  Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n  Args:\n    s: The input string.\n\n  Returns:\n    The minimum number of rotations. If the input string is empty or a single character, returns 1.\n  \"\"\"\n  if len(s) <= 1:\n    return 1\n  for i in range(1, len(s)):\n    rotated = s[i:] + s[:i]\n    if rotated == s:\n      return i\n  return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    For example:\n    find_Rotations(\"aaaa\") == 1\n    \"\"\"\n\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations.\n    \"\"\"\n\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations required, or 1 if the string\n        can only be obtained by rotating once.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        temp = s[i:] + s[:i]\n        if temp == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n  \"\"\"\n  Find the minimum number of rotations required to get the same string.\n  Args:\n    s: The input string.\n\n  Returns:\n    The minimum number of rotations required. If the string is empty or has only 1 character, return 1.\n  \"\"\"\n  if len(s) <= 1:\n    return 1\n\n  for i in range(1, len(s)):\n    temp = s[i:] + s[:i]\n    if temp == s:\n      return i\n\n  return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s: The input string.\n\n    Returns:\n        The minimum number of rotations required. Returns 1 if the string is already a rotation of itself (like \"aaaa\").\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n      temp = s[i:] + s[:i] \n      if temp == s:\n        return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(text: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    For example:\n    find_Rotations(\"aaaa\") == 1\n    find_Rotations(\"abcabc\") == 3\n    find_Rotations(\"abcd\") == 4\n\n    \"\"\"\n    n = len(text)\n    for i in range(1, n):\n        temp = \"\"\n        for j in range(i, n):\n            temp += text[j]\n        for j in range(0, i):\n            temp += text[j]\n\n        if (temp == text):\n            return i\n    return n", "matching_cluster_idx": -1}, {"solution": "def find_Rotations(str1):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    Args:\n      str1: The input string.\n    Returns:\n      The minimum number of rotations.\n    \"\"\"\n    n = len(str1)\n    for i in range(1, n):\n        temp = \"\"\n        for j in range(i, n):\n            temp += str1[j]\n        for j in range(0, i):\n            temp += str1[j]\n        if (temp == str1):\n            return i\n    return n", "matching_cluster_idx": -1}, {"solution": "def find_Rotations(s: str) -> int:\n  \"\"\"\n  Finds the minimum number of rotations (greater than 0) required to get the same string.\n  \"\"\"\n  n = len(s)\n  for i in range(1, n):\n    temp = \"\"\n    for j in range(i, n):\n      temp += s[j]\n    for j in range(0, i):\n      temp += s[j]\n    if (temp == s):\n      return i\n  return n", "matching_cluster_idx": -1}]}, "Mbpp/11": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 86.0, "profiled": [{"solution": "def remove_Occ(text, char):\n  \"\"\"Removes the first and last occurrences of a given character from a string.\n\n  Args:\n    text: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of the character removed, \n    or the original string if the character does not appear.\n  \"\"\"\n  try:\n    first_index = text.index(char)\n    last_index = text.rindex(char)\n    return text[:first_index] + text[first_index+1:last_index] + text[last_index+1:]\n  except ValueError:\n    return text", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s,c):\n  \"\"\"Removes first and last occurrence of a character from a string.\n\n  Args:\n    s: The input string.\n    c: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of c removed.\n  \"\"\"\n  try:\n    first_index = s.index(c)\n    last_index = s.rindex(c)\n    if first_index == last_index:\n      return s[:first_index] + s[first_index+1:]\n    else:\n      return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n  except ValueError:\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1,char):\n    first_index = str1.find(char)\n    last_index = str1.rfind(char)\n    if first_index != -1 and last_index != -1:\n        return str1[:first_index] + str1[first_index+1:last_index] + str1[last_index+1:] \n    else:\n      return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(text, char):\n  \"\"\"Removes the first and last occurrences of a given character from a string.\n\n  Args:\n    text: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of 'char' removed.\n  \"\"\"\n  first = text.find(char)\n  last = text.rfind(char)\n  if first != -1 and last != -1:\n    return text[:first] + text[first+1:last] + text[last+1:]\n  else:\n    return text", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char):\n    \"\"\"Removes the first and last occurrence of a character from a string.\n\n    Args:\n        str1: The string to modify.\n        char: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed,\n        or the original string if the character does not occur.\n    \"\"\"\n\n    first_occurrence = str1.find(char)\n    last_occurrence = str1.rfind(char)\n\n    if first_occurrence != -1 and last_occurrence != -1:\n      return str1[:first_occurrence] + str1[first_occurrence+1:last_occurrence] + str1[last_occurrence+1:]\n    else:\n      return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char1):\n  \"\"\"\n  This function removes the first and last occurrences of a given character from a string.\n\n  Args:\n    str1: The input string.\n    char1: The character to be removed.\n\n  Returns:\n    The string with the first and last occurrences of char1 removed, or the original string if char1 is not present.\n  \"\"\"\n  first_occur = str1.find(char1)\n  last_occur = str1.rfind(char1)\n\n  if first_occur == -1:\n    return str1  \n  elif first_occur == last_occur:\n    return str1.replace(char1, '')\n  else:\n    return str1[:first_occur] + str1[first_occur+1:last_occur] + str1[last_occur+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n  \"\"\"Removes the first and last occurrence of a given character from a string.\n\n  Args:\n    s: The input string.\n    c: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of c removed.\n  \"\"\"\n  first_index = s.find(c)\n  last_index = s.rfind(c)\n  if first_index == -1 or last_index == -1:\n    return s\n  return s[:first_index] + s[first_index + 1: last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(text, char):\n  \"\"\"\n  Removes the first and last occurrences of a given character from a string.\n\n  Args:\n    text: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of the character removed.\n  \"\"\"\n  first_occ = text.find(char)\n  last_occ = text.rfind(char)\n  if first_occ != -1 and last_occ != -1:\n    return text[:first_occ] + text[first_occ+1:last_occ] + text[last_occ+1:]\n  else:\n    return text", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char):\n    \"\"\"\n    Removes the first and last occurrences of a character from a string.\n\n    Args:\n        str1: The input string.\n        char: The character to remove.\n\n    Returns:\n        The string with the first and last occurrences of the character removed.\n    \"\"\"\n\n    first_occurence = str1.find(char)\n    last_occurrence = str1.rfind(char)\n\n    if first_occurence != -1 and last_occurrence != -1:\n      return str1[:first_occurence] + str1[first_occurence+1:last_occurrence] + str1[last_occurrence+1:]\n    else:\n      return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char):\n  \"\"\"Removes the first and last occurrences of a given character from a string.\n\n  Args:\n    str1: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of the character removed.\n  \"\"\"\n\n  first_occ = str1.find(char)\n  last_occ = str1.rfind(char)\n  \n  if first_occ != -1 and last_occ != -1 and first_occ != last_occ:\n    return str1[:first_occ] + str1[first_occ + 1:last_occ] + str1[last_occ + 1:]\n  elif first_occ != -1 and last_occ != -1 and first_occ == last_occ:\n    return str1[:first_occ] + str1[first_occ + 1:]\n  else:\n    return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n  \"\"\"\n  Removes the first and last occurrence of a given character from a string.\n\n  Args:\n    s: The string to modify.\n    char: The character to remove.\n\n  Returns:\n    The modified string with the first and last occurrences of 'char' removed, or the original string if 'char' is not present.\n  \"\"\"\n  try:\n    first_occurence = s.index(char)\n    last_occurence = s.rindex(char)\n    if first_occurence != last_occurence:\n      return s[:first_occurence] + s[first_occurence+1:last_occurence] + s[last_occurence+1:]\n    else:\n      return s[:first_occurence] + s[first_occurence+1:]  \n  except ValueError:\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(text, char):\n    \"\"\"Removes first and last occurrence of a character from a string.\"\"\"\n    first_index = text.find(char)\n    last_index = text.rfind(char)\n    if first_index != -1 and last_index != -1:\n      return text[:first_index] + text[first_index + 1:last_index] + text[last_index + 1:]\n    else:\n      return text", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n  \"\"\"\n  Removes the first and last occurrence of a given character from a string.\n\n  Args:\n    string: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of the given character removed.\n  \"\"\"\n  first_occurence = string.find(char)\n  last_occurrence = string.rfind(char)\n\n  if first_occurence != -1 and last_occurrence != -1:\n    return string[:first_occurence] + string[first_occurence + 1:last_occurrence] + string[last_occurrence + 1:]\n  else:\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(text, char):\n  \"\"\"\n  This function removes the first and last occurrence of a given character from a string.\n\n  Args:\n    text: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrence of the character removed.\n  \"\"\"\n\n  first_occurence = text.find(char)\n  last_occurence = text.rfind(char)\n\n  if first_occurence != -1 and last_occurence != -1: \n    return text[:first_occurence] + text[first_occurence+1:last_occurence] + text[last_occurence+1:]\n  else:\n    return text", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char1):\n    \"\"\"\n    Removes the first and last occurrence of a given character from a string.\n\n    Args:\n        str1 (str): The input string.\n        char1 (str): The character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrences of the character removed.\n    \"\"\"\n    first_occurence = str1.find(char1)\n    last_occurence = str1.rfind(char1)\n\n    if first_occurence != -1 and last_occurence != -1:\n        return str1[:first_occurence] + str1[first_occurence+1:last_occurence] + str1[last_occurence+1:]\n    else:\n      return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(str1, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from a string.\n\n    Args:\n        str1 (str): The input string.\n        char (str): The character to remove.\n\n    Returns:\n        str: The string with the first and last occurrences of the character removed. \n             Returns the original string if the character is not found.\n    \"\"\"\n\n    first_index = str1.find(char)\n    last_index = str1.rfind(char)\n\n    if first_index != -1 and last_index != -1:\n        return str1[:first_index] + str1[first_index + 1: last_index] + str1[last_index + 1:] \n    else:\n        return str1", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s,char):\n  first_occ = s.find(char)\n  last_occ = s.rfind(char)\n\n  if first_occ == -1:\n    return s\n  elif first_occ == last_occ:\n    return s.replace(char,\"\")\n  else:\n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n  \"\"\"\n  Removes the first and last occurrence of a given character from a string.\n\n  Args:\n    s: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of the character removed.\n  \"\"\"\n\n  first_index = s.find(char)\n  last_index = s.rfind(char)\n\n  if first_index != -1 and last_index != -1 and first_index != last_index:\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n  elif first_index != -1:\n    return s[:first_index] + s[first_index+1:]\n  elif last_index != -1:\n    return s[:last_index] + s[last_index+1:]\n  else:\n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n  \"\"\"Removes the first and last occurrence of a given character from a string.\n\n  Args:\n    string: The input string.\n    char: The character to remove.\n\n  Returns:\n    The string with the first and last occurrences of the character removed.\n  \"\"\"\n\n  first_index = string.find(char)\n  last_index = string.rfind(char)\n\n  if first_index != -1 and last_index != -1:\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]\n  else:\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n  \"\"\"Removes the first and last occurrences of a given character from a string.\n\n  Args:\n      s: The input string.\n      char: The character to remove.\n\n  Returns:\n      The modified string with the first and last occurrences of char removed. \n      If char is not present in the string, it returns the original string.\n  \"\"\"\n\n  if char in s:\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n  else:\n    return s", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new matrix sorted by the sum of its rows in ascending order.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n  \n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new list of lists representing the sorted matrix.\n  \"\"\"\n\n  return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new list of lists representing the sorted matrix.\n  \"\"\"\n  return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new matrix sorted by the sum of its rows in ascending order.\n  \"\"\"\n  return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new matrix sorted by the sum of its rows in ascending order.\n  \"\"\"\n  return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix (list of lists): The input matrix.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new matrix sorted by row sums in ascending order.\n  \"\"\"\n  return sorted(matrix, key=lambda row: sum(row))\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new matrix with rows sorted in ascending order of their sum.\n  \"\"\"\n  return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new list of lists representing the sorted matrix.\n    \"\"\"\n\n    # Calculate the sum of each row and store it with the row\n    rows_with_sums = [(sum(row), row) for row in matrix]\n\n    # Sort the rows based on their sums\n    rows_with_sums.sort(key=lambda x: x[0])\n\n    # Extract the sorted rows\n    sorted_matrix = [row for _, row in rows_with_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new matrix with rows sorted in ascending order based on their sum.\n    \"\"\"\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n      matrix: A list of lists representing the matrix.\n\n  Returns:\n      A new list of lists representing the sorted matrix.\n  \"\"\"\n  return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing a matrix.\n\n    Returns:\n        A new matrix with the rows sorted in ascending order based on their sums.\n    \"\"\"\n\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new matrix with rows sorted by their sum in ascending order.\n    \"\"\"\n\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"\n  Sorts a given matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new list of lists representing the sorted matrix.\n  \"\"\"\n  return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        A new matrix sorted in ascending order based on the sum of row elements.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n        matrix: A list of lists representing a matrix.\n\n    Returns:\n        A new matrix sorted in ascending order based on the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      A new list of lists representing the sorted matrix.\n    \"\"\"\n\n    return sorted(matrix, key=sum)\nmatrix = [[1, 2, 3], [2, 4, 5], [1, 1, 1]]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n  \"\"\"Sorts a matrix in ascending order according to the sum of its rows.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    A new matrix with rows sorted in ascending order by sum.\n  \"\"\"\n  return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"Sorts a matrix in ascending order according to the sum of its rows.\"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  This function returns True if the input string contains sequences of lowercase letters\n  joined with an underscore and False otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n    \"\"\"\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n  Args:\n    text: The input string to check.\n\n  Returns:\n    True if the string contains sequences of lowercase letters joined with an underscore, False otherwise.\n  \"\"\"\n  return bool(re.fullmatch(r'^[a-z]+(?:_[a-z]+)*$', text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    True if the string contains sequences of lowercase letters joined with an underscore, \n    False otherwise.\n  \"\"\"\n  pattern = r'^[a-z]+(?:_[a-z]+)*$'\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Returns True if the input string contains sequences of lowercase letters joined with an underscore and False otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text: str) -> bool:\n  \"\"\"\n  Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore and False otherwise.\n    \"\"\"\n    pattern = r\"^[a-z]+(?:_[a-z]+)*$\"\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Returns True if the input string contains sequences of lowercase letters joined with an underscore and False otherwise.\n  \"\"\"\n  return bool(re.fullmatch(r\"[a-z]+(_[a-z]+)*\", text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains sequences of lowercase letters joined with underscores.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    True if the string contains lowercase letters joined with underscores, False otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n  \"\"\"\n  pattern = r'^[a-z]+(_[a-z]+)*$'\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains only sequences of lowercase letters joined with underscores.\n\n  Args:\n    text: The string to check.\n\n  Returns:\n    True if the string matches the pattern, False otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\"\"\"\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters \n    joined with an underscore.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      True if the input string contains sequences of lowercase letters joined with\n      an underscore, False otherwise.\n    \"\"\"\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    match = re.match(pattern, text)\n    return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains sequences of lowercase letters joined with underscores.\n\n  Args:\n    text: The input string to check.\n\n  Returns:\n    True if the string contains valid sequences, False otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  This function checks if a string contains sequences of lowercase letters joined with underscores.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      True if the string contains lowercase letter sequences joined by underscores, False otherwise.\n  \"\"\"\n  regex = r'^[a-z]+(_[a-z]+)*$'\n  match = re.match(regex, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n  Args:\n    text: The input string to check.\n\n  Returns:\n    True if the string contains sequences of lowercase letters joined with an underscore, False otherwise.\n  \"\"\"\n  pattern = r\"^[a-z]+(_[a-z]+)*$\"\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n  \"\"\"\n  Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n  \"\"\"\n  import re\n  pattern = r'^[a-z]+(_[a-z]+)*$'\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if a string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        True if the string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    return bool(re.fullmatch(r\"[a-z]+(_[a-z]+)*\", text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n  \"\"\"\n  Checks if a string contains sequences of lowercase letters joined with underscores.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    True if the string contains sequences of lowercase letters joined with underscores, False otherwise.\n  \"\"\"\n  pattern = r'^[a-z]+(_[a-z]+)*$'\n  match = re.match(pattern, text)\n  return bool(match)", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 81.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    assert test_duplicate(([1,2,3,4,5]))==False\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if a list of integers contains any duplicate elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if the list contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    This function checks if a given array of integers contains any duplicate element.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if there is a duplicate element in the list, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n  \"\"\"\n  This function checks if a given array of integers contains any duplicate elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if the array contains duplicates, False otherwise.\n  \"\"\"\n  seen = set()\n  for num in nums:\n    if num in seen:\n      return True\n    seen.add(num)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      True if the array contains any duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if there is a duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if a list of integers contains duplicate elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if there are duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n  \"\"\"\n  Checks if an array of integers contains any duplicate elements.\n  \n  Args:\n      arr: A list of integers.\n\n  Returns:\n      True if the array contains duplicates, False otherwise.\n  \"\"\"\n  seen = set()\n  for num in arr:\n    if num in seen:\n      return True\n    seen.add(num)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if an array of integers contains duplicate elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if the array contains duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n          return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n  \"\"\"\n  Checks if an array of integers contains duplicate elements.\n  Args:\n    arr: A list of integers.\n  Returns:\n    True if the array contains duplicate elements, False otherwise.\n  \"\"\"\n  seen = set()\n  for num in arr:\n    if num in seen:\n      return True\n    seen.add(num)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate element.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if the list contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n  \"\"\"\n  Checks if an array contains duplicate elements.\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    True if the array contains duplicate elements, False otherwise.\n  \"\"\"\n  seen = set()\n  for element in arr:\n    if element in seen:\n      return True\n    seen.add(element)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if an array of integers contains any duplicate element.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        True if the array contains a duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n  \"\"\"\n  This function checks if a given array of integers contains any duplicate elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if the array contains duplicates, False otherwise.\n  \"\"\"\n  seen = set()\n  for num in nums:\n    if num in seen:\n      return True\n    seen.add(num)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n  \"\"\"\n  Checks if an array of integers contains any duplicate elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if the array contains duplicates, False otherwise.\n  \"\"\"\n  seen = set()\n  for num in nums:\n    if num in seen:\n      return True\n    seen.add(num)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if there are duplicate elements in the list, False otherwise.\n    \"\"\"\n\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n  \"\"\"\n  Checks if an array of integers contains any duplicate elements.\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    True if the array contains duplicates, False otherwise.\n  \"\"\"\n  seen = set()\n  for element in arr:\n    if element in seen:\n      return True\n    seen.add(element)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n  \"\"\"\n  Checks if an array of integers contains any duplicate elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if the array contains duplicate elements, False otherwise.\n  \"\"\"\n\n  seen = set()\n  for num in nums:\n    if num in seen:\n      return True\n    seen.add(num)\n  return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if an array of integers contains any duplicate elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Checks if a given array of integers contains any duplicate elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if there are duplicate elements, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 80.5, "dps_norm": 87.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The smallest number in the list.\n    \"\"\"\n    if not numbers:\n      return None  \n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  smallest = nums[0]  \n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  This function finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n\n  if not nums:\n    return None\n\n  smallest = nums[0] \n  for num in nums:\n    if num < smallest:\n      smallest = num\n\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n\n  if not nums:\n    return None  # Handle empty list case\n\n  smallest = nums[0]\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  smallest = nums[0]\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n  \"\"\"Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  This function finds the smallest number in a list.\n  Args:\n    nums: A list of numbers.\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  smallest = nums[0]  # Assume the first element is the smallest\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The smallest number in the list.\n    \"\"\"\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n  \"\"\"Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n\n  if not nums:\n    return None \n\n  smallest = nums[0]  # Assume the first element is the smallest\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The smallest number in the list.\n    \"\"\"\n\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  This function finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  smallest = nums[0]\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  smallest = nums[0]\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    \"\"\"Finds the smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The smallest number in the list.\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Finds the smallest number in a list.\n    \"\"\"\n    smallest = nums[0]  # Assume first element is the smallest initially\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n  \"\"\"\n  This function finds the smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n\n  return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n  \"\"\"\n  This function finds the smallest number in a list.\n\n  Args:\n      nums: A list of numbers.\n\n  Returns:\n      The smallest number in the list.\n  \"\"\"\n  smallest = nums[0]\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n  \"\"\"Finds the smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The smallest number in the list.\n  \"\"\"\n  if not nums:\n    return None  \n  smallest = nums[0]\n  for num in nums:\n    if num < smallest:\n      smallest = num\n  return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples which have all elements divisible by k from the given list of tuples.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples that meet the divisibility condition.\n  \"\"\"\n  return [tuple for tuple in tuples_list if all(x % k == 0 for x in tuple)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples from a list where all elements are divisible by k.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: An integer to check divisibility by.\n\n  Returns:\n    A list of tuples from tuples_list where all elements are divisible by k.\n  \"\"\"\n\n  result = []\n  for tup in tuples_list:\n    if all(x % k == 0 for x in tup):\n      result.append(tup)\n  return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples which have all elements divisible by k from a given list of tuples.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: An integer to check divisibility by.\n\n  Returns:\n    A list of tuples that satisfy the condition.\n  \"\"\"\n  result = []\n  for tup in tuples_list:\n    if all(elem % k == 0 for elem in tup):\n      result.append(tup)\n  return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples from a list where all elements are divisible by k.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples where each element is divisible by k.\n  \"\"\"\n\n  result = []\n  for tup in tuples_list:\n    if all(x % k == 0 for x in tup):\n      result.append(tup)\n  return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples which have all elements divisible by k from the given list of tuples.\n\n  Args:\n      tuples_list: A list of tuples.\n      k: An integer.\n\n  Returns:\n      A list of tuples where all elements in each tuple are divisible by k.\n  \"\"\"\n  return [tup for tup in tuples_list if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Finds tuples with all elements divisible by k.\n\n    Args:\n      list_of_tuples: A list of tuples.\n      k: An integer to check for divisibility.\n\n    Returns:\n      A list of tuples from the input where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in list_of_tuples if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples which have all elements divisible by k from the given list of tuples.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples that have all elements divisible by k.\n  \"\"\"\n\n  result = []\n  for tup in tuples_list:\n    if all(x % k == 0 for x in tup):\n      result.append(tup)\n  return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples where all elements are divisible by k.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples where all elements are divisible by k.\n  \"\"\"\n  return [tup for tup in tuples_list if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n  \"\"\"Finds tuples where all elements are divisible by k.\n\n  Args:\n    tuple_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples where all elements are divisible by k.\n  \"\"\"\n  return [t for t in tuple_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        tuples_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"Find tuples where all elements are divisible by k.\"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples which have all elements divisible by k from the given list of tuples.\n\n  Args:\n      tuples_list: A list of tuples.\n      k: The divisor.\n\n  Returns:\n      A list of tuples where all elements in each tuple are divisible by k.\n  \"\"\"\n  result = []\n  for tup in tuples_list:\n    if all(element % k == 0 for element in tup):\n      result.append(tup)\n  return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples which have all elements divisible by k from a given list of tuples.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: An integer.\n\n  Returns:\n    A list of tuples where all elements are divisible by k.\n  \"\"\"\n  result = []\n  for tup in tuples_list:\n    if all(elem % k == 0 for elem in tup):\n      result.append(tup)\n  return result\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  This function finds tuples where all elements are divisible by k.\n\n  Args:\n    tuples_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples where all elements are divisible by k.\n  \"\"\"\n  return [tup for tup in tuples_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Args:\n        tuples_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n  \"\"\"\n  Finds tuples from a list where all elements are divisible by k.\n\n  Args:\n      tuples_list: A list of tuples.\n      k: The divisor.\n\n  Returns:\n      A list of tuples where all elements are divisible by k.\n  \"\"\"\n  return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples in a list where all elements are divisible by k.\n\n    Args:\n        tuples_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.\n    \"\"\"\n\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        tuples_list: A list of tuples.\n        k: The divisor.\n\n    Returns:\n        A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k.\n\n    Args:\n      tuples_list: A list of tuples.\n      k: An integer.\n\n    Returns:\n      A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tuple for tuple in tuples_list if all(element % k == 0 for element in tuple)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n  \"\"\"Finds tuples where all elements are divisible by k.\n\n  Args:\n    tuple_list: A list of tuples.\n    k: The divisor.\n\n  Returns:\n    A list of tuples where all elements are divisible by k.\n  \"\"\"\n  return [tup for tup in tuple_list if all(x % k == 0 for x in tup)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n  \"\"\"Counts the frequency of each element in a list.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are unique elements of the list and values are\n    their respective frequencies.\n  \"\"\"\n  freq = {}\n  for item in lst:\n    if item in freq:\n      freq[item] += 1\n    else:\n      freq[item] = 1\n  return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"Counts the frequency of each element in a list and returns a dictionary.\n\n    Args:\n      lst: A list of elements.\n\n    Returns:\n      A dictionary where keys are the elements of the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  This function takes a list and returns a dictionary with the frequency of each element.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are the unique elements in the list and values are their frequencies.\n  \"\"\"\n  freq = {}\n  for item in lst:\n    if item in freq:\n      freq[item] += 1\n    else:\n      freq[item] = 1\n  return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  Calculates the frequency of each element in a list and returns a dictionary.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are the unique elements from the list\n    and values are their corresponding frequencies.\n  \"\"\"\n\n  frequency = {}\n  for item in lst:\n    if item in frequency:\n      frequency[item] += 1\n    else:\n      frequency[item] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  Counts the frequency of each element in a list.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are the unique elements of the list and values are their frequencies.\n  \"\"\"\n\n  frequency = {}\n  for item in lst:\n    if item in frequency:\n      frequency[item] += 1\n    else:\n      frequency[item] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  This function takes a list and returns a dictionary containing the frequency of each element in the list.\n\n  Args:\n      lst: A list of elements.\n\n  Returns:\n      A dictionary where the keys are the elements of the list and the values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for item in lst:\n    if item in frequency:\n      frequency[item] += 1\n    else:\n      frequency[item] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(data):\n    \"\"\"\n    Calculate the frequency of each element in a list.\n    \n    Args:\n        data: A list of elements.\n    \n    Returns:\n        A dictionary where keys are the unique elements from the list and values are their respective frequencies.\n    \"\"\"\n    frequency = {}\n    for element in data:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(list1):\n  \"\"\"Counts the frequency of elements in a list and returns a dictionary.\n\n  Args:\n      list1: A list of elements.\n\n  Returns:\n      A dictionary where keys are unique elements from the list and values are \n      their frequencies.\n  \"\"\"\n  frequency = {}\n  for element in list1:\n    if element in frequency:\n      frequency[element] += 1\n    else:\n      frequency[element] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  Calculates the frequency of elements in a list.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are unique elements from the list and values\n    are their respective frequencies.\n  \"\"\"\n  freq = {}\n  for item in lst:\n    if item in freq:\n      freq[item] += 1\n    else:\n      freq[item] = 1\n  return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  This function takes a list and returns a dictionary containing the frequency of each element in the list.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are the unique elements in the list and values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for element in lst:\n    if element in frequency:\n      frequency[element] += 1\n    else:\n      frequency[element] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  This function takes a list as input and returns a dictionary\n  containing the frequency of each element in the list.\n  \"\"\"\n  frequency = {}\n  for item in lst:\n    if item in frequency:\n      frequency[item] += 1\n    else:\n      frequency[item] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  Calculates the frequency of each element in a list and returns it as a dictionary.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A dictionary where keys are unique elements from the list and values are their frequencies.\n  \"\"\"\n  freq = {}\n  for item in lst:\n    if item in freq:\n      freq[item] += 1\n    else:\n      freq[item] = 1\n  return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(data):\n    \"\"\"Counts the frequency of each element in a list.\n\n    Args:\n        data: A list of elements.\n\n    Returns:\n        A dictionary where keys are unique elements from the list and values are their frequencies.\n    \"\"\"\n\n    freq = {}\n    for item in data:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  This function takes a list as input and returns a dictionary containing the frequency of each element in the list.\n  \"\"\"\n  frequency = {}\n  for element in lst:\n    if element in frequency:\n      frequency[element] += 1\n    else:\n      frequency[element] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(nums):\n    \"\"\"\n    Returns a dictionary with frequency count of each element in a list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(nums):\n    \"\"\"\n    Counts the frequency of elements in a list and returns a dictionary\n    where keys are elements and values are their frequencies.\n    \n    For example:\n    assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1}) \n    \"\"\"\n    counts = {}\n    for num in nums:\n      if num in counts:\n        counts[num] += 1\n      else:\n        counts[num] = 1\n    return counts\nnums = [10,10,10,10,20,20,20,20,40,40,50,50,30]", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Counts the frequency of all elements in a list.\n\n    Args:\n      lst: A list of elements.\n\n    Returns:\n      A dictionary where keys are the unique elements in the list and values are their frequencies.\n    \"\"\"\n\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(nums):\n  \"\"\"\n  Calculates the frequency of each element in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    A dictionary where keys are the unique elements in the list\n    and values are their respective frequencies.\n  \"\"\"\n  freq = {}\n  for num in nums:\n    if num in freq:\n      freq[num] += 1\n    else:\n      freq[num] = 1\n  return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n  \"\"\"\n  This function takes a list and returns a dictionary containing the frequency of each element.\n\n  Args:\n      lst: A list of elements.\n\n  Returns:\n      A dictionary where keys are the unique elements of the list and values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for item in lst:\n    if item in frequency:\n      frequency[item] += 1\n    else:\n      frequency[item] = 1\n  return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list as input and returns a dictionary containing the frequency\n    of each element in the list.\n\n    For example:\n    freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30]) == {10: 4, 20: 4, 40: 2, 50: 2, 30: 1}\n    \"\"\"\n\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 75.90243902439025, "dps_norm": 84.28571428571428, "pass@1": 96.0, "profiled": [{"solution": "def len_log(words):\n  \"\"\"\n  Finds the length of the longest word in a list of words.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n        words: A list of strings.\n\n    Returns:\n        An integer representing the length of the longest word in the list.\n    \"\"\"\n\n    max_length = 0\n    for word in words:\n      if len(word) > max_length:\n        max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function takes a list of words and returns the length of the longest word.\n  \"\"\"\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"Finds the length of the longest word in a list of words.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    An integer representing the length of the longest word in the list.\n  \"\"\"\n\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function finds the length of the longest word in a list.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function takes a list of words and returns the length of the longest word.\n\n  Args:\n      words: A list of strings\n\n  Returns:\n      The length of the longest word in the list\n  \"\"\"\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  Finds the length of the longest word in a list of words.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n\n  longest_len = 0\n  for word in words:\n    if len(word) > longest_len:\n      longest_len = len(word)\n  return longest_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function takes a list of words and returns the length of the longest word.\n\n  Args:\n      words: A list of strings.\n\n  Returns:\n      The length of the longest word in the list.\n  \"\"\"\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"Finds the length of the longest word in a list of words.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n  longest_len = 0\n  for word in words:\n    longest_len = max(longest_len, len(word))\n  return longest_len", "matching_cluster_idx": 3}, {"solution": "def len_log(words):\n  \"\"\"\n  This function finds the length of the longest word in a list of words.\n\n  Args:\n      words: A list of strings.\n\n  Returns:\n      The length of the longest word in the list.\n  \"\"\"\n\n  max_len = 0\n  for word in words:\n    if len(word) > max_len:\n      max_len = len(word)\n  return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n  \"\"\"\n  This function takes a list of strings as input and returns the length of the longest word in the list.\n\n  Args:\n    lst: A list of strings.\n\n  Returns:\n    An integer representing the length of the longest word in the list.\n  \"\"\"\n  longest_length = 0\n  for word in lst:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function takes a list of words and returns the length of the longest word.\n\n  Args:\n      words: A list of strings.\n\n  Returns:\n      An integer representing the length of the longest word in the input list.\n  \"\"\"\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(strings):\n  \"\"\"\n  This function finds the length of the longest word in a list of strings.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n  longest_length = 0\n  for word in strings:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"Finds the length of the longest word in a list.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    An integer representing the length of the longest word in the list.\n  \"\"\"\n  return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  Finds the length of the longest word in a list of words.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n\n  longest_length = 0\n  for word in words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(strings):\n  \"\"\"Returns the length of the longest word in a list of strings.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The length of the longest string in the list.\n  \"\"\"\n  longest_length = 0\n  for string in strings:\n    if len(string) > longest_length:\n      longest_length = len(string)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function takes a list of words and returns the length of the longest word.\n  \"\"\"\n  return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(list_of_words):\n  \"\"\"\n  This function finds the length of the longest word in a list of words.\n\n  Args:\n    list_of_words: A list of strings.\n\n  Returns:\n    An integer representing the length of the longest word in the list.\n  \"\"\"\n  longest_length = 0\n  for word in list_of_words:\n    if len(word) > longest_length:\n      longest_length = len(word)\n  return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n  \"\"\"\n  This function finds the length of the longest word in a list of words.\n\n  Args:\n    words: A list of strings.\n\n  Returns:\n    The length of the longest word in the list.\n  \"\"\"\n  return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 87.65243902439025, "dps_norm": 78.0, "pass@1": 85.0, "profiled": [{"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n  \"\"\"\n  This function finds the first value of the tuple with the smallest second value.\n\n  Args:\n      tuples_list: A list of tuples, where each tuple contains two values.\n\n  Returns:\n      The first value of the tuple with the smallest second value.\n  \"\"\"\n  # If the list is empty, return None.\n  if not tuples_list:\n    return None\n  \n  # Initialize min_value and min_tuple with the first tuple in the list.\n  min_value = tuples_list[0][1]\n  min_tuple = tuples_list[0]\n\n  # Iterate through the list of tuples, starting from the second tuple.\n  for tuple_ in tuples_list[1:]:\n    # If the second value of the current tuple is smaller than the current minimum value.\n    if tuple_[1] < min_value:\n      # Update the minimum value and the tuple with the minimum value.\n      min_value = tuple_[1]\n      min_tuple = tuple_\n\n  # Return the first value of the tuple with the minimum value.\n  return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuples_list):\n  \"\"\"\n  Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n  Args:\n    tuples_list: A list of tuples, where each tuple contains two values.\n\n  Returns:\n    The first value of the tuple with the smallest second value.\n  \"\"\"\n  min_tuple = min(tuples_list, key=lambda x: x[1])\n  return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n  \"\"\"\n  Finds the first value of the tuple with the smallest second value in a list of tuples.\n\n  Args:\n    tuples: A list of tuples, where each tuple has two elements.\n\n  Returns:\n    The first value of the tuple with the smallest second value.\n  \"\"\"\n  return min(tuples, key=lambda x: x[1])[0]\ntuples = [('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n    Args:\n    tuples (list): A list of tuples where each tuple has two elements (first value, second value).\n\n    Returns:\n    str: The first value of the tuple with the smallest second value.\n\n    Example:\n    index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    \"\"\"\n\n    min_value = float('inf') \n    min_index = ''\n    for tup in tuples:\n      if tup[1] < min_value:\n        min_value = tup[1]\n        min_index = tup[0]\n    return min_index", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \n    For example:\n    index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n    \"\"\"\n\n    min_tuple = min(tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples: A list of tuples where each tuple contains two elements.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n    min_value = float('inf')\n    min_tuple = None\n    for tup in tuples:\n        if tup[1] < min_value:\n            min_value = tup[1]\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples):\n  \"\"\"\n  Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n  Args:\n    tuples: A list of tuples, where each tuple has two values.\n\n  Returns:\n    The first value of the tuple with the smallest second value.\n  \"\"\"\n  return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple contains two values.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(list_of_tuples, key=lambda item: item[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(data):\n  \"\"\"\n  Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n  Args:\n    data: A list of tuples, where each tuple has two elements.\n\n  Returns:\n    The first value of the tuple with the smallest second value.\n  \"\"\"\n\n  min_value = float('inf')\n  result = None\n  for item in data:\n    if item[1] < min_value:\n      min_value = item[1]\n      result = item[0]\n  return result", "matching_cluster_idx": 4}, {"solution": "def index_minimum(data):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    min_value = float('inf') \n    min_key = None\n\n    for item in data:\n        if item[1] < min_value:\n            min_value = item[1]\n            min_key = item[0]\n    return min_key", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples_list):\n  \"\"\"\n  Given a list of tuples, returns the first value of the tuple with the smallest second value.\n  \"\"\"\n  min_value = tuples_list[0][1]  # Assume first tuple's second value is the minimum initially\n  min_index = 0\n  for i in range(1, len(tuples_list)):\n    if tuples_list[i][1] < min_value:\n      min_value = tuples_list[i][1]\n      min_index = i\n  return tuples_list[min_index][0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n\n    Args:\n      tuples_list: A list of tuples, where each tuple contains two elements: a string and an integer.\n\n    Returns:\n      The first value of the tuple with the smallest second value.\n    \"\"\"\n\n    # Initialize min_value and min_tuple to the first tuple in the list\n    min_value = tuples_list[0][1]\n    min_tuple = tuples_list[0]\n\n    # Iterate through the list of tuples\n    for tup in tuples_list:\n        # If the second value of the current tuple is smaller than the current minimum value\n        if tup[1] < min_value:\n            # Update the minimum value and the minimum tuple\n            min_value = tup[1]\n            min_tuple = tup\n\n    # Return the first value of the minimum tuple\n    return min_tuple[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n      tuples_list: A list of tuples, where each tuple contains two values.\n\n    Returns:\n      The first value of the tuple with the smallest second value.\n    \"\"\"\n    \n    min_tuple = tuples_list[0]\n    for tup in tuples_list:\n        if tup[1] < min_tuple[1]:\n          min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(data):\n  \"\"\"\n  Given a list of tuples, return the first value of the tuple with the smallest second value.\n  Args:\n    data: A list of tuples, each containing a string and an integer.\n  Returns:\n    The first value (string) from the tuple with the smallest second value (integer).\n  \"\"\"\n  min_value = float('inf')\n  result = None\n\n  for item in data:\n    if item[1] < min_value:\n      min_value = item[1]\n      result = item[0]\n  return result", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuple_list):\n  \"\"\"\n  Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n  Args:\n    tuple_list: A list of tuples, where each tuple contains two values.\n\n  Returns:\n    The first value of the tuple with the smallest second value.\n  \"\"\"\n  \n  min_tuple = min(tuple_list, key=lambda item: item[1])\n  return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n  \"\"\"\n  Given a list of tuples, returns the first value of the tuple with the smallest second value.\n  \n  Args:\n    list_of_tuples: A list of tuples.\n\n  Returns:\n    The first value of the tuple with the smallest second value.\n  \"\"\"\n  min_value = float('inf')\n  result = None\n\n  for tup in list_of_tuples:\n    if tup[1] < min_value:\n      min_value = tup[1]\n      result = tup[0]\n\n  return result", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    min_value = float('inf')  # Initialize with a very large number\n    min_tuple = None\n\n    for tup in tuples_list:\n      if tup[1] < min_value:\n        min_value = tup[1]\n        min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(data):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    Args:\n        data: A list of tuples, where each tuple contains two values.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n\n    min_value = data[0][1]  \n    min_index = 0 \n\n    for i in range(1, len(data)):\n        if data[i][1] < min_value:\n            min_value = data[i][1]\n            min_index = i\n\n    return data[min_index][0]\ndata = [('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(data):\n    \"\"\"Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Args:\n        data: A list of tuples, where each tuple contains two values.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not data:\n      return None\n    min_value = data[0][1]\n    min_index = 0\n    for i in range(1, len(data)):\n      if data[i][1] < min_value:\n        min_value = data[i][1]\n        min_index = i\n    return data[min_index][0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 22.083333333333332, "dps_norm": 39.285714285714285, "pass@1": 83.0, "profiled": [{"solution": "def divisor(n):\n  \"\"\"Returns the number of divisors of a given integer.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n        n: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2  \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n: The integer to find the number of divisors for.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n\n    count = 0  \n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  This function finds the number of divisors of a given integer.\n  \n  Args:\n      n: An integer.\n  \n  Returns:\n      The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  Finds the number of divisors of a given integer.\n\n  Args:\n    n: The integer to find the number of divisors for.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  This function returns the number of divisors of a given integer.\n  \"\"\"\n  count = 0 \n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"Calculates the number of divisors of a given integer.\n\n  Args:\n      n: The integer to find the number of divisors for.\n\n  Returns:\n      The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  This function takes a positive integer n and returns the number of its divisors.\n\n  Args:\n    n: A positive integer.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  Finds the number of divisors of a given integer.\n\n  Args:\n      n: The integer to find divisors for.\n\n  Returns:\n      The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n\n    Args:\n        n: The integer to find the number of divisors for.\n\n    Returns:\n        The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  Finds the number of divisors of a given integer.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  Calculates the number of divisors of a given integer.\n\n  Args:\n    n: The integer for which to find the number of divisors.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  Finds the number of divisors of a given integer.\n\n  Args:\n      n: The integer to find the divisors for.\n\n  Returns:\n      The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, int(n**0.5) + 1):\n    if n % i == 0:\n      if i == n // i:\n        count += 1\n      else:\n        count += 2\n  return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n  \"\"\"Find the number of divisors of a given integer.\n\n  Args:\n      n: The integer to find divisors for.\n\n  Returns:\n      The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, int(n**0.5) + 1):\n    if n % i == 0:\n      if i * i == n:  # If i is the square root of n, count it once\n        count += 1\n      else:\n        count += 2  # Count both i and n/i\n  return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n  \"\"\"\n  This function calculates the number of divisors of a given integer.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(num):\n    \"\"\"\n    Find the number of divisors of a given integer.\n\n    Args:\n        num: The integer for which to find the number of divisors.\n\n    Returns:\n        The number of divisors of the given integer.\n    \"\"\"\n\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  This function takes an integer n and returns the number of divisors of n.\n  \n  For example:\n  divisor(15) == 4\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n  \"\"\"\n  This function counts the number of divisors of a given integer.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The number of divisors of n.\n  \"\"\"\n  count = 0\n  for i in range(1, n+1):\n    if n % i == 0:\n      count += 1\n  return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(lists):\n    \"\"\"\n    Find frequency of each element in a flattened list of lists.\n\n    Args:\n        lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are unique elements and values are their frequencies.\n    \"\"\"\n\n    frequency = {}\n    for sublist in lists:\n      for element in sublist:\n        if element in frequency:\n          frequency[element] += 1\n        else:\n          frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n  \"\"\"\n  Finds the frequency of each element in a flattened list of lists.\n\n  Args:\n    lst: A list of lists.\n\n  Returns:\n    A dictionary where keys are unique elements and values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for sublist in lst:\n    for element in sublist:\n      if element in frequency:\n        frequency[element] += 1\n      else:\n        frequency[element] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n  \"\"\"\n  Calculates the frequency of each element in a flattened list of lists.\n\n  Args:\n    lists: A list of lists containing integers.\n\n  Returns:\n    A dictionary where keys are the unique elements and values are their frequencies.\n  \"\"\"\n\n  flattened_list = [item for sublist in lists for item in sublist]\n  frequency = {}\n  for item in flattened_list:\n    if item in frequency:\n      frequency[item] += 1\n    else:\n      frequency[item] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    Find frequency of each element in a flattened list of lists, returned in a dictionary.\n\n    Args:\n        nested_list (list): A list of lists of numbers.\n\n    Returns:\n        dict: A dictionary where keys are unique elements from the flattened list and values are their frequencies.\n    \"\"\"\n\n    frequency = {}\n    for inner_list in nested_list:\n      for element in inner_list:\n        if element in frequency:\n          frequency[element] += 1\n        else:\n          frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n  \"\"\"\n  This function finds the frequency of each element in a flattened list of lists\n  and returns the result in a dictionary.\n\n  Args:\n      list_of_lists: A list of lists.\n\n  Returns:\n      A dictionary where the keys are the unique elements and the values are\n      the frequencies of those elements.\n  \"\"\"\n\n  flattened_list = [item for sublist in list_of_lists for item in sublist]\n  return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef frequency_lists(nested_list: List[List[int]]) -> dict:\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    frequency = {}\n    for sublist in nested_list:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists and returns it in a dictionary.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are the unique elements and values are their frequencies.\n    \"\"\"\n\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency = {}\n    for element in flattened_list:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"Finds frequency of each element in a flattened list of lists.\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    \"\"\"Finds frequency of each element in a flattened list of lists.\n\n    Args:\n    lists: A list of lists.\n\n    Returns:\n    A dictionary where keys are unique elements and values are their frequencies.\n    \"\"\"\n    flattened_list = [item for sublist in lists for item in sublist]  \n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Finds frequency of each element in a flattened list of lists.\n\n    Args:\n        lists: A list of lists.\n\n    Returns:\n        A dictionary with element frequencies.\n    \"\"\"\n    frequency = {}\n    for sublist in lists:\n      for element in sublist:\n        if element in frequency:\n          frequency[element] += 1\n        else:\n          frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Counts the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists: A list of lists.\n\n    Returns:\n        A dictionary where keys are unique elements from the flattened list\n        and values are their respective counts.\n    \"\"\"\n\n    frequency = {}\n    for inner_list in list_of_lists:\n        for element in inner_list:\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n  \"\"\"\n  This function takes a list of lists as input and returns a dictionary \n  containing the frequency of each unique element.\n\n  Args:\n    list_of_lists: A list of lists of integers.\n\n  Returns:\n    A dictionary where the keys are the unique elements from the flattened list and \n    the values are their corresponding frequencies.\n  \"\"\"\n\n  frequency = {}\n  for sublist in list_of_lists:\n    for element in sublist:\n      if element in frequency:\n        frequency[element] += 1\n      else:\n        frequency[element] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n  \"\"\"\n  Finds the frequency of each element in a flattened list of lists.\n\n  Args:\n    lists: A list of lists.\n\n  Returns:\n    A dictionary where keys are unique elements and values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for sublist in lists:\n    for element in sublist:\n      if element in frequency:\n        frequency[element] += 1\n      else:\n        frequency[element] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n  \"\"\"\n  This function takes a list of lists and returns a dictionary containing the frequency of each unique element in the flattened list.\n\n  Args:\n    list_of_lists: A list of lists.\n\n  Returns:\n    A dictionary where keys are unique elements from the flattened list and values are their frequencies.\n  \"\"\"\n  flat_list = [item for sublist in list_of_lists for item in sublist]\n  frequency = {}\n  for element in flat_list:\n    if element in frequency:\n      frequency[element] += 1\n    else:\n      frequency[element] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n  \"\"\"\n  Finds the frequency of each element in a flattened list of lists.\n\n  Args:\n    lists: A list of lists.\n\n  Returns:\n    A dictionary where keys are the unique elements in the flattened list\n    and values are their respective frequencies.\n  \"\"\"\n  flattened_list = [item for sublist in lists for item in sublist]\n  return dict(Counter(flattened_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(nested_list):\n  \"\"\"\n  Finds the frequency of each element in a flattened list of lists, returned in a dictionary.\n\n  Args:\n      nested_list: A list of lists.\n\n  Returns:\n      A dictionary where keys are the unique elements in the flattened list, and values are their corresponding frequencies.\n  \"\"\"\n  flat_list = [item for sublist in nested_list for item in sublist]\n  return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lsts):\n  \"\"\"\n  Calculates the frequency of each element in a flattened list of lists.\n\n  Args:\n      lst_of_lsts: A list of lists.\n\n  Returns:\n      A dictionary where keys are unique elements and values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for lst in lst_of_lsts:\n    for item in lst:\n      if item in frequency:\n        frequency[item] += 1\n      else:\n        frequency[item] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n  \"\"\"\n  Calculates the frequency of each element in a flattened list of lists.\n\n  Args:\n    list_of_lists: A list of lists containing integers.\n\n  Returns:\n    A dictionary where keys are the unique elements and values are their frequencies.\n  \"\"\"\n  frequency = {}\n  for sublist in list_of_lists:\n    for element in sublist:\n      if element in frequency:\n        frequency[element] += 1\n      else:\n        frequency[element] = 1\n  return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n\n    For example:\n    frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    frequency = {}\n    for lst in lists:\n        for item in lst:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n  \"\"\"\n  Calculates the frequency of each element in a flattened list of lists.\n\n  Args:\n    list_of_lists: A list of lists.\n\n  Returns:\n    A dictionary where keys are the unique elements and values are their frequencies.\n  \"\"\"\n  flattened_list = [item for sublist in list_of_lists for item in sublist]\n  return dict(Counter(flattened_list))", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 81.49350649350649, "dps_norm": 91.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n  \"\"\"\n  Appends the given list to the given tuple.\n\n  Args:\n    lst: A list of elements to append.\n    tup: A tuple to which the list will be appended.\n\n  Returns:\n    A new tuple with the elements of the list appended to the tuple.\n  \"\"\"\n  return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"Appends a list to a tuple.\n\n  Args:\n    lst: The list to be appended.\n    tup: The tuple to which the list will be appended.\n\n  Returns:\n    A new tuple with the elements of the list appended to the tuple.\n  \"\"\"\n  return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n  \"\"\"Append the given list to the given tuples.\n\n  Args:\n    list1: A list of numbers.\n    tuple1: A tuple of numbers.\n\n  Returns:\n    A new tuple with the elements of the input tuple followed by the elements of the input list.\n\n  Examples:\n  assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n\n  \"\"\"\n  return tuple1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"Appends the given list to the given tuple.\n\n  Args:\n    lst: The list to append.\n    tup: The tuple to append to.\n\n  Returns:\n    A new tuple with the list appended to the original tuple.\n  \"\"\"\n  return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(list1, tup1):\n  \"\"\"\n  This function appends a given list to a given tuple.\n  Args:\n    list1: The list to be appended.\n    tup1: The tuple to which the list will be appended.\n  Returns:\n    A new tuple with the elements of the list appended to the tuple.\n  \"\"\"\n  return tup1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"\n  Appends the given list to the given tuple.\n\n  Args:\n    lst: The list to be appended.\n    tup: The tuple to append to.\n\n  Returns:\n    A new tuple with the elements of the list appended to the tuple.\n  \"\"\"\n  return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, tup):\n  \"\"\"Appends the given list to the given tuple.\n\n  Args:\n    list_to_add: A list of elements to add to the tuple.\n    tup: The tuple to append the list to.\n\n  Returns:\n    A new tuple with the list elements appended.\n  \"\"\"\n  return tup + tuple(list_to_add)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"Appends the given list to the given tuples.\"\"\"\n  return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n      lst: The list to be appended.\n      tup: The tuple to which the list will be appended.\n\n    Returns:\n      A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "from typing import Tuple, List\ndef add_lists(lst: List[int], tup: Tuple[int, ...]) -> Tuple[int, ...]:\n    \"\"\"\n    Appends the given list to the given tuples.\n\n    Args:\n        lst: The list to append\n        tup: The tuple to which the list will be appended\n\n    Returns:\n        A new tuple with the list appended to the given tuple.\n\n    \"\"\"\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(my_list, my_tuple):\n  \"\"\"\n  Appends the elements of a list to a tuple and returns a new tuple.\n\n  Args:\n    my_list: The list to be appended.\n    my_tuple: The tuple to append to.\n\n  Returns:\n    A new tuple with the elements of the list appended to the tuple.\n  \"\"\"\n  return my_tuple + tuple(my_list)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"\n  This function appends the given list to the given tuple.\n\n  Args:\n      lst: A list of elements to append.\n      tup: A tuple to which the list will be appended.\n\n  Returns:\n      A new tuple with the elements of the input tuple followed by the elements of the input list.\n  \"\"\"\n  return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"Appends the given list to the given tuple.\n\n    Args:\n        lst: The list to be appended.\n        tup: The tuple to append to.\n\n    Returns:\n        A new tuple with the list elements appended to the end of the tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"Appends a list to a tuple.\n\n  Args:\n    lst: A list of elements to append.\n    tup: The tuple to append the list to.\n\n  Returns:\n    A new tuple with the list elements appended.\n  \"\"\"\n  return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(input_list, input_tuple):\n  \"\"\"Appends the given list to the given tuple.\n\n  Args:\n    input_list: A list of elements.\n    input_tuple: A tuple of elements.\n\n  Returns:\n    A new tuple containing all elements of the input tuple followed by the elements of the input list.\n  \"\"\"\n  return input_tuple + tuple(input_list)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n  \"\"\"\n  Appends the given list to the given tuple.\n\n  Args:\n    lst: The list to be appended.\n    tpl: The tuple to which the list is appended.\n\n  Returns:\n    A new tuple with the list elements appended to the end of the tuple.\n  \"\"\"\n  return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n  \"\"\"Appends the given list to the given tuple.\n\n  Args:\n    lst: A list of elements.\n    tup: A tuple of elements.\n\n  Returns:\n    A tuple with the elements of the input tuple followed by the elements of the input list.\n  \"\"\"\n  return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tuple1):\n    \"\"\"Appends a list to a tuple.\n\n    Args:\n      list1: The list to be appended.\n      tuple1: The tuple to append the list to.\n\n    Returns:\n      A new tuple with the elements of the list appended to the tuple.\n    \"\"\"\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, tuple_to_add_to):\n  \"\"\"Appends a list to a tuple.\n\n  Args:\n    list_to_append: The list to be appended to the tuple.\n    tuple_to_add_to: The tuple to which the list will be appended.\n\n  Returns:\n    A new tuple with the list appended to the end of the original tuple.\n  \"\"\"\n  return tuple_to_add_to + tuple(list_to_append)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple.\n    Args:\n      lst: The list to be appended.\n      tpl: The tuple to which the list will be appended.\n\n    Returns:\n      A new tuple with the elements of the list appended to the tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/111": {"dps": 91.53846153846155, "dps_norm": 86.25, "pass@1": 99.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n  \"\"\"Finds the common elements in a list of lists.\n\n  Args:\n    nested_lists: A list of lists.\n\n  Returns:\n    A set of the common elements.\n  \"\"\"\n  common = set(nested_lists[0])  \n  for lst in nested_lists[1:]:\n    common = common.intersection(set(lst))\n  return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(list_of_lists):\n  \"\"\"\n  Finds the common elements in given nested lists.\n\n  Args:\n      list_of_lists: A list of lists.\n\n  Returns:\n      A set containing the common elements found in all lists.\n  \"\"\"\n  common_elements = set(list_of_lists[0])\n  for lst in list_of_lists[1:]:\n    common_elements &= set(lst)\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n        nested_lists: A list of lists.\n\n    Returns:\n        A set containing the common elements.\n    \"\"\"\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n  \"\"\"Finds the common elements in given nested lists.\n\n  Args:\n    nested_lists: A list of lists.\n\n  Returns:\n    A set containing the common elements.\n  \"\"\"\n\n  common_elements = set(nested_lists[0])\n  for lst in nested_lists[1:]:\n    common_elements.intersection_update(lst)\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \n    Args:\n      nested_list: A list of lists.\n    Returns:\n      A set of the common elements.\n    \"\"\"\n    common = set(nested_list[0])\n    for sublist in nested_list[1:]:\n      common &= set(sublist)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n    \n    Args:\n      nested_lists: A list of lists.\n\n    Returns:\n      A set of the common elements.\n    \"\"\"\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists.\n\n    Returns:\n      A set of elements common to all nested lists.\n    \"\"\"\n\n    # Find the set of elements in the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate through remaining lists\n    for lst in nested_lists[1:]:\n        # Find the intersection with the current list\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n  \"\"\"\n  Finds the common elements in a list of nested lists.\n\n  Args:\n    nested_lists: A list of lists.\n\n  Returns:\n    A set containing the common elements found in all nested lists.\n  \"\"\"\n  common_elements = set(nested_lists[0])  \n  for sublist in nested_lists[1:]:\n    common_elements &= set(sublist)  \n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"Finds common elements in given nested lists.\n\n    Args:\n        lists: A list of lists.\n\n    Returns:\n        A set of elements common to all input lists.\n    \"\"\"\n\n    common_elements = set(lists[0])  \n    for lst in lists[1:]:\n        common_elements &= set(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(list_of_lists):\n  \"\"\"Finds the common elements in given nested lists.\n\n  Args:\n      list_of_lists: A list of lists.\n\n  Returns:\n      A set containing the common elements.\n  \"\"\"\n  common_elements = set(list_of_lists[0])  \n  for lst in list_of_lists[1:]:\n    common_elements &= set(lst)\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"Finds the common elements in given nested lists.\n\n    Args:\n        lists: A list of lists.\n\n    Returns:\n        A set containing the common elements.\n    \"\"\"\n    common = set(lists[0])\n    for lst in lists[1:]:\n      common &= set(lst)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n  \"\"\"\n  Finds the common elements in given nested lists.\n\n  Args:\n    nested_lists: A list of lists.\n\n  Returns:\n    A set of the common elements.\n  \"\"\"\n  common_elements = set(nested_lists[0])\n  for lst in nested_lists[1:]:\n    common_elements &= set(lst)\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n  \"\"\"Finds the common elements in a given nested list.\n\n  Args:\n    nested_list: A list of lists.\n\n  Returns:\n    A set containing the common elements present in all the sublists.\n  \"\"\"\n  common_elements = set(nested_list[0])\n  for sublist in nested_list[1:]:\n    common_elements &= set(sublist)\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n  \"\"\"\n  Finds the common elements in given nested lists.\n\n  Args:\n    nested_lists: A list of lists containing integers.\n\n  Returns:\n    A set containing the common elements.\n  \"\"\"\n  common_elements = set(nested_lists[0])\n  for lst in nested_lists[1:]:\n    common_elements &= set(lst)\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n  \"\"\"Finds the common elements in given nested lists.\n\n  Args:\n    nested_lists: A list of lists.\n\n  Returns:\n    A set containing the common elements.\n  \"\"\"\n  common_elements = set(nested_lists[0])\n  for lst in nested_lists[1:]:\n    common_elements = common_elements.intersection(set(lst))\n  return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n  \"\"\"\n  Finds the common elements in given nested lists.\n\n  Args:\n    nested_list: A list of lists.\n\n  Returns:\n    A set of common elements.\n  \"\"\"\n  common = set(nested_list[0])\n  for lst in nested_list[1:]:\n    common &= set(lst)\n  return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists, where each inner list contains integers.\n\n    Returns:\n      A set containing the common elements found in all input lists.\n    \"\"\"\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n      common_elements = common_elements.intersection(set(lst))\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n  \"\"\"\n  Finds the common elements in given nested lists.\n\n  Args:\n    nested_list: A list of lists containing integers.\n\n  Returns:\n    A set containing the common elements.\n  \"\"\"\n  common_elements = set(nested_list[0])\n  for lst in nested_list[1:]:\n    common_elements &= set(lst) \n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Args:\n      nested_lists: A list of lists.\n\n    Returns:\n      A set containing the common elements.\n    \"\"\"\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n  \"\"\"\n  Finds the common elements in given nested lists.\n\n  Args:\n    lists: A list of lists.\n\n  Returns:\n    A set containing the common elements.\n  \"\"\"\n\n  common_elements = set(lists[0])  \n  for lst in lists[1:]:\n    common_elements &= set(lst)\n  return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 72.0, "profiled": [{"solution": "def sum_divisors(n):\n    \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Calculates the sum of all amicable numbers below a given limit.\n\n    Args:\n        limit: The upper limit for finding amicable numbers.\n\n    Returns:\n        The sum of all amicable numbers below the limit.\n    \"\"\"\n\n    amicable_sum = 0\n    for num in range(2, limit):\n        other_num = sum_divisors(num)\n        if sum_divisors(other_num) == num and num != other_num:\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"\n  Calculates the sum of divisors of a given number.\n  \"\"\"\n  divisors = [1]\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i:\n        divisors.append(n // i)\n  return sum(divisors)\ndef amicable_numbers_sum(limit):\n  \"\"\"\n  Calculates the sum of all amicable numbers up to a specified limit.\n  \"\"\"\n  total_sum = 0\n  for i in range(2, limit + 1):\n    j = sum_divisors(i)\n    if sum_divisors(j) == i and i != j:  \n      total_sum += i\n  return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n  divisors = [1]\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i:\n        divisors.append(n // i)\n  return sum(divisors)\ndef amicable_numbers_sum(limit):\n  \"\"\"Calculates the sum of all amicable numbers up to a given limit.\"\"\"\n  amicable_sum = 0\n  for i in range(2, limit + 1):\n    j = sum_divisors(i)\n    if i != j and sum_divisors(j) == i:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n  \"\"\"\n  Calculate the sum of all proper divisors of a number.\n  \"\"\"\n  sum = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      sum += i\n      if i != n//i:  # Avoid double-counting for perfect squares\n        sum += n//i\n  return sum\ndef amicable_numbers_sum(limit):\n  \"\"\"\n  Calculate the sum of all amicable numbers below a given limit.\n\n  An amicable number is a number whose sum of proper divisors is equal to another number,\n  whose sum of proper divisors is the original number.\n  \"\"\"\n  amicable_sum = 0\n  for i in range(2, limit):\n    a = sum_of_divisors(i)\n    b = sum_of_divisors(a)\n    if i != a and b == i:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(num):\n  \"\"\"Returns the sum of the proper divisors of a given number.\"\"\"\n  divisors = [1]\n  for i in range(2, int(num**0.5) + 1):\n    if num % i == 0:\n      divisors.append(i)\n      if i != num // i:\n        divisors.append(num // i)\n  return sum(divisors)\ndef amicable_numbers_sum(limit):\n  \"\"\"Returns the sum of all amicable numbers below the given limit.\"\"\"\n  amicable_sum = 0\n  for num in range(2, limit):\n    sum1 = sum_proper_divisors(num)\n    sum2 = sum_proper_divisors(sum1)\n    if sum2 == num and num != sum1:\n      amicable_sum += num\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n  divisors_sum = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors_sum += i\n      if i != n // i:\n        divisors_sum += n // i\n  return divisors_sum\ndef amicable_numbers_sum(limit):\n  \"\"\"Calculates the sum of all amicable numbers from 1 to a given limit.\"\"\"\n  amicable_sum = 0\n  for i in range(2, limit + 1):\n    sum_i = sum_divisors(i)\n    sum_sum_i = sum_divisors(sum_i)\n    if i != sum_i and i == sum_sum_i:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"Calculates the sum of divisors of a number.\"\"\"\n  sum_of_divisors = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      sum_of_divisors += i\n      if i != n // i:\n        sum_of_divisors += n // i\n  return sum_of_divisors\ndef amicable_numbers_sum(limit):\n  \"\"\"Calculates the sum of all amicable numbers below the specified limit.\"\"\"\n  total_sum = 0\n  for i in range(2, limit):\n    j = sum_divisors(i)\n    if i != j and sum_divisors(j) == i:\n      total_sum += i\n  return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n  \"\"\"\n  Calculates the sum of proper divisors of a number.\n  \"\"\"\n  divisors_sum = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors_sum += i\n      if i != n // i:\n        divisors_sum += n // i\n  return divisors_sum\ndef amicable_numbers_sum(limit):\n  \"\"\"\n  Calculates the sum of all amicable numbers up to a given limit.\n\n  Args:\n    limit: The upper limit for finding amicable numbers.\n\n  Returns:\n    The sum of all amicable numbers less than or equal to the limit.\n  \"\"\"\n  amicable_sum = 0\n  for i in range(2, limit + 1):\n    sum_divisors_i = sum_of_proper_divisors(i)\n    sum_divisors_j = sum_of_proper_divisors(sum_divisors_i)\n    if sum_divisors_j == i and i != sum_divisors_i:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"Calculates the sum of proper divisors (excluding the number itself) of a given number.\"\"\"\n    divisors = [1]  \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:  \n                divisors.append(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Finds the sum of all amicable numbers from 1 to a given limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        sum_i = sum_proper_divisors(i)\n        sum_sum_i = sum_proper_divisors(sum_i)\n        if sum_sum_i == i and i != sum_i: \n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n  \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n  divisors_sum = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors_sum += i\n      if i != n // i:\n        divisors_sum += n // i\n  return divisors_sum\ndef amicable_numbers_sum(limit):\n  \"\"\"Calculates the sum of amicable numbers up to a given limit.\"\"\"\n  amicable_sum = 0\n  for i in range(2, limit + 1):\n    a = sum_proper_divisors(i)\n    b = sum_proper_divisors(a)\n    if i == b and i != a:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculates the sum of all amicable numbers from 1 to a specified number.\n\n    Args:\n      limit: The upper limit for finding amicable numbers.\n\n    Returns:\n      The sum of all amicable numbers less than or equal to the limit.\n    \"\"\"\n\n    def sum_proper_divisors(n):\n      \"\"\"Calculates the sum of proper divisors (divisors excluding the number itself) of a number.\"\"\"\n      divisors_sum = 1  \n      for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n          divisors_sum += i + (n // i)  \n          if i == n // i:  \n            divisors_sum -= i \n      return divisors_sum\n\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n      a = sum_proper_divisors(i)\n      b = sum_proper_divisors(a)\n      if i == b and i != a:\n        amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"\n  Calculates the sum of proper divisors of a number.\n  \"\"\"\n  total = 1  # Start with 1 as it's always a divisor\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      total += i\n      if i != n // i:  # Avoid adding the same divisor twice for perfect squares\n        total += n // i\n  return total\ndef amicable_numbers_sum(limit):\n  \"\"\"\n  Calculates the sum of all amicable numbers less than or equal to the given limit.\n  \"\"\"\n  total_sum = 0\n  for i in range(2, limit + 1):\n    # Find the sum of divisors for i\n    sum_i = sum_divisors(i)\n    # Check if the sum of divisors of i, (sum_i), \n    # is a divisor of i and the sum of divisors of sum_i is equal to i\n    if sum_i <= limit and sum_divisors(sum_i) == i and sum_i != i:\n      total_sum += i  # Add i to the total sum \n\n  return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Returns the sum of all proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers below the given limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit):\n        a = sum_divisors(i)\n        b = sum_divisors(a)\n        if b == i and a != b:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n  \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n  divisors_sum = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors_sum += i\n      if i != n // i:\n        divisors_sum += n // i\n  return divisors_sum\ndef amicable_numbers_sum(limit):\n  \"\"\"\n  Calculates the sum of all amicable numbers up to a specified limit.\n\n  An amicable number is a number where the sum of its proper divisors \n  is equal to another number, and vice versa.\n\n  Args:\n    limit: The upper limit to search for amicable numbers.\n\n  Returns:\n    The sum of all amicable numbers up to the limit.\n  \"\"\"\n  amicable_sum = 0\n  for num in range(2, limit + 1):\n    a = sum_of_divisors(num)\n    b = sum_of_divisors(a)\n    if a != b and num == b:\n      amicable_sum += num\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Returns the sum of proper divisors of a number.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers below a given limit.\"\"\"\n    total_sum = 0\n    for i in range(2, limit):\n        j = sum_divisors(i)\n        if i != j and sum_divisors(j) == i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n  \"\"\"\n  Calculates the sum of proper divisors of a given number.\n\n  Args:\n    n: The number to calculate the sum of proper divisors for.\n\n  Returns:\n    The sum of proper divisors of n.\n  \"\"\"\n  divisors = [1]\n  for i in range(2, int(n ** 0.5) + 1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i:\n        divisors.append(n // i)\n  return sum(divisors)\ndef amicable_numbers_sum(limit):\n  \"\"\"\n  Calculates the sum of all amicable numbers up to a given limit.\n\n  Args:\n    limit: The upper limit for finding amicable numbers.\n\n  Returns:\n    The sum of all amicable numbers up to the limit.\n  \"\"\"\n  amicable_sum = 0\n  for i in range(2, limit + 1):\n    sum_divisors_i = sum_of_proper_divisors(i)\n    sum_divisors_j = sum_of_proper_divisors(sum_divisors_i)\n    if i == sum_divisors_j and i != sum_divisors_i:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"Calculates the sum of proper divisors of a number.\"\"\"\n  divisors = [1]\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i:\n        divisors.append(n // i)\n  return sum(divisors)\ndef amicable_numbers_sum(limit):\n  \"\"\"Calculates the sum of all amicable numbers below a given limit.\"\"\"\n  amicable_sum = 0\n  for i in range(2, limit):\n    j = sum_divisors(i)\n    if sum_divisors(j) == i and i != j:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"Returns the sum of proper divisors of n.\"\"\"\n  total = 1\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      total += i\n      if i != n // i:\n        total += n // i\n  return total\ndef amicable_numbers_sum(limit):\n  \"\"\"Returns the sum of all amicable numbers up to the given limit.\"\"\"\n  total = 0\n  for i in range(2, limit + 1):\n    a = sum_divisors(i)\n    b = sum_divisors(a)\n    if i != a and i == b:\n      total += i\n  return total", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Returns the sum of proper divisors of a number.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # Avoid double-counting for perfect squares\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to a given limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        j = sum_divisors(i)\n        if i != j and sum_divisors(j) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n  \"\"\"Returns the sum of proper divisors of a number.\"\"\"\n  divisors = [1]\n  for i in range(2, int(n**0.5) + 1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n // i:\n        divisors.append(n // i)\n  return sum(divisors)\ndef amicable_numbers_sum(limit):\n  \"\"\"Returns the sum of all amicable numbers less than or equal to the limit.\"\"\"\n  amicable_sum = 0\n  for i in range(2, limit + 1):\n    j = sum_divisors(i)\n    if i != j and sum_divisors(j) == i:\n      amicable_sum += i\n  return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 77.0, "profiled": [{"solution": "def long_words(n, sentence):\n  \"\"\"\n  Finds words longer than n characters from a given sentence.\n\n  Args:\n    n: The minimum length of words to return.\n    sentence: A string containing words separated by spaces.\n\n  Returns:\n    A list of words from the sentence that are longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  long_words = [word for word in words if len(word) > n]\n  return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function finds words that are longer than n characters from a given list of words.\n  Args:\n    n: An integer representing the minimum length of words to return.\n    sentence: A string containing the sentence to be processed.\n  Returns:\n    A list of words that are longer than n characters.\n  \"\"\"\n\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function finds words longer than n characters in a given sentence.\n\n  Args:\n    n: An integer representing the minimum word length.\n    sentence: A string containing a sentence.\n\n  Returns:\n    A list of words from the sentence that are longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  long_words = [word for word in words if len(word) > n]\n  return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters from a given sentence.\n\n    Args:\n        n: The minimum length of words to return.\n        sentence: The sentence to search for long words.\n\n    Returns:\n        A list of words from the sentence that are longer than n characters.\n    \"\"\"\n\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n      n: The minimum length of the words to be returned.\n      text: A string containing the words.\n\n    Returns:\n      A list of words from the text that are longer than n characters.\n    \"\"\"\n\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function takes a number n and a string of words, and returns a list\n  containing all the words from the sentence that are longer than n characters.\n\n  Args:\n      n: The minimum length of words to include in the result.\n      sentence: A string of words separated by spaces.\n\n  Returns:\n      A list of words from the sentence that are longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters from a given sentence.\n\n    Args:\n        n (int): The minimum length of words to be included.\n        sentence (str): The input sentence to extract words from.\n\n    Returns:\n        list: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds words longer than n characters from a given list of words.\n\n    Args:\n        n: The minimum length of words to be considered.\n        sentence: A string containing the words to check.\n\n    Returns:\n        A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()  \n    long_words = [word for word in words if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function takes a number n and a string of words, \n  and returns a list of words from the string that are longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  long_words_list = [word for word in words if len(word) > n]\n  return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function takes a number n and a sentence as input and returns a list of words\n  from the sentence that are longer than n characters.\n\n  Args:\n    n: An integer representing the minimum length of words to be included.\n    sentence: A string representing the sentence to be processed.\n\n  Returns:\n    A list of strings, containing words from the sentence longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  long_words = [word for word in words if len(word) > n]\n  return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function finds words longer than n characters from a given sentence.\n\n  Args:\n      n: The minimum length of the words to be returned.\n      sentence: A string containing the words to be checked.\n\n  Returns:\n      A list of words longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  Finds words longer than n characters from a given list of words.\n\n  Args:\n    n: The minimum length of words to return.\n    sentence: A string containing a sentence.\n\n  Returns:\n    A list of words from the sentence that are longer than n characters.\n  \"\"\"\n\n  words = sentence.split()\n  long_words = [word for word in words if len(word) > n]\n  return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function takes a number n and a string sentence as input.\n  It returns a list of words from the sentence that are longer than n characters.\n\n  Args:\n    n: An integer representing the minimum length of words to be returned.\n    sentence: A string containing words separated by spaces.\n\n  Returns:\n    A list of words from the sentence that are longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  long_words = [word for word in words if len(word) > n]\n  return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from a sentence that are longer than n characters.\n\n    Args:\n      n: The minimum length of words to return.\n      sentence: The sentence to extract words from.\n\n    Returns:\n      A list of words longer than n characters.\n    \"\"\"\n\n    words = sentence.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  Finds words longer than n characters in a sentence.\n\n  Args:\n    n: The minimum length of words to return.\n    sentence: The sentence to search.\n\n  Returns:\n    A list of words longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function returns a list of words from a sentence that are longer than n characters.\n\n  Args:\n    n: The minimum length of words to include in the list.\n    sentence: A string containing a sentence.\n\n  Returns:\n    A list of words longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  long_words = [word for word in words if len(word) > n]\n  return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  Finds words longer than n characters from a given sentence.\n\n  Args:\n      n: The minimum length of words to return.\n      sentence: A string containing the sentence to process.\n\n  Returns:\n      A list of words from the sentence that are longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  This function finds words that are longer than n characters from a given list of words.\n\n  Args:\n      n: The minimum length of words to be included in the result.\n      sentence: A string containing words separated by spaces.\n\n  Returns:\n      A list of words longer than n characters from the given sentence.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  Finds words longer than n characters in a sentence.\n\n  Args:\n    n: The minimum length of the words to be returned.\n    sentence: The sentence to extract words from.\n\n  Returns:\n    A list of words longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n  \"\"\"\n  Finds words longer than n characters from a given sentence.\n\n  Args:\n    n: The minimum length of words to include.\n    sentence: A string containing words separated by spaces.\n\n  Returns:\n    A list of words longer than n characters.\n  \"\"\"\n  words = sentence.split()\n  return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the numbers in each row, \n    column, and diagonal is the same.\n\n    Args:\n      matrix: A list of lists representing the square matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Calculate the target sum using the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n            column_sum += matrix[row][col]\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal1_sum = 0\n    diagonal2_sum = 0\n    for i in range(n):\n        diagonal1_sum += matrix[i][i]\n        diagonal2_sum += matrix[i][n - i - 1]\n\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n\n    return True  # All checks passed\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the elements in each row,\n    each column, and both diagonals is the same.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)  # Dimension of the square matrix\n\n    # Calculate the expected magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    # Calculate the expected magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum([matrix[row][col] for row in range(n)]) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum([matrix[i][i] for i in range(n)]) != magic_constant:\n        return False\n    if sum([matrix[i][n - i - 1] for i in range(n)]) != magic_constant:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the numbers in each row,\n    each column, and both diagonals is the same.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)  \n    magic_sum = sum(matrix[0])  \n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n            column_sum += matrix[row][col]\n        if column_sum != magic_sum:\n            return False\n\n    # Check diagonals\n    diagonal1_sum = 0\n    diagonal2_sum = 0\n    for i in range(n):\n        diagonal1_sum += matrix[i][i]\n        diagonal2_sum += matrix[i][n - i - 1]\n\n    if diagonal1_sum != magic_sum or diagonal2_sum != magic_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Checks if a given matrix is a magic square.\n\n  Args:\n    matrix: A list of lists representing the square matrix.\n\n  Returns:\n    True if the matrix is a magic square, False otherwise.\n  \"\"\"\n\n  n = len(matrix)\n  \n  # Calculate the expected sum of each row, column, and diagonal\n  magic_sum = sum(matrix[0])\n\n  # Check rows\n  for row in matrix:\n    if sum(row) != magic_sum:\n      return False\n\n  # Check columns\n  for col in range(n):\n    col_sum = sum([matrix[row][col] for row in range(n)])\n    if col_sum != magic_sum:\n      return False\n\n  # Check diagonals\n  main_diagonal_sum = sum([matrix[i][i] for i in range(n)])\n  anti_diagonal_sum = sum([matrix[i][n-i-1] for i in range(n)])\n  if main_diagonal_sum != magic_sum or anti_diagonal_sum != magic_sum:\n    return False\n\n  return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Checks if a given matrix is a magic square.\n\n  Args:\n    matrix: A list of lists representing a square matrix.\n\n  Returns:\n    True if the matrix is a magic square, False otherwise.\n  \"\"\"\n  n = len(matrix)\n\n  # Calculate the expected magic constant\n  magic_constant = sum(matrix[0])\n\n  # Check rows\n  for row in matrix:\n    if sum(row) != magic_constant:\n      return False\n\n  # Check columns\n  for col in range(n):\n    column_sum = sum(matrix[row][col] for row in range(n))\n    if column_sum != magic_constant:\n      return False\n\n  # Check diagonals\n  diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n  diagonal_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n  if diagonal_sum1 != magic_constant or diagonal_sum2 != magic_constant:\n    return False\n\n  return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  This function determines if a given matrix is a magic square.\n\n  Args:\n      matrix: A list of lists representing the matrix.\n\n  Returns:\n      True if the matrix is a magic square, False otherwise.\n  \"\"\"\n\n  n = len(matrix)\n  # Calculate the expected magic sum\n  magic_sum = sum(matrix[0]) \n\n  # Check rows\n  for row in matrix:\n    if sum(row) != magic_sum:\n      return False\n\n  # Check columns\n  for col in range(n):\n    column_sum = 0\n    for row in range(n):\n      column_sum += matrix[row][col]\n    if column_sum != magic_sum:\n      return False\n\n  # Check diagonals\n  primary_diagonal_sum = 0\n  secondary_diagonal_sum = 0\n  for i in range(n):\n    primary_diagonal_sum += matrix[i][i]\n    secondary_diagonal_sum += matrix[i][n-i-1]\n\n  if primary_diagonal_sum != magic_sum or secondary_diagonal_sum != magic_sum:\n    return False\n\n  return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Checks if a given matrix is a magic square.\n\n  Args:\n    matrix: A list of lists representing the square matrix.\n\n  Returns:\n    True if the matrix is a magic square, False otherwise.\n  \"\"\"\n  n = len(matrix)\n  target_sum = sum(matrix[0])  \n\n  # Check row sums\n  for row in matrix:\n    if sum(row) != target_sum:\n      return False\n\n  # Check column sums\n  for col in range(n):\n    col_sum = 0\n    for row in range(n):\n      col_sum += matrix[row][col]\n    if col_sum != target_sum:\n      return False\n\n  # Check diagonals\n  diag_sum1 = 0\n  diag_sum2 = 0\n  for i in range(n):\n    diag_sum1 += matrix[i][i]\n    diag_sum2 += matrix[i][n - i - 1]\n\n  if diag_sum1 != target_sum or diag_sum2 != target_sum:\n    return False\n\n  return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the elements in each row,\n    each column, and both diagonals are equal.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Calculate the target sum from the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum([matrix[row][col] for row in range(n)])\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal1_sum = sum([matrix[i][i] for i in range(n)])\n    diagonal2_sum = sum([matrix[i][n - i - 1] for i in range(n)])\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the elements in each row,\n    each column, and both diagonals is the same.\n\n    Args:\n      matrix: A list of lists representing a square matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Calculate the sum of the first row\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n - i - 1] for i in range(n))\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the numbers in each row,\n    each column, and both diagonals is the same.\n\n    Args:\n        matrix: A list of lists representing the square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n      if sum(row) != magic_sum:\n        return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = 0\n        for row in range(n):\n          column_sum += matrix[row][col]\n        if column_sum != magic_sum:\n          return False\n\n    # Check diagonals\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    diagonal2_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal1_sum != magic_sum or diagonal2_sum != magic_sum:\n      return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Determines if a given matrix is a magic square.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n\n  Returns:\n    True if the matrix is a magic square, False otherwise.\n  \"\"\"\n  n = len(matrix)\n  target_sum = sum(matrix[0])  # Calculate the expected sum of each row/column/diagonal\n\n  # Check rows\n  for row in matrix:\n    if sum(row) != target_sum:\n      return False\n\n  # Check columns\n  for col in range(n):\n    column_sum = sum(matrix[row][col] for row in range(n))\n    if column_sum != target_sum:\n      return False\n\n  # Check diagonals\n  diagonal1_sum = sum(matrix[i][i] for i in range(n))\n  diagonal2_sum = sum(matrix[i][n - i - 1] for i in range(n))\n  if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n    return False\n\n  return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Write a function to calculate whether the matrix is a magic square.\n\n    Args:\n      matrix: A list of lists representing a square matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    # Calculate the expected magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum([matrix[row][col] for row in range(n)])\n        if column_sum != magic_constant:\n            return False\n\n    # Check diagonals\n    diagonal1_sum = sum([matrix[i][i] for i in range(n)])\n    diagonal2_sum = sum([matrix[i][n - 1 - i] for i in range(n)])\n\n    if diagonal1_sum != magic_constant or diagonal2_sum != magic_constant:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Checks if a given matrix is a magic square.\n\n  A magic square is a square matrix where the sum of the elements in each row, column, and diagonal is the same.\n\n  Args:\n    matrix: A list of lists representing the square matrix.\n\n  Returns:\n    True if the matrix is a magic square, False otherwise.\n  \"\"\"\n  n = len(matrix)\n  magic_sum = sum(matrix[0])\n\n  # Check rows\n  for row in matrix:\n    if sum(row) != magic_sum:\n      return False\n\n  # Check columns\n  for col in range(n):\n    col_sum = 0\n    for row in range(n):\n      col_sum += matrix[row][col]\n    if col_sum != magic_sum:\n      return False\n\n  # Check diagonals\n  diag1_sum = 0\n  diag2_sum = 0\n  for i in range(n):\n    diag1_sum += matrix[i][i]\n    diag2_sum += matrix[i][n-i-1]\n  if diag1_sum != magic_sum or diag2_sum != magic_sum:\n    return False\n\n  return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given square matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the numbers in each row,\n    column, and diagonal is the same.\n\n    Args:\n        matrix: A list of lists representing a square matrix.\n\n    Returns:\n        True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Sum of elements in the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n    diagonal_sum2 = sum(matrix[i][n - i - 1] for i in range(n))\n\n    if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the numbers in each row,\n    each column, and both diagonals is the same.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Sum of elements in the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag1_sum != target_sum or diag2_sum != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Checks if a given matrix is a magic square.\n\n  Args:\n      matrix: A list of lists representing a square matrix.\n\n  Returns:\n      True if the matrix is a magic square, False otherwise.\n  \"\"\"\n\n  n = len(matrix)\n  target_sum = sum(matrix[0])  # Calculate expected sum from first row\n\n  # Check row sums\n  for row in matrix:\n    if sum(row) != target_sum:\n      return False\n\n  # Check column sums\n  for col in range(n):\n    col_sum = sum(matrix[i][col] for i in range(n))\n    if col_sum != target_sum:\n      return False\n\n  # Check diagonal sums\n  diagonal_sum1 = sum(matrix[i][i] for i in range(n))\n  diagonal_sum2 = sum(matrix[i][n - i - 1] for i in range(n))\n  if diagonal_sum1 != target_sum or diagonal_sum2 != target_sum:\n    return False\n\n  return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n\n    Args:\n      matrix: A list of lists representing a square matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Sum of elements in the first row\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n\n    # Check diagonals\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    diagonal2_sum = sum(matrix[i][n - i - 1] for i in range(n))\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n  \"\"\"\n  Checks if a given matrix is a magic square.\n\n  Args:\n      matrix: A list of lists representing a square matrix.\n\n  Returns:\n      True if the matrix is a magic square, False otherwise.\n  \"\"\"\n\n  n = len(matrix)\n  magic_sum = sum(matrix[0]) \n\n  # Check rows\n  for row in matrix:\n    if sum(row) != magic_sum:\n      return False\n\n  # Check columns\n  for col in range(n):\n    column_sum = 0\n    for row in range(n):\n      column_sum += matrix[row][col]\n    if column_sum != magic_sum:\n      return False\n\n  # Check diagonals\n  diagonal_sum1 = 0\n  diagonal_sum2 = 0\n  for i in range(n):\n    diagonal_sum1 += matrix[i][i]\n    diagonal_sum2 += matrix[i][n-i-1]\n  if diagonal_sum1 != magic_sum or diagonal_sum2 != magic_sum:\n    return False\n\n  return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if a given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of the elements in each row, \n    each column, and both diagonals is the same.\n\n    Args:\n      matrix: A list of lists representing a square matrix.\n\n    Returns:\n      True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    target_sum = sum(matrix[0])  # Calculate the expected sum\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[i][col] for i in range(n)) != target_sum:\n            return False\n\n    # Check diagonals\n    primary_diagonal = sum(matrix[i][i] for i in range(n))\n    secondary_diagonal = sum(matrix[i][n-i-1] for i in range(n))\n    if primary_diagonal != target_sum or secondary_diagonal != target_sum:\n        return False\n\n    return True\nmatrix = [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 94.2152466367713, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"\n    Finds the item with maximum frequency in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The item with maximum frequency. If multiple items have the same maximum frequency,\n        returns any one of them.\n    \"\"\"\n\n    counts = Counter(nums)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"Finds the item with the maximum frequency in a given list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The item with the maximum frequency in the list.\n    \"\"\"\n    counts = Counter(nums)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The item with the maximum frequency in the list.\n\n  Raises:\n    ValueError: If the input list is empty.\n  \"\"\"\n  if not nums:\n    raise ValueError(\"Input list cannot be empty.\")\n\n  counts = Counter(nums)  \n  return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n  \"\"\"\n  Find the item with maximum frequency in a given list.\n\n  Args:\n    lst: A list of integers.\n\n  Returns:\n    The item with maximum frequency in the list.\n  \"\"\"\n  return Counter(lst).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The item with the maximum frequency in the list.\n  \"\"\"\n  counts = Counter(nums)\n  return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(data):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    data: A list of elements.\n\n  Returns:\n    The item with the maximum frequency in the list.\n  \"\"\"\n\n  counts = {}\n  for item in data:\n    if item in counts:\n      counts[item] += 1\n    else:\n      counts[item] = 1\n\n  max_item = None\n  max_count = 0\n  for item, count in counts.items():\n    if count > max_count:\n      max_item = item\n      max_count = count\n\n  return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n  Args:\n    numbers: A list of integers.\n  Returns:\n    The item with the maximum frequency.\n  \"\"\"\n  counts = {}\n  for number in numbers:\n    if number in counts:\n      counts[number] += 1\n    else:\n      counts[number] = 1\n\n  max_count = 0\n  max_item = None\n  for number, count in counts.items():\n    if count > max_count:\n      max_count = count\n      max_item = number\n  return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The item with the maximum frequency in the list.\n    \"\"\"\n    counts = Counter(nums)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The item with the maximum frequency in the list.\n  \"\"\"\n  return Counter(nums).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    data: A list of items.\n\n  Returns:\n    The item with the maximum frequency in the list.\n  \"\"\"\n  counts = Counter(data)\n  return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n  \"\"\"Finds the item with maximum frequency in a given list.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      The integer with the highest frequency in the list.\n  \"\"\"\n  counts = Counter(nums)\n  return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(numbers):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The item with the highest frequency in the list.\n  \"\"\"\n  return Counter(numbers).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n  \"\"\"\n  Finds the item with maximum frequency in a given list.\n\n  Args:\n    lst: A list of integers.\n\n  Returns:\n    The item with the maximum frequency in the list.\n  \"\"\"\n\n  counts = {}\n  for item in lst:\n    if item in counts:\n      counts[item] += 1\n    else:\n      counts[item] = 1\n\n  max_item = None\n  max_count = 0\n  for item, count in counts.items():\n    if count > max_count:\n      max_item = item\n      max_count = count\n\n  return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(numbers):\n    \"\"\"Finds the item with maximum frequency in a given list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The item with the maximum frequency in the list.\n    \"\"\"\n    return Counter(numbers).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"\n    Finds the item with maximum frequency in a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The item with maximum frequency.\n    \"\"\"\n    return Counter(nums).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n    nums: A list of numbers.\n\n    Returns:\n    The item with the maximum frequency.\n    \"\"\"\n    counts = Counter(nums)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"\n    Finds the item with maximum frequency in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The item with the highest frequency in the list.\n    \"\"\"\n    counts = Counter(nums)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(data):\n    \"\"\"\n    Finds the item with maximum frequency in a given list.\n\n    Args:\n      data: A list of items.\n\n    Returns:\n      The item with the highest frequency in the list.\n    \"\"\"\n    counts = Counter(data)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(nums):\n    \"\"\"\n    Finds the item with maximum frequency in a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The item with the maximum frequency in the list.\n    \"\"\"\n    counts = {}  # Use a dictionary to store the frequency of each item.\n\n    for num in nums:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    max_count = 0\n    max_item = None\n    for num, count in counts.items():\n        if count > max_count:\n            max_count = count\n            max_item = num\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The item with the highest frequency in the list.\n    \"\"\"\n\n    counts = Counter(nums)\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "Mbpp/140": {"dps": 80.1086956521739, "dps_norm": 74.375, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n  \"\"\"\n  Flattens a list of lists into a single set of numbers.\n\n  Args:\n    list_of_lists: A list of lists, where each inner list contains numbers.\n\n  Returns:\n    A set containing all the numbers from the input list of lists.\n  \"\"\"\n\n  return set([number for sublist in list_of_lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n  \"\"\"\n  Flattens a list of lists into a single set of numbers.\n\n  Args:\n    nested_list: A list of lists containing numbers.\n\n  Returns:\n    A set containing all unique numbers from the nested lists.\n  \"\"\"\n  return set([number for sublist in nested_list for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n  \"\"\"\n  Flattens a list of lists into a single set of numbers.\n\n  Args:\n    list_of_lists: A list of lists containing numbers.\n\n  Returns:\n    A set containing all the numbers from the input lists.\n  \"\"\"\n  return set([number for sublist in list_of_lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        nested_list: A list of lists containing numbers.\n\n    Returns:\n        A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set([num for sublist in nested_list for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set([num for sublist in list_of_lists for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n  \"\"\"\n  Flattens a list of lists into a single set of numbers.\n\n  Args:\n    list_of_lists: A list of lists containing numbers.\n\n  Returns:\n    A set of all the numbers in the input list of lists.\n  \"\"\"\n\n  return set([num for sublist in list_of_lists for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n  \"\"\"\n  Flattens a list of lists into a single set of numbers.\n\n  Args:\n    list_of_lists: A list of lists of numbers.\n\n  Returns:\n    A set of numbers containing all the numbers from all the lists.\n  \"\"\"\n  return set([number for sublist in list_of_lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A set containing all the unique numbers from the input lists.\n    \"\"\"\n    return set([number for sublist in list_of_lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \"\"\"\n    return set([num for sublist in lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n  \"\"\"\n  Extracts all numbers from a list of lists into a single set.\n\n  Args:\n      lst: A list of lists containing numbers.\n\n  Returns:\n      A set containing all the unique numbers from the input list.\n  \"\"\"\n  return set([number for sublist in lst for number in sublist])", "matching_cluster_idx": 5}, {"solution": "from typing import List, Tuple, Set\ndef extract_singly(list_of_lists: List[Tuple[int, int, int]]) -> Set[int]:\n  \"\"\"\n  This function takes a list of tuples containing integers and returns a set of all unique integers from the tuples.\n\n  Args:\n    list_of_lists: A list of tuples, where each tuple contains three integers.\n\n  Returns:\n    A set of all unique integers found within the tuples.\n  \"\"\"\n  return set([num for tup in list_of_lists for num in tup])", "matching_cluster_idx": 5}, {"solution": "from typing import List, Set\ndef extract_singly(nested_list: List[tuple]) -> Set[int]:\n  \"\"\"\n  Flattens a list of lists into a single set of numbers.\n  Args:\n    nested_list: A list of lists of numbers.\n\n  Returns:\n    A set containing all unique numbers from the input list.\n  \"\"\"\n  extracted_numbers = set()\n  for sublist in nested_list:\n    for number in sublist:\n      extracted_numbers.add(number)\n  return extracted_numbers", "matching_cluster_idx": 4}, {"solution": "from typing import List, Set\ndef extract_singly(list_of_lists: List[tuple]) -> Set[int]:\n  \"\"\"\n  Write a function to flatten the list of lists into a single set of numbers.\n  assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n  \"\"\"\n  return set([num for sublist in list_of_lists for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n      lists: A list of lists containing numbers.\n\n    Returns:\n      A set containing all the numbers from the input lists, without duplicates.\n    \"\"\"\n    return set([number for sublist in lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    \"\"\"Flattens a list of lists into a single set of numbers.\n    \"\"\"\n    return set([num for sublist in lst for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n\n    assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n    \"\"\"\n    return set([num for sublist in nested_list for num in sublist])\nnested_list = [(3, 4, 5), (4, 5, 7), (1, 4)]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n\n    assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n\n    \"\"\"\n    return set([num for sublist in nested_list for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n    list_of_lists: A list of lists of numbers.\n\n    Returns:\n    A set containing all the numbers from the input list of lists.\n    \"\"\"\n    return set([num for sublist in list_of_lists for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lists_of_lists):\n  \"\"\"\n  This function flattens a list of lists into a single set of numbers.\n\n  Args:\n      lists_of_lists: A list of lists containing numbers.\n\n  Returns:\n      A set of all numbers found in the input list of lists.\n  \"\"\"\n\n  return set([number for sublist in lists_of_lists for number in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists: A list of lists containing numbers.\n\n    Returns:\n        A set of unique numbers from all the sublists.\n    \"\"\"\n    return set([number for sublist in list_of_lists for number in sublist])", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 98.41269841269842, "dps_norm": 50.0, "pass@1": 90.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list of elements using the Pancake Sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = arr.index(max(arr[:i + 1]))\n\n        # If the maximum element is not already in the correct position\n        if max_index != i:\n            # Flip the list from 0 to max_index\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Flip the list from 0 to i\n            arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        max_index = arr.index(max(arr[:i+1]))\n        if max_index != i:\n            arr[:max_index+1] = reversed(arr[:max_index+1])  # Flip to bring max to front\n            arr[:i+1] = reversed(arr[:i+1])             # Flip to move max to its correct position\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list of elements using the Pancake Sort algorithm.\n\n    Args:\n        arr: A list of elements to sort.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Flips the sub-array from index 0 to k.\"\"\"\n        return arr[:k+1][::-1] + arr[k+1:]\n\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        max_index = arr.index(max(arr[:i+1])) \n        arr = flip(arr, max_index)  \n        arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sorting algorithm.\n\n    Args:\n        arr: A list of comparable elements.\n\n    Returns:\n        A new sorted list containing the same elements as arr.\n    \"\"\"\n\n    def flip(arr, k):\n        \"\"\"Flips the first k elements of the list in place.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    n = len(arr)\n    sorted_arr = arr.copy()\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = sorted_arr.index(max(sorted_arr[:i + 1]))\n        \n        # Move the maximum element to the beginning of the list\n        if max_index != 0:\n            sorted_arr = flip(sorted_arr, max_index + 1)\n        # Move the maximum element to its correct position at the end\n        sorted_arr = flip(sorted_arr, i + 1)\n    return sorted_arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted subarray\n        max_index = arr.index(max(arr[:i + 1]))\n\n        # If the maximum element is not already at the end of the subarray\n        if max_index != i:\n            # Flip the subarray from 0 to max_index\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n            # Flip the subarray from 0 to i\n            arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr: The list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        max_index = arr.index(max(arr[:i + 1]))\n        # Flip to bring the maximum element to the beginning\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n        # Flip the entire array to place the maximum element at its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n  \"\"\"\n  Sorts a list using the pancake sorting algorithm.\n\n  Args:\n      arr: The list to sort.\n\n  Returns:\n      The sorted list.\n  \"\"\"\n  n = len(arr)\n\n  for i in range(n):\n    max_index = arr.index(max(arr[:n-i]))\n    if max_index != n - i - 1:\n      arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n      arr = arr[:n-i][::-1] + arr[n-i:]\n  return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n        arr: A list of elements to be sorted.\n\n    Returns:\n        A new list with the elements of arr sorted in ascending order.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        max_idx = arr.index(max(arr[:n-i]))  # Find the index of the maximum element in the unsorted part\n        \n        # Flip to bring the maximum element to the beginning\n        arr[:max_idx+1] = reversed(arr[:max_idx+1])\n        \n        # Flip to bring the maximum element to its correct position\n        arr[:n-i] = reversed(arr[:n-i])\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sorting algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        max_index = arr.index(max(arr[:n - i]))\n        if max_index != n - i - 1:\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            arr[:n - i] = arr[:n - i][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_index = arr.index(max(arr[:i + 1]))\n\n        # If the maximum element is not already in its correct position\n        if max_index != i:\n            # Flip the sub-array from 0 to max_index\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Flip the sub-array from 0 to i\n            arr[:i + 1] = arr[:i + 1][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr: A list of comparable elements.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:i + 1]))\n\n        # If the maximum element is not already at the end of the unsorted portion,\n        # flip the sub-array from 0 to max_index\n        if max_index != i:\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            # Flip the entire unsorted portion\n            arr[:i + 1] = reversed(arr[:i + 1])\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr: A list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:i + 1]))\n\n        # If the maximum element is not already in the correct position\n        if max_index != i:\n            # Flip the subarray from 0 to max_index\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n            # Flip the subarray from 0 to i\n            arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr\narr = [15, 79, 25, 38, 69]", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr: A list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        # Find the index of the maximum element in the unsorted subarray\n        max_index = arr.index(max(arr[:n-i]))\n\n        # Flip the subarray from 0 to max_index\n        arr[:max_index+1] = arr[:max_index+1][::-1]\n        # Flip the subarray from 0 to n-i-1\n        arr[:n-i] = arr[:n-i][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n    arr: A list of elements to be sorted.\n\n    Returns:\n    A sorted list of elements.\n    \"\"\"\n\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:i+1]))\n\n        # Flip the list from 0 to max_index\n        arr[:max_index+1] = arr[:max_index+1][::-1]\n        \n        # Flip the list from 0 to i\n        arr[:i+1] = arr[:i+1][::-1]\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n  \"\"\"Sorts a list using the pancake sort algorithm.\"\"\"\n\n  def flip(arr, k):\n    arr[:k] = arr[:k][::-1]\n  \n  n = len(arr)\n  for i in range(n - 1, 0, -1):\n    # Find the index of the largest element in the unsorted part\n    max_idx = arr.index(max(arr[:i + 1]))\n\n    # If the largest element is not already at the end of the unsorted part\n    if max_idx != i:\n      # Flip the largest element to the beginning\n      flip(arr, max_idx + 1)\n      # Flip the entire unsorted part to put the largest element at the end\n      flip(arr, i + 1)\n\n  return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        arr: A list of elements to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    n = len(arr)\n    for i in range(n):\n        max_index = arr.index(max(arr[: n - i]))\n        if max_index != n - i - 1:\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            arr[:n - i] = arr[:n - i][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr: The list to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_idx = arr.index(max(arr[: i + 1]))\n\n        # Flip to bring the maximum element to the beginning\n        arr[: max_idx + 1] = arr[: max_idx + 1][::-1]\n\n        # Flip the whole unsorted part to its correct position\n        arr[: i + 1] = arr[: i + 1][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"Sorts a list using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:i + 1]))\n        \n        # Bring the maximum element to the beginning (first flip)\n        arr[:max_index + 1] = reversed(arr[:max_index + 1])\n        \n        # Bring the maximum element to its correct position (second flip)\n        arr[:i + 1] = reversed(arr[:i + 1])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n  \"\"\"Sorts a list of elements using the Pancake Sort algorithm.\n\n  Args:\n    arr: A list of elements to be sorted.\n\n  Returns:\n    The sorted list.\n  \"\"\"\n  n = len(arr)\n  for i in range(n - 1, 0, -1):\n    # Find the index of the maximum element in the unsorted part of the array\n    max_index = arr.index(max(arr[:i + 1]))\n\n    # If the maximum element is not already in its correct position\n    if max_index != i:\n      # Flip the array from 0 to max_index\n      arr[:max_index + 1] = reversed(arr[:max_index + 1])\n\n      # Flip the array from 0 to i\n      arr[:i + 1] = reversed(arr[:i + 1])\n  return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n      arr: A list of elements to sort.\n\n    Returns:\n      The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        # Find index of the maximum element in the unsorted part\n        max_index = arr.index(max(arr[:i + 1]))\n \n        # If max element is not at the beginning, flip to the beginning\n        if max_index != 0:\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n\n        # Flip the entire unsorted part to place max element at its correct position\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs of integers in the list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    For example:\n    find_even_pair([5, 4, 7, 2, 1]) == 4\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"Counts the number of pairs of integers in a list that XOR to an even number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The number of pairs of integers in the list that XOR to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that xor to an even number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The number of pairs of integers in the list that xor to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n    nums: A list of integers.\n\n    Returns:\n    The number of pairs of integers in the list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs of integers in nums that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that xor to an even number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The number of pairs of integers in the list that xor to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that xor to an even number.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      The number of pairs of integers in the list that xor to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs of integers in nums that XOR to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The number of pairs of integers in nums that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n      for j in range(i + 1, len(nums)):\n        if (nums[i] ^ nums[j]) % 2 == 0:\n          count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums: list[int]) -> int:\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n      for j in range(i + 1, len(nums)):\n        if (nums[i] ^ nums[j]) % 2 == 0:\n          count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs of integers in the list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"Counts the number of pairs of integers in a list that xor to an even number.\n  \n  Args:\n    nums: A list of integers.\n  \n  Returns:\n    The number of pairs that xor to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i+1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count\nnums = [5, 4, 7, 2, 1]", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that XOR to an even number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The number of pairs of integers in the list that XOR to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The number of pairs of integers in nums that XOR to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that xor to an even number.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      The number of pairs of integers in the list that xor to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count\nnums = [5, 4, 7, 2, 1]", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that xor to an even number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The number of pairs of integers in nums that xor to an even number.\n  \"\"\"\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n  \"\"\"\n  Counts the number of pairs of integers in a list that xor to an even number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The number of pairs of integers in the list that xor to an even number.\n  \"\"\"\n\n  count = 0\n  for i in range(len(nums)):\n    for j in range(i + 1, len(nums)):\n      if (nums[i] ^ nums[j]) % 2 == 0:\n        count += 1\n  return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 30.0, "profiled": [{"solution": "def sum_range_list(numbers, start_index, end_index):\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    numbers: A list of numbers.\n    start_index: The starting index of the range (inclusive).\n    end_index: The ending index of the range (inclusive).\n\n  Returns:\n    The sum of numbers within the specified range.\n  \"\"\"\n  if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n    return 0\n  return sum(numbers[start_index : end_index + 1])\nnumbers = [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12]\nstart_index = 8\nend_index = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n  \"\"\"\n  This function calculates the sum of numbers in a list within a specified range.\n\n  Args:\n      nums: A list of numbers.\n      start: The starting index (inclusive) of the range.\n      end: The ending index (inclusive) of the range.\n\n  Returns:\n      The sum of numbers in the specified range of the list.\n  \"\"\"\n  if start < 0 or end >= len(nums) or start > end:\n    return 0\n  return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n        nums (list): The input list of numbers.\n        start_index (int): The starting index (inclusive).\n        end_index (int): The ending index (inclusive).\n\n    Returns:\n        int: The sum of numbers within the specified range.\n    \"\"\"\n\n    if start_index < 0 or end_index >= len(nums) or start_index > end_index:\n        return 0  \n    return sum(nums[start_index : end_index + 1])\nnums = [2,1,5,6,8,3,4,9,10,11,8,12]\nstart_index = 8\nend_index = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n  \"\"\"\n  Calculates the sum of numbers in a list within a given range.\n\n  Args:\n      nums: A list of numbers.\n      start_index: The starting index (inclusive) of the range.\n      end_index: The ending index (inclusive) of the range.\n\n  Returns:\n      The sum of the numbers in the specified range.\n      Returns 0 if the provided indices are invalid.\n  \"\"\"\n  if 0 <= start_index <= end_index < len(nums):\n    return sum(nums[start_index : end_index + 1])\n  else:\n    return 0", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n      numbers: A list of numbers.\n      start_index: The starting index of the range (inclusive).\n      end_index: The ending index of the range (inclusive).\n\n  Returns:\n      The sum of numbers within the specified range.\n  \"\"\"\n  if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n    return 0 \n  return sum(numbers[start_index : end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n  \"\"\"Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n      nums: A list of numbers.\n      start: The starting index (inclusive).\n      end: The ending index (inclusive).\n\n  Returns:\n      The sum of numbers in the specified range.\n  \"\"\"\n  if start < 0 or end >= len(nums) or start > end:\n    return 0\n  return sum(nums[start : end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    numbers: A list of numbers.\n    start_index: The starting index (inclusive) of the range.\n    end_index: The ending index (inclusive) of the range.\n\n  Returns:\n    The sum of the numbers in the specified range.\n  \"\"\"\n  if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n    return 0\n  return sum(numbers[start_index : end_index + 1])\nnumbers = [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12]", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums: list, start: int, end: int) -> int:\n    \"\"\"\n    Given a list of numbers, find the sum of numbers within a given range.\n\n    Args:\n      nums: A list of numbers.\n      start: The starting index (inclusive) of the range.\n      end: The ending index (inclusive) of the range.\n\n    Returns:\n      The sum of the numbers in the list within the specified range.\n    \"\"\"\n    if start < 0 or end >= len(nums) or start > end:\n      return 0\n\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        nums: The list of numbers.\n        start: The starting index (inclusive).\n        end: The ending index (inclusive).\n\n    Returns:\n        The sum of numbers in the specified range.\n    \"\"\"\n    if start < 0 or end >= len(nums) or start > end:\n      return 0\n    return sum(nums[start : end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data: list, start_index: int, end_index: int) -> int:\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    data: A list of numbers.\n    start_index: The starting index (inclusive) of the range.\n    end_index: The ending index (inclusive) of the range.\n\n  Returns:\n    The sum of the numbers in the specified range.\n\n  Raises:\n    IndexError: If the start or end indices are out of range.\n  \"\"\"\n  if not 0 <= start_index <= len(data) - 1 or not 0 <= end_index <= len(data) - 1:\n    raise IndexError(\"Indices are out of range.\")\n\n  return sum(data[start_index : end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n  \"\"\"\n  Calculate the sum of numbers in a list within a specified range.\n\n  Args:\n      nums: A list of numbers.\n      start: The starting index (inclusive).\n      end: The ending index (inclusive).\n\n  Returns:\n      The sum of the numbers in the list within the specified range.\n  \"\"\"\n\n  if start < 0 or end >= len(nums) or start > end:\n    return 0\n  return sum(nums[start:end+1])\nnums = [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12]\nstart = 8\nend = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(data, start, end):\n  \"\"\"\n  This function finds the sum of numbers in a list within a range specified by two indices.\n\n  Args:\n      data: A list of numbers.\n      start: The starting index (inclusive) of the range.\n      end: The ending index (inclusive) of the range.\n\n  Returns:\n      The sum of the numbers within the specified range.\n      Returns 0 if the start or end indices are invalid.\n  \"\"\"\n\n  if start < 0 or end >= len(data) or start > end:\n      return 0  \n\n  return sum(data[start : end+1])\ndata = [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12]", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n  \"\"\"\n  This function calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    nums: A list of numbers.\n    start_index: The starting index of the range (inclusive).\n    end_index: The ending index of the range (inclusive).\n\n  Returns:\n    The sum of numbers within the specified range.\n  \"\"\"\n  if start_index < 0 or end_index >= len(nums) or start_index > end_index:\n    return 0 \n  return sum(nums[start_index : end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n  \"\"\"\n\n  This function calculates the sum of numbers in a list within a specified range.\n\n  Args:\n      nums: A list of numbers.\n      start: The starting index of the range (inclusive).\n      end: The ending index of the range (inclusive).\n\n  Returns:\n      The sum of the numbers in the specified range, or 0 if the range is invalid.\n\n  \"\"\"\n  if start < 0 or end >= len(nums) or start > end:\n    return 0\n\n  return sum(nums[start : end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n      numbers: The list of numbers.\n      start_index: The starting index (inclusive) of the range.\n      end_index: The ending index (inclusive) of the range.\n\n  Returns:\n      The sum of numbers within the specified range.\n  \"\"\"\n  if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n    return 0  \n  return sum(numbers[start_index : end_index+1])\nnumbers = [2,1,5,6,8,3,4,9,10,11,8,12]\nstart_index = 8\nend_index = 10", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    nums: A list of numbers.\n    start: The starting index of the range (inclusive).\n    end: The ending index of the range (inclusive).\n\n  Returns:\n    The sum of numbers in the specified range.\n  \"\"\"\n  return sum(nums[start:end+1])\nnums = [2,1,5,6,8,3,4,9,10,11,8,12]", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n    nums: A list of numbers.\n    start: The starting index (inclusive) of the range.\n    end: The ending index (inclusive) of the range.\n\n    Returns:\n    The sum of numbers in the specified range.\n    \"\"\"\n\n    if start < 0 or end >= len(nums) or start > end:\n        return 0  \n\n    return sum(nums[start : end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n  \"\"\"\n  Calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    nums: A list of numbers.\n    start_index: The starting index (inclusive) of the range.\n    end_index: The ending index (inclusive) of the range.\n\n  Returns:\n    The sum of numbers in the specified range.\n  \"\"\"\n  if start_index < 0 or end_index >= len(nums) or start_index > end_index:\n    return 0\n\n  return sum(nums[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculates the sum of numbers in a list within a specified range.\n\n    Args:\n        nums: A list of numbers.\n        start: The starting index (inclusive) of the range.\n        end: The ending index (inclusive) of the range.\n\n    Returns:\n        The sum of numbers in the specified range.\n    \"\"\"\n    if start < 0 or end >= len(nums) or start > end:\n        return 0  \n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n  \"\"\"\n  This function calculates the sum of numbers in a list within a specified range.\n\n  Args:\n    nums: A list of numbers.\n    start: The starting index of the range (inclusive).\n    end: The ending index of the range (inclusive).\n\n  Returns:\n    The sum of numbers within the specified range.\n  \"\"\"\n  if start < 0 or end >= len(nums) or start > end:\n    return 0 \n  return sum(nums[start : end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 77.71317829457364, "dps_norm": 38.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function takes a string and returns a new string containing only the characters at even indices.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      A new string containing only the characters at even indices of the input string.\n  \"\"\"\n  return str1[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function removes the characters which have odd index values of a given string.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      A string containing only the characters at even indices.\n  \"\"\"\n  return str1[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(text):\n  \"\"\"Returns a new string containing only characters at even indices from the input string.\n  For example:\n  odd_values_string('abcdef') == 'ace'\n  \"\"\"\n  return ''.join(text[i] for i in range(len(text)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(text: str) -> str:\n  \"\"\"\n  Write a python function to remove the characters which have odd index values of a given string.\n  assert odd_values_string('abcdef') == 'ace'\n  \"\"\"\n  return \"\".join([text[i] for i in range(len(text)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(text: str) -> str:\n  \"\"\"\n  Write a python function to remove the characters which have odd index values of a given string.\n  assert odd_values_string('abcdef') == 'ace'\n  \"\"\"\n  return ''.join(text[i] for i in range(len(text)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function removes the characters which have odd index values of a given string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  return \"\".join([str1[i] for i in range(len(str1)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(str1):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    result = ''\n    for i in range(len(str1)):\n        if i % 2 == 0:\n            result += str1[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n\n  This function removes characters at odd indexes of a string and returns a new string with remaining characters.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A string with characters at odd indexes removed.\n  \"\"\"\n\n  return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function takes a string as input and returns a new string\n  containing only the characters at even indices.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      A new string containing only the characters at even indices of the input string.\n  \"\"\"\n  return ''.join(str1[i] for i in range(len(str1)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  Returns a new string with characters at odd indices removed.\n\n  Args:\n      str1: The input string\n\n  Returns:\n      A string with characters at odd indices removed.\n\n  Examples:\n      odd_values_string('abcdef') == 'ace'\n  \"\"\"\n\n  return ''.join(str1[i] for i in range(len(str1)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(text):\n  \"\"\"\n  This function removes the characters which have odd index values of a given string.\n\n  Args:\n    text: A string\n\n  Returns:\n    A string with characters at odd indices removed\n  \"\"\"\n  new_text = \"\"\n  for i in range(len(text)):\n    if i % 2 == 0:\n      new_text += text[i]\n  return new_text", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(text):\n  \"\"\"\n  Removes the characters which have odd index values of a given string.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      The string with characters at odd indices removed.\n  \"\"\"\n  return text[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function removes characters at odd indices from a string.\n\n  Args:\n    str1: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  result = \"\"\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function takes a string as input and returns a new string with only the characters at even indices.\n\n  Args:\n      str1 (str): The input string.\n\n  Returns:\n      str: A new string with characters at even indices from the input string.\n  \"\"\"\n\n  return str1[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  Write a python function to remove the characters which have odd index values of a given string.\n  \"\"\"\n  return str1[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(string):\n    \"\"\"\n    Removes characters with odd index values from a given string.\n\n    Args:\n        string: The input string\n\n    Returns:\n        A new string containing only characters with even index values.\n    \"\"\"\n\n    return \"\".join(string[i] for i in range(len(string)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(text: str) -> str:\n  \"\"\"\n  Write a python function to remove the characters which have odd index values of a given string.\n\n  assert odd_values_string('abcdef') == 'ace'\n  \"\"\"\n  result = \"\"\n  for i in range(len(text)):\n    if i % 2 == 0:\n      result += text[i]\n  return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(text: str) -> str:\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n\n    assert odd_values_string('abcdef') == 'ace'\n    \"\"\"\n    return ''.join([text[i] for i in range(len(text)) if i % 2 == 0])", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  This function removes the characters which have odd index values of a given string.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      A new string with characters at odd indices removed.\n  \"\"\"\n  return ''.join([str1[i] for i in range(len(str1)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n  \"\"\"\n  Write a python function to remove the characters which have odd index values of a given string.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      A new string with the characters at odd indices removed.\n  \"\"\"\n  result = ''\n  for i in range(len(str1)):\n    if i % 2 == 0:\n      result += str1[i]\n  return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def replace_blank(text, char):\n  \"\"\"\n  Replaces blank spaces in a string with a given character.\n\n  Args:\n      text: The input string.\n      char: The character to replace blank spaces with.\n\n  Returns:\n      The string with blank spaces replaced by the given character.\n  \"\"\"\n  return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"Replaces blank spaces in a string with a given character.\n\n  Args:\n    string: The string to be modified.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The modified string with blank spaces replaced.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"\n  Replaces blank spaces in a string with a given character.\n\n  Args:\n    string: The input string.\n    char: The character to replace spaces with.\n\n  Returns:\n    The string with spaces replaced by the given character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"Replaces blank spaces in a string with a given character.\n\n  Args:\n    string: The input string.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The string with blank spaces replaced by the specified character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n\n    Args:\n      string: The input string.\n      char: The character to replace blank spaces with.\n\n    Returns:\n      The string with blank spaces replaced.\n    \"\"\"\n\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"Replaces blank spaces in a string with a specified character.\n  \n  Args:\n    string: The string to be modified.\n    char: The character to replace spaces with.\n\n  Returns:\n    The modified string with spaces replaced by the given character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n  \"\"\"Replaces blank spaces in a string with a given character.\n\n  Args:\n    text: The string to be processed.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The string with blank spaces replaced by the given character.\n  \"\"\"\n  return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replaces blank spaces in a string with a given character.\n\n    Args:\n        string: The input string.\n        char: The character to replace blank spaces with.\n\n    Returns:\n        The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"\n  Replaces blank spaces in a string with a given character.\n\n  Args:\n    string: The input string.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The string with blank spaces replaced by the given character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n  \"\"\"\n  This function takes a string and a character, replaces blank spaces \n  in the string with the character, and returns the modified string.\n\n  Args:\n      string: The input string.\n      character: The character to replace blank spaces with.\n\n  Returns:\n      The modified string with blank spaces replaced by the specified character.\n  \"\"\"\n  return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"Replaces blank spaces in a string with a given character.\n\n  Args:\n    string: The input string.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The string with blank spaces replaced by the given character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"\n  This function takes in a string and a character, replaces blank spaces in the string with the character, and returns the new string.\n\n  Args:\n    string: The input string.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The modified string with blank spaces replaced by the given character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"Replaces blank spaces in a string with a given character.\n\n  Args:\n      string: The input string.\n      char: The character to replace blank spaces with.\n\n  Returns:\n      The string with blank spaces replaced by the character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"\n  This function takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\n  Args:\n      string: The string to be processed.\n      char: The character to replace blank spaces with.\n\n  Returns:\n      The string with blank spaces replaced by the character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"Replaces blank spaces in a string with a given character.\n    \n    Args:\n        s: The input string.\n        char: The character to replace blank spaces with.\n    \n    Returns:\n        The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  return string.replace(\" \",char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  return string.replace(\" \",char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"\n  This function takes in a string and a character, replaces blank spaces in the string \n  with the character, and returns the new string.\n\n  Args:\n    string: The string to be processed.\n    char: The character to replace spaces with.\n\n  Returns:\n    The string with spaces replaced by the given character.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n  \"\"\"Replaces blank spaces in a string with a given character.\n\n  Args:\n    string: The string to be processed.\n    char: The character to replace blank spaces with.\n\n  Returns:\n    The string with blank spaces replaced.\n  \"\"\"\n  return string.replace(\" \", char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 79.3103448275862, "dps_norm": 80.0, "pass@1": 19.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  Finds the number of possible sequences of length n, \n  such that each element is a positive integer and is greater than or equal\n  to twice the previous element but less than or equal to m.\n\n  Args:\n    m: The maximum value of elements in the sequence.\n    n: The length of the sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Initialization: For a sequence of length 1, any number from 1 to m is valid.\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Iterate over sequence lengths from 2 to n\n  for i in range(2, n + 1):\n    # Iterate over possible ending values for the sequence\n    for j in range(1, m + 1):\n      # For each ending value, sum the counts of sequences with \n      # previous elements that are valid (i.e., less than j/2)\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k]\n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n,\n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    assert get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Initialize base case: for a sequence of length 1, we can have any number from 1 to m\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Iterate through each possible sequence length\n    for i in range(2, n + 1):\n        # Iterate through each possible last element in the sequence\n        for j in range(1, m + 1):\n            # Iterate through all possible previous elements\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  Finds the number of possible sequences of length n, such that each element \n  is a positive integer and is greater than or equal to twice the previous element\n  but less than or equal to m.\n\n  Args:\n    m: The upper bound for each element in the sequence.\n    n: The length of the sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Initialize base case: for sequence of length 1, any number from 1 to m is valid\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Build up the dp table\n  for i in range(2, n + 1):  # For each sequence length\n    for j in range(1, m + 1):  # For each possible last element\n      for k in range(1, j // 2 + 1):  # For each possible previous element\n        dp[i][j] += dp[i - 1][k]\n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n  \"\"\"\n  Given positive integers m and n, find the number of possible sequences of length n, \n  such that each element is a positive integer and is greater than or equal to \n  twice the previous element but less than or equal to m.\n\n  Args:\n    m: The upper limit of each element in the sequence.\n    n: The length of the desired sequences.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Base case: For a sequence of length 1, we can have any number from 1 to m\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Build up the dp table\n  for i in range(2, n + 1):\n    for j in range(1, m + 1):\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k]\n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Counts the number of possible sequences of length n, where each element is a positive integer\n    greater than or equal to twice the previous element and less than or equal to m.\n\n    Args:\n      m: The upper limit for each element in the sequence.\n      n: The length of the desired sequences.\n\n    Returns:\n      The number of possible sequences.\n    \"\"\"\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base case: For a sequence of length 1, there are 'm' possible values (1 to m).\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Iterate through each sequence length\n    for i in range(2, n + 1):\n        # Iterate through each possible value for the last element\n        for j in range(1, m + 1):\n            # Sum the possibilities from all valid previous elements\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Given positive integers m and n, return the number of possible sequences of length n, such that each element\n    is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    \"\"\"\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Initialize base case: for n=1, all numbers up to m are valid\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Build up the dp table\n    for i in range(2, n + 1):\n      for j in range(1, m + 1):\n        for k in range(1, j // 2 + 1):\n          dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  Counts the number of possible sequences of length n, where each element is a\n  positive integer greater than or equal to twice the previous element but less than\n  or equal to m.\n\n  Args:\n    m: The maximum allowed value for any element in the sequence.\n    n: The length of the sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Base case: For a sequence of length 1, any value from 1 to m is valid.\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # For each sequence length from 2 to n...\n  for i in range(2, n + 1):\n    # For each possible value of the last element...\n    for j in range(1, m + 1):\n      # Count sequences ending in j by considering possible previous elements.\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k]\n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is\n    a positive integer and is greater than or equal to twice the previous element\n    but less than or equal to m.\n    \"\"\"\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Initialization: For a sequence of length 1, any number from 1 to m is valid.\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    for i in range(2, n + 1):  # Iterate through sequence lengths\n        for j in range(1, m + 1): # Iterate through possible last element values\n            for k in range(1, j // 2 + 1): # Iterate through possible previous element values\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  Counts the number of possible sequences of length n, where each element is\n  a positive integer greater than or equal to twice the previous element,\n  and less than or equal to m.\n\n  Args:\n    m: The maximum value of each element in the sequence.\n    n: The length of the sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Base case: for a sequence of length 1, there's one valid sequence for each possible value\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  for i in range(2, n + 1):  # Iterate through sequence lengths\n    for j in range(1, m + 1):  # Iterate through possible ending values\n      for k in range(1, j // 2 + 1):  # Iterate through possible previous values\n        dp[i][j] += dp[i - 1][k]\n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  This function takes in positive integers m and n and finds the number of possible sequences of length n,\n  such that each element is a positive integer and is greater than or equal to twice the previous element \n  but less than or equal to m.\n\n  For example:\n  get_total_number_of_sequences(10, 4) == 4\n  \"\"\"\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Base case: For length 1 sequence, all numbers from 1 to m are valid\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Iterate over sequence lengths\n  for i in range(2, n + 1):\n    # Iterate over possible ending numbers for a sequence of length i\n    for j in range(1, m + 1):\n      # For each ending number, consider all possible previous numbers\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k] \n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n,\n    where each element is a positive integer greater than or equal to\n    twice the previous element but less than or equal to m.\n\n    Args:\n      m: The maximum allowed value for each element in the sequence.\n      n: The length of the sequence.\n\n    Returns:\n      The number of possible sequences.\n    \"\"\"\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Base case: For a sequence of length 1, there's 1 valid sequence for each possible starting number\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Iterate through sequence lengths from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # For each possible value j at position i,\n            # sum the valid sequences from previous positions\n            # where the previous value is at most j // 2\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # The total number of sequences of length n is the sum of valid sequences ending with\n    # each possible value from 1 to m\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function takes in positive integers m and n and finds the number of possible sequences\n    of length n, such that each element is a positive integer and is greater than or equal\n    to twice the previous element but less than or equal to m.\n\n    For example:\n    get_total_number_of_sequences(10, 4) == 4\n    \"\"\"\n\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Base case: For sequence length 1, any number from 1 to m is valid\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    for i in range(2, n + 1):  # Iterate over sequence lengths\n        for j in range(1, m + 1):  # Iterate over possible ending numbers\n            for k in range(1, j // 2 + 1):  # Iterate over possible previous numbers\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  This function takes in positive integers m and n and finds the number of possible sequences of length n, \n  such that each element is a positive integer and is greater than or equal to twice the previous element \n  but less than or equal to m.\n\n  Args:\n    m: The upper limit of the integers in the sequence.\n    n: The length of the desired sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n  \n  # Initialize base case: For a sequence of length 1, any number from 1 to m is valid.\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Iterate through each sequence length from 2 to n\n  for i in range(2, n + 1):\n    # For each possible ending value in the sequence\n    for j in range(1, m + 1):\n      # Iterate through possible previous values\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k]\n  \n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  This function calculates the number of possible sequences of length n,\n  such that each element is a positive integer and is greater than or equal to\n  twice the previous element but less than or equal to m.\n\n  Args:\n    m: The upper limit for each element in the sequence.\n    n: The length of the sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n  # Base case: For a sequence of length 1, any number from 1 to m is valid.\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Iterate through each possible sequence length\n  for i in range(2, n + 1):\n    # Iterate through each possible ending value for the sequence\n    for j in range(1, m + 1):\n      # For each ending value, sum the number of valid sequences\n      # ending with values that are half or less (since the current element\n      # must be at least twice the previous).\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k]\n\n  # Return the total number of valid sequences of length n ending with any value\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n    \"\"\"\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Base case: for a sequence of length 1, there's 1 possible sequence for each valid value of the element\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    # Iterate through lengths of sequences from 2 to n\n    for j in range(2, n + 1):\n        # Iterate through possible values of the last element\n        for i in range(1, m + 1):\n            # For each element, count sequences with the element as the last element\n            for k in range(1, i // 2 + 1):\n                dp[i][j] += dp[k][j - 1]\n\n    # Return the total count for sequences of length n with any last element\n    return sum(dp[i][n] for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, such that each element is a\n    positive integer and is greater than or equal to twice the previous element but\n    less than or equal to m.\n\n    Args:\n        m: The maximum value of an element in the sequence.\n        n: The length of the sequence.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Counts the number of possible sequences of length n, where each element is a positive integer \n    greater than or equal to twice the previous element and less than or equal to m.\n\n    Args:\n        m: The upper limit for the elements in the sequence.\n        n: The length of the sequences.\n\n    Returns:\n        The number of possible sequences.\n    \"\"\"\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Base case: For length 1, any number from 1 to m is valid\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Build up the solution iteratively for lengths from 2 to n\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # For each element j, count valid sequences ending with j\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return sum(dp[n])  # Total count for sequences of length n", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  Finds the number of possible sequences of length n, such that each element \n  is a positive integer and is greater than or equal to twice the previous element\n  but less than or equal to m.\n\n  Args:\n    m: The upper bound for the elements in the sequence.\n    n: The length of the sequence.\n\n  Returns:\n    The number of possible sequences.\n  \"\"\"\n\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n  \n  # Base case: For a sequence of length 1, any number from 1 to m is valid\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Fill the dp table\n  for i in range(2, n + 1):\n    for j in range(1, m + 1):\n      # For each possible last element j, count the valid previous elements\n      for k in range(1, j // 2 + 1): \n        dp[i][j] += dp[i - 1][k]\n\n  return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n  \"\"\"\n  Calculates the number of possible sequences of length n,\n  such that each element is a positive integer greater than\n  or equal to twice the previous element but less than or equal to m.\n  \"\"\"\n\n  dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n  \n  # Base case: For a sequence of length 1, any number from 1 to m is valid\n  for i in range(1, m + 1):\n    dp[1][i] = 1\n\n  # Iterate through sequence lengths from 2 to n\n  for i in range(2, n + 1):\n    # Iterate through possible values of the last element in the sequence\n    for j in range(1, m + 1):\n      # Iterate through possible values of the second-to-last element\n      for k in range(1, j // 2 + 1):\n        dp[i][j] += dp[i - 1][k] \n\n  return sum(dp[n])", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 51.52439024390244, "dps_norm": 67.77777777777779, "pass@1": 83.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n  \"\"\"Replaces the last element of lst1 with the elements of lst2.\"\"\"\n  lst1[-1:] = lst2\n  return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n  \"\"\"Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n  \n  Args:\n    list1: The first list.\n    list2: The second list.\n  \n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  This function takes two lists and replaces the last element of the first list\n  with the elements of the second list.\n\n  Args:\n      list1: The first list.\n      list2: The second list.\n\n  Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  new_list = list1[:-1] + list2\n  return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n      lst1: The first list.\n      lst2: The second list.\n\n  Returns:\n      A new list with the last element of lst1 replaced by the elements of lst2.\n  \"\"\"\n\n  return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  This function replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  new_list = list1[:-1] + list2\n  return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n\n    Returns:\n      A new list with the last element of the first list replaced by the elements of the second list.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    The modified first list.\n  \"\"\"\n  list1[-1:] = list2\n  return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  This function takes in two lists and replaces the last element of the first list\n  with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the modification described above.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  This function takes in two lists and replaces the last element of the first list with the elements of the second list.\n\n  Args:\n      list1: The first list.\n      list2: The second list.\n\n  Returns:\n      A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    The modified first list with the last element replaced by the elements of the second list.\n  \"\"\"\n  list1[:-1] + list2 \n  return list1[:-1] + list2", "matching_cluster_idx": 3}, {"solution": "def replace_list(list1, list2):\n  \"\"\"\n  Replaces the last element of the first list with the elements of the second list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n\n  Returns:\n    A new list with the last element of list1 replaced by the elements of list2.\n  \"\"\"\n  return list1[:-1] + list2", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each element in the original list.\n    \"\"\"\n\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n  \"\"\"Inserts an element before each element in a list.\n\n  Args:\n    lst: A list of elements.\n    element: The element to insert.\n\n  Returns:\n    A new list with the element inserted before each element in the original list.\n  \"\"\"\n  new_lst = []\n  for item in lst:\n    new_lst.append(element)\n    new_lst.append(item)\n  return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n      lst: The input list.\n      element: The element to insert.\n\n    Returns:\n      A new list with the element inserted before each existing element.\n    \"\"\"\n\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst\nlst = ['Red', 'Green', 'Black']\nelement = 'c'", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    This function inserts a given element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to be inserted.\n\n    Returns:\n        A new list with the element inserted before each existing element.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        elem: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each existing element.\n    \"\"\"\n    new_list = []\n    for i in lst:\n        new_list.append(elem)\n        new_list.append(i)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts the given element before each element in the list.\n\n    Args:\n      lst: The input list.\n      element: The element to be inserted.\n\n    Returns:\n      A new list with the element inserted before each existing element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n  \"\"\"Inserts a given element before each element in a list.\n\n  Args:\n    input_list: The input list.\n    element: The element to be inserted.\n\n  Returns:\n    A new list with the element inserted before each element in the input list.\n  \"\"\"\n  result = []\n  for item in input_list:\n    result.extend([element, item])\n  return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n  \"\"\"Inserts an element before each element in a list.\n\n  Args:\n      lst: The input list.\n      element: The element to insert.\n\n  Returns:\n      A new list with the element inserted before each element in the input list.\n  \"\"\"\n\n  new_lst = []\n  for item in lst:\n    new_lst.extend([element, item])\n  return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n  \"\"\"\n  Inserts an element before each element in a list.\n\n  Args:\n    list1: The input list.\n    element: The element to insert.\n\n  Returns:\n    A new list with the element inserted before each element.\n  \"\"\"\n  new_list = []\n  for item in list1:\n    new_list.append(element)\n    new_list.append(item)\n  return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n  \"\"\"Inserts a given element before each element in a list.\n\n  Args:\n      list1: The input list.\n      element: The element to insert.\n\n  Returns:\n      A new list with the element inserted before each existing element.\n  \"\"\"\n  new_list = []\n  for i in list1:\n    new_list.append(element)\n    new_list.append(i)\n  return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n    new_list = []\n    for item in list1:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n  \"\"\"Inserts a given element before each element in a list.\n\n  Args:\n    lst: The input list.\n    element: The element to be inserted.\n\n  Returns:\n    A new list with the element inserted before each existing element.\n  \"\"\"\n  new_lst = []\n  for item in lst:\n    new_lst.append(element)\n    new_lst.append(item)\n  return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n  \"\"\"Inserts an element before each element in a list.\n  Args:\n    list1: The input list.\n    element: The element to insert.\n  Returns:\n    A new list with the element inserted before each original element.\n  \"\"\"\n  new_list = []\n  for item in list1:\n    new_list.append(element)\n    new_list.append(item)\n  return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"Inserts the given element before each element in the list.\n\n    Args:\n        input_list: The list to modify.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in input_list:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    \"\"\"\n    This function inserts an element before each element in a list and returns the resulting list.\n\n    Args:\n        input_list: The input list.\n        element: The element to be inserted.\n\n    Returns:\n        A new list with the element inserted before each original element.\n    \"\"\"\n    new_list = []\n    for item in input_list:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n  \"\"\"Inserts a given element before each element in a list.\n\n  Args:\n    lst: The input list.\n    element: The element to insert.\n\n  Returns:\n    A new list with the element inserted before each existing element.\n  \"\"\"\n  new_lst = []\n  for item in lst:\n    new_lst.append(element)\n    new_lst.append(item)\n  return new_lst", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n    \"\"\"Inserts a given element before each element in a list.\n\n    Args:\n        list1: The input list.\n        element: The element to be inserted.\n\n    Returns:\n        A new list with the element inserted before each element of the input list.\n    \"\"\"\n    new_list = []\n    for i in list1:\n      new_list.append(element)\n      new_list.append(i)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"Inserts an element before each element in a list.\n\n    Args:\n        lst: The input list.\n        element: The element to insert.\n\n    Returns:\n        A new list with the element inserted before each element in the original list.\n    \"\"\"\n    new_lst = []\n    for item in lst:\n        new_lst.append(element)\n        new_lst.append(item)\n    return new_lst\nlst = ['Red', 'Green', 'Black']\nelement = 'c'", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n  \"\"\"\n  Inserts a given element before each element in a list.\n\n  Args:\n      input_list: The list to modify.\n      element: The element to insert.\n\n  Returns:\n      A new list with the element inserted before each existing element.\n  \"\"\"\n  new_list = []\n  for item in input_list:\n    new_list.append(element)\n    new_list.append(item)\n  return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n  \"\"\"Inserts the given element before each element in the input list.\n\n  Args:\n    input_list: A list of any type.\n    element: The element to insert before each element in the list.\n\n  Returns:\n    A new list with the element inserted before each existing element.\n  \"\"\"\n\n  result = []\n  for item in input_list:\n    result.append(element)\n    result.append(item)\n  return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 93.9041095890411, "dps_norm": 85.88235294117646, "pass@1": 43.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes a non-negative number and returns the number of prime numbers less than the given number.\n    \n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    prime = [True] * n\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n\n    count = 0\n    for p in range(2, n):\n        if prime[p]:\n            count += 1\n\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Given a non-negative number, return the number of prime numbers less than the given non-negative number.\n    :type n: int\n    :rtype: int\n\n    For example:\n    count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 1:\n      return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes in a non-negative number and returns the number\n    of prime numbers less than the given non-negative number.\n\n    For example:\n    count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    prime = [True] * n\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n    \n    count = 0\n    for p in range(2, n):\n        if prime[p]:\n            count += 1\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n  \"\"\"\n  Counts the number of prime numbers less than the given non-negative number.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The number of prime numbers less than n.\n  \"\"\"\n  if n <= 1:\n    return 0\n\n  primes = [True] * n\n  primes[0] = primes[1] = False\n\n  for i in range(2, int(n**0.5) + 1):\n    if primes[i]:\n      for j in range(i * i, n, i):\n        primes[j] = False\n\n  return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.\n    \"\"\"\n    \n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    \"\"\"Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n      n: A non-negative integer.\n\n    Returns:\n      The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n  \n    primes[0] = primes[1] = False  \n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n: A non-negative integer.\n\n    Returns:\n    The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n                \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    prime = [True] * n\n    prime[0] = prime[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if prime[i]:\n            for j in range(i * i, n, i):\n                prime[j] = False\n\n    return sum(prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n: A non-negative integer.\n\n    Returns:\n    The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n \n    primes[0] = primes[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    \n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n\n    if n <= 1:\n        return 0\n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n      return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n          for j in range(i * i, n, i):\n            primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n    assert count_Primes_nums(5) == 2\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n: A non-negative integer.\n\n    Returns:\n    The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n  \"\"\"\n  This function takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The number of prime numbers less than n.\n  \"\"\"\n  if n <= 1:\n    return 0\n  primes = [True] * n\n  primes[0] = primes[1] = False\n  for i in range(2, int(n ** 0.5) + 1):\n    if primes[i]:\n      for j in range(i * i, n, i):\n        primes[j] = False\n  return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n\n    return sum(primes)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 75.29069767441861, "dps_norm": 85.83333333333333, "pass@1": 91.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting the list.\n\n    Returns:\n        A list of lists, where each sublist contains elements from the input list,\n        spaced n elements apart.\n    \"\"\"\n\n    return [lst[i::n] for i in range(n)]\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n  \"\"\"\n  Splits a list for every nth element.\n\n  Args:\n      input_list: The input list to be split.\n      n: The interval at which to split the list.\n\n  Returns:\n      A list of lists, where each sub-list contains elements from the input list \n      at intervals of n.\n  \"\"\"\n  return [input_list[i::n] for i in range(n)]\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(l, n):\n    \"\"\"\n    Splits a list for every nth element.\n\n    Args:\n        l: The list to split.\n        n: The interval at which to split the list.\n\n    Returns:\n        A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [l[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sub-lists every nth element.\n\n    Args:\n        lst: The list to be split.\n        n: The number of elements per sub-list.\n\n    Returns:\n        A list of sub-lists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"Splits a list into sublists of every nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval for splitting the list.\n\n    Returns:\n        A list of sublists, each containing every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(data, n):\n  \"\"\"\n  Splits a list into sublists every nth element.\n\n  Args:\n    data: The input list to be split.\n    n: The interval for splitting the list.\n\n  Returns:\n    A list of sublists.\n  \"\"\"\n  return [data[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(data, n):\n    \"\"\"Splits a list for every nth element.\"\"\"\n    return [data[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n  \"\"\"Splits a list for every nth element.\n\n  Args:\n    lst: The list to split.\n    n: The interval at which to split the list.\n\n  Returns:\n    A list of lists, where each sublist contains every nth element from the input list.\n  \"\"\"\n\n  return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into sublists of size n.\n\n    Args:\n        input_list: The list to be split.\n        n: The size of each sublist.\n\n    Returns:\n        A list of sublists, each of size n (except possibly the last one).\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(data, n):\n  \"\"\"Splits a list into sublists every nth element.\n\n  Args:\n    data: The input list to split.\n    n: The interval at which to split the list.\n\n  Returns:\n    A list of sublists, each containing every nth element from the input list.\n  \"\"\"\n  return [data[i::n] for i in range(n)]\ndata = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n  \"\"\"\n  Splits a list for every nth element.\n\n  Args:\n    lst: The input list to be split.\n    n: The interval at which to split the list.\n\n  Returns:\n    A list of lists, each containing elements from the input list at intervals of n.\n  \"\"\"\n  return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of elements per sub-list.\n\n    Returns:\n        list: A list of lists, where each sub-list contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n  \"\"\"Splits a list into sublists of length n.\n\n  Args:\n    lst: The list to be split.\n    n: The length of each sublist.\n\n  Returns:\n    A list of sublists.\n  \"\"\"\n  return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(data, n):\n  \"\"\"\n  Splits a list for every nth element.\n\n  Args:\n    data: The list to be split.\n    n: The interval at which to split the list.\n\n  Returns:\n    A list of lists, where each sub-list contains every nth element from the original list.\n  \"\"\"\n  return [data[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element.\n\n    Args:\n        lst: The input list.\n        n: The interval at which to split the list.\n\n    Returns:\n        A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n  \"\"\"Splits a list into sublists every nth element.\n\n  Args:\n      input_list: The list to split.\n      n: The interval for splitting.\n\n  Returns:\n      A list of sublists.\n  \"\"\"\n  return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n  \"\"\"\n  Splits a list for every nth element, returning a list of the resulting lists.\n\n  Args:\n    lst: The list to split.\n    n: The interval for splitting the list.\n\n  Returns:\n    A list of lists, where each inner list contains elements from the original\n    list at intervals of n.\n  \"\"\"\n  return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n  \"\"\"Splits a list into sublists of length n.\n\n  Args:\n    input_list: The list to be split.\n    n: The length of each sublist.\n\n  Returns:\n    A list of sublists.\n  \"\"\"\n  return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n  \"\"\"\n  Splits a list into sublists of size n.\n\n  Args:\n    input_list: The list to be split.\n    n: The desired size of each sublist.\n\n  Returns:\n    A list of sublists.\n  \"\"\"\n  return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n  \"\"\"Splits a list for every nth element, returning a list of the resulting lists.\"\"\"\n  return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}]}, "Mbpp/281": {"dps": 94.3, "dps_norm": 82.72727272727272, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if the elements of a given list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if the elements of a given list are unique.\n\n  Args:\n      lst: A list of elements.\n\n  Returns:\n      True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if all elements in a list are unique.\n\n  Args:\n    lst: The list to check.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        data (list): The input list.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(set(data)) == len(data)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"Checks if all elements in a list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if all elements in a list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if the elements of a given list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements in the list are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if the elements of a given list are unique.\n  Args:\n      lst: A list of elements.\n  Returns:\n      True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if all elements in a list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: A list of elements.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"Checks if all elements in a list are unique.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Check if all elements in a list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if all elements in a list are unique.\n\n  Args:\n    lst: The list to check.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if the elements of a given list are unique.\n\n    Args:\n        lst: A list of elements.\n\n    Returns:\n        True if all elements in the list are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if all elements in a list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n\n  seen = set()\n  for item in lst:\n    if item in seen:\n      return False\n    seen.add(item)\n  return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n        lst: A list of elements.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in a given list are unique.\n\n    Args:\n        lst: A list of elements.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n  \"\"\"\n  Checks if the elements of a given list are unique.\n\n  Args:\n      input_list: A list of elements to check for uniqueness.\n\n  Returns:\n      True if all elements in the list are unique, False otherwise.\n  \"\"\"\n  return len(set(input_list)) == len(input_list)", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    \"\"\"\n    Checks if the elements of a given list are unique.\n\n    Args:\n        data: A list of elements.\n\n    Returns:\n        True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n  \"\"\"\n  Checks if all elements in a list are unique.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    True if all elements are unique, False otherwise.\n  \"\"\"\n  return len(set(lst)) == len(lst)", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 26.41025641025641, "dps_norm": 64.16666666666667, "pass@1": 98.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"Counts inversions in an array.\n\n    An inversion in an array occurs when two elements are out of order.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of elements (i, j) in the array such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair (i, j) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) where i < j and arr[i] > arr[j].\n    \n    Args:\n      arr: A list of integers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    This function counts the number of inversions in an array.\n\n    An inversion in an array occurs when an element appears before another element that is smaller than it.\n    For example, in the array [1, 20, 6, 4, 5], there are 5 inversions:\n        (20, 6), (20, 4), (20, 5), (6, 4), (6, 5).\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion occurs when two elements are out of order (i.e., \n    a[i] > a[j] where i < j).\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n    An inversion is a pair of indices (i, j) in an array where i < j but arr[i] > arr[j].\n\n    Args:\n      arr: The input array.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n    inversion_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion occurs when a pair of elements (arr[i], arr[j]) exists where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array.\n\n    An inversion occurs when an element at index i is greater than an element at index j where i < j.\n\n    Args:\n      arr: A list of integers.\n\n    Returns:\n      The number of inversions in the array.\n    \"\"\"\n\n    count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The number of inversions in the array.\n\n    An inversion is defined as a pair (i, j) where 1 <= i < j <= n and arr[i] > arr[j].\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def merge_sort_and_count_inversions(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inversions = merge_sort_and_count_inversions(arr[:mid])\n    right, right_inversions = merge_sort_and_count_inversions(arr[mid:])\n    merged, merge_inversions = merge_and_count_inversions(left, right)\n\n    return merged, left_inversions + right_inversions + merge_inversions\ndef merge_and_count_inversions(left, right):\n    merged = []\n    i = 0\n    j = 0\n    inversions = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inversions += len(left) - i  # Count inversions\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    return merged, inversions\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count_inversions(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n  \"\"\"\n  This function counts the number of inversions in an array.\n\n  An inversion in an array happens when a pair of elements (i, j) satisfies i < j\n  but arr[i] > arr[j].\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    The number of inversions in the array.\n  \"\"\"\n  count = 0\n  for i in range(len(arr)):\n    for j in range(i+1, len(arr)):\n      if arr[i] > arr[j]:\n        count += 1\n  return count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array using a merge sort approach.\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    inversion_count = 0\n\n    def merge_and_count(left, right):\n        nonlocal inversion_count\n        merged = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inversion_count += len(left) - i\n\n        while i < len(left):\n            merged.append(left[i])\n            i += 1\n        while j < len(right):\n            merged.append(right[j])\n            j += 1\n        return merged\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge_and_count(left, right)\n\n    merge_sort(arr)\n    return inversion_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n  \"\"\"\n  This function counts the number of inversions in an array.\n\n  An inversion in an array occurs when a pair of elements (a[i], a[j])\n  satisfies the condition i < j and a[i] > a[j].\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    The number of inversions in the array.\n  \"\"\"\n  n = len(arr)\n  inv_count = 0\n  for i in range(n):\n    for j in range(i+1, n):\n      if arr[i] > arr[j]:\n        inv_count += 1\n  return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) in the array such that i < j and arr[i] > arr[j].\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n\n    An inversion is a pair of indices (i, j) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\narr = [1, 20, 6, 4, 5]", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n  \"\"\"\n  Counts inversions in an array.\n\n  An inversion occurs when an element at a lower index is greater than an element \n  at a higher index in the array.\n\n  Args:\n    arr: A list of integers.\n\n  Returns:\n    The number of inversions in the array.\n  \"\"\"\n  count = 0\n  for i in range(len(arr)):\n    for j in range(i+1, len(arr)):\n      if arr[i] > arr[j]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array.\n\n    An inversion occurs when two elements in an array are out of order, meaning \n    their indices are in increasing order, but their values are in decreasing order.\n\n    For example:\n      [1, 20, 6, 4, 5] has 5 inversions:\n        (20, 6), (20, 4), (20, 5), (6, 4), (6, 5)\n\n    Args:\n        arr: A list of integers\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    inversion_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts inversions in an array.\n\n    An inversion is a pair (i, j) where i < j and arr[i] > arr[j].\n\n    Args:\n        arr: The input array.\n\n    Returns:\n        The number of inversions in the array.\n    \"\"\"\n    inversion_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    return inversion_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 94.27586206896552, "dps_norm": 65.83333333333334, "pass@1": 88.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n  Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to return.\n\n  Returns:\n      A list containing the n largest products.\n  \"\"\"\n\n  products = [(x * y, x, y) for x in list1 for y in list2]  # Calculate all products and store with original factors\n  products.sort(reverse=True)  # Sort products in descending order\n  return [product for product, _, _ in products[:n]]  # Extract only the product values from the n largest", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to find.\n\n    Returns:\n    A list of the n largest products.\n    \"\"\"\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x*y)\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists,\n  selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to return.\n\n  Returns:\n    A list containing the n largest products, sorted in descending order.\n  \"\"\"\n\n  products = [x * y for x in list1 for y in list2]\n  return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists,\n  selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to return.\n\n  Returns:\n    A list containing the n largest products, sorted in descending order.\n  \"\"\"\n  products = [x * y for x in list1 for y in list2]\n  return nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list of the n largest products.\n    \"\"\"\n    products = []\n    for x in list1:\n        for y in list2:\n            products.append(x * y)\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to find.\n\n    Returns:\n      A list containing the n largest products, sorted in descending order.\n    \"\"\"\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists,\n  selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to return.\n\n  Returns:\n    A list of the n largest products, sorted in descending order.\n  \"\"\"\n  products = []\n  for x in list1:\n    for y in list2:\n      products.append(x * y)\n  return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists,\n  selecting one factor from each list.\n\n  Args:\n      list1: The first list of integers.\n      list2: The second list of integers.\n      n: The number of largest products to return.\n\n  Returns:\n      A list containing the n largest products, sorted in descending order.\n  \"\"\"\n  products = [x * y for x in list1 for y in list2]\n  return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num_products):\n  \"\"\"Finds the specified number of largest products from two lists, selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    num_products: The number of largest products to return.\n\n  Returns:\n    A sorted list of the specified number of largest products.\n  \"\"\"\n\n  products = sorted([(x * y) for x in list1 for y in list2], reverse=True)\n  return products[:num_products]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists, \n  selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to return.\n\n  Returns:\n    A list of the n largest products.\n  \"\"\"\n\n  products = []\n  for x in list1:\n    for y in list2:\n      products.append(x * y)\n  return sorted(products, reverse=True)[:n]\nlist1 = [1, 2, 3, 4, 5, 6]\nlist2 = [3, 6, 8, 9, 10, 6]\nn = 3", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n        nums1: The first list of numbers.\n        nums2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list of the n largest products.\n    \"\"\"\n\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n    return sorted(products, reverse=True)[:n]\nnums1 = [1, 2, 3, 4, 5, 6]\nnums2 = [3, 6, 8, 9, 10, 6]\nn = 3", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists, \n  selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to find.\n\n  Returns:\n    A list of the n largest products, sorted in descending order.\n  \"\"\"\n  products = []\n  for num1 in list1:\n    for num2 in list2:\n      products.append(num1 * num2)\n  return sorted(products, reverse=True)[:n]\nlist1 = [1, 2, 3, 4, 5, 6]\nlist2 = [3, 6, 8, 9, 10, 6]\nn = 3", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list of the n largest products, sorted in descending order.\n    \"\"\"\n    products = [x * y for x in list1 for y in list2]  \n    products.sort(reverse=True)  \n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to return.\n\n    Returns:\n      A list containing the n largest products.\n    \"\"\"\n    products = sorted([(x * y) for x in list1 for y in list2], reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"Finds the specified number of largest products from two lists, selecting one\n  factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    n: The number of largest products to find.\n\n  Returns:\n    A list of the n largest products, sorted in descending order.\n  \"\"\"\n\n  products = [x * y for x in list1 for y in list2]\n  return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to return.\n\n    Returns:\n        A list containing the n largest products.\n    \"\"\"\n\n    products = []\n    for num1 in list1:\n      for num2 in list2:\n        products.append(num1 * num2)\n\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n        list1: The first list of numbers.\n        list2: The second list of numbers.\n        n: The number of largest products to find.\n\n    Returns:\n        A list of the n largest products, sorted in descending order.\n    \"\"\"\n\n    from itertools import product\n\n    products = [x * y for x, y in product(list1, list2)]\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists,\n  selecting one factor from each list.\n\n  Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to find.\n\n  Returns:\n      A sorted list containing the n largest products.\n  \"\"\"\n  products = [x * y for x in list1 for y in list2]\n  return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num_products):\n  \"\"\"\n  Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n  Args:\n    list1: The first list of numbers.\n    list2: The second list of numbers.\n    num_products: The number of largest products to find.\n\n  Returns:\n    A list containing the num_products largest products, sorted in descending order.\n  \"\"\"\n\n  products = []\n  for x in list1:\n    for y in list2:\n      products.append(x*y)\n  return sorted(products, reverse=True)[:num_products]\nlist1 = [1, 2, 3, 4, 5, 6]\nlist2 = [3, 6, 8, 9, 10, 6]\nnum_products = 3", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n  \"\"\"\n  Finds the specified number of largest products from two given lists, selecting one factor from each list.\n\n  Args:\n      list1: The first list of numbers.\n      list2: The second list of numbers.\n      n: The number of largest products to return.\n\n  Returns:\n      A list of the n largest products, in descending order.\n  \"\"\"\n  products = [x * y for x in list1 for y in list2]\n  return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 93.6150234741784, "dps_norm": 97.3076923076923, "pass@1": 93.0, "profiled": [{"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    \n    memo = {}  # Use memoization to store already calculated results\n\n    def calculate_max_sum(num):\n        if num in memo:\n            return memo[num]\n        if num <= 0:\n            return 0\n        \n        memo[num] = max(calculate_max_sum(num // 2) + calculate_max_sum(num // 3) + calculate_max_sum(num // 4) + calculate_max_sum(num // 5), num)\n        return memo[num]\n\n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n  \"\"\"\n  This function calculates the maximum sum possible using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The maximum sum possible for the given integer.\n  \"\"\"\n  memo = {}  # Use a dictionary to memoize results for efficiency\n\n  def helper(n):\n    if n in memo:\n      return memo[n]\n    if n <= 0:\n      return 0\n    memo[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n    return memo[n]\n  return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the given equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The maximum sum possible for the given input.\n    \"\"\"\n    memo = {}  # Use a dictionary for memoization to store calculated values\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n\n        if n <= 0:\n            return 0\n        if n == 1:\n            return 1\n\n        memo[n] = max(helper(int(n / 2)) + helper(int(n / 3)) + helper(int(n / 4)) + helper(int(n / 5)), n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible by using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n\n    memo = {}  # Use memoization for efficiency\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n\n        if n <= 0:\n            return 0\n        \n        memo[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation:\n\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible for the given integer.\n\n    \"\"\"\n\n    memo = {}  # Use memoization to store calculated values for efficiency\n\n    def _get_max_sum(n):\n        if n in memo:\n            return memo[n]\n        if n <= 0:\n            return 0\n\n        memo[n] = max(\n            _get_max_sum(n // 2) + _get_max_sum(n // 3) + _get_max_sum(n // 4) + _get_max_sum(n // 5),\n            n,\n        )\n\n        return memo[n]\n\n    return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Find the maximum sum possible by using the given equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    memo = {}  # Use memoization to store results for efficiency\n\n    def helper(num):\n        if num in memo:\n            return memo[num]\n        if num <= 1:\n            return num\n        memo[num] = max(helper(num // 2) + helper(num // 3) + helper(num // 4) + helper(num // 5), num)\n        return memo[num]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation:\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible for the given n.\n    \"\"\"\n\n    # Memoization to store calculated results for efficiency\n    memo = {}\n\n    def helper(n):\n        if n in memo:\n            return memo[n]\n        \n        if n <= 1:\n            return n\n\n        memo[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n  \"\"\"\n  Finds the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n  \"\"\"\n  memo = {}  # Use a dictionary to store computed values for memoization\n\n  def helper(n):\n    if n <= 1:\n      return n\n    if n in memo:\n      return memo[n]\n    memo[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n    return memo[n]\n  return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer.\n\n    Returns:\n        An integer representing the maximum sum.\n    \"\"\"\n\n    memo = {}  # Use memoization for efficiency\n\n    def helper(n):\n        if n in memo:\n          return memo[n]\n        if n <= 0:\n            return 0\n\n        memo[n] = max(\n            helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n\n        )\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n  \"\"\"\n  Finds the maximum sum possible using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n  Args:\n      n: An integer representing the input value.\n\n  Returns:\n      The maximum sum achievable using the given equation.\n  \"\"\"\n  cache = {}  # Using a dictionary for memoization to avoid redundant calculations\n\n  def _get_max_sum(n):\n    if n in cache:\n      return cache[n]  \n\n    if n <= 1:\n      return n\n\n    cache[n] = max(\n        _get_max_sum(int(n / 2)) + _get_max_sum(int(n / 3)) + _get_max_sum(int(n / 4)) + _get_max_sum(int(n / 5)), n\n    )\n    return cache[n]\n\n  return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    \"\"\"\n    Given an integer n, find the maximum sum possible by using the given equation:\n    f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n\n    dp = [0] * (n + 1) \n    dp[0] = 0\n    for i in range(1, n + 1):\n        dp[i] = i  \n        dp[i] = max(dp[i], dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5])\n    return dp[n]", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n):\n  \"\"\"\n  Finds the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n  Args:\n    n: An integer.\n\n  Returns:\n    The maximum sum possible.\n  \"\"\"\n  memo = {}  # Store computed values to avoid redundant calculations (memoization)\n\n  def helper(n):\n    if n in memo:\n      return memo[n]\n    if n <= 0:\n      return 0\n    memo[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n    return memo[n]\n  return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The maximum sum achievable.\n\n    \"\"\"\n\n    dp = [0] * (n + 1)  # Initialize a DP table to store calculated results\n\n    for i in range(1, n + 1):\n        dp[i] = i  # Initially, the max sum is the number itself\n        if i >= 2:\n            dp[i] = max(dp[i], dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5])\n\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible by using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible for the given input.\n    \"\"\"\n    memo = {}  # Use memoization to store previously calculated results\n\n    def _get_max_sum(n):\n        if n in memo:\n            return memo[n]\n        if n <= 0:\n            return 0\n        memo[n] = max(n,\n                      _get_max_sum(n // 2) + _get_max_sum(n // 3) + _get_max_sum(n // 4) + _get_max_sum(n // 5))\n        return memo[n]\n    return _get_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculates the maximum sum possible using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: A non-negative integer.\n\n    Returns:\n        The maximum sum achievable.\n    \"\"\"\n    memo = {}  # Use memoization to store computed results\n\n    def calculate_max_sum(num):\n      if num <= 0:\n        return 0\n      if num in memo:\n        return memo[num]\n      \n      memo[num] = max(\n          calculate_max_sum(num // 2) + calculate_max_sum(num // 3) + calculate_max_sum(num // 4) + calculate_max_sum(num // 5),\n          num\n      )\n      return memo[num]\n    \n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: The input integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        if i >= 2:\n            dp[i] = max(dp[i], dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5])\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n  \"\"\"\n  Calculates the maximum sum possible using the equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The maximum sum achievable.\n  \"\"\"\n  memo = {}  # Use memoization to store results for efficiency\n\n  def helper(n):\n    if n in memo:\n      return memo[n]\n    if n <= 1:\n      return n\n\n    memo[n] = max(\n        helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n\n    )\n    return memo[n]\n\n  return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer.\n\n    Returns:\n        The maximum sum possible.\n    \"\"\"\n    \n    cache = {}  # Use a dictionary to store calculated results for memoization\n\n    def helper(n):\n        if n <= 1:\n            return n\n        if n in cache:\n            return cache[n]\n\n        cache[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n        return cache[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Finds the maximum sum possible using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Args:\n      n: An integer.\n    \n    Returns:\n      The maximum sum achievable using the given equation.\n    \"\"\"\n    \n    memo = {}  # Store calculated results for memoization\n\n    def calculate_max_sum(num):\n        if num in memo:\n            return memo[num]\n        if num <= 0:\n            return 0\n        memo[num] = max(calculate_max_sum(num // 2) + calculate_max_sum(num // 3) + calculate_max_sum(num // 4) + calculate_max_sum(num // 5), num)\n        return memo[num]\n\n    return calculate_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Find the maximum sum possible by using the equation f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    Args:\n        n: An integer representing the input value.\n\n    Returns:\n        The maximum sum possible according to the equation.\n    \"\"\"\n    memo = {} # store results for previously calculated values to avoid recalculations\n\n    def calculate_max_sum(n):\n        if n in memo:\n            return memo[n]\n        if n <= 1:\n            return n\n        memo[n] = max(calculate_max_sum(n // 2) + calculate_max_sum(n // 3) + calculate_max_sum(n // 4) + calculate_max_sum(n // 5), n)\n        return memo[n]\n\n    return calculate_max_sum(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        string: The input string.\n\n    Returns:\n        The first non-repeated character, or None if all characters repeat.\n    \"\"\"\n\n    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n      string: The input string.\n\n  Returns:\n      The first non-repeated character, or None if none exists.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"Finds the first non-repeated character in a given string.\n\n  Args:\n      string: The input string to search.\n\n  Returns:\n      The first non-repeated character, or None if all characters repeat.\n  \"\"\"\n\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(text):\n    \"\"\"Finds the first non-repeated character in a given string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      The first non-repeated character, or None if all characters repeat.\n    \"\"\"\n\n    char_counts = {}\n    for char in text:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    for char in text:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n      string: The input string to search.\n\n  Returns:\n      The first non-repeated character, or None if there are no non-repeated characters.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"Finds the first non-repeated character in a given string.\n  \n  Args:\n      string: The input string.\n\n  Returns:\n      The first non-repeating character in the string, or None if all characters repeat.\n  \"\"\"\n\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n    \n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"Finds the first non-repeated character in a given string.\n\n  Args:\n    string: The string to search.\n\n  Returns:\n    The first non-repeated character, or None if all characters repeat.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Args:\n    string: The input string.\n\n    Returns:\n    The first non-repeated character, or None if there is none.\n    \"\"\"\n\n    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    Args:\n        string: The input string.\n    Returns:\n        The first non-repeated character, or None if none exist.\n    \"\"\"\n    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n    \n    Args:\n      string: The input string to search.\n    \n    Returns:\n      The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n    string: The input string.\n\n  Returns:\n    The first non-repeated character, or None if there are no non-repeated characters.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n      string: The input string.\n\n    Returns:\n      The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_counts = {}\n    for char in string:\n      if char in char_counts:\n        char_counts[char] += 1\n      else:\n        char_counts[char] = 1\n\n    for char in string:\n      if char_counts[char] == 1:\n        return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n    string: The string to search.\n\n  Returns:\n    The first non-repeated character, or None if there are no non-repeated characters.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"Finds the first non-repeated character in a given string.\n\n  Args:\n    string: The input string.\n\n  Returns:\n    The first non-repeating character, or None if no such character exists.\n  \"\"\"\n\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n      string: The string to search.\n\n  Returns:\n      The first non-repeated character, or None if none exists.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n  \n  return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n  \"\"\"\n  This function finds the first non-repeated character in a given string.\n\n  Args:\n      string: The input string.\n\n  Returns:\n      The first non-repeated character, or None if there are no non-repeated characters.\n  \"\"\"\n  char_counts = Counter(string)  # Count occurrences of each character\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n    string: The string to search.\n\n  Returns:\n    The first non-repeated character, or None if there are no non-repeated characters.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        string: The input string to search.\n\n    Returns:\n        The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None  # No non-repeating character found", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(text):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n    text: The string to search.\n\n  Returns:\n    The first non-repeated character, or None if all characters repeat.\n  \"\"\"\n  char_counts = {}\n  for char in text:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in text:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n  \"\"\"\n  Finds the first non-repeated character in a given string.\n\n  Args:\n    string: The input string.\n\n  Returns:\n    The first non-repeated character in the string, or None if there are no\n    non-repeated characters.\n  \"\"\"\n  char_counts = {}\n  for char in string:\n    if char in char_counts:\n      char_counts[char] += 1\n    else:\n      char_counts[char] = 1\n\n  for char in string:\n    if char_counts[char] == 1:\n      return char\n\n  return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n      input_tuple: The tuple to search within.\n      element: The element to search for.\n\n    Returns:\n      True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"Checks if an element exists in a tuple.\n\n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_x, element):\n  \"\"\"Checks if an element exists within a tuple.\n\n  Args:\n    tuple_x: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in tuple_x", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple1, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuple1: The tuple to search within.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple1", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"Checks if an element exists within a tuple.\n\n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(my_tuple, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n    Args:\n        my_tuple (tuple): The tuple to check.\n        element: The element to search for.\n    Returns:\n        bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in my_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"Checks if an element exists within a tuple.\n\n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"\n  This function checks whether a given element exists within a tuple.\n\n  Args:\n    input_tuple: The tuple to be checked.\n    element: The element to be searched for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n    \"\"\"\n    This function checks if a given element exists within a tuple.\n\n    Args:\n        input_tuple: The tuple to be searched.\n        element: The element to search for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n  \"\"\"\n  Checks if an element exists within a tuple.\n\n  Args:\n    tpl: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n\n  return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_in, element):\n  \"\"\"Checks if an element exists within a tuple.\n\n  Args:\n    tuple_in: The tuple to search within.\n    element: The element to look for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in tuple_in", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"Checks if an element exists in a tuple.\n\n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element exists in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks whether an element exists within a tuple.\n\n    Args:\n        tuplex: The tuple to search within.\n        element: The element to check for.\n\n    Returns:\n        True if the element is found in the tuple, False otherwise.\n    \"\"\"\n\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n  \"\"\"\n  Checks whether an element exists within a tuple.\n\n  Args:\n    tuplex: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n  \"\"\"\n  Checks if an element exists within a tuple.\n\n  Args:\n    tuplex: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element exists in the tuple, False otherwise.\n  \"\"\"\n  return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"\n  This function checks if an element exists within a tuple.\n\n  Args:\n      input_tuple: The tuple to be searched.\n      element: The element to search for.\n\n  Returns:\n      True if the element exists in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"\n  Checks if an element exists within a tuple.\n\n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"Checks if an element exists within a tuple.\n\n  Args:\n      input_tuple: The tuple to search within.\n      element: The element to search for.\n\n  Returns:\n      True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"\n  Checks whether an element exists within a tuple.\n  \n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n    \n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n  return element in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, element):\n  \"\"\"Checks if an element exists within a tuple.\n\n  Args:\n    input_tuple: The tuple to search within.\n    element: The element to search for.\n\n  Returns:\n    True if the element is found in the tuple, False otherwise.\n  \"\"\"\n\n  return element in input_tuple", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 91.30434782608695, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in seq1 exists in seq2.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in one sequence exists in another sequence.\n\n  Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n  Returns:\n      True if any element in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for element in seq1:\n    if element in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in seq1 exists in seq2.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in a sequence exists in another sequence.\n\n  Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n  Returns:\n      True if any value in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for value in seq1:\n    if value in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in a sequence exists in another sequence.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any element of seq1 is present in seq2, False otherwise.\n    \"\"\"\n    for element in seq1:\n        if element in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in seq1 exists in seq2.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value from seq1 is found in seq2, False otherwise.\n  \"\"\"\n\n  for value in seq1:\n    if value in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"Checks if any value in one sequence exists in another.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for element in seq1:\n    if element in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks if any element in seq1 exists in seq2.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any element from seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for element in seq1:\n    if element in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(lst1, lst2):\n  \"\"\"\n  Checks whether any value in a sequence exists in another sequence.\n\n  Args:\n    lst1: The first sequence.\n    lst2: The second sequence.\n\n  Returns:\n    True if any value in lst1 exists in lst2, False otherwise.\n  \"\"\"\n  for element in lst1:\n    if element in lst2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  This function checks whether any value in one sequence exists in another sequence.\n\n  Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n  Returns:\n      True if there is any overlap between the sequences, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n\n    Returns:\n        True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"Checks if any value in seq1 exists in seq2.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value from seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in seq1 exists in seq2.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value in seq1 is also in seq2, False otherwise.\n  \"\"\"\n  for value in seq1:\n    if value in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq1 exists in seq2.\n\n    Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n    Returns:\n      True if any element of seq1 is found in seq2, False otherwise.\n    \"\"\"\n    for element in seq1:\n        if element in seq2:\n          return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in a sequence exists in another sequence.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  This function checks if any element of seq1 is present in seq2.\n  Args:\n      seq1: The first sequence (list, tuple, etc.).\n      seq2: The second sequence (list, tuple, etc.).\n  Returns:\n      True if any element of seq1 is in seq2, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks if any value in seq1 exists in seq2.\n\n  Args:\n    seq1: The first sequence.\n    seq2: The second sequence.\n\n  Returns:\n    True if any value in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks whether any value in seq1 exists in seq2.\n\n  Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n  Returns:\n      True if any value in seq1 exists in seq2, False otherwise.\n  \"\"\"\n  for element in seq1:\n    if element in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks if any value in the first sequence exists in the second sequence.\n\n  Args:\n      seq1: The first sequence.\n      seq2: The second sequence.\n\n  Returns:\n      True if there is an overlapping value, False otherwise.\n  \"\"\"\n\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n  \"\"\"\n  Checks if any value in seq1 exists in seq2.\n  \n  Args:\n    seq1: The first sequence (list, tuple, string, etc.).\n    seq2: The second sequence (list, tuple, string, etc.).\n\n  Returns:\n    True if there is any overlap, False otherwise.\n  \"\"\"\n  for item in seq1:\n    if item in seq2:\n      return True\n  return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 15.226337448559672, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(data, delimiter='-'):\n  \"\"\"\n  This function concatenates each element of a tuple with a specified delimiter.\n\n  Args:\n      data: A tuple of elements.\n      delimiter: The delimiter to be used between elements (default is '-').\n\n  Returns:\n      A string containing all elements of the tuple concatenated with the delimiter.\n  \"\"\"\n  return delimiter.join(str(element) for element in data)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"Concatenates each element of a tuple by a delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter to use, defaults to '-'.\n\n    Returns:\n        A string with all elements concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(str(x) for x in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"Concatenates each element of a tuple by the delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use. Defaults to '-'.\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n  \"\"\"Concatenates each element of a tuple using a delimiter.\n\n  Args:\n    input_tuple: The tuple to concatenate.\n    delimiter: The delimiter to use between elements. Defaults to \"-\".\n\n  Returns:\n    A string containing the concatenated elements of the tuple.\n  \"\"\"\n  return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n    \"\"\"\n    Concatenates each element of a tuple by a given delimiter.\n\n    Args:\n        input_tuple (tuple): The tuple to be concatenated.\n        delimiter (str, optional): The delimiter to be used. Defaults to \"-\".\n\n    Returns:\n        str: A string containing all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(str(x) for x in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n  \"\"\"Concatenates each element of a tuple by a specified delimiter.\n\n  Args:\n      input_tuple: The tuple to concatenate.\n      delimiter: The string used to separate elements (default is '-').\n\n  Returns:\n      A string containing all elements concatenated with the delimiter.\n  \"\"\"\n  return delimiter.join(str(x) for x in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    \"\"\"\n    Concatenates each element of a tuple by a hyphen delimiter.\n\n    Args:\n        input_tuple: The tuple containing elements to be concatenated.\n\n    Returns:\n        A string with all elements of the tuple concatenated by hyphens.\n    \"\"\"\n    return '-'.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"Concatenates each element of a tuple by the given delimiter.\n\n    Args:\n        tup: The input tuple.\n        delimiter: The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        A string with the concatenated elements of the tuple.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\") -> str:\n    \"\"\"\n    Concatenates each element of a tuple by the specified delimiter.\n\n    Args:\n        input_tuple: The input tuple.\n        delimiter: The delimiter to use for concatenation. Defaults to \"-\".\n\n    Returns:\n        A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n  \"\"\"\n  Concatenates each element of a tuple by the delimiter.\n\n  Args:\n    input_tuple: A tuple of elements to concatenate.\n    delimiter: The delimiter to use between elements (default is '-').\n\n  Returns:\n    A string containing all elements concatenated by the delimiter.\n  \"\"\"\n  return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"Concatenates each element of a tuple using a delimiter.\n\n    Args:\n      input_tuple: The tuple to concatenate.\n      delimiter: The delimiter to use between elements (default is '-').\n\n    Returns:\n      A string containing the concatenated elements of the tuple.\n    \"\"\"\n\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\") -> str:\n  \"\"\"\n  Concatenates each element of a tuple by the given delimiter.\n\n  Args:\n    input_tuple: The tuple to concatenate.\n    delimiter: The delimiter to use for concatenation. Defaults to \"-\".\n\n  Returns:\n    A string containing the concatenated elements of the tuple.\n  \"\"\"\n  return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter = \"-\"):\n  \"\"\"\n  Concatenates each element of a tuple by the delimiter.\n\n  Args:\n    input_tuple: The input tuple to concatenate.\n    delimiter: The delimiter to use between elements. Defaults to \"-\".\n\n  Returns:\n    A string containing the concatenated elements of the tuple.\n  \"\"\"\n  return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using a given delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use. Defaults to '-'.\n\n    Returns:\n        A string containing the concatenated elements.\n    \"\"\"\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n  \"\"\"Concatenates each element of a tuple by a delimiter.\n\n  Args:\n      input_tuple: The input tuple.\n      delimiter: The delimiter to use for concatenation. Defaults to \"-\".\n\n  Returns:\n      A string containing the concatenated elements of the tuple.\n  \"\"\"\n  return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\") -> str:\n    \"\"\"Concatenates each element of a tuple by the given delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use between elements. Defaults to \"-\".\n\n    Returns:\n        A string containing all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n  \"\"\"\n  Concatenates elements of a tuple into a string using a delimiter.\n\n  Args:\n      input_tuple: The tuple to concatenate.\n      delimiter: The delimiter to use. Defaults to '-'.\n\n  Returns:\n      A string with the concatenated elements.\n  \"\"\"\n\n  return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"Concatenates each element of a tuple by the delimiter.\n\n    Args:\n        input_tuple: The tuple to concatenate.\n        delimiter: The delimiter to use, defaults to '-'.\n\n    Returns:\n        A string with the concatenated elements.\n    \"\"\"\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"Concatenates each element of a tuple by the delimiter.\n\n    Args:\n        input_tuple: A tuple of elements.\n        delimiter: The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        A string formed by concatenating the tuple elements with the delimiter.\n    \"\"\"\n    return delimiter.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n  \"\"\"\n  Concatenates each element of a tuple by the delimiter \"-\".\n\n  Args:\n      input_tuple: A tuple of elements to concatenate.\n\n  Returns:\n      A string containing the concatenated elements separated by \"-\".\n  \"\"\"\n  return '-'.join(str(element) for element in input_tuple)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(strs):\n  \"\"\"\n  Extracts the rear (last) element from each string in a tuple.\n\n  Args:\n    strs: A tuple of strings.\n\n  Returns:\n    A list containing the last element of each string in the input tuple.\n  \"\"\"\n  return [s[-1] for s in strs]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n  \"\"\"\n  Extracts the rearmost (last) character of each string in a tuple.\n\n  Args:\n    input_tuple: A tuple containing strings.\n\n  Returns:\n    A list containing the last character of each string in the input tuple.\n  \"\"\"\n  return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n  \"\"\"Extracts the rear element (last character) of each string in the given tuple.\n\n  Args:\n    string_tuple: A tuple of strings.\n\n  Returns:\n    A list containing the rear element of each string in the input tuple.\n  \"\"\"\n  return [string[-1] for string in string_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(data: tuple) -> list:\n    \"\"\"\n    Write a function to extract only the rear index element of each string in the given tuple.\n    assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']\n    \"\"\"\n    return [string[-1] for string in data]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n  \"\"\"\n  Extract only the rear index element of each string in the given tuple.\n\n  Args:\n    strings: A tuple of strings.\n\n  Returns:\n    A list containing the last characters of each string in the tuple.\n  \"\"\"\n  return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n    \"\"\"\n    This function extracts the last character (rear index element) from each string in a tuple.\n\n    Args:\n        string_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last characters of each string in the tuple.\n    \"\"\"\n    return [string[-1] for string in string_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strs):\n    \"\"\"\n    Extracts the last character from each string in a tuple.\n\n    Args:\n      strs: A tuple of strings.\n\n    Returns:\n      A list of the last characters of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in strs]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extracts the last character of each string in a tuple.\n\n    Args:\n        strings: A tuple of strings.\n\n    Returns:\n        A list of the last characters of each string in the input tuple.\n    \"\"\"\n\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in a tuple.\n    Args:\n      strings: A tuple of strings.\n    Returns:\n      A list containing the last character of each string.\n    \"\"\"\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in a tuple.\n\n    Args:\n        strings: A tuple of strings.\n\n    Returns:\n        A list of characters, where each character is the last character of\n        the corresponding string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n  \"\"\"\n  This function extracts the last character of each string in a tuple.\n\n  Args:\n    input_tuple: A tuple of strings.\n\n  Returns:\n    A list containing the last character of each string in the input tuple.\n  \"\"\"\n  return [s[-1] for s in input_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n  \"\"\"\n  This function extracts the rear (last) index element of each string in a tuple.\n\n  Args:\n    string_tuple: A tuple of strings.\n\n  Returns:\n    A list containing the rear element of each string in the tuple.\n  \"\"\"\n  return [string[-1] for string in string_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"Extracts the last character of each string in a tuple.\n\n    Args:\n        strings: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n  \"\"\"\n  This function extracts the last character (rear index element) from each string in a tuple.\n\n  Args:\n    strings: A tuple of strings.\n\n  Returns:\n    A list containing the last character of each string in the input tuple.\n  \"\"\"\n  return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n  \"\"\"\n  Extracts the last character of each string in a tuple.\n\n  Args:\n    strings: A tuple of strings.\n\n  Returns:\n    A list of the last characters of each string in the tuple.\n  \"\"\"\n  return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n  \"\"\"Extracts the last character of each string in a tuple.\n\n  Args:\n    strings: A tuple of strings.\n\n  Returns:\n    A list containing the last character of each string in the input tuple.\n  \"\"\"\n  return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n  \"\"\"Extracts the last character of each string in a tuple.\n\n  Args:\n    strings: A tuple of strings.\n\n  Returns:\n    A list of the last characters of each string in the input tuple.\n  \"\"\"\n  return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n  \"\"\"Extracts the last character from each string in a tuple.\n\n  Args:\n      strings: A tuple of strings.\n\n  Returns:\n      A list containing the last character of each string in the input tuple.\n  \"\"\"\n  return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(string_tuple):\n    \"\"\"\n    Extracts the last character (rear index element) of each string in a tuple.\n\n    Args:\n        string_tuple: A tuple of strings.\n\n    Returns:\n        A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in string_tuple]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        lst: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  This function counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists that contain the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to count.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"Counts the number of sublists containing a particular element.\n\n  Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n  Returns:\n      The number of sublists containing the element.\n  \"\"\"\n\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n    Returns:\n      The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n      if element in sublist:\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  Counts the number of sublists containing a particular element.\n\n  Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n  Returns:\n      The number of sublists containing the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists: A list of lists.\n        element: The element to search for.\n\n    Returns:\n        The number of sublists containing the element.\n    \"\"\"\n\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"Counts the number of sublists containing a particular element.\n\n  Args:\n      list_of_lists: A list of lists.\n      element: The element to search for.\n\n  Returns:\n      The number of sublists containing the element.\n  \"\"\"\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n  \"\"\"\n  Counts the number of sublists containing a particular element.\n\n  Args:\n    list_of_lists: A list of lists.\n    element: The element to search for.\n\n  Returns:\n    The number of sublists containing the element.\n  \"\"\"\n\n  count = 0\n  for sublist in list_of_lists:\n    if element in sublist:\n      count += 1\n  return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 28.553719008264462, "dps_norm": 45.0, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using shell sort algorithm.\n\n    Args:\n        arr: A list of numbers to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using Shell sort algorithm.\n\n    Args:\n        arr: The input array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n  n = len(arr)\n  gap = n // 2\n\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n\n    gap //= 2\n\n  return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts the given array using shell sort.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using shell sort algorithm.\n\n    Args:\n        arr: A list of numbers to be sorted.\n\n    Returns:\n        A sorted list of numbers.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2 \n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n  \"\"\"\n  Sorts a list using Shell Sort.\n  \"\"\"\n  n = len(arr)\n  gap = n // 2\n\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n    gap //= 2\n  return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using shell sort.\n\n    Args:\n        arr: A list of numbers to be sorted.\n\n    Returns:\n        The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(array):\n    \"\"\"\n    Sorts the given array using shell sort.\n\n    Args:\n      array: The array to be sorted.\n\n    Returns:\n      The sorted array.\n    \"\"\"\n\n    n = len(array)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using shell sort algorithm.\n\n    Args:\n        arr: The array to be sorted.\n\n    Returns:\n        The sorted array.\n    \"\"\"\n\n    n = len(arr)\n    gap = n // 2 \n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  \n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n  \"\"\"\n  Sorts a given array using shell sort.\n\n  Args:\n    arr: The array to be sorted.\n\n  Returns:\n    The sorted array.\n  \"\"\"\n  n = len(arr)\n  gap = n // 2\n\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n    gap //= 2\n  return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n  \"\"\"Sorts a given array using Shell sort.\n\n  Args:\n    arr: The array to be sorted.\n\n  Returns:\n    The sorted array.\n  \"\"\"\n  n = len(arr)\n  gap = n // 2\n\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n    gap //= 2\n  return arr\narr = [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n  \"\"\"Sorts the given array using shell sort.\"\"\"\n  n = len(arr)\n  gap = n // 2\n\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n    gap //= 2\n  return arr", "matching_cluster_idx": 3}]}, "Mbpp/433": {"dps": 91.22340425531915, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if a number is greater than all elements in an array.\n\n    Args:\n        array: A list of numbers.\n        number: The number to compare against the array elements.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n  \"\"\"\n  Checks if a given number is greater than all elements in an array.\n\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against.\n\n  Returns:\n    True if num is greater than all elements in arr, False otherwise.\n  \"\"\"\n  for x in arr:\n    if num <= x:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, n):\n  \"\"\"\n  Checks whether the entered number is greater than all elements of the given array.\n\n  Args:\n    arr: A list of numbers.\n    n: The number to compare against the array elements.\n\n  Returns:\n    True if n is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for element in arr:\n    if n <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n  \"\"\"Checks if a given number is greater than all elements in an array.\n\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against.\n\n  Returns:\n    True if num is greater than all elements in arr, False otherwise.\n  \"\"\"\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, number):\n  \"\"\"\n  This function checks if a given number is greater than all elements in an array.\n\n  Args:\n    arr: A list of numbers.\n    number: The number to compare against the elements of the array.\n\n  Returns:\n    True if the number is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for i in arr:\n    if number <= i:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n  \"\"\"\n  Checks whether the given number is greater than all elements in the given array.\n\n  Args:\n    array: A list of numbers.\n    number: The number to compare against the elements of the array.\n\n  Returns:\n    True if the number is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for element in array:\n    if number <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n      array: A list of numbers.\n      number: The number to compare against the elements of the array.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n  \"\"\"\n  Checks whether the entered number is greater than all elements of the given array.\n\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against the elements of the array.\n\n  Returns:\n    True if num is greater than all elements of arr, False otherwise.\n  \"\"\"\n\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n  \"\"\"\n  Checks if a given number is greater than all elements in an array.\n\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against.\n\n  Returns:\n    True if num is greater than all elements in arr, False otherwise.\n  \"\"\"\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n      arr: A list of numbers.\n      num: The number to compare.\n\n    Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n\n    for element in arr:\n      if num <= element:\n        return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n  \"\"\"\n  Checks whether the entered number is greater than all elements of the given array.\n\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against.\n\n  Returns:\n    True if num is greater than all elements in arr, False otherwise.\n  \"\"\"\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, number):\n  \"\"\"Checks if a given number is greater than all elements in an array.\n\n  Args:\n    arr: A list of numbers.\n    number: The number to compare against.\n\n  Returns:\n    True if the number is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for elem in arr:\n    if number <= elem:\n      return False\n  return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n  \"\"\"Checks whether the entered number is greater than all elements of the given array.\n\n  Args:\n      arr: A list of numbers.\n      num: The number to compare against.\n\n  Returns:\n      True if num is greater than all elements in arr, False otherwise.\n  \"\"\"\n\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, number):\n  \"\"\"\n  Checks whether the given number is greater than all elements in the array.\n\n  Args:\n      arr: A list of numbers.\n      number: The number to compare.\n\n  Returns:\n      True if the number is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for element in arr:\n    if number <= element:\n      return False\n  return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n    arr: A list of numbers.\n    num: The number to compare against.\n\n    Returns:\n    True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n  \"\"\"\n  Checks if a given number is greater than all elements in an array.\n\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against the elements of the array.\n\n  Returns:\n    True if the number is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if a given number is greater than all elements of an array.\n\n    Args:\n    arr: A list of numbers.\n    num: The number to compare against the array elements.\n\n    Returns:\n    True if the number is greater than all elements of the array, False otherwise.\n    \"\"\"\n\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all elements of the given array.\n\n    Args:\n        arr: A list of numbers.\n        num: The number to compare against.\n\n    Returns:\n        True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n  \"\"\"\n  This function checks if a given number is greater than all elements of an array.\n  Args:\n    arr: A list of numbers.\n    num: The number to compare against the array elements.\n  Returns:\n    True if the number is greater than all elements of the array, False otherwise.\n  \"\"\"\n  for element in arr:\n    if num <= element:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n  \"\"\"\n  Checks whether the entered number is greater than all elements of the given array.\n\n  Args:\n    array: A list of numbers.\n    number: The number to compare against the array elements.\n\n  Returns:\n    True if the number is greater than all elements in the array, False otherwise.\n  \"\"\"\n  for element in array:\n    if number <= element:\n      return False\n  return True", "matching_cluster_idx": 4}]}, "Mbpp/437": {"dps": 74.04411764705883, "dps_norm": 29.0, "pass@1": 39.0, "profiled": [{"solution": "def remove_odd(text):\n  \"\"\"Removes every second character from a string, starting with the second character.\n  \n  Args:\n    text: The input string.\n\n  Returns:\n    The string with every second character removed.\n  \"\"\"\n\n  return text[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(text):\n  \"\"\"Removes every other character from a string, starting with the second character.\n  For example:\n  remove_odd(\"python\") == \"yhn\"\n  \"\"\"\n  return text[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(text):\n    \"\"\"\n    Removes characters at odd indices in a string.\n\n    Args:\n    text (str): The input string.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join(text[i] for i in range(len(text)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n  \"\"\"\n  This function removes odd characters from a string.\n  For example:\n  remove_odd(\"python\") == \"yhn\"\n  \"\"\"\n  new_string = \"\"\n  for i, char in enumerate(string):\n    if i % 2 != 0:  \n      new_string += char\n  return new_string", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n  return \"\".join([c for i, c in enumerate(s) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"\n  Removes characters at odd indices in a string.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      A new string with characters at odd indices removed.\n  \"\"\"\n  return ''.join(text[i] for i in range(len(text)) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"\n  This function removes characters from a string at odd indices.\n  \"\"\"\n  return ''.join([text[i] for i in range(len(text)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n    \"\"\"\n    Removes characters at odd indices from a string.\n    For example:\n    remove_odd(\"python\") == \"yhn\"\n    \"\"\"\n    return \"\".join([text[i] for i in range(len(text)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"\n  This function removes characters at odd indices from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  return ''.join([text[i] for i in range(len(text)) if i % 2 != 0])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(text):\n  \"\"\"\n  This function removes characters at odd indices from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  return \"\".join(text[i] for i in range(len(text)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n  \"\"\"Removes odd-indexed characters from a string.\"\"\"\n  return \"\".join(string[i] for i in range(len(string)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"Removes odd-indexed characters from a string.\"\"\"\n  return \"\".join(text[i] for i in range(len(text)) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n  \"\"\"\n  Removes characters at odd indices from a string.\n\n  Args:\n    s: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"\n  This function removes characters at odd indices in a string.\n  \"\"\"\n  return \"\".join(text[i] for i in range(len(text)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"\n  This function removes characters at odd indices in a string.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      A string with characters at odd indices removed.\n  \"\"\"\n  return \"\".join([text[i] for i in range(len(text)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    return \"\".join(string[i] for i in range(len(string)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n    \"\"\"\n    This function removes characters from a string at odd indices.\n\n    Args:\n      text: The string to process.\n\n    Returns:\n      A new string with characters at odd indices removed.\n    \"\"\"\n    return ''.join([text[i] for i in range(len(text)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n  \"\"\"\n  This function removes characters at odd indices from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  return ''.join(text[i] for i in range(len(text)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n  \"\"\"\n  This function removes characters at odd indices from a given string.\n\n  Args:\n    string: The input string.\n\n  Returns:\n    A new string with characters at odd indices removed.\n  \"\"\"\n  return ''.join([string[i] for i in range(len(string)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(text):\n    \"\"\"\n    Removes characters at odd indices from a string.\n    For example:\n    remove_odd(\"python\") == \"yhn\"\n    \"\"\"\n    return \"\".join(text[i] for i in range(len(text)) if i % 2 != 0)", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.25615763546799, "dps_norm": 62.0, "pass@1": 94.0, "profiled": [{"solution": "def count_Occurrence(input_tuple, target_list):\n  \"\"\"\n  This function counts the occurrences of elements from a target list within a given tuple.\n\n  Args:\n    input_tuple: The tuple in which to search for the elements.\n    target_list: A list of elements to count occurrences of.\n\n  Returns:\n    The total count of occurrences of elements from target_list within input_tuple.\n  \"\"\"\n  count = 0\n  for element in target_list:\n    count += input_tuple.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements):\n  \"\"\"\n  Counts the occurrences of elements in a tuple.\n\n  Args:\n    input_tuple: A tuple of elements.\n    elements: A list of elements to count.\n\n  Returns:\n    The total count of occurrences of elements in the tuple.\n  \"\"\"\n  count = 0\n  for element in elements:\n    count += input_tuple.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_to_count):\n    \"\"\"\n    Counts the occurrences of elements from a list within a tuple.\n\n    Args:\n      input_tuple: The tuple to search within.\n      elements_to_count: A list of elements to count.\n\n    Returns:\n      An integer representing the total count of occurrences.\n    \"\"\"\n\n    count = 0\n    for element in elements_to_count:\n      count += input_tuple.count(element) \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data_tuple, target_list):\n  \"\"\"Counts the occurrence of elements in target_list within data_tuple.\n\n  Args:\n    data_tuple: The tuple to search within.\n    target_list: The list of elements to count.\n\n  Returns:\n    The total count of elements from target_list found in data_tuple.\n  \"\"\"\n\n  count = 0\n  for item in target_list:\n    count += data_tuple.count(item)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data_tuple,elements):\n    \"\"\"\n    This function counts the occurrences of elements in a tuple\n\n    Args:\n      data_tuple: a tuple of elements.\n      elements: a list of elements to count.\n\n    Returns:\n      The total count of the elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for element in elements:\n      count += data_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data_tuple, elements):\n  \"\"\"\n  Counts the occurrences of elements from a list within a tuple.\n\n  Args:\n    data_tuple: The tuple in which to count element occurrences.\n    elements: A list of elements to count within the tuple.\n\n  Returns:\n    The total count of occurrences of the specified elements in the tuple.\n  \"\"\"\n  count = 0\n  for element in elements:\n    count += data_tuple.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n  \"\"\"\n  Counts the occurrences of elements from a list within a tuple.\n\n  Args:\n    input_tuple: A tuple containing elements to be checked.\n    input_list: A list of elements whose occurrences need to be counted.\n\n  Returns:\n    The total count of occurrences of elements from the list in the tuple.\n  \"\"\"\n  count = 0\n  for element in input_list:\n    count += input_tuple.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data: tuple, elements: list) -> int:\n    \"\"\"\n    Count the occurrence of elements from a list within a tuple.\n\n    Args:\n      data: The tuple to search within.\n      elements: The list of elements to count occurrences of.\n\n    Returns:\n      The total count of occurrences of elements from the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in elements:\n        count += data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data_tuple, target_list):\n    \"\"\"\n    Counts the occurrence of all elements of a list in a tuple.\n    \n    Args:\n        data_tuple (tuple): The tuple to search within.\n        target_list (list): The list of elements to count.\n\n    Returns:\n        int: The total count of occurrences of elements from target_list in data_tuple.\n    \"\"\"\n    count = 0\n    for item in target_list:\n        count += data_tuple.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, list_elements):\n    \"\"\"\n    Counts the occurrence of elements from a list within a tuple.\n\n    Args:\n        input_tuple: A tuple of elements.\n        list_elements: A list of elements to count within the tuple.\n\n    Returns:\n        The total count of occurrences of elements from the list within the tuple.\n    \"\"\"\n    count = 0\n    for element in list_elements:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data, elements):\n  \"\"\"\n  Counts the occurrence of all elements in a tuple.\n\n  Args:\n    data: A tuple of elements.\n    elements: A list of elements to count.\n\n  Returns:\n    The total count of occurrences of the elements in the tuple.\n  \"\"\"\n  count = 0\n  for element in elements:\n    count += data.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, target_list):\n  \"\"\"\n  This function counts the occurrences of elements from a list within a tuple.\n\n  Args:\n    input_tuple: A tuple of elements.\n    target_list: A list of elements to count within the tuple.\n\n  Returns:\n    The total count of occurrences of the elements in target_list within input_tuple.\n  \"\"\"\n  count = 0\n  for element in target_list:\n    count += input_tuple.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data, targets):\n  \"\"\"\n  Counts the occurrence of elements in a tuple.\n\n  Args:\n    data: A tuple of elements.\n    targets: A list of elements to count.\n\n  Returns:\n    The total count of target elements in the tuple.\n  \"\"\"\n  count = 0\n  for item in targets:\n    count += data.count(item)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, target_list):\n    \"\"\"\n    Counts the occurrences of all elements in a list within a tuple.\n\n    Args:\n        input_tuple (tuple): The tuple to search within.\n        target_list (list): The list of elements to count.\n\n    Returns:\n        int: The total count of all target elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in target_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data_tuple, elements_list):\n  \"\"\"\n  Counts the occurrence of all elements in a list within a tuple.\n\n  Args:\n      data_tuple: A tuple of elements.\n      elements_list: A list of elements to count in the tuple.\n\n  Returns:\n      The total count of elements in 'elements_list' found in 'data_tuple'.\n  \"\"\"\n\n  count = 0\n  for element in elements_list:\n    count += data_tuple.count(element) \n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data_tuple, elements):\n  \"\"\"\n  Counts the occurrences of elements in a tuple.\n\n  Args:\n    data_tuple: A tuple of elements.\n    elements: A list of elements to count.\n\n  Returns:\n    The total count of occurrences of the elements in the tuple.\n  \"\"\"\n  count = 0\n  for element in elements:\n    count += data_tuple.count(element)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_to_count):\n    \"\"\"\n    Counts the occurrences of specified elements within a tuple.\n\n    Args:\n        input_tuple: The tuple to search within.\n        elements_to_count: A list of elements to count occurrences for.\n\n    Returns:\n        The total count of occurrences of the specified elements.\n    \"\"\"\n\n    count = 0\n    for element in elements_to_count:\n      count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(input_tuple, target_list):\n  \"\"\"Counts the occurrence of elements in a tuple from a given list.\n\n  Args:\n    input_tuple: A tuple containing elements to be counted.\n    target_list: A list of elements whose occurrences need to be counted.\n\n  Returns:\n    An integer representing the total count of elements from the target list within the tuple.\n  \"\"\"\n  # Use Counter to efficiently count all elements in the tuple\n  element_counts = Counter(input_tuple)\n  total_count = 0\n\n  # Iterate through the target list and sum the counts of each element\n  for element in target_list:\n    total_count += element_counts.get(element, 0) \n\n  return total_count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(data_tuple, target_list):\n  \"\"\"\n  Counts the occurrence of elements from target_list within a given tuple.\n\n  Args:\n      data_tuple: A tuple containing elements to be counted.\n      target_list: A list of elements to search for in the tuple.\n\n  Returns:\n      The total count of occurrences of elements from target_list in data_tuple.\n  \"\"\"\n  count = 0\n  for item in target_list:\n    count += data_tuple.count(item)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, target_list):\n  \"\"\"\n  Counts the occurrence of all elements of a list within a tuple.\n\n  Args:\n      input_tuple: The tuple to search within.\n      target_list: The list of elements to count.\n\n  Returns:\n      The total count of all target elements in the tuple.\n  \"\"\"\n  count = 0\n  for item in target_list:\n    count += input_tuple.count(item)\n  return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 64.0, "profiled": [{"solution": "def remove_whitespaces(text: str) -> str:\n  \"\"\"\n  Write a function to remove all whitespaces from the given string.\n  assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text: str) -> str:\n  \"\"\"Removes all whitespaces from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"Removes all whitespaces from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n    \"\"\"Removes all whitespaces from the given string.\"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"Removes all whitespaces from the given string.\n\n  Args:\n      text: The string to remove whitespaces from.\n\n  Returns:\n      The string without whitespaces.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  This function removes all whitespaces from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text: str) -> str:\n  \"\"\"\n  This function removes all whitespaces from the given string.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  Removes all whitespaces from the given string.\n\n  Args:\n    text: The string to remove whitespaces from.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  Removes all whitespaces from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  This function removes all whitespaces from the given string.\n\n  Args:\n      text: The string from which whitespaces need to be removed.\n\n  Returns:\n      The string without any whitespaces.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"Removes all whitespaces from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      The string with all whitespaces removed.\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  This function removes all whitespaces from a given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"Removes all whitespaces from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  This function removes all whitespaces from the given string.\n\n  Args:\n      text: The string to remove whitespaces from.\n\n  Returns:\n      The string without whitespaces.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"\n  This function removes all whitespaces from a given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text: str) -> str:\n  \"\"\"\n  Write a function to remove all whitespaces from the given string.\n  assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n  \"\"\"Removes all whitespaces from the given string.\n\n  Args:\n    text: The string to remove whitespaces from.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a given list of string values.\n\n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    A new list with each string in the input list reversed.\n  \"\"\"\n  return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n  \"\"\"Reverses each string in a given list of string values.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    A new list containing the reversed strings.\n  \"\"\"\n  return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"\n  Reverses each string in a list.\n\n  Args:\n      string_list: A list of strings.\n\n  Returns:\n      A new list with each string reversed.\n  \"\"\"\n  return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n      string_list: A list of string values.\n\n    Returns:\n      A new list with each string reversed.\n    \"\"\"\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n  \"\"\"\n  Reverses each string in a list of strings.\n\n  Args:\n    input_list: A list of strings.\n\n  Returns:\n    A new list with each string in the input list reversed.\n  \"\"\"\n\n  reversed_list = [s[::-1] for s in input_list]\n  return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list with each string reversed.\n    \"\"\"\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a given list of strings.\n  \n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    A new list with each string reversed.\n  \"\"\"\n  return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"Reverses each string in a given list of strings.\n\n    Args:\n        str_list: A list of strings.\n\n    Returns:\n        A new list with each string in str_list reversed.\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a list.\n\n    Args:\n      string_list: A list of strings.\n\n    Returns:\n      A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a given list of string values.\n\n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    A new list with each string reversed.\n  \"\"\"\n  return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a given list of string values.\n\n  Args:\n      string_list: A list of strings.\n\n  Returns:\n      A new list with each string reversed.\n  \"\"\"\n\n  return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n  \"\"\"\n  Reverses each string in a given list of string values.\n  \n  Args:\n      strings: A list of strings.\n      \n  Returns:\n      A new list with the strings in the input list reversed.\n  \"\"\"\n  return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list: A list of strings.\n\n    Returns:\n    A new list with each string reversed.\n    \"\"\"\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a given list of string values.\n\n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    A list of strings with each string reversed.\n  \"\"\"\n  return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n  \"\"\"\n  This function takes a list of strings and returns a new list with each string reversed.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    A new list with each string in the input list reversed.\n  \"\"\"\n  return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a list of strings.\n  \n  Args:\n      string_list: A list of strings.\n  \n  Returns:\n      A new list with each string in the input list reversed.\n  \"\"\"\n  return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n  \"\"\"\n  Reverses each string in a given list of strings.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    A new list with each string reversed.\n  \"\"\"\n  return [string[::-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n        string_list: A list of string values.\n\n    Returns:\n        A list of strings with each original string reversed.\n    \"\"\"\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n  \"\"\"Reverses each string in a given list of string values.\n\n  Args:\n    string_list: A list of string values.\n\n  Returns:\n    A new list with each string in the input list reversed.\n  \"\"\"\n\n  return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverses each string in a given list of strings.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        A new list with each string in the input list reversed.\n    \"\"\"\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 87.01923076923077, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lists):\n  \"\"\"\n  Extracts the first element of each sublist in a list of lists.\n\n  Args:\n    lists: A list of lists.\n\n  Returns:\n    A list containing the first elements of each sublist.\n  \"\"\"\n  return [sublist[0] for sublist in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n  \"\"\"\n  This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n  Args:\n    lst: A list of lists.\n\n  Returns:\n    A new list containing the first element of each sublist.\n  \"\"\"\n  return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n    lists: A list of lists.\n\n    Returns:\n    A list containing the first element of each sublist.\n    \"\"\"\n\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in a list.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A new list containing the first elements of each sublist in lst.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n  \"\"\"\n  This function extracts the first element from each sublist within a list.\n\n  Args:\n      lst: A list of lists.\n\n  Returns:\n      A list containing the first element of each sublist.\n  \"\"\"\n  return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n  \"\"\"\n  This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n  Args:\n      lst: A list of lists.\n\n  Returns:\n      A new list containing the first element of each sublist.\n  \"\"\"\n  return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n  \"\"\"\n  This function extracts the first element from each sublist in a list of lists.\n\n  Args:\n    lst: A list of lists.\n\n  Returns:\n    A new list containing the first element of each sublist in lst.\n  \"\"\"\n  return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n  \"\"\"\n  Returns a list containing the first element of each sublist in the input list.\n  \"\"\"\n  return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function extracts the first element from each sublist.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extract the first element of each sublist.\n    Args:\n        lst: A list of lists.\n    Returns:\n        A new list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists and returns a new list containing the first element of each sublist.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A new list containing the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n  \"\"\"\n  This function extracts the first element of each sublist in a list.\n\n  Args:\n    lst: A list of lists.\n\n  Returns:\n    A new list containing the first element of each sublist.\n  \"\"\"\n  return [sublst[0] for sublst in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n  \"\"\"\n  This function takes a list of lists as input and returns a new list containing the first element of each sublist.\n\n  Args:\n      list_of_lists: A list of lists.\n\n  Returns:\n      A new list containing the first element of each sublist.\n\n  Raises:\n      TypeError: If the input is not a list of lists.\n  \"\"\"\n  if not isinstance(list_of_lists, list):\n    raise TypeError(\"Input must be a list of lists.\")\n\n  return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists and returns a new list containing only the first element of each sublist.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: A new list containing the first element of each sublist.\n    \"\"\"\n\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A list containing the first elements of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n  \"\"\"\n  Extracts the first element of each sublist.\n\n  Args:\n      sublists: A list of lists.\n\n  Returns:\n      A new list containing the first element of each sublist.\n  \"\"\"\n  return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace old_char with.\n\n    Returns:\n        The string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  Replaces all occurrences of a given character in a string with another character.\n\n  Args:\n    text: The string in which to replace characters.\n    old_char: The character to be replaced.\n    new_char: The character to replace with.\n\n  Returns:\n    The modified string with all occurrences of old_char replaced by new_char.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  Replaces all occurrences of a character in a string with another character.\n\n  Args:\n    text: The input string.\n    old_char: The character to be replaced.\n    new_char: The character to replace with.\n\n  Returns:\n    The string with the replaced characters.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  Replaces all occurrences of 'old_char' in 'text' with 'new_char'.\n\n  Args:\n    text: The string to modify.\n    old_char: The character to be replaced.\n    new_char: The character to replace 'old_char' with.\n\n  Returns:\n    The modified string with all occurrences of 'old_char' replaced by 'new_char'.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of 'old_char' with 'new_char' in the given string.\n\n    Args:\n        text: The string to perform the replacement on.\n        old_char: The character to be replaced.\n        new_char: The character to replace 'old_char' with.\n\n    Returns:\n        The modified string with replacements made.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a specific character in a string with another character.\n\n    Args:\n        text (str): The string in which characters will be replaced.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace the old character with.\n\n    Returns:\n        str: The modified string with replacements made.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"Replaces all occurrences of 'old_char' with 'new_char' in a string.\n  \n  Args:\n    text: The string to modify.\n    old_char: The character to replace.\n    new_char: The character to replace 'old_char' with.\n\n  Returns:\n    The string with replacements made.\n  \"\"\"\n\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  Replaces all occurrences of old_char with new_char in a string.\n\n  Args:\n    text: The string to modify.\n    old_char: The character to be replaced.\n    new_char: The character to replace with.\n\n  Returns:\n    The string with the characters replaced.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces occurrences of old_char with new_char in a string.\n\n    Args:\n      text: The string to modify.\n      old_char: The character to replace.\n      new_char: The character to replace old_char with.\n\n    Returns:\n      The modified string with replacements made.\n    \"\"\"\n\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of 'old_char' with 'new_char' in a string.\n\n    Args:\n      text: The input string.\n      old_char: The character to be replaced.\n      new_char: The character to replace 'old_char' with.\n\n    Returns:\n      The string with 'old_char' replaced by 'new_char'.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"Replaces all occurrences of old_char with new_char in a string.\n\n  Args:\n    text: The input string.\n    old_char: The character to be replaced.\n    new_char: The character to replace with.\n\n  Returns:\n    The modified string with replacements.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  This function replaces all occurrences of a character in a string with another character.\n  \n  Args:\n      text: The string to be modified.\n      old_char: The character to be replaced.\n      new_char: The character to replace with.\n\n  Returns:\n      The modified string with all occurrences of old_char replaced by new_char.\n  \"\"\"\n\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of 'old_char' with 'new_char' in a string.\"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  Replaces all occurrences of old_char with new_char in the given text.\n\n  Args:\n    text: The string in which to replace characters.\n    old_char: The character to be replaced.\n    new_char: The character to replace old_char with.\n\n  Returns:\n    The string with all occurrences of old_char replaced by new_char.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\n\n    Args:\n        text: The input string.\n        old_char: The character to be replaced.\n        new_char: The character to replace old_char with.\n\n    Returns:\n        The modified string with replacements.\n    \"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  This function replaces all occurrences of a given character in a string with another character.\n  Args:\n      text (str): The string to modify.\n      old_char (str): The character to be replaced.\n      new_char (str): The character to replace with.\n  Returns:\n      str: The modified string with all instances of old_char replaced by new_char.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  This function replaces all occurrences of a character in a string.\n\n  Args:\n    text: The string to modify.\n    old_char: The character to be replaced.\n    new_char: The character to replace with.\n\n  Returns:\n    A new string with the replacements made.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"Replaces all occurrences of a character in a string.\n\n  Args:\n    text: The string to modify.\n    old_char: The character to replace.\n    new_char: The character to substitute.\n\n  Returns:\n    The modified string with replaced characters.\n  \"\"\"\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    \"\"\"Replaces all occurrences of old_char with new_char in a string.\"\"\"\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n  \"\"\"\n  Replaces all occurrences of a given character in a string with another character.\n\n  Args:\n      text: The string to modify.\n      old_char: The character to be replaced.\n      new_char: The character to replace with.\n\n  Returns:\n      The modified string with replacements made.\n  \"\"\"\n\n  return text.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n  \"\"\"\n  Finds the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest numbers in the array.\n  \"\"\"\n  if not arr:\n    return 0  \n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Finds the sum of the largest and smallest value in a given array.\n\n  Args:\n      arr: A list of numbers.\n\n  Returns:\n      The sum of the largest and smallest values in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  This function finds the sum of the largest and smallest value in a given array.\n  \n  Args:\n      arr: A list of numbers.\n  \n  Returns:\n      The sum of the largest and smallest numbers in the array.\n  \"\"\"\n  if len(arr) == 0:\n    return 0\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Find the sum of the largest and smallest value in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest numbers in the array.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Write a python function to find the sum of the largest and smallest value in a given array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Find the sum of the largest and smallest values in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest values in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Finds the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest numbers in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"Finds the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest elements in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Find the sum of the largest and smallest value in a given array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  This function finds the sum of the largest and smallest values in a given array.\n  \n  Args:\n    arr: A list of numbers\n\n  Returns:\n    The sum of the largest and smallest values in the array.\n  \"\"\"\n  smallest = min(arr)\n  largest = max(arr)\n  return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Finds the sum of the largest and smallest values in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest values in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  This function finds the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest numbers in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  This function takes an array of numbers and returns the sum of the largest and smallest values.\n\n  Args:\n      arr: A list of numbers.\n\n  Returns:\n      The sum of the largest and smallest numbers in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Write a python function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n\n    Args:\n      arr: A list of numbers.\n\n    Returns:\n      The sum of the largest and smallest values in the array.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n\n    Args:\n        arr: A list of numbers.\n\n    Returns:\n        The sum of the largest and smallest values in the list.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  This function finds the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest value in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Find the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest values in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  This function takes an array as input and returns the sum of its largest and smallest elements.\n\n  Args:\n      arr: A list of numbers.\n\n  Returns:\n      The sum of the largest and smallest values in the input array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n  \"\"\"\n  Finds the sum of the largest and smallest value in a given array.\n\n  Args:\n    arr: A list of numbers.\n\n  Returns:\n    The sum of the largest and smallest values in the array.\n  \"\"\"\n  return max(arr) + min(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(text):\n  \"\"\"Converts a given string to lowercase.\n\n  Args:\n    text: The string to be converted.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n  \"\"\"\n  This function converts the given string to lowercase.\n\n  Args:\n    string: The input string.\n\n  Returns:\n    The input string converted to lowercase.\n  \"\"\"\n  return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  This function converts the given string to lower case.\n\n  Args:\n      text: The string to be converted.\n\n  Returns:\n      The lowercase version of the string.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"Converts a string to lowercase.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The input string converted to lowercase.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"Converts the given string to lower case.\"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  This function converts the given string to lowercase.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      The lowercase version of the input string.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  This function takes a string as input and returns the string in lower case.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n    \"\"\"Converts a given string to lowercase.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The input string converted to lowercase.\n    \"\"\"\n    return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  Convert the given string to lower case.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  This function takes a string and converts it to lowercase.\n\n  Args:\n    text: The string to be converted to lowercase.\n\n  Returns:\n    The input string converted to lowercase.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text: str) -> str:\n  \"\"\"\n  Write a python function to convert the given string to lower case.\n\n  Example:\n  assert is_lower(\"InValid\") == \"invalid\"\n  \"\"\"\n  return text.lower()\ntext = \"InValid\"", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"Converts the given string to lowercase.\n  \n  Args:\n    text: The string to be converted.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The string in lower case.\n    \"\"\"\n    return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text: str) -> str:\n  \"\"\"Converts the given string to lowercase.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The input string converted to lowercase.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  This function converts a string to lowercase.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"\n  Converts the given string to lower case.\n\n  Args:\n    text: The string to convert.\n\n  Returns:\n    The lowercase version of the string.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Converts the given string to lowercase.\n\n    Args:\n      string: The input string.\n\n    Returns:\n      The string in lowercase.\n    \"\"\"\n\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n  \"\"\"Converts a string to lowercase.\n\n  Args:\n    text: The input string to be converted to lowercase.\n\n  Returns:\n    The lowercase version of the input string.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text: str) -> str:\n  \"\"\"\n  This function converts the given string to lower case.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      The input string converted to lower case.\n  \"\"\"\n  return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text: str) -> str:\n    \"\"\"\n    Write a python function to convert the given string to lower case.\n    assert is_lower(\"InValid\") == \"invalid\"\n    \"\"\"\n    return text.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values enclosed in double quotes from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"Extracts values between quotation marks from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings extracted from between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of values extracted from the string.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        text: The string to extract values from.\n\n    Returns:\n        A list of strings containing the values between quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"Extracts values between quotation marks from a string.\"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of values found between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n      text: The string to extract values from.\n\n    Returns:\n      A list of strings containing the values between quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values enclosed in quotation marks from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of values enclosed in quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings containing the values between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of values extracted between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  This function extracts values between quotation marks from a string.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      A list of strings containing the values between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings containing the values between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values enclosed in double quotes from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings containing the values between double quotes.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n  \n  Args:\n    text: The input string containing values in quotation marks.\n  \n  Returns:\n    A list of strings extracted between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"Extracts values enclosed in double quotes from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings containing the extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values enclosed in double quotes from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings containing the extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings extracted from between the quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n    text: The string to extract values from.\n\n  Returns:\n    A list of values found between quotation marks.\n  \"\"\"\n\n  return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n    text: The string to extract values from.\n\n  Returns:\n    A list of strings containing the extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n  \"\"\"\n  Extracts values between quotation marks from a string.\n\n  Args:\n      text: The string to extract values from.\n\n  Returns:\n      A list of strings containing the values between quotation marks.\n  \"\"\"\n  return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/578": {"dps": 64.17460317460318, "dps_norm": 65.0, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the interleaved elements.\n  \"\"\"\n  return [x for t in zip(list1, list2, list3) for x in t]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  Interleaves three lists of equal length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing elements from the input lists interleaved.\n  \"\"\"\n  interleaved_list = []\n  for i in range(len(list1)):\n    interleaved_list.extend([list1[i], list2[i], list3[i]])\n  return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the input lists interleaved.\n  \"\"\"\n  interleaved_list = []\n  for i in range(len(list1)):\n    interleaved_list.extend([list1[i], list2[i], list3[i]])\n  return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the three input lists interleaved.\n  \"\"\"\n  interleaved_list = []\n  for i in range(len(list1)):\n    interleaved_list.extend([list1[i], list2[i], list3[i]])\n  return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A new list containing all elements from the input lists interleaved.\n    \"\"\"\n    interleaved = []\n    for i in range(len(list1)):\n      interleaved.extend([list1[i], list2[i], list3[i]])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n    Returns:\n      A new list containing the elements of the three input lists interleaved.\n    \"\"\"\n\n    interleaved_list = []\n    for i in range(len(list1)):\n      interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length into a single flat list.\"\"\"\n  interleaved = []\n  for i in range(len(list1)):\n    interleaved.extend([list1[i], list2[i], list3[i]])\n  return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleaves three lists into a single flat list.\"\"\"\n    result = []\n    for i in range(len(list1)):\n      result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length into a single flat list.\"\"\"\n  interleaved = []\n  for i in range(len(list1)):\n    interleaved.extend([list1[i], list2[i], list3[i]])\n  return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1: The first list.\n        list2: The second list.\n        list3: The third list.\n\n    Returns:\n        A single list containing elements from the three input lists interleaved.\n    \"\"\"\n\n    interleaved_list = []\n    for i in range(len(list1)):\n      interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n      lst1: The first list.\n      lst2: The second list.\n      lst3: The third list.\n\n    Returns:\n      A new list containing the elements of the input lists interleaved.\n    \"\"\"\n\n    interleaved_list = []\n    for i in range(len(lst1)):\n        interleaved_list.extend([lst1[i], lst2[i], lst3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  This function interleaves three lists of the same length into a single flat list.\n\n  Args:\n      list1: The first list.\n      list2: The second list.\n      list3: The third list.\n\n  Returns:\n      A new list containing the elements of the input lists interleaved.\n  \"\"\"\n\n  interleaved = []\n  for i in range(len(list1)):\n    interleaved.extend([list1[i], list2[i], list3[i]])\n  return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list with elements from the input lists interleaved.\n  \"\"\"\n\n  interleaved_list = []\n  for i in range(len(list1)):\n    interleaved_list.extend([list1[i], list2[i], list3[i]])\n  return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the three input lists interleaved.\n  \"\"\"\n\n  interleaved_list = []\n  for i in range(len(list1)):\n    interleaved_list.extend([list1[i], list2[i], list3[i]])\n  return interleaved_list\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the three input lists interleaved.\n\n  Examples:\n    interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n  \"\"\"\n  return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A single list containing all elements from the input lists interleaved.\n  \"\"\"\n  interleaved = []\n  for i in range(len(list1)):\n    interleaved.extend([list1[i], list2[i], list3[i]])\n  return interleaved\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the input lists interleaved.\n  \"\"\"\n  \n  interleaved = []\n  for i in range(len(list1)):\n    interleaved.extend([list1[i], list2[i], list3[i]])\n  return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length into a single flat list.\"\"\"\n  return [x for t in zip(list1, list2, list3) for x in t]\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"\n  Interleaves three lists of equal length into a single list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the three input lists interleaved.\n\n  Raises:\n    ValueError: If the input lists are not of equal length.\n  \"\"\"\n  if len(list1) != len(list2) or len(list1) != len(list3):\n    raise ValueError(\"Input lists must have the same length.\")\n\n  interleaved_list = []\n  for i in range(len(list1)):\n    interleaved_list.extend([list1[i], list2[i], list3[i]])\n  return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n  \"\"\"Interleaves three lists of the same length into a single flat list.\n\n  Args:\n    list1: The first list.\n    list2: The second list.\n    list3: The third list.\n\n  Returns:\n    A new list containing the elements of the three input lists\n    interleaved together.\n  \"\"\"\n  interleaved = []\n  for i in range(len(list1)):\n    interleaved.extend([list1[i], list2[i], list3[i]])\n  return interleaved", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 94.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: The list to be split.\n    n: The index to split the list at.\n\n  Returns:\n    A new list with the first part of the input list appended to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\"\"\"\n\n    if n >= len(arr):\n        return arr  \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"\n  Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: A list of elements.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first n elements moved to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr,n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n    arr: The input list.\n    n: The index to split the list at.\n\n    Returns:\n    A new list with the first part of the input list appended to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr: The input list.\n        n: The index to split at.\n\n    Returns:\n        A new list with the first n elements moved to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n  \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    lst: The list to be split.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first part of the original list appended to the end.\n  \"\"\"\n  return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: The list to split.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first part of the original list appended to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n  \"\"\"\n  Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n      input_list: The input list.\n      n: The index to split the list at.\n\n  Returns:\n      A new list with the first part appended to the end.\n  \"\"\"\n  return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"\n  Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n      arr: The input list.\n      n: The index at which to split the list.\n\n  Returns:\n      A new list with the first n elements appended to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n      arr: The input list.\n      n: The index to split the list at.\n\n  Returns:\n      The list with the first part moved to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"Splits a list at the nth element and adds the first part to the end.\"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"\n  Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: The input list.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first part of the original list appended to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"\n  Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: The input list.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first n elements moved to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: The input list.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first n elements moved to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        input_list: The list to be split and rearranged.\n        n: The index at which to split the list.\n\n    Returns:\n        A new list with the first n elements moved to the end.\n    \"\"\"\n    return input_list[n:] + input_list[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"\n  Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n      arr: The input list.\n      n: The index at which to split the list.\n\n  Returns:\n      A new list with the first part of the input list added to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n  \"\"\"Splits a list at the nth element and adds the first part to the end.\n\n  Args:\n    arr: A list of elements.\n    n: The index at which to split the list.\n\n  Returns:\n    A new list with the first n elements moved to the end.\n  \"\"\"\n  return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 69.25675675675676, "dps_norm": 91.25, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(input_list):\n  \"\"\"\n  This function converts a list to a tuple.\n\n  Args:\n    input_list: A list.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    lst: The list to convert.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    input_list: A list.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n  \"\"\"\n  Converts a list to a tuple.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    input_list: A list of elements.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    input_list: A list of any type.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n        input_list: A list to be converted.\n\n    Returns:\n        A tuple containing the elements of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    lst: A list.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n  \"\"\"\n  This function converts a list to a tuple.\n  \n  Args:\n    input_list: A list of elements.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        input_list: A list of elements.\n\n    Returns:\n        A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"\n  Converts a list to a tuple.\n\n  Args:\n    input_list: A list of elements.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    \"\"\"Converts a list to a tuple.\n\n    Args:\n      input_list: The input list.\n\n    Returns:\n      A tuple containing the elements of the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n  \"\"\"\n  Converts a list to a tuple.\n\n  Args:\n    lst: A list.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n      input_list: A list to convert.\n\n  Returns:\n      A tuple with the same elements as the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    input_list: A list.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    input_list: A list of elements.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n  \"\"\"\n  This function converts a list to a tuple.\n\n  Args:\n    input_list: The list to be converted.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"Converts a list to a tuple.\n\n  Args:\n    input_list: The input list.\n\n  Returns:\n    A tuple containing the elements of the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n  \"\"\"\n  This function converts a list to a tuple.\n\n  Args:\n    input_list: A list of elements.\n\n  Returns:\n    A tuple containing the same elements as the input list.\n  \"\"\"\n  return tuple(input_list)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  This function takes a list of numbers as input and returns the difference\n  between the largest and smallest values in the list.\n  \n  Args:\n    nums: A list of numbers.\n  \n  Returns:\n    An integer representing the difference between the largest and smallest \n    values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  Find the difference between the largest and smallest values in a given list.\n\n  Args:\n      nums: A list of numbers.\n\n  Returns:\n      The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if not nums:\n      return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function finds the difference between the largest and smallest values in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The difference between the largest and smallest values in the list.\n    \"\"\"\n\n    if len(nums) == 0:\n      return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  This function finds the difference between the largest and smallest values in a given list.\n\n  Args:\n      nums: A list of numbers.\n\n  Returns:\n      The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  Finds the difference between the largest and smallest values in a given list.\n\n  Args:\n      nums: A list of numbers.\n\n  Returns:\n      The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n  \"\"\"\n  Find the difference between largest and smallest value in a given list.\n\n  Args:\n    lst: A list of numbers.\n\n  Returns:\n    The difference between the largest and smallest value in the list.\n  \"\"\"\n  if not lst:\n    return 0\n  return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  This function finds the difference between the largest and smallest values in a list.\n  Args:\n      nums: A list of numbers.\n  Returns:\n      The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n  \"\"\"\n  Finds the difference between the largest and smallest values in a given list.\n\n  Args:\n    lst: A list of integers.\n\n  Returns:\n    The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  Finds the difference between the largest and smallest values in a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  Finds the difference between the largest and smallest values in a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a given list.\n\n    Args:\n        lst: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n    \"\"\"\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  This function finds the difference between the largest and smallest values in a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The difference between the largest and smallest values in the list.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function takes a list of numbers and returns the difference between \n    the largest and smallest values in the list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest value in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The difference between the largest and smallest values in the list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 53.53333333333334, "dps_norm": 39.0, "pass@1": 20.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n  \"\"\"\n  This function calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n      n: An integer representing the degree of the binomial expansion.\n\n  Returns:\n      The sum of the product of consecutive binomial coefficients.\n  \"\"\"\n  total = 0\n  for i in range(n):\n    total += math.comb(n, i) * math.comb(n, i + 1)  \n  return total", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n    n: An integer representing the upper limit for the binomial coefficients.\n\n  Returns:\n    The sum of the product of consecutive binomial coefficients up to n.\n  \"\"\"\n\n  total = 0\n  for i in range(n):\n    total += binomial_coefficient(n, i) * binomial_coefficient(n, i + 1)\n  return total\ndef binomial_coefficient(n, k):\n  \"\"\"\n  Calculates the binomial coefficient (n choose k).\n\n  Args:\n    n: The total number of items.\n    k: The number of items to choose.\n\n  Returns:\n    The binomial coefficient (n choose k).\n  \"\"\"\n  if k < 0 or k > n:\n    return 0\n  if k == 0 or k == n:\n    return 1\n  return factorial(n) // (factorial(k) * factorial(n - k))\ndef factorial(n):\n  \"\"\"\n  Calculates the factorial of a non-negative integer.\n\n  Args:\n    n: The non-negative integer.\n\n  Returns:\n    The factorial of n.\n  \"\"\"\n  if n == 0:\n    return 1\n  else:\n    return n * factorial(n-1)", "matching_cluster_idx": -1}, {"solution": "from math import comb\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n      n: A non-negative integer.\n\n  Returns:\n      The sum of the products of consecutive binomial coefficients up to n.\n  \"\"\"\n  total = 0\n  for i in range(n):\n    total += comb(n, i) * comb(n, i+1)\n  return total", "matching_cluster_idx": 5}, {"solution": "from math import factorial\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n    n: An integer representing the upper limit for binomial coefficients.\n\n  Returns:\n    The sum of the product of consecutive binomial coefficients up to n.\n  \"\"\"\n  total_sum = 0\n  for i in range(n):\n      total_sum += factorial(n) // (factorial(i) * factorial(n - i)) * factorial(n) // (factorial(i + 1) * factorial(n - i - 1))\n  return total_sum", "matching_cluster_idx": 1}, {"solution": "from math import factorial\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients up to n.\n\n    Args:\n      n: An integer representing the upper limit for binomial coefficients.\n\n    Returns:\n      An integer representing the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n      total_sum += (factorial(n) // (factorial(i) * factorial(n - i))) * (factorial(n) // (factorial(i + 1) * factorial(n - i - 1)))\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficients.\n\n    Returns:\n        An integer representing the sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += math.comb(n, i) * math.comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients up to n.\n\n    Args:\n        n: An integer representing the upper limit for the binomial coefficients.\n\n    Returns:\n        An integer representing the sum of products.\n    \"\"\"\n\n    total_sum = 0\n    for i in range(n):\n        total_sum += math.comb(n, i) * math.comb(n, i + 1)  # Calculate product and add to sum\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Args:\n        n: An integer representing the upper limit of the binomial coefficient range (inclusive).\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients from 0 to n.\n    \"\"\"\n\n    total_sum = 0\n    for i in range(n):\n      total_sum += binomial_coefficient(n, i) * binomial_coefficient(n, i + 1)\n    return total_sum\ndef binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient (n choose k).\n\n    Args:\n        n: The total number of items.\n        k: The number of items to choose.\n\n    Returns:\n        The binomial coefficient (n choose k).\n    \"\"\"\n\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n\n    numerator = 1\n    for i in range(n, n - k, -1):\n        numerator *= i\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator *= i\n    return numerator // denominator", "matching_cluster_idx": 1}, {"solution": "def sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n      n: A non-negative integer.\n\n  Returns:\n      The sum of the product of consecutive binomial coefficients up to n.\n  \"\"\"\n\n  total = 0\n  for i in range(n):\n    # Calculate the binomial coefficients\n    binom_coeff1 = factorial(n) // (factorial(i) * factorial(n-i))\n    binom_coeff2 = factorial(n) // (factorial(i+1) * factorial(n-i-1))\n    # Add the product to the total\n    total += binom_coeff1 * binom_coeff2\n\n  return total\ndef factorial(num):\n  \"\"\"\n  Calculates the factorial of a non-negative integer.\n\n  Args:\n      num: A non-negative integer.\n\n  Returns:\n      The factorial of num.\n  \"\"\"\n\n  if num == 0:\n    return 1\n  else:\n    return num * factorial(num - 1)", "matching_cluster_idx": -1}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    For example:\n    sum_Of_product(3) == 1 * 3 + 3 * 3 + 3 * 1 = 15\n    \"\"\"\n\n    total = 0\n    for i in range(n):\n        total += comb(n, i) * comb(n, i+1)\n    return total", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n    n: An integer representing the upper limit for the binomial coefficients.\n\n  Returns:\n    The sum of the product of consecutive binomial coefficients up to n.\n  \"\"\"\n  total_sum = 0\n  for i in range(n):\n    total_sum += comb(n, i) * comb(n, i+1)\n  return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Args:\n    n: A non-negative integer.\n\n    Returns:\n    The sum of the product of consecutive binomial coefficients from C(n, 0)*C(n, 1) to C(n, n-1)*C(n, n).\n    \"\"\"\n\n    sum = 0\n    for i in range(n):\n        sum += math.comb(n, i) * math.comb(n, i + 1) \n    return sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n  \"\"\"\n  This function calculates the sum of the product of consecutive binomial coefficients.\n  \n  Args:\n    n: An integer representing the highest power of the binomial expansion.\n\n  Returns:\n    The sum of the product of consecutive binomial coefficients up to n.\n  \"\"\"\n  total_sum = 0\n  for i in range(n):\n    total_sum += factorial(n) // (factorial(i) * factorial(n - i)) * factorial(n) // (factorial(i + 1) * factorial(n - i - 1))\n  return total_sum\ndef factorial(num):\n  \"\"\"\n  This function calculates the factorial of a non-negative integer.\n  \n  Args:\n    num: A non-negative integer.\n  \n  Returns:\n    The factorial of num.\n  \"\"\"\n  if num == 0:\n    return 1\n  else:\n    return num * factorial(num - 1)", "matching_cluster_idx": -1}, {"solution": "def sum_Of_product(n: int) -> int:\n    \"\"\"\n    This function finds the sum of the product of consecutive binomial coefficients.\n\n    For example:\n    sum_Of_product(3) == 15  because (1 * 3) + (3 * 3) + (3 * 1) = 15\n\n    Args:\n    n: A non-negative integer\n\n    Returns:\n    The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        # Using the formula for binomial coefficient: n choose k = n! / (k! * (n-k)!)\n        coefficient1 = factorial(n) // (factorial(i) * factorial(n - i))\n        coefficient2 = factorial(n) // (factorial(i + 1) * factorial(n - (i + 1)))\n        total_sum += coefficient1 * coefficient2\n    return total_sum\ndef factorial(num: int) -> int:\n  \"\"\"\n  Helper function to calculate factorial.\n  \"\"\"\n  if num == 0:\n    return 1\n  else:\n    return num * factorial(num - 1)", "matching_cluster_idx": -1}, {"solution": "import math\ndef sum_Of_product(n):\n  \"\"\"\n  Find the sum of the product of consecutive binomial coefficients.\n\n  Args:\n      n: The upper limit for the binomial coefficients.\n\n  Returns:\n      The sum of the product of consecutive binomial coefficients up to n.\n  \"\"\"\n  total_sum = 0\n  for i in range(n):\n    total_sum += math.comb(n, i) * math.comb(n, i + 1) \n  return total_sum", "matching_cluster_idx": 5}, {"solution": "def factorial(n):\n  if n == 0:\n    return 1\n  else:\n    return n * factorial(n-1)\ndef binomial_coefficient(n, k):\n  return factorial(n) // (factorial(k) * factorial(n-k))\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    The sum of the product of consecutive binomial coefficients for n.\n  \"\"\"\n  sum = 0\n  for i in range(n):\n    sum += binomial_coefficient(n, i) * binomial_coefficient(n, i+1)\n  return sum", "matching_cluster_idx": -1}, {"solution": "import math\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  For example:\n  sum_Of_product(3) == 15 \n\n  Explanation:\n  The binomial coefficients for n=3 are:\n     1, 3, 3, 1\n  The products of consecutive coefficients are:\n     1*3 = 3\n     3*3 = 9\n     3*1 = 3\n  The sum of these products is 3 + 9 + 3 = 15\n\n  Args:\n    n: A non-negative integer.\n\n  Returns:\n    The sum of the product of consecutive binomial coefficients for n.\n  \"\"\"\n  sum = 0\n  for i in range(n):\n    sum += math.comb(n, i) * math.comb(n, i+1)\n  return sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n: int) -> int:\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients.\n\n    Args:\n        n: An integer greater than or equal to 0.\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients for n.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += math.comb(n, i) * math.comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef sum_Of_product(n):\n  \"\"\"\n  Calculates the sum of the product of consecutive binomial coefficients.\n\n  Args:\n      n: The upper limit of the binomial coefficients.\n\n  Returns:\n      The sum of the product of consecutive binomial coefficients.\n  \"\"\"\n  total_sum = 0\n  for i in range(n):\n    total_sum += math.comb(n, i) * math.comb(n, i + 1)\n  return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients.\n\n    Args:\n        n: An integer representing the upper limit for the binomial coefficients.\n\n    Returns:\n        The sum of the product of consecutive binomial coefficients up to n.\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += math.comb(n, i) * math.comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 33.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"Finds the kth element from two sorted arrays.\n\n  Args:\n    arr1: The first sorted array.\n    arr2: The second sorted array.\n    k: The kth element to find.\n\n  Returns:\n    The kth element from the combined sorted arrays.\n  \"\"\"\n  merged_array = sorted(arr1 + arr2)\n  return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"Finds the kth element in the merged sorted array of arr1 and arr2.\n\n  Args:\n    arr1: The first sorted array.\n    arr2: The second sorted array.\n    k: The desired kth element.\n\n  Returns:\n    The kth element in the merged sorted array.\n  \"\"\"\n  merged_arr = sorted(arr1 + arr2)  # Merge and sort the arrays\n  return merged_arr[k - 1]  # Return the kth element (zero-indexed)", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"\n  Finds the kth element from two sorted arrays.\n\n  Args:\n      arr1: The first sorted array.\n      arr2: The second sorted array.\n      k: The kth element to find.\n\n  Returns:\n      The kth element from the combined sorted arrays.\n  \"\"\"\n  merged_arr = sorted(arr1 + arr2)\n  return merged_arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"\n  Finds the kth element from two sorted arrays.\n\n  Args:\n    arr1: The first sorted array.\n    arr2: The second sorted array.\n    k: The kth element to find.\n\n  Returns:\n    The kth element from the merged sorted arrays.\n  \"\"\"\n  merged_array = sorted(arr1 + arr2)\n  return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n      arr1: The first sorted array.\n      arr2: The second sorted array.\n      k: The kth element to find.\n\n    Returns:\n      The kth element in the merged sorted arrays.\n    \"\"\"\n\n    merged_arr = sorted(arr1 + arr2)\n    return merged_arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n        arr1: The first sorted array.\n        arr2: The second sorted array.\n        k: The kth element to find.\n\n    Returns:\n        The kth element from the combined sorted arrays.\n    \"\"\"\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n        arr1 (list): The first sorted array.\n        arr2 (list): The second sorted array.\n        k (int): The kth element to find.\n\n    Returns:\n        int: The kth element.\n    \"\"\"\n\n    merged_arr = sorted(arr1 + arr2)\n    return merged_arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"\n  Finds the kth element in two sorted arrays.\n\n  Args:\n    arr1: The first sorted array.\n    arr2: The second sorted array.\n    k: The kth element to find.\n\n  Returns:\n    The kth element in the combined sorted arrays.\n  \"\"\"\n\n  merged_arr = sorted(arr1 + arr2)\n  return merged_arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Finds the kth element in two sorted arrays.\n\n    Args:\n        nums1 (list of ints): The first sorted array.\n        nums2 (list of ints): The second sorted array.\n        k (int): The kth element to find.\n\n    Returns:\n        int: The kth element in the merged sorted arrays.\n    \"\"\"\n    merged = sorted(nums1 + nums2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"Finds the kth element from two sorted arrays.\n\n    Args:\n        arr1: The first sorted array.\n        arr2: The second sorted array.\n        k: The desired kth element.\n\n    Returns:\n        The kth element in the merged sorted array of arr1 and arr2.\n    \"\"\"\n\n    merged_array = sorted(arr1 + arr2)\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n      arr1: The first sorted array.\n      arr2: The second sorted array.\n      k: The desired kth element.\n\n    Returns:\n      The kth element from the merged sorted arrays.\n    \"\"\"\n    merged_array = sorted(arr1 + arr2)\n    if len(merged_array) < k:\n      return None\n    return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n        arr1: The first sorted array.\n        arr2: The second sorted array.\n        k: The kth element to find.\n\n    Returns:\n        The kth element from the merged sorted arrays.\n    \"\"\"\n\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"Finds the kth element in two sorted arrays.\n\n    Args:\n        arr1: The first sorted array.\n        arr2: The second sorted array.\n        k: The kth element to find.\n\n    Returns:\n        The kth element in the merged sorted arrays.\n    \"\"\"\n\n    merged_array = sorted(arr1 + arr2)\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n        arr1: The first sorted array.\n        arr2: The second sorted array.\n        k: The kth element to find.\n\n    Returns:\n        The kth element from the merged sorted arrays.\n    \"\"\"\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"\n  Finds the kth element from two sorted arrays.\n\n  Args:\n    arr1: The first sorted array.\n    arr2: The second sorted array.\n    k: The kth element to find.\n\n  Returns:\n    The kth element in the merged sorted arrays.\n  \"\"\"\n  merged_array = sorted(arr1 + arr2)\n  return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n  \"\"\"\n  Finds the k-th smallest element in two sorted arrays.\n\n  Args:\n    nums1: The first sorted array.\n    nums2: The second sorted array.\n    k: The k-th smallest element to find.\n\n  Returns:\n    The k-th smallest element in the merged sorted arrays.\n  \"\"\"\n\n  merged_array = sorted(nums1 + nums2) \n  return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n  \"\"\"\n  Finds the kth element from the given two sorted arrays.\n\n  Args:\n    nums1: The first sorted array.\n    nums2: The second sorted array.\n    k: The kth element to find.\n\n  Returns:\n    The kth element from the merged sorted arrays.\n  \"\"\"\n\n  merged_array = sorted(nums1 + nums2)\n  return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Finds the kth element from two sorted arrays.\n\n    Args:\n        nums1: The first sorted array.\n        nums2: The second sorted array.\n        k: The kth element to find.\n\n    Returns:\n        The kth element from the merged sorted arrays.\n    \"\"\"\n    merged = sorted(nums1 + nums2)  # Merge and sort the arrays\n    return merged[k - 1]  # Return the kth element (index k-1)", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    Args:\n        nums1: The first sorted array.\n        nums2: The second sorted array.\n        k: The kth element to find.\n\n    Returns:\n        The kth element from the merged sorted arrays.\n    \"\"\"\n\n    merged_array = sorted(nums1 + nums2)\n    return merged_array[k - 1]\nnums1 = [2, 3, 6, 7, 9]\nnums2 = [1, 4, 8, 10]\nk = 5", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n  \"\"\"\n  Finds the kth smallest element in two sorted arrays.\n\n  Args:\n    arr1: The first sorted array.\n    arr2: The second sorted array.\n    k: The kth element to find.\n\n  Returns:\n    The kth smallest element.\n  \"\"\"\n  merged_array = sorted(arr1 + arr2)\n  return merged_array[k-1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 57.04545454545455, "dps_norm": 91.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(text):\n  \"\"\"Reverses the order of words in a given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A string with the words in reversed order.\n  \"\"\"\n  return \" \".join(text.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the order of words in a string separated by spaces.\n\n    Args:\n      s: The input string.\n\n    Returns:\n      A new string with the words in reversed order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n    \"\"\"\n    Reverses the order of words in a given string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        str: The string with words reversed.\n    \"\"\"\n    return \" \".join(text.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n  \"\"\"\n  Reverses the order of words in a given string.\n\n  Args:\n      s: The string to reverse.\n\n  Returns:\n      The string with the words in reverse order.\n  \"\"\"\n  words = s.split()\n  return \" \".join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n  \"\"\"\n  Reverses words separated by spaces in a given string.\n\n  Args:\n    s: The input string.\n\n  Returns:\n    The string with words reversed.\n  \"\"\"\n  words = s.split()\n  return \" \".join(words[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses the order of words in a string.\n\n  Args:\n    text: The string to reverse the words in.\n\n  Returns:\n    The string with the words reversed.\n  \"\"\"\n  return \" \".join(text.split()[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(text):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      The string with the words reversed.\n    \"\"\"\n    return \" \".join(text.split()[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n  \"\"\"\n  This function reverses words separated by spaces in a given string.\n  \n  Args:\n    s: A string of words separated by spaces.\n\n  Returns:\n    A string with the words in reverse order.\n  \"\"\"\n  words = s.split()\n  return \" \".join(reversed(words))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses words in a string separated by spaces.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with words reversed.\n  \"\"\"\n  return \" \".join(text.split()[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(text):\n  \"\"\"\n  Reverses the order of words in a given string.\n\n  Args:\n    text: The input string with words separated by spaces.\n\n  Returns:\n    A string with the words in reversed order.\n  \"\"\"\n  words = text.split()\n  return \" \".join(words[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n  \"\"\"Reverses words separated by spaces in a given string.\n\n  Args:\n    s: The string to reverse.\n\n  Returns:\n    The string with words reversed.\n  \"\"\"\n  return \" \".join(s.split()[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n  \"\"\"\n  Reverses words separated by spaces in a given string.\n\n  Args:\n    s: A string of words separated by spaces.\n\n  Returns:\n    A string with the words in reverse order.\n  \"\"\"\n  return ' '.join(s.split()[::-1])", "matching_cluster_idx": 3}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses words separated by spaces in a given string.\n\n  Args:\n    text: The string to reverse.\n\n  Returns:\n    The string with words reversed.\n  \"\"\"\n  return \" \".join(text.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses the order of words in a given string.\n\n  Args:\n    text: The string containing words separated by spaces.\n\n  Returns:\n    A new string with the words in reversed order.\n  \"\"\"\n  words = text.split()\n  return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses the order of words in a string.\n\n  Args:\n    text: The input string with words separated by spaces.\n\n  Returns:\n    A new string with the words in reversed order.\n  \"\"\"\n  return \" \".join(text.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n  \"\"\"\n  Reverses words separated by spaces in a given string.\n\n  Args:\n      s: The string to reverse.\n\n  Returns:\n      The string with words reversed.\n  \"\"\"\n  words = s.split()\n  return \" \".join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses words separated by spaces in a given string.\n\n  Args:\n    text: The string to reverse.\n\n  Returns:\n    A string with the words reversed.\n  \"\"\"\n\n  words = text.split()\n  return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n  \"\"\"Reverses words separated by spaces in a given string.\n\n  Args:\n    s: The string to reverse.\n\n  Returns:\n    The string with the words reversed.\n  \"\"\"\n  words = s.split()\n  return \" \".join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n    \"\"\"\n    Reverses words in a string separated by spaces.\n\n    Args:\n      text: The string to reverse.\n\n    Returns:\n      The string with words reversed.\n    \"\"\"\n    words = text.split()\n    return \" \".join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n  \"\"\"Reverses the order of words in a string.\n\n  Args:\n      text: The string to reverse the words in.\n\n  Returns:\n      The string with the words in reverse order.\n  \"\"\"\n  words = text.split()\n  return \" \".join(reversed(words))", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/611": {"dps": 77.30061349693251, "dps_norm": 95.83333333333333, "pass@1": 90.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Finds the maximum value in the nth column of a matrix.\n\n  Args:\n      matrix: A list of lists representing the matrix.\n      n: The index of the column to search (0-indexed).\n\n  Returns:\n      The maximum value in the nth column.\n  \"\"\"\n  max_val = float('-inf')\n  for row in matrix:\n    if len(row) > n:\n      max_val = max(max_val, row[n])\n  return max_val", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Finds the maximum value in the n'th column of a matrix.\n\n    Args:\n      matrix: A list of lists representing the matrix.\n      n: The index of the column (0-based) to find the maximum in.\n\n    Returns:\n      The maximum value in the n'th column.\n    \"\"\"\n    max_val = float('-inf')  # Initialize with negative infinity\n    for row in matrix:\n      if n < len(row):  # Handle cases where column index is out of bounds\n        max_val = max(max_val, row[n])\n    return max_val\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  This function takes a matrix represented as a list of lists and returns the maximum value in the nth column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column (0-based).\n\n  Returns:\n    The maximum value in the nth column.\n  \"\"\"\n  return max([row[n] for row in matrix])\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"Given a matrix represented as a list of lists, returns the max of the n'th column.\"\"\"\n  return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists returns the max of the n'th column.\n\n    For example:\n    max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    \"\"\"\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, return the maximum value in the nth column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum value in.\n\n  Returns:\n    The maximum value in the nth column.\n  \"\"\"\n  max_value = float('-inf')  \n  for row in matrix:\n    if n < len(row):  # Check if column index is valid\n      max_value = max(max_value, row[n])\n  return max_value", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, return the max of the n'th column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum of.\n\n  Returns:\n    The maximum value in the n'th column.\n  \"\"\"\n  return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Returns the maximum value of the n'th column in a matrix represented as a list of lists.\n\n  Args:\n    matrix: A list of lists representing a matrix.\n    n: The index of the column to find the maximum value of.\n\n  Returns:\n    The maximum value in the n'th column.\n  \"\"\"\n\n  column_values = [row[n] for row in matrix]\n  return max(column_values)\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, returns the max of the n'th column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum value in.\n\n  Returns:\n    The maximum value in the n'th column.\n\n  Raises:\n    IndexError: If n is out of bounds for the matrix columns.\n  \"\"\"\n  if n >= len(matrix[0]):\n    raise IndexError(\"Column index out of bounds\")\n  max_value = matrix[0][n]\n  for row in matrix:\n    if row[n] > max_value:\n      max_value = row[n]\n  return max_value\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, returns the max of the n'th column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum of (0-indexed).\n\n  Returns:\n    The maximum value in the n'th column.\n  \"\"\"\n  max_val = float('-inf')  # Initialize with negative infinity\n\n  for row in matrix:\n    if n < len(row):  # Check if the column index is valid for the current row\n      max_val = max(max_val, row[n]) \n\n  return max_val", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix (represented as a list of lists) and a column index 'n',\n    and returns the maximum value in the specified column.\n\n    Args:\n        matrix: A list of lists representing the matrix.\n        n: The index (starting from 0) of the column to check.\n\n    Returns:\n        The maximum value in the nth column of the matrix.\n    \"\"\"\n    max_val = matrix[0][n]  # Initialize max_val with the first element of the column\n\n    for row in matrix:\n        if row[n] > max_val:\n            max_val = row[n]\n    return max_val\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]\nn = 2", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the max of the n'th column.\n    For example:\n    max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    \"\"\"\n    max_val = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_val:\n            max_val = row[n]\n    return max_val", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Returns the maximum value of the nth column in a matrix.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column (starting from 0).\n\n  Returns:\n    The maximum value in the nth column.\n  \"\"\"\n  max_val = float('-inf')\n  for row in matrix:\n    if len(row) > n:\n      max_val = max(max_val, row[n])\n  return max_val\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 4}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, returns the max of the n'th column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum value of.\n\n  Returns:\n    The maximum value in the n'th column of the matrix.\n  \"\"\"\n  return max([row[n] for row in matrix])\nmatrix = [[5, 6, 7], [1, 3, 5], [8, 9, 19]]", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"Given a matrix represented as a list of lists, return the max of the n'th column.\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum value of.\n  Returns:\n    The maximum value in the n'th column of the matrix.\n\n  For example:\n  max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n  \"\"\"\n  return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, return the max of the n'th column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column (0-indexed).\n\n  Returns:\n    The maximum value in the n'th column of the matrix.\n  \"\"\"\n  return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Given a matrix represented as a list of lists, returns the max of the n'th column.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum of (0-indexed).\n\n  Returns:\n    The maximum value in the n'th column of the matrix.\n  \"\"\"\n\n  max_value = matrix[0][n]\n  for row in matrix:\n    if row[n] > max_value:\n      max_value = row[n]\n  return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n  \"\"\"\n  Returns the max of the nth column in a matrix.\n\n  Args:\n    matrix: A list of lists representing the matrix.\n    n: The index of the column to find the maximum of.\n\n  Returns:\n    The maximum value in the nth column.\n  \"\"\"\n  return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Given a matrix represented as a list of lists, return the max of the nth column.\"\"\"\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists returns the max of the n'th column.\n    \n    For example:\n    max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    \"\"\"\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes in a list to the end while maintaining the order of other elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    A new list with all zeroes moved to the end.\n  \"\"\"\n\n  non_zeroes = [num for num in nums if num != 0]\n  return non_zeroes + [0] * (len(nums) - len(non_zeroes))", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes to the end of the given list.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      A list with all zeroes moved to the end while preserving the relative order of other elements.\n  \"\"\"\n  non_zeroes = [num for num in nums if num != 0]\n  zeroes = [0] * nums.count(0) \n  return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the relative order of non-zero elements.\n    Args:\n        nums: A list of integers.\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zeros = [num for num in nums if num != 0]\n    zeros = [0] * nums.count(0)\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n        nums (list): The input list of numbers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zero_elements = [num for num in nums if num != 0]\n    zeroes = [0] * nums.count(0)  \n    return non_zero_elements + zeroes\nnums = [1, 0, 2, 0, 3, 4]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while preserving the order of the non-zero elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zeroes = [num for num in nums if num != 0]\n    zeroes = [0] * nums.count(0) \n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the relative order of non-zero elements.\n\n    Args:\n    nums (list): The input list of numbers.\n\n    Returns:\n    list: The modified list with zeroes moved to the end.\n\n    Examples:\n    >>> move_zero([1,0,2,0,3,4])\n    [1, 2, 3, 4, 0, 0]\n    \"\"\"\n    non_zeros = []\n    zeros = []\n    for num in nums:\n        if num == 0:\n            zeros.append(num)\n        else:\n            non_zeros.append(num)\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes to the end of the given list while maintaining the relative order of other elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The list with all zeroes moved to the end.\n  \"\"\"\n  non_zero_elements = [num for num in nums if num != 0]\n  zero_count = nums.count(0)\n  return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes to the end of the given list while maintaining the relative order of non-zero elements.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      The list with all zeroes moved to the end.\n  \"\"\"\n  non_zeros = [num for num in nums if num != 0]\n  zeros = [0] * nums.count(0)\n  return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes in a list to the end while maintaining relative order of non-zero elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zeros = [num for num in nums if num != 0]\n    zeros = [num for num in nums if num == 0]\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"Moves all zeroes to the end of the given list while maintaining the relative order of the other elements.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      A new list with all zeroes moved to the end.\n  \"\"\"\n\n  non_zero_elements = []\n  zero_count = 0\n\n  for num in nums:\n    if num != 0:\n      non_zero_elements.append(num)\n    else:\n      zero_count += 1\n\n  return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes to the end of the given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    A new list with all zeroes moved to the end while maintaining the relative order of non-zero elements.\n\n  Example:\n  move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n  \"\"\"\n  non_zeroes = [num for num in nums if num != 0]\n  zeroes = [0] * nums.count(0)\n  return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the relative order of other elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_nums = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n    return non_zero_nums + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the relative order of other elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The list with all zeroes moved to the end.\n    \"\"\"\n    non_zeroes = [num for num in nums if num != 0]\n    return non_zeroes + [0] * (len(nums) - len(non_zeroes))\nnums = [1, 0, 2, 0, 3, 4]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while maintaining the order of\n    non-zero elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n\n    result = []\n    zero_count = 0\n    for num in nums:\n        if num != 0:\n            result.append(num)\n        else:\n            zero_count += 1\n\n    return result + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      A list with all zeroes moved to the end, preserving the order of other elements.\n    \"\"\"\n\n    non_zeroes = [num for num in nums if num != 0]\n    zeroes = [0] * nums.count(0)\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"Moves all zeroes to the end of the given list while preserving the order of other elements.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      The modified list with zeroes moved to the end.\n    \"\"\"\n    non_zero_elements = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      A new list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zeros = [num for num in nums if num != 0]\n    zeros = [0] * nums.count(0)\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list while maintaining the order of other elements.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The input list with all zeroes moved to the end.\n    \"\"\"\n\n    non_zeroes = [num for num in nums if num != 0]\n    zeroes = [0] * nums.count(0)\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes to the end of a list while maintaining the relative order of the\n  non-zero elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The list with all zeroes moved to the end.\n  \"\"\"\n  non_zeros = []\n  zeros = []\n  for num in nums:\n    if num == 0:\n      zeros.append(num)\n    else:\n      non_zeros.append(num)\n  return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n  \"\"\"\n  Moves all zeroes to the end of the given list while maintaining the relative order of other elements.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    A new list with all zeroes moved to the end.\n  \"\"\"\n\n  non_zero_elements = [num for num in nums if num != 0]\n  zero_count = nums.count(0)\n\n  return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 94.0, "profiled": [{"solution": "def pair_xor_Sum(nums, n):\n  \"\"\"\n  Calculates the sum of XOR of all pairs of numbers in the given list.\n\n  Args:\n    nums: A list of integers.\n    n: The length of the list.\n\n  Returns:\n    The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n  xor_sum = 0\n  for i in range(n):\n    for j in range(i + 1, n):\n      xor_sum += nums[i] ^ nums[j]\n  return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n  \"\"\"\n  Calculate the sum of XOR of all pairs of numbers in a given list.\n\n  Args:\n    arr: A list of integers.\n    n: The length of the list.\n\n  Returns:\n    The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n  xor_sum = 0\n\n  for i in range(n):\n    for j in range(i+1, n):\n      xor_sum += arr[i] ^ arr[j]\n  \n  return xor_sum\narr = [5, 9, 7, 6]\nn = len(arr)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n        arr: The list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum\narr = [5, 9, 7, 6]\nn = len(arr)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums: list, n: int) -> int:\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n        nums (list): The input list of integers.\n        n (int): The length of the list (optional, can be derived from the list).\n\n    Returns:\n        int: The sum of XOR of all pairs in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n  \"\"\"\n  Calculates the sum of XOR of all pairs of numbers in a list.\n\n  Args:\n    nums: A list of integers.\n    n: The length of the list (optional, can be inferred from nums).\n\n  Returns:\n    The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n  xor_sum = 0\n  for i in range(n):\n    for j in range(i + 1, n):\n      xor_sum += nums[i] ^ nums[j]\n  return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums: list[int], n: int):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n        nums: A list of integers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums: list[int], n: int) -> int:\n  \"\"\"\n  Calculates the sum of XOR values for all pairs of numbers in a given list.\n\n  Args:\n      nums: A list of integers.\n      n: The length of the list.\n\n  Returns:\n      The sum of XOR values for all pairs of numbers in the list.\n  \"\"\"\n  xor_sum = 0\n\n  for i in range(n):\n    for j in range(i + 1, n):\n      xor_sum += nums[i] ^ nums[j]\n\n  return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n  \"\"\"\n  Calculates the sum of XOR of all pairs of numbers in a list.\n\n  Args:\n      nums: A list of numbers.\n      n: The length of the list.\n\n  Returns:\n      The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n  sum_xor = 0\n  for i in range(n):\n    for j in range(i+1, n):\n      sum_xor += nums[i] ^ nums[j]\n  return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs in a given list.\n\n    Args:\n      arr: A list of integers.\n      n: The length of the list.\n\n    Returns:\n      The sum of XOR of all pairs in the list.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor\narr = [5, 9, 7, 6]\nn = len(arr)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in a given list.\n\n    Args:\n        nums (list): A list of integers.\n        n (int): The length of the list.\n\n    Returns:\n        int: The sum of XOR of all pairs.\n    \"\"\"\n\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j] \n    return total_xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in a given list.\n\n    Args:\n        arr: A list of integers.\n        n: The length of the list.\n\n    Returns:\n        The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j] \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n      nums: A list of numbers.\n      n: The length of the list.\n\n    Returns:\n      The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n\n    xor_sum = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += nums[i] ^ nums[j] \n\n    return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n  \"\"\"\n  This function calculates the sum of XOR of all pairs of numbers in a given list.\n  Args:\n      nums: A list of numbers.\n      n: The length of the list.\n\n  Returns:\n      The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n  xor_sum = 0\n  for i in range(n):\n    for j in range(i+1, n):\n      xor_sum += nums[i] ^ nums[j]\n  return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in a list.\n\n    Args:\n    nums: A list of integers.\n    n: The length of the list.\n\n    Returns:\n    The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n  \"\"\"\n  Calculates the sum of XOR of all pairs of numbers in a given list.\n\n  Args:\n    nums: A list of numbers.\n    n: The length of the list (not strictly necessary, but included for clarity).\n\n  Returns:\n    The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n\n  xor_sum = 0\n  for i in range(n):\n    for j in range(i + 1, n):\n      xor_sum += nums[i] ^ nums[j]\n  return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums: list, n: int) -> int:\n    \"\"\"Calculates the sum of XOR values of all pairs in a list.\n\n    Args:\n        nums: A list of numbers.\n        n: The length of the list.\n\n    Returns:\n        The sum of the XOR of all pairs of numbers in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n  \"\"\"\n  This function calculates the sum of xor of all pairs of numbers in a given list.\n  \n  Args:\n    arr: A list of integers.\n    n: The length of the list.\n  \n  Returns:\n    An integer representing the sum of xor of all pairs of numbers in the list.\n  \"\"\"\n\n  total_xor_sum = 0\n\n  for i in range(n):\n    for j in range(i + 1, n):\n      total_xor_sum += arr[i] ^ arr[j]\n  \n  return total_xor_sum\narr = [5, 9, 7, 6]\nn = len(arr)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n  \"\"\"Calculates the sum of XOR of all possible pairs in a list.\n\n  Args:\n    nums: A list of integers.\n    n: The length of the list.\n\n  Returns:\n    The sum of XOR of all pairs in the list.\n  \"\"\"\n  sum = 0\n  for i in range(n):\n    for j in range(i+1, n):\n      sum += (nums[i] ^ nums[j])\n  return sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums: list, n: int):\n    \"\"\"\n    Finds the sum of xor of all pairs of numbers in the given list.\n    \"\"\"\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n  \"\"\"Calculates the sum of XOR of all pairs of numbers in a list.\n\n  Args:\n    nums: A list of integers.\n    n: The length of the list.\n\n  Returns:\n    The sum of XOR of all pairs of numbers in the list.\n  \"\"\"\n  total_xor_sum = 0\n  for i in range(n):\n    for j in range(i + 1, n):\n      total_xor_sum += nums[i] ^ nums[j]\n  return total_xor_sum\nnums = [5, 9, 7, 6]\nn = len(nums)", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 59.89361702127658, "dps_norm": 68.0, "pass@1": 86.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"\n  Reverses an array upto a given position k.\n\n  Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed.\n\n  Returns:\n      A new array with the elements reversed up to position k.\n  \"\"\"\n  return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed.\n\n    Returns:\n      A new array with the elements reversed up to position k.\n    \"\"\"\n\n    if k <= 0 or k > len(arr):\n        return arr  # Handle invalid input\n\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr) or k < 0:\n      return \"Invalid input: k should be within the bounds of the array\"\n\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"Reverses an array upto a given position.\n\n  Args:\n    arr: The input array.\n    k: The position upto which the array should be reversed (inclusive).\n\n  Returns:\n    The array with elements reversed upto position k.\n  \"\"\"\n  if k <= 0 or k > len(arr):\n    return arr\n  return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed (inclusive).\n\n    Returns:\n        The array with the elements up to position k reversed.\n    \"\"\"\n    if k > len(arr) or k < 0:\n      return arr  # Invalid k value\n    \n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array upto a given position.\n\n    Args:\n      arr: A list of numbers.\n      k: An integer representing the position up to which the array should be reversed (inclusive).\n\n    Returns:\n      A new list with the array reversed up to the given position.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array upto a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n      return arr  \n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"Reverses an array up to a given position.\n\n  Args:\n    arr: The array to be reversed.\n    k: The position up to which the array should be reversed.\n\n  Returns:\n    A new array with the elements up to position k reversed.\n  \"\"\"\n  return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"\n  This function reverses an array up to a given position 'k'.\n\n  Args:\n    arr: The input array.\n    k: The position up to which the array should be reversed.\n\n  Returns:\n    A new array with the elements reversed up to position 'k'.\n  \"\"\"\n  if k > len(arr) or k < 0:\n    return \"Invalid value of k\"\n\n  new_arr = arr[:k][::-1] + arr[k:]\n  return new_arr", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"Reverses an array up to a given position.\n\n  Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed.\n\n  Returns:\n      The array with elements reversed up to position k.\n  \"\"\"\n  if k > len(arr) or k < 0:\n    return arr\n  \n  return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses the elements of an array up to a given position.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the elements reversed up to position k.\n    \"\"\"\n    if k > len(arr) or k < 0:\n        return arr\n\n    return arr[:k][::-1] + arr[k:]\narr = [1, 2, 3, 4, 5, 6]\nk = 4", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr) or k < 0:\n        return arr  \n\n    left = 0\n    right = k - 1\n\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"Reverses an array upto a given position k.\"\"\"\n\n  if k > len(arr) or k < 0:\n    return arr  \n\n  left = 0\n  right = k-1\n  while left < right:\n    arr[left], arr[right] = arr[right], arr[left]\n    left += 1\n    right -= 1\n  return arr\narr = [1, 2, 3, 4, 5, 6]\nk = 4", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"\n  Reverses an array up to a given position.\n\n  Args:\n    arr: The input array.\n    k: The position up to which the array should be reversed (inclusive).\n\n  Returns:\n    The array with the first k elements reversed.\n  \"\"\"\n  return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr) or k < 0:\n      return \"Invalid k value\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"\n  Reverses an array up to a given position k.\n\n  Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed.\n\n  Returns:\n      A new array with the elements reversed up to position k.\n  \"\"\"\n  reversed_part = arr[:k][::-1]  # Reverse the subarray up to k\n  return reversed_part + arr[k:]  # Concatenate with the rest of the array", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n\n    Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed.\n\n    Returns:\n      The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr) or k < 0:\n      return arr\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"Reverses an array up to a given position k.\n\n    Args:\n        arr: The input array.\n        k: The position up to which the array should be reversed.\n\n    Returns:\n        The array with the first k elements reversed.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n  \"\"\"\n  Reverses the elements of an array up to a given position k.\n\n  Args:\n      arr: The input array.\n      k: The position up to which the array should be reversed.\n\n  Returns:\n      A new array with the elements reversed up to position k.\n  \"\"\"\n  return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Args:\n        arr (list): The input array.\n        k (int): The position up to which the array should be reversed (inclusive).\n\n    Returns:\n        list: The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    left, right = 0, k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n\n    return arr", "matching_cluster_idx": 6}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Appends a dictionary to the end of a tuple.\n\n    Args:\n        input_tuple (tuple): The initial tuple.\n        input_dict (dict): The dictionary to be added.\n\n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to be added.\n\n    Returns:\n        A new tuple with the dictionary appended to the original tuple.\n    \"\"\"\n    return input_tuple + (input_dict,)  # Note the comma after input_dict to make it a single-element tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"Adds a dictionary to the end of a tuple.\n\n  Args:\n    input_tuple: The tuple to which the dictionary will be added.\n    input_dict: The dictionary to be added to the tuple.\n\n  Returns:\n    A new tuple with the dictionary added to the end.\n  \"\"\"\n\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"\n  Adds a dictionary to a tuple.\n\n  Args:\n    input_tuple: The tuple to which the dictionary will be added.\n    input_dict: The dictionary to be added.\n\n  Returns:\n    A new tuple with the dictionary appended.\n  \"\"\"\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to be added.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"\n  This function adds a dictionary to the end of a tuple.\n  \n  Args:\n      input_tuple: The tuple to which the dictionary will be added.\n      input_dict: The dictionary to be added to the tuple.\n\n  Returns:\n      A new tuple with the dictionary appended.\n  \"\"\"\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n  \"\"\"\n  Adds a dictionary to a tuple.\n\n  Args:\n    t: The input tuple.\n    d: The dictionary to be added.\n\n  Returns:\n    A new tuple with the dictionary appended to the end.\n  \"\"\"\n  return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n  \"\"\"Adds a dictionary to a tuple.\n\n  Args:\n    tup: The tuple to add the dictionary to.\n    dct: The dictionary to add.\n\n  Returns:\n    A new tuple with the dictionary appended.\n  \"\"\"\n\n  return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    Args:\n    input_tuple: The original tuple.\n    input_dict: The dictionary to be added.\n\n    Returns:\n    A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"\n  This function adds a dictionary to a given tuple.\n\n  Args:\n    input_tuple: The initial tuple.\n    input_dict: The dictionary to be added.\n\n  Returns:\n    A new tuple with the dictionary appended to the end.\n  \"\"\"\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to a tuple.\n\n    Args:\n      input_tuple: The initial tuple.\n      input_dict: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)  # Note: The comma is important to create a single-element tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    Args:\n        t: The input tuple.\n        d: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"\n  Adds a dictionary to the end of a tuple.\n\n  Args:\n    input_tuple: The original tuple.\n    input_dict: The dictionary to be added.\n\n  Returns:\n    A new tuple with the dictionary appended to the end.\n  \"\"\"\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"\n  Add a dictionary to the end of a tuple.\n\n  Args:\n    input_tuple: The tuple to which the dictionary will be appended.\n    input_dict: The dictionary to be appended to the tuple.\n\n  Returns:\n    A new tuple with the dictionary appended.\n  \"\"\"\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        tup: An existing tuple.\n        dict_to_add: A dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    Args:\n        input_tuple: The input tuple.\n        input_dict: The dictionary to add.\n\n    Returns:\n        A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n      input_tuple: The original tuple.\n      input_dict: The dictionary to add.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    Args:\n      input_tuple: The tuple to add the dictionary to.\n      input_dict: The dictionary to be added.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"Adds a dictionary to a tuple.\n\n    Args:\n      input_tuple: The input tuple.\n      input_dict: The dictionary to be added.\n\n    Returns:\n      A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n  \"\"\"\n  Adds a dictionary to the end of a tuple.\n\n  Args:\n    input_tuple: The original tuple.\n    input_dict: The dictionary to add.\n\n  Returns:\n    A new tuple with the dictionary appended to the end.\n  \"\"\"\n  return input_tuple + (input_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 88.96174863387978, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings found between quotation marks.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"Extracts values between double quotation marks in a string.\n  Args:\n    text: The string to extract values from.\n\n  Returns:\n    A list of strings containing the extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  Extracts values between quotation marks \" \" of the given string.\n  Args:\n      text: The string to extract values from.\n  Returns:\n      A list of extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  Extracts values between quotation marks \" \" from a given string.\n\n  Args:\n      text: The string to extract values from.\n\n  Returns:\n      A list of extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  This function extracts values between quotation marks \" \" of the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings found between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  Extracts values between quotation marks \" \" of the given string.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  This function extracts values between quotation marks \" \" of the given string.\n  Args:\n    text: The input string.\n  Returns:\n    A list of strings containing the values extracted between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        A list of strings extracted between quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  Extracts values between quotation marks \" \" from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of extracted values.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  This function extracts values between quotation marks \" \" of the given string.\n\n  Args:\n      text: A string containing values within quotation marks.\n\n  Returns:\n      A list of strings representing the values extracted from the quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"Extracts values between quotation marks \" \" of the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings found between quotation marks.\n  \"\"\"\n\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"\n  This function extracts values between quotation marks \" \" of the given string.\n\n  Args:\n    text: A string containing values between quotation marks.\n\n  Returns:\n    A list of strings, representing the values extracted from the quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"Extracts values between quotation marks \" \" from a given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings extracted between quotation marks.\n  \"\"\"\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of strings extracted from between quotation marks.\n    \"\"\"\n\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n  \"\"\"Extracts values between quotation marks \" \" from the given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    A list of strings found between quotation marks.\n  \"\"\"\n\n  return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    For example:\n    extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      A list of strings found between quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(text):\n  \"\"\"\n  This function replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n      text: A string containing spaces, commas, or dots.\n\n  Returns:\n      The input string with spaces, commas, and dots replaced with colons.\n  \"\"\"\n  return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"\n  This function replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with spaces, commas, and dots replaced by colons.\n  \"\"\"\n\n  for char in [\" \", \",\", \".\"]:\n    text = text.replace(char, \":\")\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"\n  Replaces all occurrences of spaces, commas, or dots with a colon.\n  \"\"\"\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces spaces, commas, and dots with colons in a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with spaces, commas, and dots replaced with colons.\n  \"\"\"\n\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n    Args:\n        text: The string to be processed.\n    Returns:\n        The string with all spaces, commas, and dots replaced with colons.\n    \"\"\"\n    return text.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces all occurrences of spaces, commas, or dots with a colon.\"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with spaces, commas, and dots replaced by colons.\n  \"\"\"\n  return text.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces spaces, commas, and dots with colons.\"\"\"\n    for char in [' ', ',', '.']:\n      text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces spaces, commas, and dots with a colon in a string.\"\"\"\n  return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"\n  Replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      The string with spaces, commas, and dots replaced with colons.\n  \"\"\"\n\n  return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces spaces, commas, and dots in a string with a colon.\"\"\"\n  return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces all occurrences of spaces, commas, or dots with a colon.\"\"\"\n  return text.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"\n  Replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n    text: The string to be processed.\n\n  Returns:\n    The string with replacements made.\n  \"\"\"\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces spaces, commas, and dots with a colon.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with replacements made.\n  \"\"\"\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces spaces, commas, and dots with colons in a given string.\"\"\"\n  return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"\n  This function replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n    text: The string to be processed.\n\n  Returns:\n    The string with spaces, commas, and dots replaced with colons.\n  \"\"\"\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces all spaces, commas, or dots with a colon.\"\"\"\n  return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces spaces, commas, and dots in a string with a colon.\n\n  Args:\n    text: The string to modify.\n\n  Returns:\n    The modified string with colons replacing the special characters.\n  \"\"\"\n\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"\n  This function replaces spaces, commas, and dots in a string with colons.\n  Args:\n    text: The input string.\n  Returns:\n    The modified string with spaces, commas, and dots replaced by colons.\n  \"\"\"\n  \n  text = text.replace(\" \", \":\")\n  text = text.replace(\",\", \":\")\n  text = text.replace(\".\", \":\")\n  return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n  \"\"\"Replaces all occurrences of spaces, commas, or dots with a colon.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with spaces, commas, and dots replaced by colons.\n  \"\"\"\n  for char in [' ', ',', '.']:\n    text = text.replace(char, ':')\n  return text", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 46.654545454545456, "dps_norm": 56.111111111111114, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(data):\n  \"\"\"\n  Converts a given tuple to a key-value dictionary using adjacent elements.\n\n  Args:\n    data: A tuple with an even number of elements.\n\n  Returns:\n    A dictionary where the first element of each pair is the key and the second is the value.\n  \"\"\"\n  if len(data) % 2 != 0:\n    raise ValueError(\"Input tuple must have an even number of elements.\")\n  return dict(zip(data[::2], data[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(data):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as keys and values.\n\n  Args:\n    data: The input tuple.\n\n  Returns:\n    A dictionary created from the tuple, using adjacent elements as key-value pairs.\n  \"\"\"\n  result = {}\n  for i in range(0, len(data), 2):\n    if i + 1 < len(data):\n      result[data[i]] = data[i + 1]\n  return result", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\"\"\"\n\n  if len(input_tuple) % 2 != 0:\n    raise ValueError(\"Input tuple must have an even number of elements.\")\n\n  output_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    output_dict[input_tuple[i]] = input_tuple[i + 1]\n  return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"\n  Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n  Args:\n      input_tuple: A tuple containing pairs of values.\n\n  Returns:\n      A dictionary created from the adjacent elements of the tuple.\n  \"\"\"\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    if i + 1 < len(input_tuple):\n      result_dict[input_tuple[i]] = input_tuple[i + 1]\n  return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"\n  Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n  Args:\n    input_tuple: The input tuple.\n\n  Returns:\n    A dictionary created from adjacent elements of the tuple.\n  \"\"\"\n\n  output_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    if i + 1 < len(input_tuple):  # Check if there's a next element for the value\n      output_dict[input_tuple[i]] = input_tuple[i + 1]\n  return output_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as keys and values.\n\n  Args:\n    input_tuple: The input tuple.\n\n  Returns:\n    A dictionary created from adjacent elements of the tuple.\n  \"\"\"\n  output_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    if i + 1 < len(input_tuple):\n      output_dict[input_tuple[i]] = input_tuple[i + 1]\n  return output_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tup: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where every other element of the tuple becomes a key\n        and the next element becomes its corresponding value.\n    \"\"\"\n    result = {}\n    for i in range(0, len(tup), 2):\n      if i + 1 < len(tup):\n        result[tup[i]] = tup[i + 1]\n    return result", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"\n  Converts a given tuple to a dictionary using adjacent elements as key-value pairs.\n\n  Args:\n    input_tuple: The tuple to be converted.\n\n  Returns:\n    A dictionary where adjacent elements from the tuple are used as key-value pairs.\n  \"\"\"\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    if i + 1 < len(input_tuple):\n      result_dict[input_tuple[i]] = input_tuple[i + 1]\n  return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary created from adjacent elements of the tuple.\n    \"\"\"\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a key-value dictionary using adjacent elements.\n\n  Args:\n    input_tuple: A tuple with an even number of elements.\n\n  Returns:\n    A dictionary where the first element of each pair is a key and the second\n    is its corresponding value.\n  \"\"\"\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    result_dict[input_tuple[i]] = input_tuple[i + 1]\n  return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(data: tuple) -> dict:\n  \"\"\"\n  Convert the given tuple to a key-value dictionary using adjacent elements.\n\n  Args:\n    data: A tuple with an even number of elements.\n\n  Returns:\n    A dictionary where keys are the odd-indexed elements and values are the even-indexed elements.\n  \"\"\"\n  return {data[i]: data[i+1] for i in range(0, len(data), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as keys and values.\n\n  Args:\n      input_tuple: The input tuple.\n\n  Returns:\n      A dictionary created from the tuple's adjacent elements.\n  \"\"\"\n\n  if len(input_tuple) % 2 != 0:\n    raise ValueError(\"Input tuple must have an even number of elements\")\n\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    result_dict[input_tuple[i]] = input_tuple[i + 1]\n  return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n  Args:\n    input_tuple: The input tuple.\n\n  Returns:\n    A dictionary formed by using adjacent elements of the tuple as key-value pairs.\n  \"\"\"\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    if i + 1 < len(input_tuple):\n      result_dict[input_tuple[i]] = input_tuple[i + 1]\n  return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: A tuple with an even number of elements.\n\n    Returns:\n        A dictionary where the keys are the odd-indexed elements and the values are the even-indexed elements.\n\n    Raises:\n        ValueError: if the input tuple has an odd number of elements.\n    \"\"\"\n\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n  Args:\n      input_tuple: A tuple with an even number of elements.\n\n  Returns:\n      A dictionary created from adjacent pairs in the input tuple.\n  \"\"\"\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    result_dict[input_tuple[i]] = input_tuple[i+1]\n  return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n  Args:\n    input_tuple: A tuple with an even number of elements.\n\n  Returns:\n    A dictionary where keys are every other element starting at index 0, and\n    values are the subsequent elements.\n\n  Raises:\n    ValueError: If the input tuple has an odd number of elements.\n  \"\"\"\n\n  if len(input_tuple) % 2 != 0:\n    raise ValueError(\"Input tuple must have an even number of elements.\")\n\n  output_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    output_dict[input_tuple[i]] = input_tuple[i + 1]\n\n  return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: The input tuple.\n\n    Returns:\n        A dictionary where keys are the first element of each pair and values\n        are the second element of each pair.\n\n    Example:\n        tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n        input_tuple: A tuple containing key-value pairs.\n\n    Returns:\n        A dictionary created from adjacent elements of the input tuple.\n    \"\"\"\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n      if i + 1 < len(input_tuple):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"Converts a given tuple to a key-value dictionary using adjacent elements.\n\n  Args:\n    input_tuple: A tuple containing key-value pairs represented as adjacent elements.\n\n  Returns:\n    A dictionary created from the tuple.\n  \"\"\"\n  output_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    if i + 1 < len(input_tuple):\n      output_dict[input_tuple[i]] = input_tuple[i + 1]\n  return output_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n  \"\"\"\n  Converts the given tuple to a key-value dictionary using adjacent elements.\n\n  Args:\n      input_tuple: A tuple with an even number of elements.\n\n  Returns:\n      A dictionary where adjacent elements from the tuple form key-value pairs.\n  \"\"\"\n\n  if len(input_tuple) % 2 != 0:\n    raise ValueError(\"Input tuple must have an even number of elements\")\n\n  result_dict = {}\n  for i in range(0, len(input_tuple), 2):\n    result_dict[input_tuple[i]] = input_tuple[i+1]\n  return result_dict", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 94.0068493150685, "dps_norm": 95.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n  \"\"\"Checks if the given tuple has any None value.\n\n  Args:\n    input_tuple: The tuple to check.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if a tuple contains any None values.\n\n  Args:\n    input_tuple: The tuple to check.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None values.\n    \n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains a None value, False otherwise.\n    \"\"\"\n\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    This function checks if the given tuple has any None value or not.\n\n    Args:\n    input_tuple: The tuple to be checked.\n\n    Returns:\n    True if the tuple contains a None value, False otherwise.\n    \"\"\"\n    for element in input_tuple:\n        if element is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple has any None value or not.\n\n    Args:\n      input_tuple: The tuple to check.\n\n    Returns:\n      True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if a tuple contains any None values.\n\n  Args:\n      input_tuple: The tuple to be checked.\n\n  Returns:\n      True if the tuple contains None, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if a tuple contains any None values.\n\n  Args:\n    input_tuple: The tuple to check.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  for item in input_tuple:\n    if item is None:\n      return True\n  return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple has any None values.\n\n    Args:\n        input_tuple: The tuple to be checked.\n\n    Returns:\n        True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if a tuple contains any None values.\n\n  Args:\n    input_tuple: A tuple of any type.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value.\n\n  Args:\n    input_tuple: The tuple to check.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple has any None values.\n\n    Args:\n    input_tuple: The tuple to check.\n\n    Returns:\n    True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"Checks if a given tuple has any None values.\n\n  Args:\n    input_tuple: The tuple to be checked.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(data: tuple) -> bool:\n    \"\"\"\n    Write a function to check if the given tuple has any none value or not.\n    assert check_none((10, 4, 5, 6, None)) == True\n    \"\"\"\n\n    for item in data:\n      if item is None:\n        return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value.\n\n  Args:\n      input_tuple: A tuple to check for None values.\n\n  Returns:\n      True if the tuple contains at least one None value, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value.\n\n  Args:\n    input_tuple: A tuple to check for None values.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value or not.\n\n  Args:\n    input_tuple: A tuple to check for None values.\n\n  Returns:\n    True if the tuple contains a None value, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value or not.\n\n  Args:\n    input_tuple: A tuple to check for None values.\n\n  Returns:\n    True if the tuple contains at least one None value, False otherwise.\n  \"\"\"\n  return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value.\n\n  Args:\n    input_tuple: A tuple to check for None values.\n\n  Returns:\n    True if the tuple contains None, False otherwise.\n  \"\"\"\n  for element in input_tuple:\n    if element is None:\n      return True\n  return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if a tuple has any None values.\n\n    Args:\n        input_tuple: The tuple to check.\n\n    Returns:\n        True if the tuple has at least one None value, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n  \"\"\"\n  Checks if the given tuple has any None value or not.\n\n  Args:\n      input_tuple: The tuple to be checked.\n\n  Returns:\n      True if the tuple contains a None value, False otherwise.\n  \"\"\"\n  for item in input_tuple:\n    if item is None:\n      return True\n  return False", "matching_cluster_idx": 4}]}, "Mbpp/750": {"dps": 53.57142857142857, "dps_norm": 53.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(list1, tuple1):\n  \"\"\"Appends the elements of a tuple to a list.\n\n  Args:\n      list1: The input list.\n      tuple1: The input tuple.\n\n  Returns:\n      A new list with the tuple elements appended.\n  \"\"\"\n  new_list = list1.copy()  \n  new_list.extend(tuple1)\n  return new_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(list_a, tuple_a):\n  \"\"\"\n  Write a function to add the given tuple to the given list.\n\n  Args:\n    list_a: A list.\n    tuple_a: A tuple.\n\n  Returns:\n    A new list with elements from list_a and tuple_a.\n  \"\"\"\n  return list_a + list(tuple_a)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  This function takes a list and a tuple as input and adds the elements of\n  the tuple to the end of the list.\n\n  Args:\n      list1: The list to add the tuple to.\n      tuple1: The tuple containing elements to be added to the list.\n\n  Returns:\n      The updated list with the tuple's elements appended.\n  \"\"\"\n  for item in tuple1:\n    list1.append(item)\n  return list1", "matching_cluster_idx": 0}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Args:\n        list1: The list to add the tuple to.\n        tuple1: The tuple to add to the list.\n\n    Returns:\n        The updated list with the tuple elements appended.\n    \"\"\"\n\n    list1.extend(tuple1) \n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  Write a function to add the given tuple to the given list.\n  \"\"\"\n  return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"Adds the given tuple to the given list.\n  For example:\n  add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n  \"\"\"\n  return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  This function adds the elements of a given tuple to the end of a given list.\n\n  Args:\n    list1: The list to add elements to.\n    tuple1: The tuple whose elements will be added.\n\n  Returns:\n    A new list with the tuple's elements appended.\n  \"\"\"\n  new_list = list1.copy() # Create a copy to avoid modifying the original list\n  new_list.extend(tuple1)\n  return new_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(list1: list, tuple1: tuple) -> list:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n  \"\"\"\n  This function adds the elements of a tuple to the end of a list.\n\n  Args:\n      lst: A list to add the tuple elements to.\n      tpl: The tuple whose elements will be added to the list.\n\n  Returns:\n      A new list with the elements of the tuple appended to the original list.\n  \"\"\"\n  new_list = lst + list(tpl)\n  return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  This function adds the elements of a given tuple to a given list.\n  \n  Args:\n    list1: The list to which the tuple will be added.\n    tuple1: The tuple containing elements to be added.\n  \n  Returns:\n    A new list with the elements of the tuple appended.\n  \"\"\"\n  return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n  \"\"\"\n  Write a function to add the given tuple to the given list.\n  assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n  \"\"\"\n  return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"\n    Adds the elements of a tuple to a list.\n\n    Args:\n      list1: The list to which the tuple's elements will be added.\n      tuple1: The tuple whose elements will be added to the list.\n\n    Returns:\n      A new list with the elements of the tuple appended to the original list.\n    \"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  Write a function to add the given tuple to the given list.\n  assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n  \"\"\"\n  return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"Adds the given tuple to the given list.\n\n    Args:\n        list1: A list of elements.\n        tuple1: A tuple of elements.\n\n    Returns:\n        A new list with the elements of the tuple added to the end of the list.\n    \"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(input_list, input_tuple):\n    \"\"\"Adds a tuple to the end of a list.\"\"\"\n    return input_list + list(input_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  Adds the elements of a tuple to the end of a list.\n\n  Args:\n    list1: The list to add the tuple to.\n    tuple1: The tuple to be added.\n\n  Returns:\n    A new list with the elements of the tuple appended to the end.\n  \"\"\"\n  return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"Add the given tuple to the given list.\"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_a: list, tuple_a: tuple) -> list:\n    \"\"\"\n    Write a function to add the given tuple to the given list.\n\n    assert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n    \"\"\"\n    return list_a + list(tuple_a)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n  \"\"\"\n  This function adds the elements of a tuple to the end of a list.\n\n  Args:\n    list1: A list.\n    tuple1: A tuple.\n\n  Returns:\n    A new list with the elements of the tuple appended to the end of the list.\n  \"\"\"\n\n  new_list = list1.copy()\n  new_list.extend(tuple1)\n  return new_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tup):\n  \"\"\"Adds the given tuple to the given list.\n\n  Args:\n    lst: The list to append to.\n    tup: The tuple to append.\n\n  Returns:\n    A new list with the tuple's elements added to the end.\n  \"\"\"\n  return lst + list(tup)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(list_of_tuples, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples, where the second element of each tuple is used for comparison.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple has the format (name, value).\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k tuples with the smallest values.\n    \"\"\"\n    return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples, based on the second element of each tuple.\n\n  Args:\n    list_of_tuples: A list of tuples, where each tuple has the form (name, value).\n    k: The number of minimum records to return.\n\n  Returns:\n    A list of the k tuples with the smallest values, sorted in ascending order of values.\n  \"\"\"\n  return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_tuples, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples, based on the second element of each tuple (assumed to be an integer).\n\n  Args:\n      list_tuples: A list of tuples, where each tuple contains a name and a numerical value.\n      k: The number of minimum records to return.\n\n  Returns:\n      A list of the k tuples with the minimum values, sorted in ascending order by the second element.\n  \"\"\"\n  return sorted(list_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples based on the second element (integer value).\n\n  Args:\n    tuples_list: A list of tuples, where each tuple has the format (name, value).\n    k: The number of minimum records to return.\n\n  Returns:\n    A list containing the k minimum records as tuples.\n  \"\"\"\n  return sorted(tuples_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(data, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples, based on the second element (assumed to be a numeric value)\n\n    Args:\n        data: A list of tuples, where each tuple represents a record.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list containing the k tuples with the minimum second element values.\n    \"\"\"\n    return sorted(data, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples.\n\n  Args:\n    list_of_tuples: A list of tuples where the second element of each tuple is a numerical value.\n    k: The number of minimum records to return.\n\n  Returns:\n    A list of tuples containing the k minimum records.\n  \"\"\"\n  return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples, sorted by the second element (integer).\n\n    Args:\n    list_of_tuples: A list of tuples, where each tuple contains a string and an integer.\n    k: The number of minimum records to return.\n\n    Returns:\n    A list of k tuples with the minimum integer values, sorted by ascending order of the integers.\n    \"\"\"\n\n    return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples based on the second element (integer value).\n\n  Args:\n    tuple_list: A list of tuples, where each tuple has the format (name, value).\n    k: The number of minimum records to return.\n\n  Returns:\n    A list containing the k tuples with the smallest values.\n  \"\"\"\n  return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples based on the second element (integer) of each tuple.\n\n  Args:\n    tuple_list: A list of tuples, where each tuple has the format (string, integer).\n    k: The number of minimum records to return.\n\n  Returns:\n    A list of the k tuples with the smallest integer values.\n  \"\"\"\n  return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples, ordered by the second element of each tuple.\n\n    Args:\n        list_of_tuples: A list of tuples, where each tuple contains a name and a number.\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k tuples with the smallest second elements.\n    \"\"\"\n    return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(data, k):\n  \"\"\"Finds the k records with the smallest second element from a list of tuples.\n\n  Args:\n    data: A list of tuples, where each tuple has the form (name, value).\n    k: The number of records to return.\n\n  Returns:\n    A list of k tuples with the smallest values, sorted by the second element.\n  \"\"\"\n  return sorted(data, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples.\n\n  Args:\n    tuples_list: A list of tuples, where the second element of each tuple is a number.\n    k: The number of minimum records to return.\n\n  Returns:\n    A new list containing the k tuples with the smallest second elements.\n  \"\"\"\n  return sorted(tuples_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(input_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples, where the second element\n  of each tuple represents a numerical value.\n\n  Args:\n    input_list: A list of tuples, where each tuple is in the form (name, value).\n    k: The number of minimum records to return.\n\n  Returns:\n    A list containing the k tuples with the minimum values.\n  \"\"\"\n  return sorted(input_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n  \"\"\"\n  Finds the k minimum records from a list of tuples, sorted by the second element of each tuple.\n\n  Args:\n    tuple_list: A list of tuples, where each tuple has the format (name, value).\n    k: The number of minimum records to return.\n\n  Returns:\n    A list containing the k tuples with the minimum values, sorted by the second element.\n  \"\"\"\n  return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element (integer value).\n\n    Args:\n        tuple_list: A list of tuples, where each tuple has the format (name, value).\n        k: The number of minimum records to return.\n\n    Returns:\n        A list of the k tuples with the minimum values, sorted in ascending order based on the second element.\n    \"\"\"\n    return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples.\n\n  Args:\n      tuples_list: A list of tuples where each tuple contains a name and a number.\n      k: The number of minimum records to return.\n\n  Returns:\n      A list containing the k tuples with the smallest numbers.\n  \"\"\"\n  return sorted(tuples_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element (integer value) of each tuple.\n\n    Args:\n      list_of_tuples: A list of tuples, where each tuple contains a string and an integer.\n      k: The number of minimum records to return.\n\n    Returns:\n      A list containing the k minimum records as tuples.\n    \"\"\"\n    return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n  \"\"\"\n  This function takes a list of tuples and an integer k, and returns a list of the k tuples with the smallest second elements.\n\n  Args:\n    list_of_tuples: A list of tuples, where each tuple has two elements: a string and an integer.\n    k: The number of tuples to return.\n\n  Returns:\n    A list of the k tuples with the smallest second elements.\n  \"\"\"\n\n  return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples based on the second element (integer).\n\n  Args:\n    tuple_list: A list of tuples, where each tuple contains a string and an integer.\n    k: The number of minimum records to return.\n\n  Returns:\n    A list of the k tuples with the smallest integer values.\n  \"\"\"\n  return sorted(tuple_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(list_of_tuples, k):\n  \"\"\"\n  Finds the minimum k records from a list of tuples, sorted by the second element of each tuple.\n\n  Args:\n    list_of_tuples: A list of tuples, where each tuple contains a string and an integer.\n    k: The number of minimum records to return.\n\n  Returns:\n    A list containing the k tuples with the minimum second elements.\n  \"\"\"\n  return sorted(list_of_tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 89.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists that appear under the same index in all lists.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list containing the common elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list of common elements from l1, l2, and l3.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists appearing at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list containing the common elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n      if l1[i] == l2[i] == l3[i]:\n        common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists.\n\n  An element is considered common if it appears in all three lists under the same index.\n  \n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list of common elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists at the same index.\n\n    Args:\n      l1: The first list.\n      l2: The second list.\n      l3: The third list.\n\n    Returns:\n      A list containing the common elements.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n      if l1[i] == l2[i] == l3[i]:\n        common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  This function finds elements that appear in the same index across three lists.\n\n  Args:\n      l1: The first list.\n      l2: The second list.\n      l3: The third list.\n\n  Returns:\n      A list containing the common elements.\n  \"\"\"\n\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds elements common to three lists at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list containing the elements that appear at the same index in all three input lists.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that appear in the same index in all three lists.\n\n    Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n    Returns:\n    A list of common elements.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  This function finds common elements from three lists. \n  The function returns a list of these elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds elements common to three lists at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list of elements that appear at the same index in all three input lists.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists at the same index.\n\n    Args:\n      l1: The first list.\n      l2: The second list.\n      l3: The third list.\n\n    Returns:\n      A list containing the common elements.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n      if l1[i] == l2[i] == l3[i]:\n        common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index in all lists.\n\n    Args:\n      l1: The first list.\n      l2: The second list.\n      l3: The third list.\n\n    Returns:\n      A list containing the common elements.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i]) \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n    assert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 7]\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n      if l1[i] == l2[i] == l3[i]:\n        common_elements.append(l1[i])\n    return common_elements\nl1 = [1, 1, 3, 4, 5, 6, 7]\nl2 = [0, 1, 2, 3, 4, 5, 7]\nl3 = [0, 1, 2, 3, 4, 5, 7]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements common to three lists at the same index.\n\n    Args:\n      l1: The first list.\n      l2: The second list.\n      l3: The third list.\n\n    Returns:\n      A list of elements common to all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n          common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists based on same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list of common elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list containing the common elements.\n  \"\"\"\n\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list containing the common elements.\n  \"\"\"\n  common = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common.append(l1[i])\n  return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds elements that appear at the same index in all three lists.\n\n  Args:\n    l1, l2, l3: Three lists.\n\n  Returns:\n    A list of common elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n  \"\"\"\n  Finds common elements from three lists that appear at the same index.\n\n  Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n\n  Returns:\n    A list of common elements.\n  \"\"\"\n  common_elements = []\n  for i in range(min(len(l1), len(l2), len(l3))):\n    if l1[i] == l2[i] == l3[i]:\n      common_elements.append(l1[i])\n  return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 64.86725663716814, "dps_norm": 81.66666666666667, "pass@1": 54.0, "profiled": [{"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list.\n      Returns None if the list has less than two distinct elements.\n    \"\"\"\n    if len(set(numbers)) < 2:\n      return None \n    \n    smallest = min(numbers)\n    second_smallest = float('inf') \n    for number in numbers:\n      if number != smallest and number < second_smallest:\n        second_smallest = number\n    return second_smallest", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list. \n        Returns None if the list has less than two unique elements.\n    \"\"\"\n    unique_numbers = sorted(set(numbers))\n    return unique_numbers[1] if len(unique_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list. \n    Returns None if the list has less than two distinct elements.\n  \"\"\"\n  unique_numbers = sorted(set(numbers))\n  if len(unique_numbers) < 2:\n    return None\n  return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list, or None if the list\n        has less than two unique numbers.\n    \"\"\"\n\n    # Handle cases with fewer than two unique elements\n    unique_numbers = set(numbers)\n    if len(unique_numbers) < 2:\n      return None\n    \n    # Find smallest and second smallest\n    smallest = min(unique_numbers)\n    second_smallest = max(unique_numbers)  \n\n    for num in unique_numbers:\n      if num > smallest and num < second_smallest:\n        second_smallest = num\n\n    return second_smallest", "matching_cluster_idx": 2}, {"solution": "def second_smallest(nums):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The second smallest number in the list, or None if the list has less than two\n    distinct elements.\n  \"\"\"\n  \n  # Remove duplicates to ensure we don't accidentally consider the same number twice\n  unique_nums = list(set(nums)) \n  \n  if len(unique_nums) < 2:\n    return None\n  \n  smallest = min(unique_nums)\n  second_smallest = max(unique_nums)  # Initialize with maximum for comparison\n\n  for num in unique_nums:\n    if num != smallest and num < second_smallest:\n      second_smallest = num\n\n  return second_smallest", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list, or None if the list has fewer than 2 distinct elements.\n  \"\"\"\n  unique_numbers = sorted(set(numbers))\n  if len(unique_numbers) < 2:\n    return None\n  return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n      numbers: A list of numbers.\n\n  Returns:\n      The second smallest number in the list, or None if the list has fewer than two unique elements.\n  \"\"\"\n  unique_numbers = set(numbers)\n  if len(unique_numbers) < 2:\n    return None  # Not enough unique elements\n\n  # Remove the smallest element and find the smallest in the remaining set\n  unique_numbers.remove(min(unique_numbers))\n  return min(unique_numbers)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list. Returns None if the list has less than two unique elements.\n\n  \"\"\"\n  unique_numbers = sorted(set(numbers))\n  if len(unique_numbers) < 2:\n    return None\n  return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The second smallest number in the list.\n\n        Returns None if the list has less than two distinct elements.\n    \"\"\"\n    unique_numbers = sorted(set(numbers))\n    if len(unique_numbers) < 2:\n      return None\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  This function finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list.\n    Returns None if the list is empty or has less than two unique elements.\n  \"\"\"\n  if len(numbers) < 2:\n    return None\n  \n  # Sort the list and remove duplicates\n  unique_numbers = sorted(set(numbers))\n  \n  # Return the second element (index 1) if there are at least two elements\n  if len(unique_numbers) >= 2:\n    return unique_numbers[1]\n  else:\n    return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n      numbers: A list of numbers.\n\n  Returns:\n      The second smallest number in the list, or None if the list has less than two distinct elements.\n  \"\"\"\n  unique_numbers = set(numbers)\n  if len(unique_numbers) < 2:\n    return None\n  unique_numbers.remove(min(unique_numbers))\n  return min(unique_numbers)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  This function finds the second smallest number in a list.\n\n  Args:\n      numbers: A list of numbers.\n\n  Returns:\n      The second smallest number in the list, or None if the list is empty or has less than two distinct elements.\n  \"\"\"\n  if len(numbers) < 2:\n    return None\n\n  # Find the smallest and second smallest numbers.\n  smallest = min(numbers)\n  second_smallest = float('inf')\n  for num in numbers:\n    if num != smallest and num < second_smallest:\n      second_smallest = num\n\n  # Return the second smallest number, or None if there is no second smallest.\n  return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list, or None if the list has less than two unique elements.\n  \"\"\"\n\n  # Remove duplicates and sort the list\n  unique_numbers = sorted(set(numbers))\n\n  # Return the second element (index 1) if it exists\n  return unique_numbers[1] if len(unique_numbers) >= 2 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list.\n    Returns None if the list has less than two unique elements.\n  \"\"\"\n  \n  # Sort the list, removing duplicates while maintaining order\n  unique_numbers = sorted(set(numbers))\n  \n  # Check if there are at least two unique numbers\n  if len(unique_numbers) < 2:\n    return None\n  \n  return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list, or None if the list has less than \n    two distinct elements.\n  \"\"\"\n  # Handle edge cases: less than 2 elements \n  if len(set(numbers)) < 2:\n    return None\n  \n  # Find the smallest and second smallest numbers\n  smallest = min(numbers)\n  second_smallest = max(numbers)  # Initialize with a large value\n\n  for number in numbers:\n    if number != smallest and number < second_smallest:\n      second_smallest = number\n\n  return second_smallest", "matching_cluster_idx": 2}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Finds the second smallest number in a list.\n\n    Args:\n    nums: A list of numbers.\n\n    Returns:\n    The second smallest number in the list, or None if the list has fewer than two distinct elements.\n    \"\"\"\n    #Handle cases with less than two elements\n    if len(set(nums)) < 2:\n      return None\n    \n    #Remove duplicates and sort the list\n    unique_nums = sorted(set(nums))\n    return unique_nums[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n  Args:\n    numbers: A list of numbers.\n  Returns:\n    The second smallest number in the list, or None if the list has fewer than two unique elements.\n  \"\"\"\n  unique_numbers = set(numbers)\n  if len(unique_numbers) < 2:\n    return None\n  unique_numbers.remove(min(unique_numbers))\n  return min(unique_numbers)", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list. Returns None if the list has\n    fewer than two unique elements.\n  \"\"\"\n\n  # Remove duplicates and sort the list\n  unique_numbers = sorted(set(numbers))\n\n  # Return the second element if the list has at least two unique elements\n  if len(unique_numbers) >= 2:\n    return unique_numbers[1]\n  else:\n    return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n  \"\"\"\n  Finds the second smallest number in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    The second smallest number in the list, or None if the list has less than two distinct elements.\n  \"\"\"\n  if len(set(numbers)) < 2:\n    return None\n\n  smallest = min(numbers)\n  second_smallest = float('inf')\n  for num in numbers:\n    if num != smallest and num < second_smallest:\n      second_smallest = num\n  return second_smallest", "matching_cluster_idx": 2}, {"solution": "def second_smallest(numbers):\n    \"\"\"Finds the second smallest number in a list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The second smallest number in the list, or None if the list has less than two distinct elements.\n    \"\"\"\n    unique_numbers = set(numbers) \n    if len(unique_numbers) < 2:\n        return None\n    \n    unique_numbers.remove(min(unique_numbers))\n    return min(unique_numbers)", "matching_cluster_idx": 4}]}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 90.0, "profiled": [{"solution": "def count_reverse_pairs(strings):\n  \"\"\"\n  Counts the number of pairs of reverse strings in a list.\n\n  Args:\n      strings: A list of strings.\n\n  Returns:\n      The number of pairs of reverse strings in the list.\n  \"\"\"\n\n  count = 0\n  seen = set()\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1] and (i, j) not in seen:\n        count += 1\n        seen.add((i, j))  # To avoid counting the same pair twice\n        seen.add((j, i))\n\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"Counts the number of pairs of reverse strings in a list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count\nstrings = [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n  \"\"\"\n  Counts the number of pairs of reverse strings in the given string list.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n  \"\"\"\n  Counts the pairs of reverse strings in a given list of strings.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n  \"\"\"Counts the pairs of reverse strings in the given string list.\n\n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  for i in range(len(string_list)):\n    for j in range(i + 1, len(string_list)):\n      if string_list[i][::-1] == string_list[j]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n    strings: A list of strings.\n\n    Returns:\n    The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list.\n\n    assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == 2\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"Counts the pairs of reverse strings in a given list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count\nstrings = [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list.\n    assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== 2\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count\nstrings = [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n  \"\"\"Counts pairs of reverse strings in a list.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n  \"\"\"\n  Counts the number of pairs of reverse strings in a given list.\n\n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  for i in range(len(string_list)):\n    for j in range(i + 1, len(string_list)):\n      if string_list[i] == string_list[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n  \"\"\"Counts the pairs of reverse strings in a list.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n\n  count = 0\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      words: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    for i in range(len(words)):\n      for j in range(i+1, len(words)):\n        if words[i] == words[j][::-1]:  \n          count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n  \"\"\"Counts the pairs of reverse strings in the given string list.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n\n  count = 0\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n  \"\"\"\n  This function counts the number of pairs of reverse strings in a list.\n\n  Args:\n    strings: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  for i in range(len(strings)):\n    for j in range(i + 1, len(strings)):\n      if strings[i] == strings[j][::-1]:\n        count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n  \"\"\"\n  Counts the pairs of reverse strings in the given string list.\n\n  Args:\n    string_list: A list of strings.\n\n  Returns:\n    The number of pairs of reverse strings in the list.\n  \"\"\"\n  count = 0\n  seen = set()\n  for i in range(len(string_list)):\n    for j in range(i + 1, len(string_list)):\n      if string_list[i] == string_list[j][::-1] and (i, j) not in seen:\n        count += 1\n        seen.add((i, j))\n        seen.add((j, i))  # Since order doesn't matter for pairs\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n      strings: A list of strings.\n\n    Returns:\n      The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n          if strings[i] == strings[j][::-1]:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strs):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list. \n\n    Args:\n        strs: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    seen = set()\n    for i in range(len(strs)):\n      for j in range(i+1, len(strs)):\n        if strs[i] == strs[j][::-1] and (i,j) not in seen:\n          count += 1\n          seen.add((i,j))\n          seen.add((j,i)) # Add the reverse pair\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"Counts the number of reverse string pairs in a list.\n\n    Args:\n        string_list: A list of strings.\n\n    Returns:\n        The number of pairs of strings where one is the reverse of the other.\n    \"\"\"\n    count = 0\n    seen = set()\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1] and (i, j) not in seen:\n                count += 1\n                seen.add((i, j))\n                seen.add((j, i))  # Account for both orderings of the pair\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the number of pairs of reverse strings in a list.\n\n    Args:\n        strings: A list of strings.\n\n    Returns:\n        The number of pairs of reverse strings in the list.\n    \"\"\"\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 69.05405405405405, "dps_norm": 76.875, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    \"\"\"Counts the occurrences of lists within a list and returns a dictionary.\n\n    Args:\n        lst: A list of lists.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)  # Convert sublist to tuple for hashability\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n  \"\"\"\n  Counts the occurrences of sublists within a list.\n\n  Args:\n    input_list: A list of lists.\n\n  Returns:\n    A dictionary where keys are tuples representing the sublists, and values\n    are the counts of their occurrences.\n  \"\"\"\n  counts = {}\n  for sublist in input_list:\n    sublist_tuple = tuple(sublist)  \n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n  \"\"\"\n  Counts the occurrences of unique sublists within a list.\n\n  Args:\n    input_list: A list of lists.\n\n  Returns:\n    A dictionary where keys are tuples representing unique sublists and values are their counts.\n  \"\"\"\n  counts = {}\n  for sublist in input_list:\n    sublist_tuple = tuple(sublist)  # Convert sublist to tuple for hashability\n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"Counts occurrences of lists within a list and returns a dictionary.\n\n    Args:\n        list_of_lists: A list containing lists as elements.\n\n    Returns:\n        A dictionary where keys are tuples representing unique sublists \n        and values are the counts of their occurrences.\n    \"\"\"\n\n    counts = {}\n    for sublist in list_of_lists:\n        sublist_tuple = tuple(sublist)  # Convert sublist to a tuple for hashable keys\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lists):\n  \"\"\"\n  Counts the occurrences of each sublist in a list.\n\n  Args:\n      lists: A list of lists.\n\n  Returns:\n      A dictionary where keys are tuples representing the unique sublists, and values\n      are the counts of each sublist.\n  \"\"\"\n  return dict(Counter(tuple(l) for l in lists))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(data):\n  \"\"\"Counts the occurrences of each sublist within a list.\n\n  Args:\n      data: A list of lists.\n\n  Returns:\n      A dictionary where keys are tuples representing unique sublists,\n      and values are their respective counts.\n  \"\"\"\n\n  counts = {}\n  for sublist in data:\n    key = tuple(sublist)  # Convert sublist to tuple for hashability\n    if key in counts:\n      counts[key] += 1\n    else:\n      counts[key] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Counts the occurrences of unique sublists within a list.\n\n    Args:\n    input_list: A list of lists.\n\n    Returns:\n    A dictionary where keys are tuples representing unique sublists\n    and values are their counts.\n    \"\"\"\n    counts = {}\n    for sublist in input_list:\n        sublist_tuple = tuple(sublist)  # Convert to tuple for hashability\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    \"\"\"\n    Counts the occurrences of lists within a list, converting them to tuples.\n\n    Args:\n      list_of_lists: A list of lists.\n\n    Returns:\n      A dictionary where keys are tuples representing unique sublists\n      and values are their respective counts.\n    \"\"\"\n\n    counts = {}\n    for sublist in list_of_lists:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n  \"\"\"\n  Counts occurrences of unique sublists in a list.\n\n  Args:\n      list_of_lists: A list containing other lists.\n\n  Returns:\n      A dictionary where keys are tuples representing unique sublists,\n      and values are the counts of their occurrences.\n  \"\"\"\n  counts = {}\n  for sublist in list_of_lists:\n    sublist_tuple = tuple(sublist)  \n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(data):\n    \"\"\"\n    Counts the occurrences of lists within a list.\n\n    Args:\n      data: A list containing lists.\n\n    Returns:\n      A dictionary where the keys are tuples representing unique sublists and the values are their frequencies.\n    \"\"\"\n\n    counts = {}\n    for sublist in data:\n        # Convert sublist to a tuple for hashability\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in counts:\n          counts[sublist_tuple] += 1\n        else:\n          counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Counts the occurrences of sublists within a list.\n\n    Args:\n      input_list: A list of lists.\n\n    Returns:\n      A dictionary where the keys are tuples representing unique sublists\n      and the values are their counts.\n    \"\"\"\n    counts = {}\n    for sublist in input_list:\n        sublist_tuple = tuple(sublist)  # Convert sublist to tuple for hashability\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    \"\"\"\n    Counts the occurrences of lists within a list.\n\n    Args:\n      input_list: A list of lists.\n\n    Returns:\n      A dictionary where the keys are tuples representing unique sublists\n      and the values are their respective counts.\n    \"\"\"\n\n    counts = {}\n    for sublist in input_list:\n      sublist_tuple = tuple(sublist)  \n      if sublist_tuple in counts:\n        counts[sublist_tuple] += 1\n      else:\n        counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of lists within a list and returns a dictionary where\n    each unique list (converted to a tuple) is a key, and its value is the count.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A dictionary with tuples (representing the unique sublists) as keys and\n      their counts as values.\n    \"\"\"\n\n    counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)  # Convert to tuple for hashability\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n  \"\"\"\n  Counts the occurrences of lists within a list.\n\n  Args:\n    list_of_lists: A list of lists.\n\n  Returns:\n    A dictionary where keys are tuples representing unique lists and values are\n    the number of occurrences of each list.\n  \"\"\"\n  counts = {}\n  for sublist in list_of_lists:\n    sublist_tuple = tuple(sublist)\n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(data):\n  \"\"\"\n  Counts occurrences of lists within a list and returns a dictionary\n\n  Args:\n    data: A list of lists.\n\n  Returns:\n    A dictionary where keys are tuples representing unique sublists,\n    and values are the counts of those sublists in the original list.\n  \"\"\"\n  counts = {}\n  for sublist in data:\n    sublist_tuple = tuple(sublist)  # Convert to tuple for hashability\n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n  \"\"\"\n  Counts the occurrences of lists within a list.\n\n  Args:\n    lst: A list of lists.\n\n  Returns:\n    A dictionary where keys are tuples representing unique sublists\n    and values are their counts.\n  \"\"\"\n  sublist_counts = {}\n  for sublist in lst:\n    sublist_tuple = tuple(sublist)\n    if sublist_tuple in sublist_counts:\n      sublist_counts[sublist_tuple] += 1\n    else:\n      sublist_counts[sublist_tuple] = 1\n  return sublist_counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n  \"\"\"\n  Counts the occurrences of each sublist within a list of lists.\n\n  Args:\n    list_of_lists: A list containing other lists as its elements.\n\n  Returns:\n    A dictionary where keys are tuples representing unique sublists,\n    and values are the counts of their occurrences in the input list.\n  \"\"\"\n  counts = {}\n  for sublist in list_of_lists:\n    sublist_tuple = tuple(sublist)  \n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(data):\n  \"\"\"\n  Counts the occurrences of lists within a list, returning a dictionary\n  where each unique list (converted to a tuple) is a key and its value is\n  the count.\n\n  Args:\n    data: A list of lists.\n\n  Returns:\n    A dictionary of unique list tuples and their counts.\n  \"\"\"\n\n  counts = {}\n  for sublist in data:\n    sublist_tuple = tuple(sublist)  # Convert list to tuple for hashability\n    if sublist_tuple in counts:\n      counts[sublist_tuple] += 1\n    else:\n      counts[sublist_tuple] = 1\n  return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(data):\n    \"\"\"\n    Counts the occurrences of lists within a list.\n\n    Args:\n        data (list): A list of lists.\n\n    Returns:\n        dict: A dictionary where keys are tuples representing unique sublists and values are their counts.\n    \"\"\"\n    counts = {}\n    for sublist in data:\n      key = tuple(sublist)  # Convert sublist to tuple for hashability\n      if key in counts:\n          counts[key] += 1\n      else:\n          counts[key] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"Counts the occurrences of unique sublists within a list.\n\n    Args:\n      lst: A list of lists.\n\n    Returns:\n      A dictionary where each unique sublist (converted to a tuple) is a key,\n      and its value is the number of times it appears in the input list.\n    \"\"\"\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(nums):\n    \"\"\"Checks if a list of numbers contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums: list) -> bool:\n    \"\"\"\n    Checks if a list contains only one distinct element.\n    Args:\n        nums: A list of numbers.\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks whether a list of numbers contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums: list[int]) -> bool:\n    \"\"\"\n    Checks whether a list of numbers contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Check if a list contains only one distinct element.\n\n    Args:\n    nums: A list of numbers.\n\n    Returns:\n    True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks whether a list of numbers contains only one distinct element.\n\n    Args:\n      lst: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n  \"\"\"\n  Checks whether a list of numbers contains only one distinct element.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n  \"\"\"Checks if a list contains only one distinct element.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n  \"\"\"\n  Checks if a list contains only one distinct element.\n\n  Args:\n    lst: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n  \"\"\"\n  This function checks whether a list of numbers contains only one distinct element.\n\n  Args:\n      numbers: A list of numbers.\n\n  Returns:\n      True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n  \"\"\"\n  Checks whether a list of numbers contains only one distinct element.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n  \"\"\"\n  Checks if a list of numbers contains only one distinct element.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Checks if a list of numbers contains only one distinct element.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n  \"\"\"\n  Checks if a list of numbers contains only one distinct element.\n  Args:\n    nums: A list of numbers.\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n  \"\"\"\n  Checks if a list of numbers contains only one distinct element.\n\n  Args:\n    input_list: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(input_list)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n  \"\"\"\n  Checks whether a list of numbers contains only one distinct element.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if the list contains only one distinct element, False otherwise.\n  \"\"\"\n  return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks if a list contains only one distinct element.\n\n    Args:\n        lst: A list of numbers.\n\n    Returns:\n        True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(str1):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in str1:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n      str1: The string to check.\n\n  Returns:\n      The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in str1:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n    text: The string to analyze.\n\n  Returns:\n    The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in text:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n  \"\"\"Counts the number of digits in a given string.\n\n  Args:\n    string: The string to analyze.\n\n  Returns:\n    The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in string:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n  \"\"\"Counts the number of digits in a given string.\n\n  Args:\n    input_string: The string to analyze.\n\n  Returns:\n    The number of digits found in the string.\n  \"\"\"\n  count = 0\n  for char in input_string:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n      text: The input string.\n\n  Returns:\n      The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in text:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n  \"\"\"\n  Counts the number of digits in a given string.\n  \n  Args:\n      text (str): The string to analyze.\n\n  Returns:\n      int: The count of digits in the string.\n  \"\"\"\n  return sum(1 for char in text if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n    string: The input string.\n\n  Returns:\n    The number of digits in the string.\n  \"\"\"\n\n  count = 0\n  for char in string:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n    string: The input string to be analyzed.\n\n  Returns:\n    The number of digits present in the string.\n  \"\"\"\n  count = 0\n  for char in string:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    \"\"\"\n    This function counts the number of digits in a given string.\n\n    Args:\n        str1: The input string to be checked.\n\n    Returns:\n        The number of digits present in the string.\n    \"\"\"\n    count = 0\n    for char in str1:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n  \"\"\"\n  Counts the number of digits in a given string.\n  Args:\n      string: The string to search for digits.\n\n  Returns:\n      The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in string:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n  \"\"\"\n  Counts the number of digits in a given string.\n\n  Args:\n    text: The string to analyze.\n\n  Returns:\n    The number of digits found in the string.\n  \"\"\"\n  return sum(c.isdigit() for c in text)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        string: The string to search for digits in.\n\n    Returns:\n        The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n  \"\"\"\n  This function counts the number of digits in a given string.\n\n  Args:\n      text: The string to analyze.\n\n  Returns:\n      The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in text:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n      input_string: The string to count digits in.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n    \"\"\"\n    This function counts the number of digits in a given string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      The number of digits in the string.\n    \"\"\"\n\n    count = 0\n    for char in text:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Write a python function to count number of digits in a given string.\n    assert number_ctr('program2bedone') == 1\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Counts the number of digits in a given string.\n\n    Args:\n    s: The input string.\n\n    Returns:\n    The number of digits in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n      if char.isdigit():\n        count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n  \"\"\"\n  This function counts the number of digits in a given string.\n\n  Args:\n      str1: The input string.\n\n  Returns:\n      The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in str1:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n  \"\"\"Counts the number of digits in a given string.\n\n  Args:\n    string: The string to count digits in.\n\n  Returns:\n    The number of digits in the string.\n  \"\"\"\n  count = 0\n  for char in string:\n    if char.isdigit():\n      count += 1\n  return count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 71.54205607476635, "dps_norm": 60.833333333333336, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n  \"\"\"\n  This function returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n      lst: A list of any data type.\n\n  Returns:\n      A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: A list of items.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n  For example:\n  pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        lst: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple represents a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n        lst: A list of items.\n\n    Returns:\n        A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    For example:\n    pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n    lst: A list of items.\n\n    Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: A list of items.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Return a list of all pairs of consecutive items in a given list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    A list of tuples, where each tuple represents a pair of consecutive items.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  This function returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: A list of any type.\n\n  Returns:\n    A list of tuples, where each tuple contains two consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  This function takes a list and returns a list of all pairs of consecutive items in the list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Return a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: The input list.\n\n  Returns:\n    A list of tuples, where each tuple contains two consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  This function returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: A list of items.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive elements \n    from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"\n  Return a list of all pairs of consecutive items in a given list.\n\n  Args:\n    lst: A list of elements.\n\n  Returns:\n    A list of tuples, where each tuple contains a pair of consecutive elements from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n  \"\"\"Returns a list of all pairs of consecutive items in a given list.\n\n  Args:\n      lst: A list of items.\n\n  Returns:\n      A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n  \"\"\"\n  return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 94.39999999999999, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(nums):\n  \"\"\"\n  Checks whether every odd index contains odd numbers of a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks whether every odd index contains odd numbers in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n      if nums[i] % 2 == 0:\n        return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  Checks whether every odd index contains odd numbers in a given list.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks whether every odd index contains odd numbers of a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n      if nums[i] % 2 == 0:\n        return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks whether every odd index contains an odd number in a given list.\n\n    Args:\n      nums: A list of integers.\n\n    Returns:\n      True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n      if nums[i] % 2 == 0:\n        return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every odd index in a list contains an odd number.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n      if nums[i] % 2 == 0:\n        return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  Checks whether every odd index in a list contains an odd number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  This function checks if every odd index in a list contains an odd number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n  \"\"\"\n  Checks whether every odd index contains odd numbers of a given list.\n  \n  Args:\n    lst: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(lst), 2):\n    if lst[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  Checks whether every odd index contains odd numbers of a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"Checks if every odd index in a list contains an odd number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every odd index contains an odd number in a given list.\n\n    Args:\n        lst: A list of integers.\n\n    Returns:\n        True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # Iterate through odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n\n    for i in range(1, len(nums), 2):  # Iterate through odd indices\n        if nums[i] % 2 == 0:\n            return False \n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  Checks whether every odd index contains odd numbers of a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"Checks if every odd index in a list contains an odd number.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  Checks whether every odd index contains an odd number in a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Checks if every odd index in a list contains an odd number.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n  \"\"\"\n  Checks whether every odd index in a list contains an odd number.\n\n  Args:\n    numbers: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n\n  for i in range(1, len(numbers), 2):\n    if numbers[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n  \"\"\"Checks whether every odd index contains odd numbers in a list.\n\n  Args:\n    numbers: A list of numbers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(numbers), 2):\n    if numbers[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n  \"\"\"\n  Checks if every odd index in a list contains an odd number.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    True if every odd index contains an odd number, False otherwise.\n  \"\"\"\n  for i in range(1, len(nums), 2):\n    if nums[i] % 2 == 0:\n      return False\n  return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 57.142857142857146, "dps_norm": 68.88888888888889, "pass@1": 88.0, "profiled": [{"solution": "def find_sum(nums):\n  \"\"\"Finds the sum of non-repeated elements in a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The sum of the non-repeated elements in the list.\n  \"\"\"\n  seen = set()\n  total = 0\n  for num in nums:\n    if num not in seen:\n      total += num\n      seen.add(num)\n  return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(numbers):\n  \"\"\"\n  This function calculates the sum of non-repeated elements in a list.\n\n  Args:\n      numbers: A list of numbers.\n\n  Returns:\n      The sum of non-repeated elements in the list.\n  \"\"\"\n  unique_numbers = set(numbers)  \n  return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The sum of non-repeated elements in the list.\n    \"\"\"\n    unique_nums = set(nums) \n    return sum(unique_nums)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n  \"\"\"\n  This function calculates the sum of non-repeated elements in a list.\n\n  Args:\n      numbers: A list of numbers.\n\n  Returns:\n      The sum of the non-repeated elements in the list.\n  \"\"\"\n  unique_numbers = set(numbers)  # Create a set to store unique numbers\n  sum_of_uniques = sum(unique_numbers) \n  return sum_of_uniques", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n  \"\"\"\n  Finds the sum of non-repeated elements in a given list.\n\n  Args:\n    nums: A list of numbers.\n\n  Returns:\n    The sum of non-repeated elements in the list.\n  \"\"\"\n  seen = set()\n  total = 0\n  for num in nums:\n    if num not in seen:\n      total += num\n      seen.add(num)\n  return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(data):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Args:\n        data (list): The input list of numbers.\n\n    Returns:\n        int: The sum of non-repeated elements.\n    \"\"\"\n    seen = set()\n    total = 0\n    for num in data:\n        if num not in seen:\n            total += num\n            seen.add(num)\n    return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(data: list) -> int:\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n\n    Args:\n        data (list): The input list of numbers.\n\n    Returns:\n        int: The sum of non-repeated elements.\n    \"\"\"\n    seen = set()\n    sum_of_unique = 0\n    for num in data:\n      if num not in seen:\n        sum_of_unique += num\n        seen.add(num)\n    return sum_of_unique", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The sum of non-repeated elements in the list.\n    \"\"\"\n\n    seen = set()\n    total = 0\n    for num in nums:\n      if num not in seen:\n          total += num\n          seen.add(num)\n    return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n  \"\"\"\n  Finds the sum of non-repeated elements in a list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The sum of the non-repeated elements in the list.\n  \"\"\"\n\n  seen = set()\n  total = 0\n  for num in nums:\n    if num not in seen:\n      total += num\n      seen.add(num)\n  return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The sum of the non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    total = 0\n    for num in nums:\n        if num not in seen:\n            total += num\n            seen.add(num)\n    return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n\n    Args:\n        nums: A list of numbers.\n\n    Returns:\n        The sum of non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    sum = 0\n    for num in nums:\n      if num not in seen:\n        sum += num\n        seen.add(num)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n  \"\"\"\n  This function finds the sum of non-repeated elements in a given list.\n\n  Args:\n      nums: A list of integers.\n\n  Returns:\n      The sum of non-repeated elements in the list.\n  \"\"\"\n  unique_nums = set(nums)\n  return sum(unique_nums)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Args:\n        numbers: A list of integers.\n\n    Returns:\n        The sum of the non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    sum = 0\n    for num in numbers:\n        if num not in seen:\n            sum += num\n            seen.add(num)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(data):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Args:\n      data: A list of integers.\n\n    Returns:\n      The sum of the non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    sum = 0\n    for item in data:\n      if item not in seen:\n        sum += item\n        seen.add(item)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n  \"\"\"\n  This function finds the sum of non-repeated elements in a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The sum of non-repeated elements in the list.\n  \"\"\"\n  unique_nums = set(nums)\n  return sum(unique_nums)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"Finds the sum of non-repeated elements in a given list.\n\n    Args:\n      numbers: A list of numbers.\n\n    Returns:\n      The sum of non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    sum = 0\n    for number in numbers:\n        if number not in seen:\n            sum += number\n            seen.add(number)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n  \"\"\"\n  Finds the sum of non-repeated elements in a given list.\n\n  Args:\n    nums: A list of integers.\n\n  Returns:\n    The sum of non-repeated elements in the list.\n  \"\"\"\n\n  seen = set()\n  total = 0\n  for num in nums:\n    if num not in seen:\n      total += num\n      seen.add(num)\n  return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(numbers):\n    \"\"\"Calculates the sum of non-repeated elements in a list.\n\n    Args:\n        numbers: A list of numbers.\n\n    Returns:\n        The sum of the non-repeated elements in the list.\n    \"\"\"\n\n    unique_numbers = set(numbers)  # Use a set to efficiently find unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    \"\"\"\n    Finds the sum of non-repeated elements in a given list.\n\n    Args:\n        nums: A list of integers.\n\n    Returns:\n        The sum of the non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    sum = 0\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            sum += num\n    return sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n    \"\"\"Finds the sum of non-repeated elements in a list.\n\n    Args:\n      nums: A list of numbers.\n\n    Returns:\n      The sum of the non-repeated elements in the list.\n    \"\"\"\n    seen = set()\n    sum = 0\n    for num in nums:\n        if num not in seen:\n            sum += num\n            seen.add(num)\n    return sum", "matching_cluster_idx": 4}]}, "Mbpp/781": {"dps": 88.26771653543307, "dps_norm": 47.0, "pass@1": 48.0, "profiled": [{"solution": "def count_divisors(num):\n    \"\"\"\n    Calculates the number of divisors of a given integer.\n\n    Args:\n    num: The integer to check for divisors.\n\n    Returns:\n    True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n  \"\"\"Counts the number of divisors of a given integer.\n  \n  Args:\n    n: The integer to check.\n\n  Returns:\n    True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function checks whether the count of divisors of a given number is even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n  \"\"\"Counts the number of divisors of a given number and checks if it's even.\n\n  Args:\n      n: An integer.\n\n  Returns:\n      True if the count of divisors of n is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "import math\ndef count_divisors(num):\n  \"\"\"\n  Checks whether the count of divisors of a number is even.\n\n  Args:\n    num: An integer to check.\n\n  Returns:\n    True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, int(math.sqrt(num)) + 1):\n    if num % i == 0:\n      if num / i == i:\n        count += 1\n      else:\n        count += 2\n  return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n  \"\"\"\n  Counts the number of divisors of a given number and checks if it's even.\n\n  Args:\n    num: The number to check.\n\n  Returns:\n    True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, num + 1):\n    if num % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the number of divisors of a given number n and checks if it's even.\n\n    Args:\n        n: An integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the number of divisors of a given positive integer.\n\n    Args:\n        n: A positive integer.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n  \"\"\"\n  This function counts the divisors of a number and returns True if the count is even, \n  otherwise False.\n\n  Args:\n      num: An integer.\n\n  Returns:\n      True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, num + 1):\n    if num % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n  \"\"\"Counts the number of divisors of a given number and checks if the count is even.\n\n  Args:\n    num: The number to check.\n\n  Returns:\n    True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, num + 1):\n    if num % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n  \"\"\"\n  This function checks if the count of divisors of a given number is even.\n\n  Args:\n    n: An integer.\n\n  Returns:\n    True if the count of divisors of n is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n  \"\"\"\n  This function counts the number of divisors of a given integer.\n\n  Args:\n      n: An integer.\n\n  Returns:\n      True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, n + 1):\n    if n % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of a number is even.\n    \n    Args:\n    n: An integer.\n    \n    Returns:\n    True if the number of divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n  \"\"\"\n  This function checks whether the count of divisors of a given number is even.\n\n  Args:\n    num: An integer.\n\n  Returns:\n    True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, num + 1):\n    if num % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"Checks whether the count of divisors of a given number is even.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n  \"\"\"\n  Checks whether the count of divisors of a number is even.\n\n  Args:\n    num: An integer.\n\n  Returns:\n    True if the count of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, num + 1):\n    if num % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n    \"\"\"\n    Counts the number of divisors for a given positive integer.\n\n    Args:\n        num: The positive integer to check.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(num):\n  \"\"\"Counts the number of divisors a number has and returns True if even, False otherwise.\n\n  Args:\n    num: The integer to check.\n\n  Returns:\n    True if the number of divisors is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, num + 1):\n    if num % i == 0:\n      count += 1\n  return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n  \"\"\"\n  Counts the number of divisors of a positive integer n and checks if the count is even.\n\n  Args:\n    n: A positive integer.\n\n  Returns:\n    True if the number of divisors of n is even, False otherwise.\n  \"\"\"\n  count = 0\n  for i in range(1, int(n**0.5) + 1):\n    if n % i == 0:\n      if i * i == n:\n        count += 1\n      else:\n        count += 2\n  return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(num):\n    \"\"\"\n    Counts the number of divisors of a given number and checks if the count is even.\n\n    Args:\n        num: The number to check.\n\n    Returns:\n        True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 80.0, "profiled": [{"solution": "def remove_all_spaces(text):\n    \"\"\"Removes all whitespaces from a string.\n    \n    Args:\n        text: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  This function removes all whitespace characters from a given string.\n\n  Args:\n    text: The input string\n\n  Returns:\n    A string with all whitespace characters removed.\n  \"\"\"\n\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"Removes all whitespaces from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    assert remove_all_spaces('python  program')==('pythonprogram')\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  Removes all whitespaces from a string.\n\n  Args:\n    text: The string to remove spaces from.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  This function removes all whitespaces from a given string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"Removes all whitespaces from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n    \"\"\"Removes all whitespace characters from a string.\n\n    Args:\n        text: The string to remove whitespaces from.\n\n    Returns:\n        The string with all whitespace characters removed.\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  Removes all whitespace characters from a string.\n\n  Args:\n    text: The string to remove whitespace from.\n\n  Returns:\n    The string with all whitespace characters removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n    \"\"\"Removes all whitespaces from a string.\n\n    Args:\n        text: The input string.\n\n    Returns:\n        The string with all whitespaces removed.\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"Removes all whitespaces from a string.\n  \n  Args:\n      text: The string to remove spaces from.\n\n  Returns:\n      A new string with all spaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"Removes all whitespaces from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  This function removes all whitespaces from a given string.\n\n  Args:\n    text: The string to remove whitespaces from.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  Removes all whitespace characters from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespace characters removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"Removes all whitespaces from a string.\n\n  Args:\n    text: The input string.\n\n  Returns:\n    The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  This function removes all whitespaces from a string.\n\n  Args:\n      text: The string to remove whitespaces from.\n\n  Returns:\n      The string with all whitespaces removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n    \"\"\"\n    Removes all whitespace characters from a string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      The string with all whitespace characters removed.\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text: str) -> str:\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n\n    Args:\n      text: The input string.\n\n    Returns:\n      The string with all whitespaces removed.\n\n    Examples:\n      remove_all_spaces('python  program') == 'pythonprogram'\n    \"\"\"\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"\n  This function removes all whitespaces from a string.\n\n  Args:\n    text: The string to remove whitespaces from.\n\n  Returns:\n    The string without any whitespace characters.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n  \"\"\"Removes all whitespaces from a string.\n\n  Args:\n    text: The string to remove whitespaces from.\n\n  Returns:\n    A string with all whitespace characters removed.\n  \"\"\"\n  return text.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list with the maximum sum of elements within a list of lists.\n\n    Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n    Returns:\n      The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = []\n    for sublist in list_of_lists:\n      current_sum = sum(sublist)\n      if current_sum > max_sum:\n        max_sum = current_sum\n        max_list = sublist\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  This function finds the list within a list of lists that has the highest sum of elements.\n\n  Args:\n      list_of_lists: A list of lists, where each inner list contains numbers.\n\n  Returns:\n      The list with the highest sum of elements.\n  \"\"\"\n\n  max_sum = float('-inf')\n  max_sum_list = []\n\n  for inner_list in list_of_lists:\n    current_sum = sum(inner_list)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_sum_list = inner_list\n\n  return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  This function takes a list of lists and returns the list with the highest sum of elements.\n\n  Args:\n      list_of_lists: A list of lists containing numbers.\n\n  Returns:\n      The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf')  \n  result_list = []\n  for lst in list_of_lists:\n    current_sum = sum(lst)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      result_list = lst\n  return result_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  This function returns the list in a list of lists whose sum of elements is the highest.\n\n  Args:\n    list_of_lists: A list of lists containing numbers.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf')  # Initialize with negative infinity to ensure any sum is greater\n  max_list = []\n  for sublist in list_of_lists:\n    current_sum = sum(sublist)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = sublist\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = []\n    for sublist in list_of_lists:\n      current_sum = sum(sublist)\n      if current_sum > max_sum:\n        max_sum = current_sum\n        max_list = sublist\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"Returns the list in a list of lists whose sum of elements is the highest.\n\n    For example:\n    max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]]) == [10, 11, 12]\n    \"\"\"\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n  \"\"\"\n  Finds the list in a list of lists whose sum of elements is the highest.\n\n  Args:\n    lists: A list of lists of numbers.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf')\n  max_list = []\n  for lst in lists:\n    current_sum = sum(lst)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = lst\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  Finds the list in a list of lists whose sum of elements is the highest.\n\n  Args:\n      list_of_lists: A list of lists of numbers.\n\n  Returns:\n      The list with the highest sum of elements.\n  \"\"\"\n\n  max_list = list_of_lists[0]  # Initialize with the first list\n  max_sum = sum(max_list)\n\n  for lst in list_of_lists:\n    current_sum = sum(lst)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = lst\n\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  Returns the list in a list of lists whose sum of elements is the highest.\n\n  Args:\n    list_of_lists: A list of lists of numbers.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf') \n  max_list = []\n  for sublist in list_of_lists:\n    current_sum = sum(sublist)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = sublist\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n  \"\"\"\n  Finds the list with the highest sum of elements in a list of lists.\n\n  Args:\n    lists: A list of lists, where each inner list contains integers.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf')\n  max_list = None\n  for lst in lists:\n    current_sum = sum(lst)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = lst\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n  \"\"\"Returns the list in a list of lists whose sum of elements is the highest.\n\n  Args:\n    lists: A list of lists of numbers.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf')\n  max_list = []\n  for lst in lists:\n    current_sum = sum(lst)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = lst\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  Finds the list in a list of lists whose sum of elements is the highest.\n\n  Args:\n    list_of_lists: A list of lists containing numerical values.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n\n  max_sum = float('-inf')  \n  max_list = []\n\n  for lst in list_of_lists:\n    current_sum = sum(lst)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = lst\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    For example:\n    max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]]) == [10, 11, 12]\n    \"\"\"\n    max_sum = float('-inf')  \n    result_list = []\n    for inner_list in list_of_lists:\n        current_sum = sum(inner_list)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result_list = inner_list\n    return result_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n      lists: A list of lists.\n\n    Returns:\n      The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf') \n    max_list = []\n    for lst in lists:\n      current_sum = sum(lst)\n      if current_sum > max_sum:\n        max_sum = current_sum\n        max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list within a list of lists that has the highest sum of elements.\n\n    Args:\n        list_of_lists: A list of lists containing numerical values.\n\n    Returns:\n        The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf')  # Initialize with negative infinity\n    max_list = []\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists with the highest sum of elements.\n\n    Args:\n        list_of_lists: A list of lists of numbers.\n\n    Returns:\n        The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = None\n    for inner_list in list_of_lists:\n        current_sum = sum(inner_list)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = inner_list\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n  \"\"\"\n  This function takes a list of lists and returns the list with the highest sum of elements.\n\n  Args:\n    list_of_lists: A list of lists of numbers.\n\n  Returns:\n    The list with the highest sum of elements.\n  \"\"\"\n  max_sum = float('-inf')\n  max_list = []\n  for sublist in list_of_lists:\n    current_sum = sum(sublist)\n    if current_sum > max_sum:\n      max_sum = current_sum\n      max_list = sublist\n  return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Finds the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = []\n    for lst in list_of_lists:\n      current_sum = sum(lst)\n      if current_sum > max_sum:\n        max_sum = current_sum\n        max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n      list_of_lists: A list of lists of numbers.\n\n    Returns:\n      A list of numbers, the list with the highest sum.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lst):\n    \"\"\"\n    Finds the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n      lst_of_lst: A list of lists of numbers.\n\n    Returns:\n      The list with the highest sum of elements.\n    \"\"\"\n    max_sum = float('-inf')  \n    max_list = []\n\n    for lst in lst_of_lst:\n      current_sum = sum(lst)\n      if current_sum > max_sum:\n        max_sum = current_sum\n        max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n  \"\"\"\n  Checks if a given tuple contains a specific value (k).\n\n  Args:\n    tup: The input tuple.\n    k: The value to search for.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n  \"\"\"\n  Checks if a given tuple contains the element k.\n\n  Args:\n      input_tuple: The tuple to search within.\n      k: The element to search for.\n\n  Returns:\n      True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(my_tuple, k):\n  \"\"\"\n  Checks if a given tuple contains a specific value 'k'.\n\n  Args:\n    my_tuple: A tuple to be checked.\n    k: The value to search for.\n\n  Returns:\n    True if 'k' is found in the tuple, False otherwise.\n  \"\"\"\n  return k in my_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(data, k):\n  \"\"\"\n  Checks if the given tuple contains the element k.\n\n  Args:\n      data: A tuple of elements.\n      k: The element to search for.\n\n  Returns:\n      True if k is in the tuple, False otherwise.\n  \"\"\"\n  return k in data", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_in, k):\n  \"\"\"\n  Checks if a tuple contains a given value.\n\n  Args:\n    tuple_in: The input tuple to search.\n    k: The value to search for within the tuple.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n\n  return k in tuple_in", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple1, k):\n  \"\"\"\n  Checks if the given tuple contains the value k.\n\n  Args:\n    tuple1: A tuple of integers.\n    k: The value to search for in the tuple.\n\n  Returns:\n    True if k is present in the tuple, False otherwise.\n  \"\"\"\n  return k in tuple1", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n  \"\"\"\n  This function checks if the given tuple contains the element k.\n\n  Args:\n    tuple_data: The tuple to be searched.\n    k: The element to be searched for.\n\n  Returns:\n    True if the tuple contains k, False otherwise.\n  \"\"\"\n  return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    \"\"\"\n    Checks if a given tuple contains the value k.\n\n    Args:\n      input_tuple: A tuple to be checked.\n      k: The value to search for in the tuple.\n\n    Returns:\n      True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n  \"\"\"\n  This function checks if the given tuple contains the element k.\n\n  Args:\n    input_tuple: A tuple of numbers.\n    k: The number to search for in the tuple.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n  \"\"\"\n  Checks if the given tuple contains the value k.\n\n  Args:\n    input_tuple: The tuple to be checked.\n    k: The value to search for.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n  \"\"\"\n  This function checks if the given tuple contains the value k.\n  Args:\n      input_tuple: The tuple to be checked.\n      k: The value to be searched for in the tuple.\n\n  Returns:\n      True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(data, k):\n  \"\"\"Checks if the given tuple contains the element k.\n\n  Args:\n    data: A tuple of elements.\n    k: The element to search for.\n\n  Returns:\n    True if k is in the tuple, False otherwise.\n  \"\"\"\n  return k in data", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n  \"\"\"\n  This function checks if the given tuple contains the value k.\n\n  Args:\n      tuple_data: A tuple of elements.\n      k: The element to search for in the tuple.\n\n  Returns:\n      True if the tuple contains k, False otherwise.\n  \"\"\"\n  return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n  \"\"\"Checks if the given tuple contains the element k.\n\n  Args:\n    input_tuple: A tuple of integers.\n    k: An integer to check for in the tuple.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n  \"\"\"\n  Checks if the given tuple contains the value k.\n\n  Args:\n      tuple_data: The tuple to be checked.\n      k: The value to search for in the tuple.\n\n  Returns:\n      True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n  \"\"\"\n  This function checks if the given tuple contains the element k.\n\n  Args:\n    tuple_data: A tuple of elements.\n    k: The element to search for in the tuple.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(data, k):\n  \"\"\"\n  This function checks if the given tuple contains the element k.\n\n  Args:\n    data: A tuple of numbers.\n    k: The number to search for.\n\n  Returns:\n    True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in data", "matching_cluster_idx": 5}, {"solution": "def check_K(data, k):\n  \"\"\"\n  Checks if the given tuple contains the value k.\n\n  Args:\n      data: A tuple of numbers.\n      k: The number to search for.\n\n  Returns:\n      True if k is found in the tuple, False otherwise.\n  \"\"\"\n  return k in data", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_data, k):\n  \"\"\"\n  This function checks if the given tuple contains the value k.\n\n  Args:\n      tuple_data: A tuple of values.\n      k: The value to search for.\n\n  Returns:\n      True if the tuple contains k, False otherwise.\n  \"\"\"\n  return k in tuple_data", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n  \"\"\"\n  Checks if the given tuple contains the value k.\n\n  Args:\n      input_tuple: A tuple of integers.\n      k: An integer to search for within the tuple.\n\n  Returns:\n      True if k is present in the tuple, False otherwise.\n  \"\"\"\n  return k in input_tuple", "matching_cluster_idx": 5}]}}}
