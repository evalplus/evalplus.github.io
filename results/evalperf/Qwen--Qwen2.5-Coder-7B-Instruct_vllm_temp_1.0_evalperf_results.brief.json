{"date": "2024-10-19 16:30", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 79.81023172966313, "dps_norm": 76.74937875060594, "pass@1": 76.42372881355932}, "eval": {"HumanEval/9": {"dps": 79.70031545741325, "dps_norm": 75.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = float('-inf')\n    \n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    current_max = numbers[0]\n\n    for number in numbers[1:]:\n        if number > current_max:\n            current_max = number\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    for number in numbers[1:]:\n        rolling_max_list.append(max(rolling_max_list[-1], number))\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n\n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = []\n    current_max = numbers[0]\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        current_max = max(current_max, number)  # Update current_max if the number is greater\n        result.append(current_max)  # Append the current_max to the result list\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    for number in numbers:\n        current_max = max(current_max, number)\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize the list to store the rolling maxima\n    rolling_max_list = []\n    # Initialize the current max to the first element\n    current_max = numbers[0]\n    # Iterate over the list of numbers\n    for number in numbers:\n        # Update the current max if the current number is greater\n        if number > current_max:\n            current_max = number\n        # Append the current max to the rolling maxima list\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    max_list = []\n    current_max = float('-inf')\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_list = [numbers[0]]\n    for number in numbers[1:]:\n        max_list.append(max(max_list[-1], number))\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_until_now = numbers[0]\n    result = [max_until_now]\n\n    for number in numbers[1:]:\n        if number > max_until_now:\n            max_until_now = number\n        result.append(max_until_now)\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 58.02325581395348, "dps_norm": 65.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Iterate through each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the absolute difference between the numbers is less than the threshold\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    # Iterate through the sorted list and check adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the list to make comparison easier\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make the comparison easier\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparison easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate through each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the absolute difference between the numbers is less than the threshold\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate over each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Check if the absolute difference between any two numbers is less than the threshold\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    # Return False if no such pair is found\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make comparison easier\n    sorted_numbers = sorted(numbers)\n    # Iterate through the sorted list and check adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        # If the difference between two adjacent elements is less than the threshold, return True\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    # If no such pair is found, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nfrom itertools import combinations\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    for num1, num2 in combinations(numbers, 2):\n        if abs(num1 - num2) < threshold:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sorting the list to reduce the number of comparisons\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparison easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make comparison easier\n    numbers.sort()\n    # Iterate through the list and compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make the comparison easier\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 65.99683544303798, "dps_norm": 70.83333333333333, "pass@1": 97.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    return total_deviation / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers cannot be empty\")\n\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate Mean Absolute Deviation of a list of numbers around the mean.\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    mads = [abs(x - mean) for x in numbers]\n    mad = sum(mads) / len(mads)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = statistics.mean(numbers)\n    return statistics.mean([abs(x - mean) for x in numbers])", "matching_cluster_idx": 0}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    data_mean = mean(numbers)\n    return mean([abs(x - data_mean) for x in numbers])", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    return total_deviation / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean_value = statistics.mean(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0.0 if the list is empty to avoid division by zero\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = statistics.mean(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = statistics.mean(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0 if the list is empty\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = statistics.mean(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of these absolute deviations (MAD)\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    Calculate the Mean Absolute Deviation of a given list of numbers.\n\n    :param numbers: List of input numbers.\n    :return: Mean Absolute Deviation of the input numbers.\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = mean(numbers)\n    abs_deviation_sum = sum(abs(x - mean_value) for x in numbers)\n    mad = abs_deviation_sum / len(numbers)\n    return mad", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 42.7906976744186, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(s: str) -> int:\n    # Convert the string to lowercase to ignore case differences\n    s = s.lower()\n    # Use a set to store unique characters\n    distinct_chars = set(s)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lowercase_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_characters = set(lowercase_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate over each character in the string\n    for char in string:\n        # Add the character to the set (duplicates are ignored)\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    lowercase_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_characters = set(lowercase_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case and use a set to find distinct characters\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(s: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(s.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase to ignore case differences and create a set of characters\n    unique_chars = set(string.lower())\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    # Then use a set to store unique characters\n    unique_chars = set(string.lower())\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case and use a set to store distinct characters\n    distinct_chars = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    # Use a set to store distinct characters\n    distinct_chars = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    lower_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase to ignore case and use a set to find distinct characters\n    return len(set(string.lower()))", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(s: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case and then find distinct characters\n    distinct_chars = set(s.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 84.21307506053269, "dps_norm": 88.88888888888889, "pass@1": 97.0, "profiled": [{"solution": "from typing import List, Tuple\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Initialize the minimum distance and closest pair with very large distance and dummy values\n    min_distance = math.inf\n    closest_pair = (None, None)\n    \n    # Sort the list to ensure that potential closest elements are adjacent\n    numbers_sorted = sorted(numbers)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers_sorted) - 1):\n        current_distance = numbers_sorted[i + 1] - numbers_sorted[i]\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (numbers_sorted[i], numbers_sorted[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nfrom math import inf\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = inf\n    closest_pair = (0, 0)\n\n    # Sort the list to make finding the closest pair more efficient\n    sorted_numbers = sorted(numbers)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # First, sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    Find and return the two closest numbers in the provided list.\n\n    Args:\n    numbers: A list of floating-point numbers with at least two elements.\n\n    Returns:\n    A tuple containing the two closest numbers, ordered from smallest to largest.\n\n    Examples:\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n\n    # Iterate through the list to find the closest pair\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            current_diff = abs(numbers[j] - numbers[i])\n            if current_diff < smallest_diff:\n                smallest_diff = current_diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    # Return the closest pair as a tuple (smaller number, larger number)\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()  # Sort the numbers to make comparison easier\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n\n    for i in range(1, len(numbers) - 1):\n        current_diff = abs(numbers[i + 1] - numbers[i])\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    # Sort the list to make finding the closest elements easier\n    numbers.sort()\n\n    # Initialize variables to store the closest elements and the smallest difference found\n    closest_pair = (numbers[0], numbers[1])\n    smallest_difference = abs(numbers[1] - numbers[0])\n\n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(numbers) - 1):\n        current_difference = abs(numbers[i + 1] - numbers[i])\n        if current_difference < smallest_difference:\n            closest_pair = (numbers[i], numbers[i + 1])\n            smallest_difference = current_difference\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            current_diff = abs(numbers[j] - numbers[i])\n            if current_diff < smallest_diff:\n                smallest_diff = current_diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Initialize with the first two elements\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n    \n    # Iterate through each pair of elements to find the closest one\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[j] - numbers[i])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to simplify the process of finding the closest elements\n    sorted_numbers = sorted(numbers)\n    closest_distance = float('inf')\n    closest_pair = (0, 0)\n\n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < closest_distance:\n            closest_distance = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    :param numbers: List of numbers with at least two elements\n    :return: A tuple of two closest numbers, in ascending order\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i + 1] - numbers[i])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each other\n    and return them in order (smaller number, larger number).\n    \"\"\"\n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n    \n    # Sort the numbers to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = ()\n    smallest_diff = float('inf')\n    \n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    min_distance = abs(numbers[1] - numbers[0])\n\n    for i in range(1, len(numbers) - 1):\n        current_distance = abs(numbers[i + 1] - numbers[i])\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n    \n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i + 1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    Find and return two numbers from the supplied list that are closest to each other, in ascending order.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    # Sort the list to make it easier to find the closest elements\n    numbers.sort()\n\n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers) - 1):\n        current_diff = abs(numbers[i + 1] - numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            current_diff = abs(numbers[i] - numbers[j])\n            if current_diff < min_diff:\n                min_diff = current_diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_pair", "matching_cluster_idx": 3}]}, "HumanEval/24": {"dps": 72.04081632653062, "dps_norm": 31.25, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors other than 1 for numbers <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for divisor in range(n - 1, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return None  # In case n is 1, which has no divisors smaller than itself", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors for numbers less than or equal to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start from the largest possible divisor, which is n // 2\n    for divisor in range(n // 2, 0, -1):\n        # Check if n is divisible by the current divisor\n        if n % divisor == 0:\n            return divisor\n    # If no divisor is found, return 1 (every number is divisible by 1)\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found other than 1, return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n-1, 0, -1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            return i  # Return the first divisor found, which is the largest\n    return 1  # If no divisor found other than 1, return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "from typing import *\ndef largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for divisor in range(n - 1, 0, -1):\n        if n % divisor == 0:\n            return divisor", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, return 1 (for prime numbers)", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found other than 1, return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1 to find the largest divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1 to find the largest divisor\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 96.4, "dps_norm": 98.75, "pass@1": 25.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter numbers that occur more than once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Dictionary to track the count of each number\n    count = defaultdict(int)\n    # List to store numbers that occur only once\n    unique_numbers = []\n\n    # Count occurrences of each number\n    for number in numbers:\n        count[number] += 1\n\n    # Append numbers that occur only once to the result list\n    for number in numbers:\n        if count[number] == 1:\n            unique_numbers.append(number)\n\n    return unique_numbers", "matching_cluster_idx": 2}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use a dictionary to count occurrences of each number\n    count = defaultdict(int)\n    for num in numbers:\n        count[num] += 1\n    \n    # Filter out numbers that occur more than once and return the result\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a counter for all numbers in the list\n    number_counts = Counter(numbers)\n    \n    # Filter out numbers that appear more than once and return the result\n    return [num for num in numbers if number_counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a counter to keep track of the occurrence of each number\n    number_counter = Counter(numbers)\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if number_counter[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a counter for the elements in the list\n    element_count = Counter(numbers)\n    # Filter out elements that appear more than once and keep the order\n    unique_numbers = [num for num in numbers if element_count[num] == 1]\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    counts = defaultdict(int)\n    for number in numbers:\n        counts[number] += 1\n\n    # Filter out numbers that occur more than once and maintain the order\n    result = [number for number in numbers if counts[number] == 1]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to keep track of the occurrences of each number\n    occurrences = {}\n    \n    # Iterate over the list and count occurrences\n    for number in numbers:\n        if number in occurrences:\n            occurrences[number] += 1\n        else:\n            occurrences[number] = 1\n    \n    # Use list comprehension to filter out numbers that occur more than once\n    result = [number for number in numbers if occurrences[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count = Counter(numbers)\n    \n    # Filter out numbers that occur more than once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count = Counter(numbers)\n    # Filter numbers that occur only once and maintain order\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a counter to count occurrences of each number\n    counts = Counter(numbers)\n    # Filter numbers that occur only once and preserve the order\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    counts = Counter(numbers)\n    # Filter numbers that appear only once and preserve the order\n    unique_numbers = [num for num in numbers if counts[num] == 1]\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use a dictionary to count occurrences of each number\n    counts = defaultdict(int)\n    for number in numbers:\n        counts[number] += 1\n    \n    # Keep only numbers that occur exactly once\n    return [number for number in numbers if counts[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    counts = Counter(numbers)\n    # Filter numbers that occur more than once and maintain the original order\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n\n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\nfrom typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the count of each number\n    count = Counter(numbers)\n    # Filter numbers that occur only once and maintain their order\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    num_counts = Counter(numbers)\n    # Filter numbers that appear only once and preserve the original order\n    return [num for num in numbers if num_counts[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 88.10126582278481, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Check if the number is less than 2\n    if n <= 1:\n        return False\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    # Handle numbers less than 2 and even numbers directly\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return False\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return True  # 2 and 3 are prime numbers\n    \n    # Check if n is divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    # Check for factors from 5 to the square root of n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 92.60416666666667, "dps_norm": 80.9090909090909, "pass@1": 88.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    third_elements.sort()\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace the elements in the result list at indices divisible by three with the sorted elements\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = third_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(lst: list):\n    \"\"\"\n    This function takes a list and returns a new list where elements at indices divisible by three are sorted,\n    while other elements remain unchanged.\n    \n    :param lst: List of integers\n    :return: Modified list with sorted elements at indices divisible by three\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [lst[i] for i in range(len(lst)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Create a new list to store the result\n    result = lst[:]\n    \n    # Replace elements at indices divisible by three with sorted values\n    for i in range(len(divisible_by_three)):\n        result[i * 3] = divisible_by_three[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace elements in the result list at indices divisible by three with sorted elements\n    for i, value in enumerate(sorted_third_elements):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef sort_third(l: List[int]) -> List[int]:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    sorted_third = sorted(divisible_by_three)\n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at indices divisible by three with sorted elements\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(lst):\n    \"\"\"\n    This function takes a list and returns a new list where elements at indices divisible by three are sorted.\n    Other elements remain unchanged.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    elements_to_sort = [lst[i] for i in range(len(lst)) if i % 3 == 0]\n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    # Create a new list with sorted elements placed back at the correct positions\n    result_list = lst[:]\n    for i, value in enumerate(sorted_elements):\n        result_list[i * 3] = value\n    return result_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a copy of the list to modify\n    sorted_list = l[:]\n    # Extract elements at indices divisible by three\n    elements_to_sort = [sorted_list[i] for i in range(0, len(sorted_list), 3)]\n    # Sort these elements\n    elements_to_sort.sort()\n    # Replace the original elements with the sorted ones\n    for i, value in enumerate(elements_to_sort):\n        sorted_list[i * 3] = value\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    elements_to_sort.sort()\n    # Create a new list where sorted elements replace original elements at divisible by three indices\n    result = l[:]\n    for i, value in enumerate(elements_to_sort):\n        result[i * 3] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    # Sort the extracted elements\n    third_elements.sort()\n    \n    # Create a copy of the original list to modify\n    l_copy = l[:]\n    # Replace elements at indices divisible by three with sorted ones\n    for i, val in enumerate(third_elements):\n        l_copy[i * 3] = val\n    \n    return l_copy", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    to_sort.sort()\n    # Create a new list to store the result\n    l_prime = l[:]\n    # Replace elements at indices divisible by three with the sorted values\n    for i, value in enumerate(to_sort):\n        l_prime[i * 3] = value\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Replace the original elements with sorted ones at the same indices\n    result = l[:]\n    for i, value in enumerate(divisible_by_three):\n        result[i * 3] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l_prime = l[:]\n    l_div_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    l_div_by_three.sort()\n    for i, val in enumerate(l_div_by_three):\n        l_prime[i * 3] = val\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a copy of the original list to modify\n    result = l[:]\n    # Replace elements at indices divisible by three with sorted elements\n    for i, value in enumerate(sorted_elements):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    indices_div_by_three = [i for i, x in enumerate(l) if i % 3 == 0]\n    values_div_by_three = [l[i] for i in indices_div_by_three]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_div_by_three)\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace elements at indices divisible by three with sorted values\n    for i, value in zip(indices_div_by_three, sorted_values):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    divisible_by_three.sort()\n    \n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at indices divisible by three with sorted values\n    for i, value in enumerate(divisible_by_three):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    sorted_thirds = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    result = []\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(sorted_thirds[sorted_index])\n            sorted_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    third_elements.sort()\n    \n    # Create a new list to store the result\n    result = []\n    # Iterator for sorted elements\n    third_iter = iter(third_elements)\n    \n    for i in range(len(l)):\n        if i % 3 == 0:\n            # Append from sorted elements\n            result.append(next(third_iter))\n        else:\n            # Append the original element\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    Args:\n    l (list): The input list of integers.\n\n    Returns:\n    list: A new list where elements at indices divisible by three are sorted, while other elements remain unchanged.\n\n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    to_sort.sort()\n    # Create a new list with sorted elements at the correct positions\n    result = [to_sort.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]\n    return result", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    Sorts elements at indexes that are divisible by three in the given list.\n    Args:\n    l: A list of integers.\n    \n    Returns:\n    A list of integers with elements at indexes divisible by three sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these specific elements\n    divisible_by_three_sorted = sorted(divisible_by_three)\n    \n    # Create a new list where sorted elements are placed back at their original positions\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = divisible_by_three_sorted[sorted_index]\n            sorted_index += 1\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(lst):\n    \"\"\"\n    This function takes a list lst and returns a list lst' such that\n    lst' is identical to lst in the indices that are not divisible by three, while its values at the indices that are divisible by three\n    are equal to the values of the corresponding indices of lst, but sorted.\n    \n    Args:\n    lst (list): The input list to be modified.\n    \n    Returns:\n    list: The modified list with elements at indices divisible by three sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    \n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    elements_to_sort = [lst[i] for i in range(len(lst)) if i % 3 == 0]\n    \n    # Sort these elements\n    elements_to_sort.sort()\n    \n    # Create a copy of the original list to modify\n    sorted_list = lst[:]\n    \n    # Replace elements at indices divisible by three with sorted elements\n    for i, value in enumerate(elements_to_sort):\n        sorted_list[i * 3] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    sorted_indices = [i for i in range(len(l)) if i % 3 == 0]\n    values_at_sorted_indices = [l[i] for i in sorted_indices]\n    sorted_values = sorted(values_at_sorted_indices)\n    \n    result = l[:]\n    for i, value in zip(sorted_indices, sorted_values):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list\n    unique_elements = list(set(l))\n    # Sort the list before returning\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = list(set(l))  # Convert list to set to remove duplicates\n    unique_elements.sort()  # Sort the list\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list.\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert it back to a list\n    unique_elements = list(set(l))\n    # Sort the list before returning\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert list to a set to remove duplicates, then convert back to a sorted list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(l)\n    # Convert the set back to a list and sort it\n    sorted_unique_list = sorted(unique_elements)\n    return sorted_unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then sort the set and return\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then sort the result\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n\n    Args:\n        l (list): A list of elements.\n\n    Returns:\n        list: A sorted list of unique elements from the input list.\n\n    Examples:\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list\n    unique_elements = list(set(l))\n    # Sort the list and return\n    return sorted(unique_elements)", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then back to a sorted list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = list(set(l))\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = list(set(l))\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 87.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    # Initialize a counter to keep track of the occurrences of the digit '7'\n    count = 0\n    \n    # Iterate through numbers from 1 to n-1 (exclusive)\n    for i in range(1, n):\n        # Check if the current number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string to count occurrences of '7'\n            count += str(i).count('7')\n    \n    # Return the total count of '7's found\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Count how many times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Parameters:\n    n (int): The upper limit (exclusive) to search for numbers divisible by 11 or 13.\n    \n    Returns:\n    int: The total count of digit 7 appearances.\n    \"\"\"\n    count = 0\n    # Iterate through all numbers less than n\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to string and count the '7's\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    # Initialize a counter for the occurrences of the digit 7\n    count_of_sevens = 0\n    \n    # Iterate through all numbers less than n\n    for i in range(1, n):\n        # Check if the number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Convert the number to a string and count the occurrences of '7'\n            count_of_sevens += str(i).count('7')\n    \n    # Return the total count of the digit 7\n    return count_of_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Args:\n    n (int): The upper limit (exclusive) to search for numbers divisible by 11 or 13 containing the digit 7.\n\n    Returns:\n    int: The count of times the digit 7 appears in numbers less than n divisible by 11 or 13.\n\n    Examples:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: An integer representing the upper limit (exclusive) for checking numbers.\n    :return: The count of digit 7 appearances in numbers less than n divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 95.43371522094927, "dps_norm": 91.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[::2])\n    # Create a new list to store the result\n    result = l[:]\n    # Replace even-indexed elements in the result list with sorted elements\n    result[::2] = even_elements\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at even indices with sorted elements\n    for i, value in enumerate(even_elements):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    even_elements.sort()\n    # Create a new list to store the result\n    l_prime = l[:]\n    # Replace elements at even indices in the new list with sorted elements\n    for i, value in enumerate(even_elements):\n        l_prime[2*i] = value\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef sort_even(l: List[int]) -> List[int]:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Create a copy of the original list to modify\n    result = l[:]\n    \n    # Replace even-indexed elements in the result list with sorted values\n    for i, value in enumerate(even_elements):\n        result[2 * i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract the elements at even indices\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements.sort()\n    # Create a new list to store the result\n    result = []\n    even_index = 0\n    # Iterate over the original list\n    for i in range(len(l)):\n        # If the index is even, insert the sorted element\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            # If the index is odd, keep the original element\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_values = sorted(l[i] for i in range(0, len(l), 2))\n    l_prime = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        l_prime[i] = even_indices_values[even_index]\n        even_index += 1\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    even_elements.sort()\n    # Create a new list to store the result\n    result = []\n    even_index = 0\n    # Iterate over the original list\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Replace element at even index with sorted element\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            # Keep element at odd index unchanged\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract elements at even indices and sort them\n    even_elements = sorted(l[::2])\n    # Iterate over the list and replace elements at even indices with sorted ones\n    for i, value in enumerate(even_elements):\n        l[i * 2] = value\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the extracted elements\n    even_elements.sort()\n    \n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at even indices with sorted elements\n    result[::2] = even_elements\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the extracted elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace the elements at even indices with the sorted ones\n    j = 0\n    for i in range(0, len(result), 2):\n        result[i] = even_elements_sorted[j]\n        j += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    \n    # Reconstruct the list with sorted even-indexed elements and original odd-indexed elements\n    result = [even_elements[i // 2] if i % 2 == 0 else l[i] for i in range(len(l))]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the extracted elements\n    even_elements.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at even indices with sorted elements\n    for i, value in enumerate(even_elements):\n        result[2 * i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_indices_elements.sort()\n    \n    # Create a new list with the sorted even indices elements\n    l_prime = l.copy()\n    even_index = 0\n    for i in range(len(l_prime)):\n        if i % 2 == 0:\n            l_prime[i] = even_indices_elements[even_index]\n            even_index += 1\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the extracted elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a copy of the original list to modify\n    result = l[:]\n    \n    # Replace elements at even indices with sorted values\n    result[::2] = even_elements_sorted\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements.sort()\n    \n    # Create a new list to store the result\n    l_prime = l.copy()\n    # Replace elements at even indices with sorted elements\n    even_index = 0\n    for i in range(len(l_prime)):\n        if i % 2 == 0:\n            l_prime[i] = even_elements[even_index]\n            even_index += 1\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over the original list and construct the result list\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Append sorted even elements\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            # Append elements from the original list at odd indices\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Extract elements at even indices\n    even_indices_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_indices_elements.sort()\n    \n    # Create a new list to store the result\n    l_prime = l[:]\n    # Replace elements at even indices with sorted elements\n    for i, value in enumerate(even_indices_elements):\n        l_prime[i * 2] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract the values at even indices\n    even_values = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort these values\n    even_values.sort()\n    \n    # Create a new list to hold the result\n    l_prime = l[:]\n    # Replace the values at even indices in the result list with the sorted values\n    for i, value in enumerate(even_values):\n        l_prime[i * 2] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_values = sorted(l[i] for i in range(0, len(l), 2))\n    sorted_list = l[:]\n    for i, value in enumerate(even_indices_values):\n        sorted_list[2 * i] = value\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_values = sorted(l[::2])\n    l_prime = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        l_prime[i] = even_indices_values[even_index]\n        even_index += 1\n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 93.88235294117646, "dps_norm": 98.0, "pass@1": 77.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n using the built-in pow function which is optimized for this purpose\n    power_result = pow(2, n, p)\n    \n    # Return the result modulo p\n    return power_result % p", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n\n    power_result = 2 ** n\n    \n    # Calculate 2^n modulo p\n    mod_result = power_result % p\n    \n    return mod_result", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    # Calculate 2^n and then take modulo p\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Using Python's built-in pow function for modular exponentiation\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    # Using Python's built-in pow function with three arguments for efficient calculation\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n    n (int): The exponent to raise 2 by.\n    p (int): The modulo value.\n    \n    Returns:\n    int: The result of (2^n) % p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = pow(2, n, p)  # Utilizing Python's built-in pow function for efficient calculation\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent to raise 2 to.\n        p (int): The modulus.\n\n    Returns:\n        int: The result of (2^n) % p.\n\n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n using the pow function with three arguments for efficiency\n    # This also handles large exponents more gracefully by using modulo during exponentiation\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n and then take modulo p\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n % p using the built-in pow function which is efficient\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n modulo p using Python's built-in pow function with three arguments for efficiency\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    # Calculate 2^n\n    result = 2 ** n\n    # Compute result modulo p\n    return result % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n        n (int): The exponent to raise 2 by.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of 2^n mod p.\n    \n    Examples:\n        >>> modp(3, 5)\n        3\n        >>> modp(1101, 101)\n        2\n        >>> modp(0, 101)\n        1\n        >>> modp(3, 11)\n        8\n        >>> modp(100, 101)\n        1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n modulo p using Python's built-in pow function with three arguments\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Use Python's built-in pow function to compute (2^n) % p efficiently\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n\n    The function uses Python's built-in pow function with three arguments\n    for efficient computation of power modulo, which is more efficient\n    and numerically stable than manually calculating 2^n and then taking the modulo.\n\n    Args:\n    n (int): The exponent to which 2 is raised.\n    p (int): The modulus.\n\n    Returns:\n    int: The result of (2^n) % p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 91.42512077294685, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define a regular expression pattern to match vowels both lowercase and uppercase\n    vowel_pattern = re.compile('[aeiouAEIOU]')\n    \n    # Use the sub() method to replace all occurrences of the pattern with an empty string\n    return vowel_pattern.sub('', text)", "matching_cluster_idx": 1}, {"solution": "def remove_vowels(text):\n    # Define a string containing all vowels (both lowercase and uppercase)\n    vowels = 'aeiouAEIOU'\n    # Use a list comprehension to filter out vowels from the text\n    # and join the list back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    # Define a string containing all vowels in both lowercase and uppercase\n    vowels = \"aeiouAEIOU\"\n    # Use a list comprehension to filter out the vowels and join the result to form a new string\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define a string of vowels including both uppercase and lowercase\n    vowels = 'aeiouAEIOU'\n    # Use a generator expression to filter out vowels and join the result back into a string\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    # Define a string of vowels\n    vowels = \"aeiouAEIOU\"\n    # Use list comprehension to filter out vowels and join the result to form the new string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    # Define a set of vowels for quick lookup\n    vowels = set('aeiouAEIOU')\n    # Use a list comprehension to filter out vowels and join the result into a string\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \"\"\"\n    # Define a string containing all vowels in both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    # Use a generator expression to filter out vowels and join the result to form the new string\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define a string containing all vowel characters in both lower and upper case\n    vowels = \"aeiouAEIOU\"\n    # Use a list comprehension to filter out vowels and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    # Define a string of vowels including both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n    # Use a list comprehension to filter out vowels and join the result back into a string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    # Define a set of vowels for quick lookup\n    vowels = set('aeiouAEIOU')\n    \n    # Use a list comprehension to filter out vowels and join the result to form the new string\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    result = ''.join([char for char in text if char not in vowels])\n    return result", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 87.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings have the same characters, False otherwise.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "from typing import *\nfrom collections import *\ndef same_chars(s0: str, s1: str) -> bool:\n    # Create sets from the characters of both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Remove duplicates by converting the strings to sets\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Compare the sets to check if they have the same elements\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets of characters to remove duplicates\n    # and compare them for equality\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    :param s0: First word to compare.\n    :param s1: Second word to compare.\n    :return: True if both words have the same characters, False otherwise.\n    \"\"\"\n    # Using set to compare unique characters in both strings\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n    s0 (str): The first word to compare.\n    s1 (str): The second word to compare.\n\n    Returns:\n    bool: True if both words have the same characters, False otherwise.\n    \"\"\"\n    # Use set to compare unique characters in both strings\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first string to compare.\n    s1 (str): The second string to compare.\n    \n    Returns:\n    bool: True if both strings contain the same characters, False otherwise.\n    \"\"\"\n    # Create sets from both strings to remove duplicate characters and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets of characters and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Use set to remove duplicate characters and compare the length of the resulting sets\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    :param s0: First string to compare\n    :param s1: Second string to compare\n    :return: True if both strings have the same characters, False otherwise\n    \"\"\"\n    # Convert both strings to sets and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \n    Args:\n    s0 (str): The first word to compare.\n    s1 (str): The second word to compare.\n\n    Returns:\n    bool: True if both words have the same characters, False otherwise.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets of characters and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n    s0 (str): The first word.\n    s1 (str): The second word.\n\n    Returns:\n    bool: True if both words have the same characters, False otherwise.\n    \"\"\"\n    # Use set to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Use set to remove duplicates and compare the sorted lists of characters from both strings\n    return sorted(set(s0)) == sorted(set(s1))", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 89.11417322834646, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and convert the result to a sorted list\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set of common elements back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\ndef common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find the intersection of the two sets created from the lists\n    common_elements = set(l1).intersection(set(l2))\n    # Convert the set to a sorted list and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\ndef common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find the intersection\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Parameters:\n    l1 (list): The first input list.\n    l2 (list): The second input list.\n\n    Returns:\n    list: A sorted list of unique common elements.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to find the unique common elements\n    common_set = set(l1).intersection(l2)\n    # Return the sorted list of the common elements\n    return sorted(common_set)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom itertools import chain\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common_elements = set(chain(l1, l2))  # Combine both lists into one set\n    common_elements &= set(l1) & set(l2)  # Find the intersection of both sets\n    return sorted(list(common_elements))  # Return sorted list of common elements", "matching_cluster_idx": 2}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Use set intersection to find common elements and then sort the result\n    result = sorted(set(l1) & set(l2))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    common_elements = set(l1) & set(l2)\n    \n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set to a sorted list\n    sorted_common_elements = sorted(common_elements)\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    # Use set intersection to find common elements and then sort them\n    result = sorted(list(set(l1) & set(l2)))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements\n    common_elements = set(l1) & set(l2)\n    # Return sorted list of unique common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to find the common elements and remove duplicates\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements and remove duplicates\n    common_elements = set(l1) & set(l2)\n    # Return sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements and then sort them\n    common_elements = sorted(set(l1) & set(l2))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    common_elements = set(l1) & set(l2)\n    # Sort the common elements and return as a list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a list and sort it\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): The first list of integers.\n    l2 (list): The second list of integers.\n\n    Returns:\n    list: A sorted list of unique elements that are common to both input lists.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find unique elements and common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    common_set = set1.intersection(set2)\n    # Convert the set to a sorted list before returning\n    return sorted(common_set)", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 95.57291666666667, "dps_norm": 96.66666666666667, "pass@1": 95.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    factor = 2\n    last_factor = 1\n    \n    # Divide n by 2 until it's odd\n    while n % factor == 0:\n        last_factor = factor\n        n //= factor\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    max_factor = int(n**0.5) + 1\n    while factor <= max_factor:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n            max_factor = int(n**0.5) + 1\n        factor += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        last_factor = n\n    \n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n    # Initialize the largest prime factor\n    largest_prime = -1\n\n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    # n must be odd at this point, so we can skip even numbers in our loop\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n            last_factor = factor\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_prime = -1\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_prime = factor\n            n //= factor\n        factor += 2\n\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n            last_factor = factor\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest factor\n    largest_factor = None\n    \n    # Divide n by 2 until it becomes odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n becomes a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    Examples:\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            last_factor = factor\n            n //= factor\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Finding the largest prime factor\n    largest_factor = 1\n    for i in range(2, n + 1):\n        if n % i == 0 and is_prime(i):\n            largest_factor = max(largest_factor, i)\n    return largest_factor", "matching_cluster_idx": 2}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n    \n    return max(prime_factors(n))", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = None\n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i + 2)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_prime = -1\n\n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    # n must be odd at this point, so a skip of 2 (i += 2) can be used\n    factor = 3\n    while factor * factor <= n:\n        # While factor divides n, remove it and set largest_prime to factor\n        while n % factor == 0:\n            largest_prime = factor\n            n //= factor\n        factor += 2\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor\n    factor = 2\n    last_factor = 1\n    \n    # Divide n by the smallest factor as long as possible\n    while n % factor == 0:\n        last_factor = factor\n        n //= factor\n    \n    # Now n must be odd, start checking from 3 and step by 2\n    for factor in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n    \n    # If n is now reduced to a prime number greater than 2\n    if n > 2:\n        last_factor = n\n    \n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor to the lowest possible value\n    largest_prime = -1\n    \n    # Divide n by 2 to remove all even factors\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n    \n    # n must be odd at this point, so we can skip one element (Note i = i +2)\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, remove i and set largest_prime to i\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n    \n    return largest_prime", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 83.96103896103897, "dps_norm": 60.0, "pass@1": 78.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    s = s.lower()\n    # Define the set of vowels\n    vowels = set('aeiou')\n    # Initialize the vowel count\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = sum(1 for char in s if char.lower() in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Initialize the count of vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' or 'Y' and add to count if true\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set(\"aeiouAEIOU\")\n    # Initialize a counter for vowels\n    count = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    # Check if the last character is 'y' or 'Y' and add to count if true\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    # Initialize the vowel count\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' or 'Y' and consider it as a vowel\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to make the function case-insensitive\n    s = s.lower()\n    # Define the set of vowels\n    vowels = set('aeiou')\n    # Initialize the count of vowels\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to simplify matching\n    s = s.lower()\n    # Define the set of vowels\n    vowels = set('aeiou')\n    # Initialize the count of vowels\n    count = 0\n\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n\n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    This function takes a string s and returns the count of vowels in it.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' if it is the last character.\n    \"\"\"\n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Convert string to lowercase for uniformity\n    s = s.lower()\n    \n    # Initialize count of vowels\n    count = 0\n    \n    # Iterate through each character in the string\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        # Check for 'y' at the end of the word\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the vowels including 'y' as a special case\n    vowels = \"aeiouAEIOU\"\n    # Initialize a counter for vowels\n    count = 0\n\n    # Check each character in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    # Check if 'y' is at the end and is not preceded by another vowel\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    # Define the set of vowels including 'y' as a vowel only when it is at the end\n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' and consider it as a vowel\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    # Count each vowel in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' or 'Y'\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    # Define the set of vowels, including 'y' at the end\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    # Convert the input string to lowercase to handle case insensitivity\n    s = s.lower()\n    # Initialize the count of vowels\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Function to count the number of vowels in a given word.\n    Vowels are 'a', 'e', 'i', 'o', 'u', and 'y' if it is at the end of the word.\n    \"\"\"\n    # Define the set of vowels\n    vowels = set(\"aeiouAEIOU\")\n    # Initialize a counter for vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n        # Check if 'y' is at the end and treat it as a vowel\n        elif char == 'y' or char == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    \n    # Return the total count of vowels\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Counts the number of vowels in a given word.\n    Vowels are 'a', 'e', 'i', 'o', 'u'.\n    'y' is considered a vowel only if it is the last character of the word.\n    \"\"\"\n    # Define a set of vowels for easy checking\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Convert the input string to lowercase to handle mixed cases\n    s = s.lower()\n    \n    # Initialize a counter for vowels\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If the character is a vowel, increment the count\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y', and if so, increment the count\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set('aeiouAEIOU')\n    \n    # Initialize the count of vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' or 'Y' and count it as a vowel\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    # Initialize the count of vowels\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a vowel\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' or 'Y', it should be considered a vowel if it's at the end\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    \n    # Return the total count of vowels\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = set(\"aeiouAEIOU\")\n    # Initialize the count of vowels\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # If the character is a vowel, increment the count\n        if char in vowels:\n            count += 1\n    # Check if the last character is 'y' or 'Y' and it's not the only character\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    # Return the total count of vowels\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Count the number of vowels in a given word, considering 'y' as a vowel only if it is at the end of the word.\"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 93.46341463414635, "dps_norm": 87.77777777777777, "pass@1": 91.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of the first list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    # Calculate the total number of characters in all strings of the second list\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the list with fewer characters\n    # If both lists have the same number of characters, return the first list\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    This function takes two lists of strings and returns the list with the lesser total number of characters.\n    If both lists have the same total number of characters, it returns the first list.\n    \n    Parameters:\n    lst1 (List[str]): The first list of strings.\n    lst2 (List[str]): The second list of strings.\n    \n    Returns:\n    List[str]: The list with the lesser total number of characters or the first list if they are equal.\n    \"\"\"\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of lst1 and lst2\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total characters and return the list with fewer characters\n    # If both have the same number of characters, return the first list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    # Calculate the total number of characters in all strings of lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "from typing import *\nfrom collections import *\ndef total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the list with fewer characters\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    if total_chars(lst1) < total_chars(lst2):\n        return lst1\n    elif total_chars(lst1) > total_chars(lst2):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 5}, {"solution": "def total_match(lst1, lst2):\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare total characters and return the list with fewer or equal characters\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Returns the list with a total number of characters in all strings less than the other list.\n    Returns the first list if the total number of characters is the same in both lists.\n\n    Parameters:\n    lst1 (list of str): The first list of strings.\n    lst2 (list of str): The second list of strings.\n\n    Returns:\n    list of str: The list with fewer total characters or the first list if they are equal.\n    \"\"\"\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the list with fewer characters, or the first one if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the list with fewer characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        # Return the first list if both have the same number of characters\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate total number of characters in all strings of lst1\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    \n    # Calculate total number of characters in all strings of lst2\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the list with fewer characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1  # Return the first list if they have the same total number of characters", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of lst1 and lst2\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    # Compare the total characters and return the list with fewer characters\n    # If both lists have the same number of characters, return the first list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total characters and return the list with fewer characters or the first list if equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in all strings of each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 85.0, "dps_norm": 51.666666666666664, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to zero\n    total = 0\n    \n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is even\n        if lst[i] % 2 == 0:\n            # Add it to the total sum\n            total += lst[i]\n    \n    # Return the final sum\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "from typing import *\nfrom collections import *\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "from typing import *\nfrom collections import *\ndef add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 1 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    sum_even = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the sum\n            sum_even += value\n    \n    # Return the total sum of even elements at odd indices\n    return sum_even", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "from typing import *\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 != 0 and val % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize sum to store the result\n    result = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for i, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if i % 2 == 1 and value % 2 == 0:\n            # Add the value to the result\n            result += value\n    \n    # Return the final result\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    # Initialize the sum of even elements at odd indices\n    total_sum = 0\n    \n    # Iterate through the list with both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 == 1 and value % 2 == 0:\n            total_sum += value\n    \n    # Return the computed sum\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 != 0 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate through the list with index\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            result += lst[i]  # Add the even element at odd index to the result\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "from typing import *\nfrom collections import *\ndef add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 67.0, "profiled": [{"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words and iterate over them\n    return ' '.join([''.join(sorted(word)) for word in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the sentence into words\n    words = s.split(' ')\n    # Process each word\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the processed words back into a sentence\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    result = []\n    for word in s.split(' '):\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    # Process each word\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the processed words back into a single string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    \n    # Process each word\n    ordered_words = []\n    for word in words:\n        # Sort characters of the word in ascending order\n        sorted_word = ''.join(sorted(word))\n        # Append the sorted word to the list\n        ordered_words.append(sorted_word)\n    \n    # Join the sorted words back into a string with spaces\n    ordered_string = ' '.join(ordered_words)\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    ordered_words = [sort_word(word) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and iterate over them\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        # Sort the characters of the word in ascending order and join them back into a word\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back into a sentence with spaces and return\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words and spaces\n    words_and_spaces = s.split(' ')\n    # Initialize an empty list to store the ordered words\n    ordered_words = []\n    # Iterate over each element in the split list\n    for element in words_and_spaces:\n        # Check if the element is a space or a word\n        if element == '':\n            # If it's a space, simply append it to the ordered list\n            ordered_words.append(element)\n        else:\n            # If it's a word, sort its characters in ascending ASCII order\n            ordered_word = ''.join(sorted(element))\n            # Append the sorted word to the ordered list\n            ordered_words.append(ordered_word)\n    # Join the ordered list into a single string and return it\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the sentence into words\n    words = s.split(' ')\n    # Process each word\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the processed words back into a sentence\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the sentence into words\n    words = s.split(' ')\n    # Process each word\n    ordered_words = [''.join(sorted(word)) for word in words]\n    # Join the ordered words back into a sentence\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    # Process each word\n    ordered_words = []\n    for word in words:\n        # Sort characters of the word in ascending order\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    # Join the processed words back into a string with spaces\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n    ordered_words = []\n    \n    # Process each word\n    for word in words:\n        # Sort the characters in the word\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    # Join the ordered words back into a string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(\" \")\n    ordered_words = []\n    \n    for word in words:\n        ordered_word = \"\".join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    return \" \".join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 83.15561959654178, "dps_norm": 56.42857142857143, "pass@1": 97.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n    # Sort by rows in ascending order, and by columns in descending order within each row\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n    # Sort by row in ascending order and then by column in descending order within the same row\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    # Sort by rows in ascending order and by columns in descending order\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2D list 'lst' and an integer 'x', find all occurrences of 'x'\n    in the list and return a list of tuples (row, col) sorted by row in ascending\n    order and by column in descending order within the same row.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort by row in ascending order and then by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    # Iterate over rows and columns to find coordinates of x\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort by rows in ascending order and then by columns in descending order within each row\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2-dimensional list 'lst' and an integer 'x', this function finds all occurrences of 'x'\n    in 'lst', returns a list of tuples representing their coordinates in the format (row, column),\n    sorted initially by rows in ascending order and then by columns in descending order within the same row.\n    \"\"\"\n    result = []\n    # Enumerate through each row and column, starting from 0\n    for row_idx, row in enumerate(lst):\n        for col_idx, item in enumerate(reversed(row)):\n            if item == x:\n                # Adjust column index for the reversed row\n                adjusted_col_idx = len(row) - 1 - col_idx\n                result.append((row_idx, adjusted_col_idx))\n    \n    # Sort the result by row in ascending order and then by column in descending order within the same row\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a 2D list and an integer x as input. It returns a list of tuples\n    representing the coordinates (row, column) of all occurrences of x in the 2D list.\n    The list of tuples is sorted by row in ascending order and by column in descending order within each row.\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row[::-1]):  # Reversing the row to sort by columns in descending order\n            if value == x:\n                # Adjusting column index to reflect correct position before reversing\n                correct_col_index = len(row) - 1 - col_index\n                result.append((row_index, correct_col_index))\n    \n    result.sort(key=lambda item: (item[0], -item[1]))  # Sorting by row (ascending) and column (descending)\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the coordinates of integer x in a 2D list (matrix),\n    where each row may have a different number of columns.\n    \n    Parameters:\n    lst (list of list of int): The input 2D list.\n    x (int): The integer to find in the list.\n    \n    Returns:\n    list of tuple: A list of tuples, where each tuple represents\n    the (row, column) coordinates of x, sorted as specified.\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda x: (x[0], -x[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # List to store the result\n    result = []\n    # Iterate over rows in the nested list\n    for row_idx, row in enumerate(lst):\n        # Iterate over columns in the row\n        for col_idx, value in enumerate(reversed(row)):\n            # Check if the value is equal to x\n            if value == x:\n                # Append the tuple (row, column) to the result list\n                # Adjust the column index because of the reversal\n                result.append((row_idx, len(row) - 1 - col_idx))\n    # Sort the result list by row in ascending order and then by column in descending order\n    result.sort(key=lambda item: (item[0], -item[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate through the list to find the integer x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                # Append the coordinate to the list\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    This function takes a 2D list 'lst' and an integer 'x'. It returns a list of tuples\n    representing the coordinates of all occurrences of 'x' in 'lst'. The coordinates are\n    sorted first by row in ascending order, and then by column in descending order within each row.\n    \"\"\"\n    result = []\n    # Iterate over each row\n    for row_idx, row in enumerate(lst):\n        # Iterate over each column in the current row\n        for col_idx, value in enumerate(row):\n            # Check if the current value matches 'x'\n            if value == x:\n                # If it matches, add the coordinate to the result list\n                result.append((row_idx, col_idx))\n    # Sort the result list by row (ascending) and then by column (descending)\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        if x in row:\n            for j in range(len(row) - 1, -1, -1):\n                if row[j] == x:\n                    result.append((i, j))\n    return sorted(result, key=lambda item: (item[0], -item[1]))", "matching_cluster_idx": 5}, {"solution": "from typing import List, Tuple\ndef get_row(lst: List[List[int]], x: int) -> List[Tuple[int, int]]:\n    coordinates = []\n\n    # Iterate over each row\n    for row_idx, row in enumerate(lst):\n        # Reverse the row for descending column order when appended\n        for col_idx, value in enumerate(row[::-1]):\n            if value == x:\n                # Reverse the column index to match original order in the reversed row\n                original_col_idx = len(row) - col_idx - 1\n                coordinates.append((row_idx, original_col_idx))\n\n    # Sort by row in ascending order and then by column in descending order within the row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the coordinates of a given value in a 2D list and returns them sorted by row and column.\n    \"\"\"\n    # List to store the coordinates of the value x\n    coordinates = []\n    \n    # Iterate over the list with index to get row number\n    for row_index, row in enumerate(lst):\n        # Reverse the row to facilitate sorting by column in descending order later\n        row = row[::-1]\n        # Enumerate the row to get column index\n        for col_index, value in enumerate(row):\n            # Check if the current value is equal to x\n            if value == x:\n                # Calculate the actual column index in the original list\n                actual_col_index = len(row) - 1 - col_index\n                # Append the coordinate (row_index, actual_col_index) to the list\n                coordinates.append((row_index, actual_col_index))\n    \n    # Sort coordinates first by row in ascending order and then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    # Return the sorted list of coordinates\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order and then by columns in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(reversed(row)):\n            if value == x:\n                result.append((i, len(row) - 1 - j))\n    \n    # Sort by rows in ascending order and then by columns in descending order within each row\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import *\nfrom collections import *\ndef get_row(lst, x):\n    \"\"\"\n    Find the coordinates of x in the given 2D list.\n    \"\"\"\n    result = []\n    # Iterate through the list\n    for i, row in enumerate(lst):\n        # Find the indices of x in the current row\n        for j in range(len(row) - 1, -1, -1):\n            if row[j] == x:\n                result.append((i, j))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(reversed(row)):\n            if value == x:\n                result.append((i, len(row) - 1 - j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    # Iterate over the list with row index\n    for row_index, row in enumerate(lst):\n        # Iterate over the row with column index\n        for col_index, value in enumerate(reversed(row)):\n            # Check if the value matches x\n            if value == x:\n                # Calculate the actual column index from the reversed position\n                actual_col_index = len(row) - 1 - col_index\n                # Append the tuple of (row, column) to the result\n                result.append((row_index, actual_col_index))\n    # Sort the result first by row (ascending) and then by column (descending)\n    result.sort(key=lambda item: (item[0], -item[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Function to find coordinates of integer x in a 2D list.\n    Each row in the list may have a different number of columns.\n    \n    Args:\n    lst (list of lists of int): The 2D list to search through.\n    x (int): The integer to search for.\n    \n    Returns:\n    list of tuples: List of coordinates (row, column) for each occurrence of x.\n                    Sorted by rows in ascending order and columns in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list to find occurrences of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                # Append the coordinates to the list\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows ascending and by columns descending within each row\n    sorted_coordinates = sorted(coordinates, key=lambda x: (x[0], -x[1]))\n    \n    # Return the sorted list of coordinates\n    return sorted_coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.71391752577321, "dps_norm": 32.142857142857146, "pass@1": 97.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet by two multiplied to two places down the alphabet.\n    \n    Args:\n    s (str): The string to encrypt.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is an alphabet\n            shift = (2 * 2) % 26  # Calculate the shift amount\n            if char.islower():\n                # Rotate lowercase letters\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Rotate uppercase letters\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            # Non-alphabet characters are added unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Calculate the shift amount (2 * 2 = 4)\n            shift = 4\n            # Determine the ASCII offset (lowercase or uppercase)\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            # Calculate the new character code with wrap-around\n            new_char_code = (ord(char) - ascii_offset + shift) % 26 + ascii_offset\n            # Convert the new character code back to a character\n            new_char = chr(new_char_code)\n            result.append(new_char)\n        else:\n            # Non-alphabetic characters are not encrypted\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet by four places.\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string with the alphabet rotated by four places.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            shift = 4\n            if char.islower():\n                base = ord('a')\n            else:\n                base = ord('A')\n            encrypted_char = chr((ord(char) - base + shift) % 26 + base)\n            result.append(encrypted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "import string\ndef encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet and create a mapping for encrypted letters\n    alphabet = string.ascii_lowercase\n    encrypted_alphabet = alphabet[4:] + alphabet[:4]  # Shift by 4 places\n\n    # Create a dictionary for quick lookup of encrypted letters\n    encryption_dict = {original: encrypted for original, encrypted in zip(alphabet, encrypted_alphabet)}\n\n    # Encrypt the input string using the lookup dictionary\n    encrypted_string = ''.join([encryption_dict[char] if char in alphabet else char for char in s])\n\n    return encrypted_string", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    encrypted_string = \"\"\n\n    # Loop through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the index of the character in the alphabet\n            index = alphabet.index(char)\n            # Calculate the new index with the rotation\n            new_index = (index + (2 * 2)) % len(alphabet)\n            # Append the rotated character to the result string\n            encrypted_string += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, append it unchanged\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet. \n    Each letter in the string is replaced by the letter that is two multiplied by two places down the alphabet.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                start = ord('a')\n            else:\n                start = ord('A')\n            encrypted_char = chr((ord(char) - start + shift) % 26 + start)\n            result += encrypted_char\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Initialize the encrypted string\n    encrypted_string = ''\n    # Iterate through each character in the input string\n    for char in s:\n        # Check if the character is in the alphabet\n        if char in alphabet:\n            # Find the new position of the character\n            new_position = (alphabet.index(char) + (2 * 2)) % 26\n            # Append the new character to the encrypted string\n            encrypted_string += alphabet[new_position]\n        else:\n            # If the character is not in the alphabet, leave it as it is\n            encrypted_string += char\n    # Return the encrypted string\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypt a string by rotating the alphabet by four places.\n    \n    Args:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():  # Check if the character is a letter\n            shift = 4\n            if char.islower():\n                base = ord('a')\n            else:\n                base = ord('A')\n            encrypted_char = chr((ord(char) - base + shift) % 26 + base)\n            result += encrypted_char\n        else:\n            result += char  # Non-alphabet characters are not encrypted\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet down by two multiplied to two places.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    encrypted_string = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = (2 * 2) % 26  # Shift by 4 places\n            index = alphabet.index(char.lower())\n            shifted_index = (index + shift) % 26\n            if char.isupper():\n                encrypted_string += alphabet[shifted_index].upper()\n            else:\n                encrypted_string += alphabet[shifted_index]\n        else:\n            encrypted_string += char  # Non-alphabetic characters remain unchanged\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_string = ''\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            encrypted_char = chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n            encrypted_string += encrypted_char\n        else:\n            encrypted_string += char\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Initialize the encrypted string\n    encrypted = ''\n    # Iterate through each character in the input string\n    for char in s:\n        # Check if the character is in the alphabet\n        if char in alphabet:\n            # Find the index of the character in the alphabet\n            index = alphabet.index(char)\n            # Calculate the new index with the specified shift\n            new_index = (index + 2 * 2) % 26\n            # Append the encrypted character to the encrypted string\n            encrypted += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, append it unchanged\n            encrypted += char\n    # Return the encrypted string\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    \n    # Function to rotate a character\n    def rotate_char(c):\n        if c in alphabet:\n            return alphabet[(alphabet.index(c) + (2 * 2)) % 26]\n        else:\n            return c\n    \n    # Encrypt each character in the input string\n    for char in s:\n        encrypted += rotate_char(char)\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"  # Initialize an empty string to store the result\n    for char in s:  # Iterate through each character in the input string\n        if char.isalpha():  # Check if the character is a letter\n            shift = 2 * 2  # Define the shift amount\n            # Shift character forward and wrap around the alphabet using modulo\n            if char.islower():\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            result += char  # If not a letter, add the character as is\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Calculate the shift amount\n            shift = (2 * 2) % 26\n            if char.islower():\n                # Encrypt lowercase letters\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Encrypt uppercase letters\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            # If not a letter, add the character as it is\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                start = ord('a')\n            else:\n                start = ord('A')\n            encrypted_char = chr((ord(char) - start + shift) % 26 + start)\n            result.append(encrypted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "import string\ndef encrypt(s):\n    # Define the alphabet and the alphabet rotated by 2*2=4 places\n    alphabet = string.ascii_lowercase\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Create a translation table for encryption\n    table = str.maketrans(alphabet, shifted_alphabet)\n    \n    # Return the encrypted string\n    return s.translate(table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                encrypted += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encrypted += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_text = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            ascii_offset = 65 if char.isupper() else 97\n            # Calculate the new character, wrapping around the alphabet if necessary\n            new_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            encrypted_text += new_char\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = (2 * 2) % 26  # Rotating the alphabet by 4 places\n            if char.islower():\n                result += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                result += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 83.96887159533074, "dps_norm": 57.5, "pass@1": 96.0, "profiled": [{"solution": "from typing import List, Optional\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Returns the 2nd smallest element in the list.\n    If there is no such element, returns None.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Initialize the smallest and second smallest with infinity\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            # Update the second smallest before updating the smallest\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "from typing import List, Optional\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Find the second smallest element in a list of integers.\n    Returns None if there is no such element.\n    \"\"\"\n    unique_elements = list(set(lst))  # Remove duplicates\n    if len(unique_elements) < 2:\n        return None\n    unique_elements.sort()  # Sort elements\n    return unique_elements[1]  # Return the second smallest element", "matching_cluster_idx": 6}, {"solution": "from typing import *\nfrom collections import *\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in the list or None if it doesn't exist.\n    \"\"\"\n    # Remove duplicates by converting to set, then back to list\n    unique_lst = list(set(lst))\n    # Sort the list\n    unique_lst.sort()\n    # Check if there is at least two unique elements\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]  # Return the second smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    \n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates to handle cases like [1, 1]\n    unique_lst = list(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list to find the 2nd smallest element\n    unique_lst.sort()\n    \n    # Return the 2nd element in the sorted list\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Convert the list to a set to remove duplicates and then back to a sorted list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Return the 2nd smallest element if it exists, otherwise return None\n    return sorted_unique_lst[1] if len(sorted_unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    \n    unique_elements.sort()\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set, then back to a sorted list\n    unique_sorted_list = sorted(set(lst))\n    # Check if there are at least two unique elements\n    if len(unique_sorted_list) < 2:\n        return None\n    # Return the second smallest element\n    return unique_sorted_list[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Check if the list has less than 2 unique elements\n    if len(set(lst)) < 2:\n        return None\n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    # Return the second smallest element\n    return sorted_unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "from typing import *\nfrom collections import *\ndef next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    unique_sorted_lst = sorted(set(lst))\n    if len(unique_sorted_lst) < 2:\n        return None\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in the list, or None if it doesn't exist.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Remove duplicates to ensure we are looking for the actual 2nd smallest distinct number\n    unique_elements = list(set(lst))\n    if len(unique_elements) < 2:\n        return None\n\n    # Sort the unique elements to find the 2nd smallest\n    unique_elements.sort()\n\n    # Return the 2nd smallest element\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element in the list, or None if it doesn't exist.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Convert list to a set to remove duplicates and then back to a sorted list\n    sorted_unique = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(sorted_unique) < 2:\n        return None\n    \n    # Return the second smallest element\n    return sorted_unique[1]", "matching_cluster_idx": 6}, {"solution": "from typing import List, Optional\ndef next_smallest(lst: List[int]) -> Optional[int]:\n    \"\"\"\n    Return the 2nd smallest element in the list if it exists, otherwise return None.\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    return unique_elements[1] if len(unique_elements) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    This function finds the 2nd smallest element in a list of integers.\n    If the list is empty or all elements are the same, it returns None.\n    \n    :param lst: List of integers\n    :return: The 2nd smallest element or None\n    \"\"\"\n    unique_elements = list(set(lst))  # Remove duplicates\n    if len(unique_elements) < 2:\n        return None  # Not enough unique elements for a 2nd smallest\n    unique_elements.sort()  # Sort the unique elements\n    return unique_elements[1]  # Return the 2nd smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Convert list to a set to remove duplicates and then back to a sorted list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    # Return the second smallest element\n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted_list = sorted(set(lst))\n    \n    # Check if there is at least two unique elements\n    if len(unique_sorted_list) < 2:\n        return None\n    \n    # Return the second smallest element\n    return unique_sorted_list[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 94.32048681541582, "dps_norm": 64.16666666666667, "pass@1": 91.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits,\n    return a list where each element is a sentence that describes the number\n    of odd digits in each string of the input list.\n    \n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for number_str in lst:\n        odd_count = sum(1 for char in number_str if int(char) % 2 == 1)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for num_str in lst:\n        odd_count = sum(1 for char in num_str if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for num_str in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in num_str if int(char) % 2 != 0)\n        # Replace all occurrences of 'i' with the count of odd digits and add to the result list\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # Define a function to count odd digits in a string\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    # Apply the count_odd_digits function to each string in the list\n    result = []\n    for i, string in enumerate(lst, start=1):\n        odd_count = count_odd_digits(string)\n        # Replace all occurrences of 'i' with the count of odd digits\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Parameters:\n    lst (list): A list of strings, each containing only digits.\n\n    Returns:\n    list: A list of strings with the specified transformation.\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        transformed_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(transformed_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for item in lst:\n        odd_count = sum(1 for char in item if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, num_str in enumerate(lst, start=1):\n        odd_count = sum(1 for digit in num_str if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # Define a helper function to count odd digits in a string\n    def count_odd(s):\n        return sum(1 for char in s if int(char) % 2 == 1)\n    \n    # Apply the helper function to each string in the input list\n    result = []\n    for s in lst:\n        odd_count = count_odd(s)\n        # Replace all 'i's in the template string with the odd count\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, number_string in enumerate(lst, start=1):\n        odd_count = sum(1 for char in number_string if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        count_odd = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # Function to count odd digits in a string\n    def count_odd_in_string(s):\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        return count\n\n    # Generate the output list\n    result = []\n    for s in lst:\n        count = count_odd_in_string(s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        modified_string = string.replace(str(odd_count), str(odd_count) + 'n')\n        modified_string = modified_string.replace(str(odd_count), str(odd_count) + 'ng ' + str(odd_count))\n        modified_string = modified_string.replace(str(odd_count), str(odd_count) + ' of ')\n        modified_string = modified_string.replace(str(odd_count), str(odd_count) + 'nput.')\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    # Helper function to count odd digits in a string\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 == 1)\n\n    # Generate the output list with the required format\n    result = [\n        f\"the number of odd elements {count_odd_digits(s)}n the str{count_odd_digits(s)}ng {count_odd_digits(s)} of the {count_odd_digits(s)}nput.\"\n        for s in lst\n    ]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 == 1)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        modified_string = s.replace(str(odd_count), 'n')\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for item in lst:\n        odd_count = sum(1 for digit in item if int(digit) % 2 != 0)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # Function to count odd digits in a string\n    def count_odd_in_string(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    # Generate the output list\n    result = []\n    for index, string in enumerate(lst):\n        odd_count = count_odd_in_string(string)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for num_str in lst:\n        odd_count = sum(1 for digit in num_str if int(digit) % 2 != 0)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if int(char) % 2 == 1)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    Check if it's possible to concatenate two strings of parentheses in some order to form a balanced string.\n    A string is balanced if all parentheses are properly closed and opened.\n\n    :param lst: List containing two strings of parentheses\n    :return: 'Yes' if a balanced string can be formed, 'No' otherwise\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    # Try concatenating in both possible orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    # Concatenate in both possible orders\n    combined1 = lst[0] + lst[1]\n    combined2 = lst[1] + lst[0]\n    \n    # Check if either combined string is good\n    if is_good(combined1) or is_good(combined2):\n        return 'Yes'\n    else:\n        return 'No'\ndef is_good(s):\n    # Initialize counter for open parentheses\n    open_count = 0\n    for char in s:\n        if char == '(':\n            open_count += 1\n        elif char == ')':\n            open_count -= 1\n            # If open count goes negative, parentheses are not balanced\n            if open_count < 0:\n                return False\n    # If open count is zero, parentheses are balanced\n    return open_count == 0", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if it is possible to concatenate two strings in some order to form a balanced string of parentheses.\n    \n    :param lst: List of two strings, each containing only '(' or ')'.\n    :return: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    # Function to check if a string of parentheses is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both concatenations\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    # Check if either concatenation results in a balanced string\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    # Check if concatenating in both possible orders results in a balanced string\n    return 'Yes' if is_balanced(str1 + str2) or is_balanced(str2 + str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    first_combination = lst[0] + lst[1]\n    second_combination = lst[1] + lst[0]\n    if is_balanced(first_combination) or is_balanced(second_combination):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    \"\"\"\n    Checks if concatenating two strings in any order can result in a balanced parentheses string.\n    \n    Args:\n    lst (list): A list containing two strings made up of '(' and ')' characters.\n    \n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    \"\"\"\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    if is_balanced(str1 + str2) or is_balanced(str2 + str1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    combined1 = lst[0] + lst[1]\n    combined2 = lst[1] + lst[0]\n    \n    # Check if either combination is balanced\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Concatenate in both possible orders\n    first_order = lst[0] + lst[1]\n    second_order = lst[1] + lst[0]\n    \n    # Check if either concatenated string is balanced\n    if is_balanced(first_order) or is_balanced(second_order):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # Helper function to check if a string has balanced parentheses\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try concatenating in both possible orders\n    first_order = lst[0] + lst[1]\n    second_order = lst[1] + lst[0]\n\n    # Check if either order results in a balanced string\n    if is_balanced(first_order) or is_balanced(second_order):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    first_order = lst[0] + lst[1]\n    second_order = lst[1] + lst[0]\n    if is_balanced(first_order) or is_balanced(second_order):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    \"\"\"\n    Checks if it is possible to concatenate two strings in some order to form a balanced parentheses string.\n    \n    Args:\n    lst (list of str): A list containing two strings composed only of '(' and ')'.\n    \n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    \"\"\"\n    # Function to check if a string has balanced parentheses\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    # Return 'Yes' if either concatenation is balanced, otherwise 'No'\n    return 'Yes' if is_balanced(concat1) or is_balanced(concat2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    \"\"\"\n    Check if concatenating two strings in some order results in a balanced parentheses string.\n\n    Args:\n    lst: A list of two strings, each containing only '(' or ')'.\n\n    Returns:\n    'Yes' if a balanced string can be formed, 'No' otherwise.\n    \"\"\"\n    # Try both possible concatenations\n    for order in [lst, lst[::-1]]:\n        balance = 0\n        for char in order[0] + order[1]:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            # If balance goes negative, parentheses are not balanced\n            if balance < 0:\n                break\n        # If balance is zero after processing both strings, they are balanced\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    \"\"\"\n    Check if two strings consisting only of '(' or ')' can be concatenated in\n    some order to form a balanced parentheses string.\n    \n    :param lst: List of two strings\n    :return: 'Yes' if a balanced string can be formed, 'No' otherwise\n    \"\"\"\n    def is_balanced(s):\n        \"\"\"Check if the given string is balanced.\"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    # Helper function to check if a string has balanced parentheses\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    concatenation1 = lst[0] + lst[1]\n    concatenation2 = lst[1] + lst[0]\n\n    # Return 'Yes' if either concatenation results in a balanced string\n    if is_balanced(concatenation1) or is_balanced(concatenation2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        # Check if the parentheses in the string are balanced\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try concatenating in both possible orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if it is possible to concatenate two strings from the list in some order\n    to form a balanced parentheses string.\n\n    :param lst: List of two strings containing only '(' and ')'.\n    :return: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    combined1 = lst[0] + lst[1]\n    combined2 = lst[1] + lst[0]\n    return 'Yes' if is_balanced(combined1) or is_balanced(combined2) else 'No'", "matching_cluster_idx": 4}, {"solution": "from typing import *\nfrom collections import *\ndef match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1 = lst[0]\n    str2 = lst[1]\n\n    # Check both concatenations\n    concat1 = str1 + str2\n    concat2 = str2 + str1\n\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it is possible to concatenate two strings in some order\n    to form a balanced parentheses string.\n    '''\n    # Importing the deque class from collections module for efficient list operations\n    from collections import deque\n    \n    # Function to check if a string has balanced parentheses\n    def is_balanced(s):\n        stack = deque()\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n    \n    # Concatenate the strings in both possible orders and check for balance\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 96.63793103448276, "dps_norm": 97.85714285714286, "pass@1": 39.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n\n    if k == 0:\n        return []\n\n    # Sort the array in descending order and take the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n\n    # Return the sorted list of the k largest elements\n    return sorted(sorted_arr)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    This implementation uses Python's built-in functions to sort the array and then slice \n    the top k elements.\n\n    Parameters:\n        arr (List[int]): The list of integers.\n        k (int): The number of top elements to return.\n\n    Returns:\n        List[int]: A sorted list of the maximum k elements in arr.\n    \"\"\"\n    # Edge case: if k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    arr.sort()\n    \n    # Return the last k elements from the sorted array, which are the largest k elements\n    return arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order to get the maximum elements at the beginning\n    arr.sort(reverse=True)\n    # Return the first k elements and then sort them in ascending order to meet the requirement\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n    # Sort the array in descending order and take the first k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    # Return the first k elements sorted in ascending order\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \n    Args:\n    arr (List[int]): The array of integers.\n    k (int): The number of maximum elements to return.\n    \n    Returns:\n    List[int]: A sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is 0 or arr is empty, return an empty list\n    if k == 0 or not arr:\n        return []\n    \n    # Sort the array in descending order to get the maximum elements at the start\n    arr.sort(reverse=True)\n    \n    # Return the first k elements and sort them to meet the problem's requirement\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Return the first k elements of the sorted array, sorted again in ascending order\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order and take the first k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the maximum k elements\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \n    The function uses Python's built-in sorting method to sort the array in \n    descending order and then returns the first k elements, which are the largest \n    ones. Finally, it sorts these k elements in ascending order before returning \n    them as the output.\n    \n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Select the first k elements\n    top_k = sorted_arr[:k]\n    # Sort the selected elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order to get the largest elements at the beginning\n    sorted_arr = sorted(arr, reverse=True)\n    # Slice the first k elements and then sort the result in ascending order\n    result = sorted(sorted_arr[:k])\n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    :param arr: List[int] - The array of integers.\n    :param k: int - The number of maximum elements to return.\n    :return: List[int] - A sorted list of the maximum k numbers.\n    \"\"\"\n    # Sort the array in descending order and select the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    # Return these elements sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Check if k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Slice the first k elements and sort them in ascending order before returning\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order and take the first k elements\n    top_k = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the top k elements\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    # Return the first k elements and sort them in ascending order before returning\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order and take the first k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the first k maximum elements\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \n    This function first sorts the array in descending order, then takes the first k\n    elements and returns them sorted in ascending order as the result.\n    \n    :param arr: List[int] - A list of integers\n    :param k: int - The number of maximum elements to return\n    :return: List[int] - A sorted list containing the maximum k elements from the input array\n    \"\"\"\n    # Check if k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Take the first k elements\n    top_k = arr[:k]\n    \n    # Return the k elements sorted in ascending order\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and then take the first k elements\n    max_elements = sorted(arr, reverse=True)[:k]\n    # Return the result sorted in ascending order\n    return sorted(max_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Return a sorted list of length k with the maximum k numbers in arr.\n\n    Args:\n    arr (list of int): The list of integers.\n    k (int): The number of maximum elements to return.\n\n    Returns:\n    list of int: The sorted list of k maximum elements.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    result = sorted(arr, reverse=True)[:k]\n    # Return the sorted result\n    return sorted(result)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n\n    # Use a min-heap to keep track of the k largest elements\n    from heapq import nlargest\n    largest_k = nlargest(k, arr)\n    \n    # Sort the list of largest k elements\n    largest_k.sort()\n    \n    return largest_k", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Return the first k elements and sort them in ascending order before returning\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    top_k = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the top k elements\n    return sorted(top_k)", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 84.88789237668162, "dps_norm": 63.57142857142858, "pass@1": 74.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum to 0\n    sum_odd = 0\n    \n    # Iterate over the list with index\n    for i in range(len(lst)):\n        # Check if the position is even and the element is odd\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum_odd += lst[i]\n    \n    return sum_odd", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(val for i, val in enumerate(lst) if i % 2 == 0 and val % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to 0\n    sum_odd_even_positions = 0\n    \n    # Iterate over the list with index\n    for i in range(len(lst)):\n        # Check if the position is even and the element is odd\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum_odd_even_positions += lst[i]\n    \n    # Return the sum\n    return sum_odd_even_positions", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total = 0\n    # Iterate over the list, considering only the even positions (0-indexed, so step by 2)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current even position is odd\n        if lst[i] % 2 != 0:\n            # Add it to the total sum\n            total += lst[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize the sum to 0\n    total = 0\n    # Iterate over the list with index\n    for i in range(0, len(lst), 2):  # Start from 0 to consider even positions\n        if lst[i] % 2 != 0:  # Check if the number is odd\n            total += lst[i]  # Add to the total if it's odd\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    # Initialize the sum to zero\n    sum_odd_even_positions = 0\n    \n    # Iterate through the list, considering only even positions (0-based index)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            # Add it to the sum\n            sum_odd_even_positions += lst[i]\n    \n    # Return the final sum\n    return sum_odd_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    # Return the total sum of odd elements at even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list, considering only even positions (0-indexed)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            # Add it to the total sum\n            total_sum += lst[i]\n    \n    # Return the computed sum\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to 0\n    sum_odd = 0\n    \n    # Iterate over the list, considering only even positions (0-indexed)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    # Return the total sum of odd elements at even positions\n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total = 0\n    # Iterate over the list, considering only even positions (0-indexed)\n    for index in range(0, len(lst), 2):\n        # Check if the element at the current even position is odd\n        if lst[index] % 2 != 0:\n            # Add it to the total sum\n            total += lst[index]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(val for idx, val in enumerate(lst) if idx % 2 == 0 and val % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to zero\n    sum_odd = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the position is even and the number is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the odd number to the sum\n            sum_odd += value\n    \n    # Return the final sum of odd numbers in even positions\n    return sum_odd", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    sum_odd = 0\n    for i in range(0, len(lst), 2):  # Iterate through even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            sum_odd += lst[i]\n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    # Return the total sum of odd elements in even positions\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate over the list, considering only even positions (indices)\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]  # Add to total sum\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    # Initialize the sum of odd elements in even positions to 0\n    odd_sum = 0\n    # Iterate over the list, considering the index\n    for i in range(len(lst)):\n        # Check if the index is even and the element is odd\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            odd_sum += lst[i]\n    # Return the calculated sum\n    return odd_sum", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by the length of the words, and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for words of the same length\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings in ascending order by length.\n    If two strings have the same length, sorts them alphabetically.\n    Removes strings with odd lengths before sorting.\"\"\"\n    # Filter out strings with odd lengths\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(even_length_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by the length of the strings, and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function removes strings with odd lengths from a list and returns a sorted list.\n    The list is sorted by word length in ascending order. If two words have the same length,\n    they are sorted alphabetically.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by word length, and then alphabetically\n    even_length_lst.sort(key=lambda x: (len(x), x))\n    \n    return even_length_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for words of the same length\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for words of the same length\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, and then alphabetically for words of the same length\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length of words, then alphabetically\n    sorted_lst = sorted(even_length_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length of words, then alphabetically for words of the same length\n    even_length_lst.sort(key=lambda x: (len(x), x))\n    \n    return even_length_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out words with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length of words, and then alphabetically if lengths are equal\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n    \"\"\"Sort a list of strings based on their lengths, and remove strings with odd lengths.\n\n    Args:\n        lst (List[str]): A list of strings.\n\n    Returns:\n        List[str]: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by word length, and then alphabetically\n    even_length_words.sort(key=lambda x: (len(x), x))\n    \n    return even_length_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by the length of each word, and alphabetically for words of the same length\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(even_length_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef sorted_list_sum(lst: List[str]) -> List[str]:\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Sorts a list of strings after removing those with odd lengths and returns the list sorted by word length and alphabetically.\"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by word length, and alphabetically if lengths are equal\n    even_length_words.sort(key=lambda word: (len(word), word))\n    \n    return even_length_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter, deletes\n    the strings that have odd lengths from it, and returns the resulted list\n    with a sorted order. The list is always a list of strings and never an\n    array of numbers, and it may contain duplicates. The order of the list\n    should be ascending by length of each word, and you should return the list\n    sorted by that rule. If two words have the same length, sort the list\n    alphabetically. The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out words with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 57.58474576271186, "dps_norm": 74.375, "pass@1": 85.0, "profiled": [{"solution": "def is_not_prime(n):\n    # Check if the number is less than or equal to 1, which are not prime\n    if n <= 1:\n        return True\n    \n    # Check divisibility from 2 up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    # If the number is less than 2, it is not prime\n    if num < 2:\n        return True\n    # If the number is 2, it is prime\n    if num == 2:\n        return False\n    # If the number is divisible by any number up to its square root, it is not prime\n    if num % 2 == 0:\n        return True\n    # Check for factors from 3 to the square root of num\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    # Check if the number is less than or equal to 1\n    if num <= 1:\n        return True\n    # Check for factors from 2 to the square root of num\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    # Check if the number is less than 2, which is not considered a prime number\n    if num < 2:\n        return True\n    # Check if the number is divisible by any number from 2 to its square root\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    # If no divisors were found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than or equal to 1, which is not prime\n    if n <= 1:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        # If n is divisible by any number in the range, it is not prime\n        if n % i == 0:\n            return True\n    # If no divisors found, n is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    # Check if the number is less than 2\n    if num < 2:\n        return True\n    # Check for factors from 2 to the square root of num\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # A number is non-prime if it is divisible by any number other than 1 and itself\n    if (n == 0 or n == 1):\n        return True\n    for x in range(2, n):\n        if n % x == 0:\n            return True\n    return False", "matching_cluster_idx": 0}, {"solution": "import math\ndef is_not_prime(x):\n    # If the number is less than or equal to 1, it is not prime\n    if x <= 1:\n        return True\n    # Check divisibility from 2 up to the square root of x\n    for i in range(2, int(math.sqrt(x)) + 1):\n        # If divisible by any number, it is not prime\n        if x % i == 0:\n            return True\n    # If not divisible by any number, it is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if n is less than 2, which is not a prime number\n    if n < 2:\n        return True\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        # If n is divisible by any number within this range, it is not prime\n        if n % i == 0:\n            return True\n    # If no factors are found, n is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    # Check if the number is less than 2\n    if num < 2:\n        return True\n    # Check if the number is divisible by any number from 2 to the square root of the number\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return True\n    # If the number is not divisible by any number, it is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if n is less than or equal to 1, which are not prime numbers\n    if n <= 1:\n        return True\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        # If a factor is found, n is not a prime number\n        if n % i == 0:\n            return True\n    # If no factors are found, n is a prime number\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # A number less than 2 is not prime\n    if n < 2:\n        return True\n    # Check divisibility from 2 up to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2, which are not prime\n    if n <= 1:\n        return True\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    # If no factors are found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(x):\n    # Check if the number is less than 2\n    if x < 2:\n        return True\n    # Check for factors from 2 to the square root of x\n    for n in range(2, int(x**0.5) + 1):\n        if x % n == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2\n    if n < 2:\n        return True\n    # Check if the number is divisible by any number from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    # If no divisors are found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_not_prime(x):\n    # If x is less than 2, it is not a prime number\n    if x < 2:\n        return True\n    # Check divisibility from 2 up to the square root of x\n    for i in range(2, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check for non-prime by attempting division from 2 to the square root of n\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    # Check if the number is less than 2, which is not a prime number\n    if num < 2:\n        return True\n    # Check for factors from 2 to the square root of num\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(x):\n    # Check if the number is less than 2, as 0 and 1 are not prime numbers\n    if x <= 1:\n        return True\n    # Check divisibility from 2 up to the square root of x\n    for n in range(2, int(x**0.5) + 1):\n        if x % n == 0:\n            # If divisible, return True indicating x is not prime\n            return True\n    # If not divisible by any number other than 1 and itself, return False\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check for non-prime numbers by testing divisibility\n    if n <= 1:\n        return True  # 1 and negative numbers are not prime\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # check for divisibility by numbers of the form 6k \u00b1 1\n        i += 6\n    return False  # no divisors found, number is prime", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.46075085324232, "dps_norm": 84.16666666666666, "pass@1": 87.0, "profiled": [{"solution": "def heap_queue_largest(nums, n):\n    # Import the heapq module to work with heap queues\n    import heapq\n    \n    # Find the n largest numbers in the list using heapq's nlargest function\n    largest_nums = heapq.nlargest(n, nums)\n    \n    # Return the largest numbers in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq's nlargest method to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Using nlargest from heapq to find the n largest elements and sorting them in descending order\n    largest_nums = heapq.nlargest(n, nums)\n    largest_nums.sort(reverse=True)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(list1, n):\n    # Using heapq.nlargest to find the n largest numbers in the list and sorting them in descending order\n    largest_nums = heapq.nlargest(n, list1)\n    # Returning the sorted list\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest elements\n    largest_nums = hq.nlargest(n, nums)\n    # Return the largest elements sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Using nlargest method from heapq to get the n largest elements\n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums  # Returning the n largest numbers in descending order", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers and return them in descending order\n    return hq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use the heapq.nlargest function to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the list of largest elements sorted in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use the nlargest function from the heapq module to find the n largest elements\n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use heapq's nlargest function to find the n largest elements in the list\n    return hq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Find the n largest numbers using heapq's nlargest function\n    largest_nums = hq.nlargest(n, nums)\n    # Return the list of n largest numbers in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the elements in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    # Use the nlargest function from the heapq module to find the n largest elements\n    # and then sort them in descending order\n    return sorted(nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use heapq to find the n largest elements and convert them to a sorted list in descending order\n    return sorted(hq.nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers_list, n):\n    # Sort the list in descending order and return the first n elements\n    return sorted(numbers_list, reverse=True)[:n]", "matching_cluster_idx": 11}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    # Use the nlargest function from the heapq module to find the n largest numbers\n    return nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Using heapq.nlargest to find the n largest numbers in the list\n    # and returning them in descending order\n    return hq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest elements\n    largest_nums = hq.nlargest(n, nums)\n    # Return the elements sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest function to get the n largest elements\n    # and return them in descending order\n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to get the n largest numbers from the list\n    # The result is already in descending order\n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 62.074829931972786, "dps_norm": 52.5, "pass@1": 26.0, "profiled": [{"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to handle rotations\n    temp = s + s\n    \n    # Initialize the minimum rotations to the length of the string\n    minimum_rotations = len(s)\n    \n    # Iterate through the possible rotations\n    for i in range(1, len(s)):\n        # Compare the current rotation with the original string\n        if (temp[i:len(s)+i] == s):\n            # Update the minimum rotations if a smaller rotation is found\n            minimum_rotations = min(minimum_rotations, i)\n    \n    # Return the minimum number of rotations greater than 0\n    return minimum_rotations", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str1):\n    # Iterate through the length of the string to check for rotations\n    for i in range(1, len(str1)):\n        # Rotate the string by slicing and compare with the original\n        if str1[i:] + str1[:i] == str1:\n            return i\n    # If no rotation matches the original, return the length of the string\n    return len(str1)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)  # Get the length of the string\n    if n == 0:  # If the string is empty, return 0 rotations needed\n        return 0\n    temp = s * 2  # Double the string to simulate rotations\n    for i in range(1, n):  # Loop from 1 to n-1 to check each rotation\n        if temp[i:i + n] == s:  # If the substring from i to i+n matches the original string\n            return i  # Return the number of rotations needed\n    return n  # If no match found, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    n = len(str)\n    for i in range(1, n):\n        # Check if the string starts with the same characters as its rotated version\n        if str.startswith(str[i:] + str[:i]):\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    # Calculate the length of the input string\n    size = len(str1)\n    # Iterate over possible rotation points\n    for i in range(1, size):\n        # Check if the string from index i to the end concatenated with the substring from the start to index i\n        # is equal to the original string\n        if (str1[i:] + str1[0:i]) == str1:\n            return i\n    # If no rotation matches the original string, return the size of the string (no full rotation needed)\n    return size", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    # Check if the input string is empty\n    if str1 == '':\n        return 0\n    \n    # Initialize rotation count to 1\n    count = 1\n    \n    # Check for the same string after rotations\n    for i in range(1, len(str1)):\n        new_str = str1[i:] + str1[:i]\n        if new_str == str1:\n            return count\n        count += 1\n    \n    # Return the minimum number of rotations\n    return count", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Concatenate the string to itself to handle rotations\n    temp = s + s\n    n = len(s)\n    \n    # Iterate through the string to check for rotations\n    for i in range(1, n):\n        # If the substring matches the original string, return i\n        if temp[i:n+i] == s:\n            return i\n    # If no match is found, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Get the length of the string\n    n = len(s)\n    \n    # Check if all characters in the string are the same\n    if len(set(s)) == 1:\n        # If so, return 1 as no rotation will change the string\n        return 1\n    \n    # Iterate through possible rotations\n    for i in range(1, n):\n        # Check if the current rotation matches the original string\n        if s[i:] + s[:i] == s:\n            # If a match is found, return the number of rotations\n            return i\n    \n    # If no match is found, return n (the total number of rotations)\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    # Check if the string is empty\n    if string == \"\":\n        return -1\n    \n    # Get the length of the string\n    length = len(string)\n    \n    # Concatenate the string to itself to check for rotations\n    concatenated_string = string + string\n    \n    # Iterate through the original string\n    for i in range(1, length):\n        # Check if the substring from index i to i+length matches the original string\n        if (concatenated_string[i:i+length] == string):\n            return i\n    \n    # If no match is found, return the length of the string\n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str):\n    # Length of the string\n    len_str = len(str)\n    for i in range(1, len_str):\n        # Rotate the string by i and check if it matches the original string\n        if (str[i:] + str[:i]) == str:\n            # If a match is found, return the number of rotations (i)\n            return i\n    # If no match is found, return the length of the string (original string is the same)\n    return len_str", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    # Get the length of the string\n    n = len(str1)\n    # Reverse the string and concatenate it with itself\n    concatenated = str1 + str1\n    # Check for each rotation\n    for i in range(1, n):\n        temp = concatenated[i:i+n]\n        # Check if the current rotation is equal to the original string\n        if (temp == str1):\n            return i\n    # If no rotation matches, return n\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Find the minimum length of rotations\n    return len(set(s[i:] + s[:i] for i in range(len(s))))", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(str):\n    # Calculate the length of the input string\n    n = len(str)\n    \n    # If the string is empty, return 0 rotations\n    if n == 0:\n        return 0\n    \n    # If the string has only one character, return 0 rotations\n    if n == 1:\n        return 0\n    \n    # Iterate through the string to find the minimum rotations required\n    for i in range(1, n):\n        if (str[i:] + str[:i]) == str:\n            return i\n    \n    # If no rotation matches, return n (the length of the string)\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    # Calculate the length of the string\n    len1 = len(str1)\n    \n    # Find the smallest index where the string has a rotation that matches the original\n    for i in range(1, len1):\n        if str1[i:] + str1[:i] == str1:\n            return i\n    \n    # If no such rotation is found, return the length of the string (no rotation needed)\n    return len1", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1): \n    # Calculate the length of the string\n    length = len(str1) \n    # Iterate through the range of the string length\n    for i in range(1, length): \n        # Check if the substring from index i to end and from start to index i are equal\n        if (str1[i:]+str1[0:i] == str1): \n            # Return the number of rotations required\n            return i \n    # If no rotation results in the same string, return the length of the string\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str1):\n    # Concatenate the string with itself to cover all possible rotations\n    concat_str = str1 + str1\n    # Calculate the length of the original string\n    len_str = len(str1)\n    # Iterate through each possible rotation\n    for i in range(1, len_str):\n        temp_str = concat_str[i:i+len_str]\n        # Check if the rotated string is equal to the original string\n        if temp_str == str1:\n            return i  # Return the number of rotations needed\n    return len_str  # Return the length of the string if no exact match is found", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(str): \n    # Get the length of the string\n    n = len(str) \n    for i in range(1, n): \n        # Rotate the string by one position\n        str1 = str[i:] + str[0:i] \n        # Compare the rotated string with the original string\n        if str1 == str: \n            # If they are the same, return the number of rotations needed\n            return i \n    # If no rotation results in the original string, return the length of the string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Iterate through all possible rotations\n    for i in range(1, len(s)):\n        # Check if the current rotation matches the original string\n        if s[i:] + s[:i] == s:\n            return i\n    # If no match is found, return the length of the string (0-based index)\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Loop through each character in the string\n    for i in range(1, len(s)):\n        # Rotate the string by slicing and concatenating\n        s1 = s[i:] + s[:i]\n        # Check if the rotated string matches the original string\n        if s1 == s:\n            return i  # Return the number of rotations\n    return len(s)  # Return the length if no match found", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(str): \n    # Initialize the length of the string\n    n = len(str) \n    # Iterate through the string\n    for i in range(1, n): \n        # Check if rotating the string gives the same string\n        if (str[i:] + str[0:i]) == str: \n            return i \n    # If no rotation gives the same string, return the length\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 25.017921146953405, "dps_norm": 68.33333333333333, "pass@1": 60.0, "profiled": [{"solution": "def remove_Occ(string, character):\n    # Find the index of the first occurrence of the character\n    index_first_occ = string.find(character)\n    \n    # Remove the first occurrence if found\n    if index_first_occ != -1:\n        string = string[:index_first_occ] + string[index_first_occ + 1:]\n    \n    # Reverse the string to find and remove the last occurrence (which is now the first in the reversed string)\n    string_reversed = string[::-1]\n    index_last_occ = string_reversed.find(character)\n    \n    # Remove the last occurrence if found\n    if index_last_occ != -1:\n        string = string[:len(string) - index_last_occ - 1] + string[len(string) - index_last_occ:]\n    \n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(text, ch):\n    # Find the index of the first occurrence of the character\n    first_occurrence = text.find(ch)\n    \n    # If the character is not found, return the original text\n    if first_occurrence == -1:\n        return text\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = text.rfind(ch)\n    \n    # If the first and last occurrences are the same, remove that occurrence\n    if first_occurrence == last_occurrence:\n        return text[:first_occurrence] + text[first_occurrence + 1:]\n    \n    # Remove both the first and last occurrences of the character\n    return text[:first_occurrence] + text[first_occurrence + 1:last_occurrence] + text[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input, C):\n    # Initialize variables to track the first and last occurrence indices\n    first, last = -1, -1\n    \n    # Loop through the string to find the first and last occurrences of the character\n    for i in range(len(input)):\n        if input[i] == C:\n            if first == -1:\n                first = i\n            last = i\n    \n    # If the character is not found in the string, return the original string\n    if first == -1:\n        return input\n    \n    # Return the string with the first and last occurrences of the character removed\n    return input[:first] + input[first+1:last] + input[last+1:]", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(my_str, S):\n    # Find the first occurrence of the character and remove it\n    first_occ = my_str.find(S)\n    if first_occ != -1:\n        my_str = my_str[:first_occ] + my_str[first_occ + 1:]\n    \n    # Find the last occurrence of the character and remove it\n    last_occ = my_str.rfind(S)\n    if last_occ != -1:\n        my_str = my_str[:last_occ] + my_str[last_occ + 1:]\n    \n    return my_str", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, character):\n    # Find the index of the first occurrence of the character\n    l = string.find(character)\n    \n    # Remove the first occurrence\n    if l != -1:\n        string = string[:l] + string[l+1:]\n    \n    # Find the index of the last occurrence of the character\n    l = string.rfind(character)\n    \n    # Remove the last occurrence if it exists\n    if l != -1:\n        string = string[:l] + string[l+1:]\n    \n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence of the character\n    first_index = string.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = string.rfind(char)\n    \n    # Return the string with the first and last occurrence removed\n    if first_index != -1:\n        return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, s):\n    # Initialize counters for the first and last occurrence\n    first = -1\n    last = -1\n    i = 0\n    \n    # Find the first occurrence of the character\n    while i < len(string):\n        if string[i] == s:\n            first = i\n            break\n        i += 1\n    \n    i = 0\n    \n    # Find the last occurrence of the character\n    while i < len(string):\n        if string[i] == s:\n            last = i\n        i += 1\n    \n    # If the character was found, remove it from the first and last occurrence\n    if first != -1:\n        string = string[:first] + string[first + 1:]\n        if last != first:\n            string = string[:last - 1] + string[last:]\n    \n    return string", "matching_cluster_idx": -1}, {"solution": "def remove_Occ(s, ch):\n    # Check if the character exists in the string and remove the first occurrence\n    if ch in s:\n        s = s.replace(ch, \"\", 1)\n    \n    # Check if the character still exists in the string and remove the last occurrence\n    if ch in s:\n        s = s[::-1].replace(ch, \"\", 1)[::-1]\n    \n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    # Remove the first occurrence of the character\n    string = string.replace(char, \"\", 1)\n    # Remove the last occurrence of the character\n    string = string[::-1].replace(char, \"\", 1)[::-1]\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(str1, char):\n    # Find the first occurrence of the character and remove it\n    first_occurrence = str1.find(char)\n    if first_occurrence != -1:\n        str1 = str1[:first_occurrence] + str1[first_occurrence + 1:]\n    \n    # Find the last occurrence of the character and remove it\n    last_occurrence = str1.rfind(char)\n    if last_occurrence != -1:\n        str1 = str1[:last_occurrence] + str1[last_occurrence + 1:]\n    \n    return str1", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(arr, ch):\n    # Loop through the string to remove the first occurrence\n    for i in range(len(arr)):\n        if arr[i] == ch:\n            arr = arr[:i] + arr[i + 1:]\n            break\n    \n    # Loop through the string in reverse to remove the last occurrence\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == ch:\n            arr = arr[:i] + arr[i + 1:]\n            break\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Find the first occurrence of the character and remove it\n    s = s.replace(ch, '', 1)\n    # Find the last occurrence of the character and remove it\n    s = s[::-1].replace(ch, '', 1)[::-1]\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    # Count the number of occurrences of the character\n    num_occ = string.count(char)\n    \n    # If the character is not found, return the original string\n    if num_occ == 0:\n        return string\n    \n    # Remove the first occurrence of the character\n    for i in range(len(string)):\n        if string[i] == char:\n            string = string[:i] + string[i+1:]\n            break\n    \n    # Remove the last occurrence of the character\n    for i in range(len(string) - 1, -1, -1):\n        if string[i] == char:\n            string = string[:i] + string[i+1:]\n            break\n    \n    return string", "matching_cluster_idx": 5}, {"solution": "def remove_Occ(S, C):\n    # Find the first occurrence of the character C in the string S\n    f_idx = S.find(C)\n    # If the character is found, remove the first occurrence by slicing\n    if f_idx != -1:\n        S = S[:f_idx] + S[f_idx + 1:]\n    \n    # Find the last occurrence of the character C in the string S\n    l_idx = S.rfind(C)\n    # If the character is found, remove the last occurrence by slicing\n    if l_idx != -1:\n        S = S[:l_idx] + S[l_idx + 1:]\n    \n    # Return the modified string without the first and last occurrence of the character\n    return S", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, character):\n    # Find the index of the first occurrence of the character\n    first_occurrence = string.find(character)\n    \n    # If the character is found, remove the first occurrence\n    if first_occurrence != -1:\n        string = string[:first_occurrence] + string[first_occurrence + 1:]\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = string.rfind(character)\n    \n    # If the character is found, remove the last occurrence\n    if last_occurrence != -1:\n        string = string[:last_occurrence] + string[last_occurrence + 1:]\n    \n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, char):\n    # Get the first index of the character\n    first = string.find(char)\n    if first != -1:\n        string = string[:first] + string[first + 1:]\n    \n    # Get the last index of the character\n    last = string.rfind(char)\n    if last != -1:\n        string = string[:last] + string[last + 1:]\n    \n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    # Find the index of the first occurrence of the character\n    f = s.find(c)\n    # If the character is not found, return the original string\n    if f == -1:\n        return s\n    # Remove the first occurrence by slicing the string\n    s = s[:f] + s[f+1:]\n    # Find the index of the last occurrence of the character\n    l = s.rfind(c)\n    # If the character is not found, return the string without the first occurrence\n    if l == -1:\n        return s\n    # Remove the last occurrence by slicing the string\n    return s[:l] + s[l+1:]", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(text, C):\n    # Check if the character is present in the string\n    if C in text:\n        # Remove the first occurrence of the character\n        text = text.replace(C, \"\", 1)\n        # Remove the last occurrence of the character\n        text = text[::-1].replace(C, \"\", 1)[::-1]\n    # Return the modified string\n    return text", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, character):\n    # Iterate over the string to remove the first occurrence\n    for i in range(len(string)):\n        if string[i] == character:\n            string = string[:i] + string[i + 1:]\n            break\n    # Iterate from the end to remove the last occurrence\n    for i in range(len(string) - 1, -1, -1):\n        if string[i] == character:\n            string = string[:i] + string[i + 1:]\n            break\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, character):\n    # Convert the string into a list of characters\n    new_str = list(s)\n    \n    # Initialize flags for finding the first and last occurrences\n    first_occurrence = -1\n    last_occurrence = -1\n    \n    # Iterate over the list to find the first and last occurrences of the character\n    for i in range(len(new_str)):\n        if new_str[i] == character:\n            if first_occurrence == -1:\n                first_occurrence = i\n            last_occurrence = i\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    \n    # Remove the first and last occurrence of the character\n    new_str.pop(first_occurrence)\n    if first_occurrence != last_occurrence:\n        new_str.pop(last_occurrence - 1)\n    \n    # Convert the list back to a string and return it\n    return ''.join(new_str)", "matching_cluster_idx": 0}]}, "Mbpp/12": {"dps": 95.08086253369272, "dps_norm": 95.9375, "pass@1": 97.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on their sum in ascending order\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(arr):\n    # Sort the matrix by the sum of rows in ascending order\n    return sorted(arr, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of rows using the sorted function with a custom key\n    return sorted(mat, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of elements in each row\n    return sorted(matrix, key=lambda x: sum(x))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix in place based on the sum of the rows\n    matrix.sort(key=lambda row: sum(row))\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix rows based on the sum of their elements in ascending order\n    mat.sort(key=sum)\n    return mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of rows using a lambda function as the key\n    # lambda x: sum(x) sorts the rows by their sum in ascending order\n    mat.sort(key=lambda x: sum(x))\n    return mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix rows based on the sum of their elements\n    sorted_mat = sorted(mat, key=sum)\n    return sorted_mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of its rows using a lambda function\n    return sorted(mat, key=lambda x: sum(x))", "matching_cluster_idx": 15}, {"solution": "from copy import deepcopy\ndef sort_matrix(matrix):\n    # Creating a deep copy of the matrix to avoid modifying the original matrix\n    sorted_matrix = deepcopy(matrix)\n    \n    # Sorting the matrix based on the sum of each row in ascending order\n    sorted_matrix.sort(key=sum)\n    \n    return sorted_matrix", "matching_cluster_idx": 2}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of its rows in ascending order\n    return sorted(mat, key=lambda x: sum(x))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of rows using a lambda function as the key\n    # The sorted function returns the matrix sorted in ascending order of row sums\n    return sorted(mat, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(m):\n    # Sort the matrix based on the sum of the rows\n    return sorted(m, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of its rows\n    mat.sort(key=sum)\n    return mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of elements in each row\n    sorted_matrix = sorted(matrix, key=lambda x: sum(x))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(A):\n    # Sort the matrix rows based on their sum\n    return sorted(A, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of its rows using the sorted function\n    sorted_mat = sorted(mat, key=sum)\n    return sorted_mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    # Sort the matrix based on the sum of each row\n    result = sorted(mat, key=lambda x: sum(x))\n    return result", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/19": {"dps": 75.60606060606061, "dps_norm": 86.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(nums):\n    # Create an empty set to store unique elements\n    num_set = set()\n    \n    # Iterate through each element in the array\n    for num in nums:\n        # Check if the element is already in the set\n        if num in num_set:\n            # If found, return True indicating a duplicate exists\n            return True\n        # Add the element to the set if not already present\n        num_set.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(lst):\n    # Create a set to store unique elements\n    unique = set()\n    \n    # Iterate through each number in the list\n    for n in lst:\n        # Check if the number is already in the set\n        if n in unique:\n            return True  # Duplicate found\n        # Add the number to the set\n        unique.add(n)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "from copy import deepcopy\ndef test_duplicate(nums):\n    # Check if the list is empty or has only one element\n    if len(nums) <= 1:\n        return False\n    \n    # Create a copy of the list to work with\n    numsCopy = deepcopy(nums)\n    \n    # Sort the copied list\n    numsCopy.sort()\n    \n    # Iterate through the sorted list to find duplicates\n    for i in range(len(numsCopy) - 1):\n        if numsCopy[i] == numsCopy[i + 1]:\n            return True\n    \n    # Return False if no duplicates are found\n    return False", "matching_cluster_idx": 1}, {"solution": "def test_duplicate(nums):\n    # Initialize an empty list to keep track of seen elements\n    seen = []\n    \n    # Iterate through each element in the input list\n    for i in nums:\n        # Check if the current element is already in the seen list\n        if i in seen:\n            return True\n        # If not, add the current element to the seen list\n        seen.append(i)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 12}, {"solution": "def test_duplicate(array_nums):\n    # Check if the array has any duplicate elements\n    return len(array_nums) != len(set(array_nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array_nums):\n    # Create a set to store unique elements\n    unique_nums = set()\n    \n    # Iterate through each number in the input array\n    for x in array_nums:\n        # If the number is already in the set, it's a duplicate\n        if x in unique_nums:\n            return True\n        # Otherwise, add the number to the set\n        unique_nums.add(x)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(lst):\n    # Create a set from the list to remove duplicates and compare its length to the original list\n    return len(lst) > len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(array_nums):\n    # Convert the list to a set to remove duplicates and compare lengths\n    unique_nums = set(array_nums)\n    return len(array_nums) != len(unique_nums)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    # Convert the array to a set to remove duplicates and compare its length to the original array\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Use a set to track unique elements\n    my_set = set()\n    # Iterate through each element in the array\n    for i in arr:\n        # Check if the element is already in the set\n        if i in my_set:\n            return True  # Duplicate found\n        else:\n            my_set.add(i)  # Add element to the set\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for i in arr:\n        # Check if the element is already in the set\n        if i in seen:\n            return True  # Duplicate found\n        seen.add(i)  # Add the element to the set\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    # Create a set to store unique elements\n    u = set()\n    # Iterate through each number in the array\n    for n in nums:\n        # Check if the number is already in the set\n        if n in u:\n            # If found, return True indicating a duplicate exists\n            return True\n        else:\n            # If not found, add the number to the set\n            u.add(n)\n    # If the loop completes, return False indicating no duplicates\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    # Create a set to store unique elements encountered in the array\n    set_nums = set()\n    \n    # Iterate through each number in the input list\n    for num in nums:\n        # Check if the number is already in the set\n        if num in set_nums:\n            # If found, return True indicating a duplicate exists\n            return True\n        else:\n            # If not found, add the number to the set\n            set_nums.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(array_nums):\n    # Create a dictionary to track the occurrences of each number\n    num_dictionary = {}\n    \n    # Iterate through the array to populate the dictionary\n    for num in array_nums:\n        if num not in num_dictionary:\n            num_dictionary[num] = 1\n        else:\n            # If the number is already in the dictionary, return True\n            return True\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(test_list):\n    # Initialize an empty set to keep track of seen elements\n    seen = set()\n    \n    # Iterate through each element in the test list\n    for ele in test_list:\n        # Check if the element is already in the seen set\n        if ele in seen:\n            # If found, return True indicating a duplicate\n            return True\n        # If not found, add the element to the seen set\n        seen.add(ele)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(array_nums):\n    # Convert the array to a set to remove duplicates and compare lengths\n    return len(array_nums) > len(set(array_nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Create an empty set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Check if the element is already in the set\n        if arr[i] in unique_elements:\n            # If found, return True indicating a duplicate\n            return True\n        # Add the element to the set\n        unique_elements.add(arr[i])\n    \n    # If no duplicates found, return False\n    return False", "matching_cluster_idx": 13}, {"solution": "def test_duplicate(arr):\n    # Convert the array to a set to remove duplicates\n    array = list(set(arr))\n    \n    # Compare the length of the set with the original array\n    if len(array) != len(arr):\n        return True  # Duplicates exist\n    else:\n        return False  # No duplicates", "matching_cluster_idx": 10}, {"solution": "def test_duplicate(nums):\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(set(nums)) != len(nums)", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 79.46153846153847, "dps_norm": 86.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(list_num):\n    # Using the min function to find the smallest number in the list\n    minimum = min(list_num)\n    return minimum", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Initialize the smallest number to a very large positive value\n    smallest = float('inf')\n    # Iterate through each number in the list\n    for num in numbers:\n        # Update the smallest number if a smaller number is found\n        if num < smallest:\n            smallest = num\n    # Return the smallest number found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Find and return the smallest number in the list using min() function\n    return min(list1)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Use the built-in min function to find and return the smallest number in the list\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list1):\n    # Initialize the smallest number with the first element of the list\n    smallest_num = list1[0]\n    \n    # Iterate through each number in the list\n    for i in list1:\n        # Update the smallest number if the current number is smaller\n        if i < smallest_num:\n            smallest_num = i\n    \n    # Return the smallest number found\n    return smallest_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Return the minimum value from the list using the built-in min() function\n    return min(list1)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    # Return the smallest number in the list using the built-in min function\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Initialize the smallest number as the first element of the list\n    smallest = numbers[0]\n    # Iterate over each number in the list\n    for num in numbers:\n        # Update the smallest number if the current number is smaller\n        if num < smallest:\n            smallest = num\n    # Return the smallest number found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    # Initialize the smallest number with the first element of the list\n    smallest_num = nums[0]\n    \n    # Iterate through each number in the list\n    for x in nums:\n        # Update the smallest number if the current number is smaller\n        if x < smallest_num:\n            smallest_num = x\n    \n    # Return the smallest number found\n    return smallest_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Initialize the smallest number to the first element in the list\n    smallest = list1[0]\n    \n    # Iterate over each number in the list\n    for x in list1:\n        # Update the smallest number if the current number is smaller\n        if x < smallest:\n            smallest = x\n    \n    # Return the smallest number found\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Find and return the minimum number in the list\n    small = min(list1)\n    return small", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list1):\n    # Check if the list is empty\n    if not list1:\n        return None  # Return None for empty list\n    \n    # Initialize the smallest number with the first element of the list\n    min = list1[0]\n    \n    # Iterate through the list starting from the second element\n    for x in list1:\n        # Update the smallest number if a smaller element is found\n        if x < min:\n            min = x\n    \n    # Return the smallest number found\n    return min", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Initialize the smallest number with the first element of the list\n    smallest = list1[0]\n    # Iterate through the list\n    for x in list1:\n        # Update the smallest number if a smaller number is found\n        if x < smallest:\n            smallest = x\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Find the smallest number in the list using the min() function\n    min_num = min(list1)\n    return min_num", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Use the built-in min() function to find the smallest number in the list\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list1):\n    # Use the min() function to find and return the smallest number in the list\n    return min(list1)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Use the min() function to find the smallest number in the list\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list1):\n    # Initialize the minimum number with the first element of the list\n    min1 = list1[0]\n    # Iterate through the list starting from the second element\n    for x in list1:\n        # Update the minimum number if a smaller element is found\n        if x < min1:\n            min1 = x\n    # Return the smallest number found\n    return min1", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list1):\n    # Initialize the smallest number with the first element of the list\n    small_num = list1[0]\n    \n    # Iterate through each number in the list\n    for i in range(len(list1)):\n        # Update the smallest number if the current number is smaller\n        if list1[i] < small_num:\n            small_num = list1[i]\n    \n    # Return the smallest number found\n    return small_num", "matching_cluster_idx": 1}, {"solution": "def smallest_num(numbers):\n    # Initialize the smallest number with the first element of the list\n    min_num = numbers[0]\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(numbers)):\n        # Update the smallest number if a smaller number is found\n        if numbers[i] < min_num:\n            min_num = numbers[i]\n    \n    # Return the smallest number found\n    return min_num", "matching_cluster_idx": 1}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(test_list, K):\n    # Use a list comprehension to filter tuples\n    res = [tuple_val for tuple_val in test_list if all(ele % K == 0 for ele in tuple_val)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples\n    # Check if all elements in the tuple are divisible by K using all() and modulo operation\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples to include only those where all elements are divisible by K\n    res = [tuple for tuple in test_list if all(i % K == 0 for i in tuple)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples\n    res = [ele for ele in test_list if all(x % K == 0 for x in ele)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples\n    res = [ele for ele in test_list if all(ele % K == 0 for ele in ele)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples\n    res = [tu for tu in test_list if all(ele % K == 0 for ele in tu)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, K):\n    # Filter the list of tuples and retain only those where all elements are divisible by K\n    result = [tuple_ for tuple_ in lst if all(num % K == 0 for num in tuple_)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store tuples with all elements divisible by K\n    res = []\n    \n    # Iterate through each tuple in the test list\n    for sub in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in sub):\n            # If condition is satisfied, add the tuple to the result list\n            res.append(sub)\n    \n    # Return the list of tuples with all elements divisible by K\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store tuples with all elements divisible by K\n    res = []\n    \n    # Iterate over each tuple in the test list\n    for ele in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(i % K == 0 for i in ele):\n            # If yes, add the tuple to the result list\n            res.append(ele)\n    \n    # Return the list of tuples\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples in the list where all elements are divisible by K\n    res = [ele for ele in test_list if all(x % K == 0 for x in ele)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K using a list comprehension\n    res = [tup for tup in test_list if all(ele % K == 0 for ele in tup)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup1, K):\n    # Use a list comprehension to filter tuples\n    res = [tup for tup in tup1 if all(ele % K == 0 for ele in tup)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, divisor):\n    # Filter tuples to find those where all elements are divisible by the divisor\n    result = [t for t in lst if all(x % divisor == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Use list comprehension to filter tuples\n    # Check if all elements in the tuple are divisible by K\n    res = [tup for tup in test_list if all(ele % K == 0 for ele in tup)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(nums, k):\n    # Use list comprehension to filter tuples\n    # Check if all elements in the tuple are divisible by k\n    result = [t for t in nums if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "from itertools import product\ndef find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K\n    res = [tuple for tuple in test_list if all(ele % K == 0 for ele in tuple)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, N):\n    # Use list comprehension to filter tuples where all elements are divisible by N\n    res = [tuple_val for tuple_val in test_list if all(ele % N == 0 for ele in tuple_val)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, divisor):\n    # Use list comprehension to filter tuples\n    # Each tuple must have all elements divisible by the divisor\n    res = [tuple for tuple in test_list if all(element % divisor == 0 for element in tuple)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K using list comprehension\n    res = [el for el in test_list if all(ele % K == 0 for ele in el)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 78.11274509803921, "dps_norm": 77.85714285714285, "pass@1": 99.0, "profiled": [{"solution": "def freq_count(test_list):\n    # Initialize an empty dictionary to store element frequencies\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for ele in test_list:\n        # If the element is already in the dictionary, increment its count\n        if ele in freq_dict:\n            freq_dict[ele] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[ele] = 1\n    \n    # Return the dictionary containing element frequencies\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    # Initialize an empty dictionary to store element frequencies\n    freq_dictionary = {}\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is already in the dictionary\n        if number in freq_dictionary:\n            # If yes, increment its count\n            freq_dictionary[number] += 1\n        else:\n            # If no, add the number to the dictionary with count 1\n            freq_dictionary[number] = 1\n    \n    # Return the dictionary containing frequencies of all elements\n    return freq_dictionary", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    # Return the dictionary containing element frequencies\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef freq_count(test_list):\n    # Initialize a default dictionary to store frequencies\n    res = defaultdict(int)\n    \n    # Iterate over each element in the list\n    for ele in test_list:\n        # Increment the count of the element in the dictionary\n        res[ele] += 1\n    \n    return dict(res)", "matching_cluster_idx": 3}, {"solution": "def freq_count(arr):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency = {}\n    \n    # Iterate over each element in the array\n    for element in arr:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency:\n            frequency[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[element] = 1\n    \n    # Return the dictionary containing the frequency of all elements\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(test_list):\n    # Use a dictionary comprehension to count the frequency of each element\n    res = {key: test_list.count(key) for key in set(test_list)}\n    return res", "matching_cluster_idx": 2}, {"solution": "def freq_count(arr):\n    # Initialize an empty dictionary to store frequencies\n    frequency = {}\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # If the element is already in the dictionary, increment its count\n        if num in frequency:\n            frequency[num] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[num] = 1\n    \n    # Return the dictionary containing elements and their frequencies\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(items):\n    # Use a dictionary comprehension to count occurrences of each item\n    return {i: items.count(i) for i in items}", "matching_cluster_idx": 0}, {"solution": "def freq_count(arr):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    # Iterate over each element in the list\n    for element in arr:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[element] = 1\n    # Return the dictionary containing the frequency of each element\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(test_list):\n    # Initialize an empty dictionary to store the frequency of elements\n    res = {}\n    \n    # Iterate over each element in the list\n    for ele in test_list:\n        # If the element is already in the dictionary, increment its count\n        if ele in res:\n            res[ele] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            res[ele] = 1\n    \n    # Return the dictionary containing element frequencies\n    return res", "matching_cluster_idx": 5}, {"solution": "def freq_count(A):\n    # Create a dictionary to store the frequency of each element\n    freqDict = {}\n    # Iterate over each element in the list\n    for i in A:\n        # Increment the count of the element in the dictionary\n        freqDict[i] = freqDict.get(i, 0) + 1\n    # Return the frequency dictionary\n    return freqDict", "matching_cluster_idx": 4}, {"solution": "def freq_count(my_list):\n    # Initialize an empty dictionary to store the frequency of elements\n    my_dict = {}\n    \n    # Iterate through each element in the list\n    for i in my_list:\n        # Check if the element is already a key in the dictionary\n        if i in my_dict:\n            # Increment the frequency of the element\n            my_dict[i] += 1\n        else:\n            # Add the element to the dictionary with a frequency of 1\n            my_dict[i] = 1\n    \n    # Return the dictionary containing the frequency of all elements\n    return my_dict", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(my_list):\n    # Using Counter to count the frequency of each element in the list\n    return dict(Counter(my_list))", "matching_cluster_idx": 6}, {"solution": "def freq_count(test_list):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for ele in test_list:\n        # If the element is already in the dictionary, increment its count\n        if ele in freq_dict:\n            freq_dict[ele] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[ele] = 1\n    \n    # Return the dictionary containing the frequency of elements\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    freq = {}\n    \n    # Iterate through each element in the list\n    for i in lst:\n        # If the element is already in the dictionary, increment its count\n        if i in freq:\n            freq[i] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq[i] = 1\n            \n    # Return the dictionary containing the frequency of each element\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(test_list):\n    # Initialize an empty dictionary to store the frequency of each element\n    res = dict()\n    \n    # Iterate through each element in the input list\n    for ele in test_list:\n        # If the element is already in the dictionary, increment its count\n        if ele in res:\n            res[ele] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            res[ele] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return res", "matching_cluster_idx": 5}, {"solution": "def freq_count(input_list):\n    # Dictionary to store the frequency of each element\n    res = {}\n    \n    # Iterate through each element in the input list\n    for ele in input_list:\n        # Increment the count of the element in the dictionary\n        res[ele] = res.get(ele, 0) + 1\n    \n    # Return the dictionary containing frequencies of all elements\n    return res", "matching_cluster_idx": 4}, {"solution": "def freq_count(input_list):\n    # Initialize an empty dictionary to store element frequencies\n    freqs = {}\n    \n    # Iterate over each element in the input list\n    for element in input_list:\n        # If the element is already in the dictionary, increment its count\n        if element in freqs:\n            freqs[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freqs[element] = 1\n    \n    # Return the dictionary containing frequencies of all elements\n    return freqs", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in freq_dict:\n            freq_dict[element] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq_dict[element] = 1\n    \n    # Return the dictionary containing the frequencies\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(nums):\n    # Create an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for num in nums:\n        # If the element is already in the dictionary, increment its count\n        if num in frequency:\n            frequency[num] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[num] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 74.3658536585366, "dps_norm": 85.0, "pass@1": 95.0, "profiled": [{"solution": "def len_log(str_list):\n    # Use the max function with key=str len to find the longest word\n    max_len = max(str_list, key=len)\n    # Return the length of the longest word\n    return len(max_len)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Use the max function with a key argument to find the longest word's length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(str1):\n    # Calculate the maximum length of words in the list using a generator expression\n    longest_word_length = max(len(word) for word in str1)\n    return longest_word_length", "matching_cluster_idx": 5}, {"solution": "from operator import itemgetter\ndef len_log(words):\n    # Use a generator expression to get the lengths of the words\n    word_lengths = ((len(word), word) for word in words)\n    # Sort the items by length and take the length of the longest word\n    max_length = max(word_lengths, key=itemgetter(0))[0]\n    return max_length", "matching_cluster_idx": 3}, {"solution": "def len_log(list):\n    # Check if the list is empty\n    if len(list) == 0:\n        return 0\n    \n    # Initialize the maximum length with the length of the first word\n    max_length = len(list[0])\n    \n    # Iterate over each word in the list\n    for i in range(1, len(list)):\n        # Update max_length if the current word's length is greater\n        if len(list[i]) > max_length:\n            max_length = len(list[i])\n    \n    # Return the maximum length found\n    return max_length", "matching_cluster_idx": 4}, {"solution": "def len_log(words):\n    # Find the length of the longest word in the list\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(strings):\n    # Initialize the longest string length variable with a value less than the length of the shortest possible string\n    longest = -1\n    # Iterate through each string in the list\n    for s in strings:\n        # Update the longest string length if the current string is longer\n        if len(s) > longest:\n            longest = len(s)\n    # Return the length of the longest string found\n    return longest", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the length of the longest word using the max function with a key function that returns the length of each word\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(texts):\n    # Find the maximum length of words in the list 'texts'\n    return max(len(x) for x in texts)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the maximum length of words in the list\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the length of the longest word in the list using a generator expression\n    max_length = max(len(word) for word in words)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(str):\n    # Initialize the length of the longest word\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in str:\n        # Update the max_length if the current word's length is greater\n        max_length = max(max_length, len(word))\n    \n    # Return the length of the longest word\n    return max_length", "matching_cluster_idx": 2}, {"solution": "def len_log(words):\n    # Find the maximum length of words in the list using the map function\n    longest = max(map(len, words))\n    return longest", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Use the max function with the key parameter set to len to find the longest word\n    # Then, use the len function to return the length of the longest word\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Initialize a variable to store the maximum word length found\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the maximum word length found\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize max_length to the length of the first word\n    max_length = len(words[0])\n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    # Return the maximum length found\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Use a list comprehension to get the lengths of all words\n    word_len = [len(word) for word in words]\n    # Return the maximum length found\n    return max(word_len)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Use the max function with a key to find the length of the longest word\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Use the map function to apply the len function to each word in the list\n    # Then, find the maximum length using the max function\n    return max(map(len, words))", "matching_cluster_idx": 5}, {"solution": "def len_log(string):\n    # Use the max function to find the maximum length of words in the list\n    # The key parameter specifies that the length of each word should be used for comparison\n    return max(len(word) for word in string)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 82.85060975609755, "dps_norm": 69.0, "pass@1": 94.0, "profiled": [{"solution": "def index_minimum(lst):\n    # Find the minimum value among the second elements of the tuples\n    min_val = min(lst, key=lambda x: x[1])[1]\n    # Iterate through the list to find the first tuple with the minimum second value\n    for i in lst:\n        if i[1] == min_val:\n            # Return the first element of the found tuple\n            return i[0]", "matching_cluster_idx": 2}, {"solution": "from operator import itemgetter\ndef index_minimum(test_list):\n    # Use the min function with key parameter set to itemgetter(1) to find the tuple with the smallest second value\n    # Return the first value of that tuple\n    res = min(test_list, key=itemgetter(1))[0]\n    return res", "matching_cluster_idx": 4}, {"solution": "def index_minimum(test_list):\n    # Use min function with key parameter to find the tuple with the smallest second value\n    # and extract the first value of that tuple\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Using min function with key to find the tuple with the minimum second value\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the index of the tuple with the minimum second value\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Use the min function with a key to find the tuple with the minimum second element\n    # Then return the first element of that tuple\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Using min function with key parameter to find the tuple with the smallest second element\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list1):\n    # Initialize a variable with infinity as a default value for comparison\n    min_value = float('inf')\n    # Variable to store the result\n    small = 0\n    # Iterate through the list of tuples\n    for i, v in enumerate(list1):\n        # Check if the second element of the tuple is less than the current minimum value\n        if min_value > v[1]:\n            min_value = v[1]\n            small = v[0]\n    return small", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # The function uses the built-in min function along with a lambda function to\n    # find the tuple with the smallest second element. The lambda function takes\n    # a tuple and returns its second element for comparison. The min function returns\n    # the tuple with the minimum value according to the second element.\n    res = min(test_list, key=lambda x: x[1])\n    # The first element of the tuple with the smallest second value is returned.\n    return res[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Initialize the minimum value to a very high number and the corresponding index to -1\n    min_val, min_ind = float('inf'), -1\n    \n    # Iterate over the list of tuples\n    for ele in test_list:\n        # Check if the current tuple's second value is smaller than the current minimum\n        if ele[1] < min_val:\n            min_val = ele[1]  # Update the minimum value\n            min_ind = ele[0]   # Update the corresponding first value\n    \n    # Return the first value of the tuple with the smallest second value\n    return min_ind", "matching_cluster_idx": 4}, {"solution": "from operator import itemgetter\ndef index_minimum(test_list):\n    # Use the itemgetter function to sort the list of tuples based on the second item of each tuple\n    # Then, extract the first element of the tuple with the smallest second item\n    res = min(test_list, key=itemgetter(1))[0]\n    return res", "matching_cluster_idx": 4}, {"solution": "def index_minimum(test_list):\n    # Find the index of the minimum value in the second element of each tuple\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Using the min function with a key to find the tuple with the minimum second element\n    # The index method then retrieves the first element of that tuple\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the index of the tuple with the minimum second element\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the minimum second element\n    res = min(test_list, key=lambda x: x[1])[0]\n    return res", "matching_cluster_idx": 2}, {"solution": "from operator import itemgetter\ndef index_minimum(lst):\n    # Using the min function with key=itemgetter(1) to find the tuple with the smallest second value\n    # Then, accessing the first value of that tuple\n    return min(lst, key=itemgetter(1))[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(test_list):\n    # Use the min function with a key to find the tuple with the smallest second value\n    res = min(test_list, key=lambda ele: ele[1])\n    # Return the first value of the found tuple\n    return res[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Use the key parameter of the min function to sort by the second item in each tuple\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "from operator import itemgetter\ndef index_minimum(test_list):\n    # Initialize min element and min value as None\n    min_element = None\n    min_value = None\n    \n    # Iterate through each element in the test list\n    for ele in test_list:\n        # Check if this is the first element or if the current element's second value is smaller\n        if min_element is None or ele[1] < min_value:\n            # Update the min element and min value\n            min_element = ele\n            min_value = ele[1]\n    \n    # Return the first value of the tuple with the smallest second value\n    return min_element[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(lst):\n    # Use the min function with a key to find the tuple with the smallest second value\n    # and then extract the first value of that tuple\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 81.1111111111111, "dps_norm": 51.42857142857142, "pass@1": 94.0, "profiled": [{"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Iterate through potential divisors from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, increment the counter\n            count += 1\n            \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    res = 0\n    \n    # Iterate through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        # If i divides n without a remainder, it is a divisor\n        if n % i == 0:\n            res += 1\n    \n    # Return the total count of divisors\n    return res", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The number to find the divisors of.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Iterate through possible divisors up to the square root of n\n    for i in range(1, int(n ** 0.5) + 1):\n        # If i is a divisor, increment the count\n        if n % i == 0:\n            count += 1\n            \n            # If i is not the square root of n, increment the count for the quotient\n            if i != n // i:\n                count += 1\n                \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Loop through possible divisors\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    cnt = 0\n    \n    # Iterate through all possible divisors from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if (n % i == 0):\n            # If it is, increment the divisor counter\n            cnt += 1\n    \n    # Return the total count of divisors\n    return cnt", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Write a python function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer to find the divisors for.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \n    Examples:\n    >>> divisor(15)\n    4\n    \"\"\"\n    count = 0  # Initialize the count of divisors\n    for i in range(1, n + 1):  # Iterate through numbers from 1 to n\n        if n % i == 0:  # Check if i is a divisor of n\n            count += 1  # Increment the count if i is a divisor\n    return count  # Return the total count of divisors", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    # Initialize a counter for divisors\n    total = 0\n    \n    # Iterate through all numbers from 1 to the square root of 'num'\n    for i in range(1, int(num**0.5) + 1):\n        # If 'i' is a divisor of 'num', increment the counter\n        if num % i == 0:\n            total += 1\n            # If 'i' is not the square root of 'num', count the pair divisor\n            if i != num // i:\n                total += 1\n                \n    # Return the total number of divisors\n    return total", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    divisor_count = 0\n    \n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the divisor count if i is a divisor\n            divisor_count += 1\n            \n    # Return the total count of divisors\n    return divisor_count", "matching_cluster_idx": 2}, {"solution": "def divisor(N):\n    # Initialize a counter for divisors\n    cnt = 0\n    # Iterate over possible divisors up to the square root of N\n    for i in range(1, int(N ** 0.5) + 1):\n        # Check if i is a divisor of N\n        if N % i == 0:\n            # If i divides N, increment the count\n            cnt += 1\n            # If i and N/i are distinct, increment the count again\n            if i != N // i:\n                cnt += 1\n    # Return the total number of divisors\n    return cnt", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    # Initialize a counter to 0\n    c = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the counter if i is a divisor\n            c += 1\n    # Return the total count of divisors\n    return c", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    num = 0\n    \n    # Iterate through possible divisors from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If divisible, increment the divisor counter\n            num += 1\n    \n    # Return the total number of divisors found\n    return num", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of divisors\n    count = 0\n    \n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if 'i' is a divisor of 'n'\n        if n % i == 0:\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize counter for divisors\n    cnt = 0\n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i divides n without a remainder, increment the counter\n        if n % i == 0:\n            cnt += 1\n    # Return the total count of divisors\n    return cnt", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize counter for divisors\n    count = 0\n    \n    # Iterate through possible divisors from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, increment the counter\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Iterate through possible divisors\n    for i in range(1, n + 1):\n        if n % i == 0:  # Check if i is a divisor of n\n            count += 1  # Increment the counter if i is a divisor\n    return count  # Return the total count of divisors", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for the number of divisors\n    count = 0\n    \n    # Iterate through all possible divisors\n    for i in range(1, n + 1):\n        # If 'i' is a divisor of 'n', increment the counter\n        if n % i == 0:\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    c = 0\n    # Iterate through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If so, increment the counter\n            c += 1\n    # Return the total count of divisors\n    return c", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Iterate through all numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n            \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of the number of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, increment the counter\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Iterate through possible divisors from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    \n    # Return the total count of divisors\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/97": {"dps": 95.19658119658119, "dps_norm": 86.25, "pass@1": 96.0, "profiled": [{"solution": "from collections import defaultdict\ndef frequency_lists(arr):\n    # Initialize a defaultdict to store frequencies\n    count_map = defaultdict(int)\n    \n    # Iterate over each list in the input list\n    for arr1 in arr:\n        # Iterate over each element in the sublist\n        for n in arr1:\n            # Increment the frequency of the element\n            count_map[n] += 1\n    \n    # Convert the defaultdict to a dictionary before returning\n    return dict(count_map)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    frequency = {}\n    # Iterate over each sublist in the list of lists\n    for sublist in lst:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # Check if the element is already in the dictionary\n            if element in frequency:\n                # Increment the count of the element in the dictionary\n                frequency[element] += 1\n            else:\n                # Add the element to the dictionary with a count of 1\n                frequency[element] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(test_list):\n    # Initialize an empty dictionary to store frequencies\n    res = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sub in test_list:\n        # Iterate over each element in the sublist\n        for ele in sub:\n            # If the element is already in the dictionary, increment its count\n            if ele in res:\n                res[ele] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                res[ele] = 1\n                \n    # Return the dictionary containing frequencies of each element\n    return res", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists into a single list\n    lst = [item for sublist in lst for item in sublist]\n    \n    # Initialize an empty dictionary to store the frequency of each element\n    f_dict = {}\n    \n    # Iterate through each element in the flattened list\n    for ele in lst:\n        # If the element is already in the dictionary, increment its count\n        if ele in f_dict:\n            f_dict[ele] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            f_dict[ele] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return f_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list1):\n    # Flatten the list of lists into a single list\n    list1 = [item for sublist in list1 for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    dict1 = {}\n    \n    # Iterate over each element in the flattened list\n    for item in list1:\n        # If the item is already in the dictionary, increment its count\n        if item in dict1:\n            dict1[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            dict1[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return dict1", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    # Flatten the list of lists using a list comprehension\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    result = dict(Counter(flattened_list))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(test_list):\n    # Flatten the list of lists using sum function\n    flat_list = sum(test_list, [])\n    \n    # Count the frequency of each element using Counter from collections\n    res = dict(Counter(flat_list))\n    \n    return res", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}  # Initialize an empty dictionary to store frequencies\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency:\n                frequency[element] += 1  # Increment the frequency of the element\n            else:\n                frequency[element] = 1  # Initialize the frequency of the element\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(test_list):\n    # Flatten the list of lists using itertools.chain\n    # Count the frequency of each element using collections.Counter\n    res = dict(Counter(chain.from_iterable(test_list)))\n    return res", "matching_cluster_idx": 7}, {"solution": "def frequency_lists(flist):\n    # Initialize an empty dictionary to store the frequency of elements\n    d = {}\n    # Iterate over each sublist in the list of lists\n    for sublist in flist:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in d:\n                d[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                d[element] = 1\n    # Return the dictionary containing the frequency of each element\n    return d", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(arr):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in arr for item in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency_dict = dict(Counter(flat_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(list1):\n    # Create a defaultdict to store the frequency of each element\n    res = defaultdict(int)\n    \n    # Iterate through each sublist in the list\n    for sub in list1:\n        # Iterate through each element in the sublist\n        for ele in sub:\n            # Increment the count of the element in the dictionary\n            res[ele] += 1\n    \n    # Convert the defaultdict to a regular dictionary and return\n    return dict(res)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list using chain.from_iterable\n    # Then, use Counter to count the frequency of each element in the flattened list\n    return dict(Counter(chain.from_iterable(list_of_lists)))", "matching_cluster_idx": 7}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(matrix):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in matrix for item in sublist]\n    \n    # Count the frequency of each element using Counter and convert to dictionary\n    result = dict(Counter(flat_list))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(arr):\n    # Initialize a defaultdict to count frequencies\n    freq = defaultdict(int)\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in arr:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # Increment the frequency count for the element\n            freq[element] += 1\n    \n    # Return the frequency dictionary\n    return dict(freq)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nums):\n    # Flatten the list of lists into a single list\n    list_nums = [num for sublist in nums for num in sublist]\n    # Count the frequency of each element in the flattened list\n    frequency = {num: list_nums.count(num) for num in set(list_nums)}\n    return frequency", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    dict1 = {}\n    \n    # Flatten the list of lists and count the frequency of each element\n    for i in lst:\n        for j in i:\n            if j in dict1:\n                dict1[j] += 1\n            else:\n                dict1[j] = 1\n    \n    # Return the dictionary with the frequency of each element\n    return dict1", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(list1: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in list1 for item in sublist]\n    # Use Counter to count the frequency of each element\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(test_list):\n    # Flatten the list of lists using list comprehension\n    flat_list = [i for sublist in test_list for i in sublist]\n    # Use Counter to count the frequency of each element in the flattened list\n    res = dict(Counter(flat_list))\n    return res", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 21.2012987012987, "dps_norm": 71.66666666666667, "pass@1": 85.0, "profiled": [{"solution": "def add_lists(list1, tup1):\n    # Convert the tuple to a list, append the second list, and convert back to a tuple\n    result = tuple(list(tup1) + list1)\n    return result", "matching_cluster_idx": 3}, {"solution": "def add_lists(test_list, test_tup):\n    # Convert the tuple to a list, append the new list, and then convert back to a tuple\n    res = tuple(list(test_tup) + test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list to it, and convert it back to a tuple\n    tup = list(tup)\n    tup.extend(lst)\n    return tuple(tup)", "matching_cluster_idx": 4}, {"solution": "def add_lists(test_list, test_tup):\n    # Append each element of the list to the tuple\n    res = tuple(list(test_tup) + test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_lists(lists, tuples):\n    # Convert the tuple to a list, append the given list, and then convert it back to a tuple\n    result = tuple(list(tuples) + lists)\n    return result", "matching_cluster_idx": 3}, {"solution": "def add_lists(test_list, test_tup):\n    # Append each element of the list to the tuple\n    res = test_tup + tuple(test_list)\n    return res", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    # Convert the tuple to a list\n    converted_tuple = list(tuple1)\n    # Extend the converted list with the given list\n    converted_tuple.extend(list1)\n    # Convert the list back to a tuple and return\n    return tuple(converted_tuple)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    # Convert the tuple to a list, append the given list, and then convert back to a tuple\n    return tuple(list(tuple1) + list1)", "matching_cluster_idx": 3}, {"solution": "def add_lists(listt, tuplee):\n    # Convert the tuple to a list, concatenate the given list, and then convert back to a tuple\n    return tuple(list(tuplee) + listt)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tup1):\n    # Convert the tuple to a list, append the second list, and then convert back to a tuple\n    return tuple(list(tup1) + list1)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tuple1):\n    # Convert the tuple to a list, append the second list, and convert it back to a tuple\n    return tuple(list(tuple1) + list1)", "matching_cluster_idx": 3}, {"solution": "def add_lists(test_list, test_tup):\n    # Convert the tuple to a list, append the original list to it, and then convert it back to a tuple\n    res = tuple(list(test_tup) + test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list and concatenate it with the given list\n    # Then convert the resulting list back to a tuple and return it\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tup):\n    # Convert the tuple to a list\n    temp = list(tup)\n    \n    # Extend the list with the original list elements\n    temp.extend(list1)\n    \n    # Convert the list back to a tuple\n    res = tuple(temp)\n    \n    return res", "matching_cluster_idx": 4}, {"solution": "def add_lists(mylist, mytuple):\n    # Convert the tuple to a list\n    mylist = list(mytuple) + mylist\n    # Convert the list back to a tuple\n    mylist = tuple(mylist)\n    return mylist", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tuple1):\n    # Convert the tuple to a list, append the given list to it, and then convert it back to a tuple\n    tuple1 = list(tuple1)\n    tuple1.extend(list1)\n    return tuple(tuple1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and then convert back to a tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tup1):\n    # Convert the tuple to a list and concatenate with the given list\n    result = list(tup1) + list1\n    # Return the concatenated list as a tuple\n    return tuple(result)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lists, tuples):\n    # Convert the tuples into a list, append the given list to it, and then convert it back to a tuple\n    new_tup = tuple(list(tuples) + lists)\n    return new_tup", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tp):\n    # Convert the tuple to a list, append the given list, and then convert back to a tuple\n    result = tuple(list(tp) + lst)\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 85.0, "profiled": [{"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Combine the three lists into one\n    nums = nums1 + nums2 + nums3\n    \n    # Sort the combined list\n    nums.sort()\n    \n    # Return the sorted list\n    return nums", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Merge the three lists into one\n    merged = nums1 + nums2 + nums3\n    # Sort the merged list\n    merged.sort()\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Merge the three lists into a single list\n    nums = nums1 + nums2 + nums3\n    \n    # Sort the merged list\n    nums.sort()\n    return nums", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Combine all three lists into one\n    nums4 = nums1 + nums2 + nums3\n    # Sort the combined list\n    nums4.sort()\n    return nums4", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Concatenate all three lists\n    nums1.extend(nums2)\n    nums1.extend(nums3)\n    # Sort the combined list\n    nums1.sort()\n    return nums1", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    \n    # Sort the merged list\n    merged_list.sort()\n    \n    # Return the sorted list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(arr1, arr2, arr3):\n    # Concatenate the three lists into one\n    merged_list = arr1 + arr2 + arr3\n    # Sort the merged list\n    merged_list.sort()\n    # Return the sorted merged list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Concatenate the three lists\n    merged_list = list1 + list2 + list3\n    \n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Concatenate the three lists into one\n    list1 = nums1 + nums2 + nums3\n    # Sort the concatenated list\n    list1.sort()\n    return list1", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(arr1, arr2, arr3):\n    # Merging the three lists\n    merged_list = arr1 + arr2 + arr3\n    # Sorting the merged list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Merge the three lists into one\n    merged = lst1 + lst2 + lst3\n    # Sort the merged list\n    merged.sort()\n    # Return the sorted merged list\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Concatenate the three input lists\n    merged_list = nums1 + nums2 + nums3\n    # Sort the merged list\n    merged_list.sort()\n    # Return the sorted list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    combined_list.sort()\n    \n    # Return the sorted list\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Merge the three lists\n    merged_list = lst1 + lst2 + lst3\n    # Sort the merged list\n    merged_list.sort()\n    # Return the sorted merged list\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(arr1, arr2, arr3):\n    # Merge the three lists\n    merged_list = arr1 + arr2 + arr3\n    \n    # Sort the merged list\n    merged_list.sort()\n    \n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(nums1, nums2, nums3):\n    # Concatenate the three lists\n    nums = nums1 + nums2 + nums3\n    # Sort the combined list\n    nums.sort()\n    return nums", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Concatenate the three lists\n    merged = list1 + list2 + list3\n    \n    # Sort the merged list\n    sorted_list = sorted(merged)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    # Concatenate the three lists\n    result = lst1 + lst2 + lst3\n    \n    # Sort the concatenated list\n    result.sort()\n    \n    # Return the sorted list\n    return result", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 33.753846153846155, "dps_norm": 71.25, "pass@1": 85.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    common_elements = set.intersection(*map(set, nested_lists))\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize a set with the first list's elements\n    common = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists\n    for sublist in nested_lists[1:]:\n        # Update the set to keep only elements present in both the current set and the current sublist\n        common &= set(sublist)\n    \n    # Return the final set of common elements\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    # Find the common elements in the nested lists using set intersection\n    result = set.intersection(*map(set, nested_list))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_list):\n    # Use set intersection to find common elements in all nested lists\n    common = set(nested_list[0]).intersection(*nested_list)\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements\n    common_elements = set.intersection(*[set(l) for l in lists])\n    # Return the common elements as a set\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set intersection to find common elements\n    common_elements = set.intersection(*map(set, nested_lists))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_list):\n    # Convert each sublist to a set and find the intersection\n    common_elements = set.intersection(*map(set, nested_list))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(input_list):\n    # Use set intersection to find common elements across all sublists\n    result = set.intersection(*[set(sublist) for sublist in input_list])\n    return result", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(lists):\n    # Initialize the common elements list with the first list in the nested lists\n    common_list = lists[0]\n    \n    # Iterate over the remaining lists in the nested lists\n    for i in range(1, len(lists)):\n        # Update the common_list with the intersection of itself and the current list\n        common_list = [value for value in common_list if value in lists[i]]\n    \n    # Return the common elements as a set\n    return set(common_list)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    # Initialize the result list with the first sublist\n    result = nested_list[0]\n    \n    # Iterate over each sublist starting from the second one\n    for sublist in nested_list[1:]:\n        # Update the result list to keep only the common elements\n        result = list(set(result).intersection(sublist))\n    \n    # Return the result list as a set for an unordered collection of unique elements\n    return set(result)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use the set intersection method to find common elements\n    return set.intersection(*map(set, nested_lists))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist to a set and find the intersection\n    result = set.intersection(*map(set, nested_lists))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Get the set of elements from each sublist and find the intersection\n    result_set = set.intersection(*[set(i) for i in nested_lists])\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(list_of_lists):\n    # Initialize a set with the elements of the first nested list\n    common_elements = set(list_of_lists[0])\n    \n    # Iterate over the rest of the nested lists\n    for sublist in list_of_lists[1:]:\n        # Update the set of common elements to intersection of current and next sublist\n        common_elements &= set(sublist)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the first list as the intersection set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for i in range(1, len(nested_lists)):\n        # Find the intersection with the current list\n        common_elements = common_elements.intersection(set(nested_lists[i]))\n    \n    # Return the set of common elements\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(a):\n    # Initialize the result set with elements from the first sublist\n    result = set(a[0])\n    \n    # Iterate over the remaining sublists\n    for b in a[1:]:\n        # Update the result set to keep only the common elements\n        result = result.intersection(b)\n    \n    # Return the result set as a sorted list\n    return sorted(list(result))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements in the nested lists\n    return set.intersection(*map(set, nested_lists))", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(list1):\n    # Find common elements in the nested lists\n    result = list(set.intersection(*map(set, list1)))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Any\ndef common_in_nested_lists(lists: List[List[Any]]) -> List[Any]:\n    # Find the intersection of all sets in the list of lists\n    common_elements = list(set.intersection(*map(set, lists)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(input_list):\n    # Use set intersection to find common elements in nested lists\n    return set.intersection(*map(set, input_list))", "matching_cluster_idx": 4}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 27.0, "profiled": [{"solution": "def amicable_numbers_sum(n):\n    # Function to find the sum of proper divisors of a number\n    def div_sum(x):\n        total = 1  # Start with 1 since it's a proper divisor for all x > 1\n        i = 2\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                if i * (x // i) == x:  # Check to avoid adding the square root twice for perfect squares\n                    total += i + x // i\n                else:\n                    total += i + x // i\n                i += 1\n        return total\n    \n    # Main logic to find amicable numbers and their sum\n    amicable_sum = 0\n    for i in range(2, n):\n        sum1 = div_sum(i)\n        sum2 = div_sum(sum1)\n        if i == sum2 and i != sum1:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_proper_divisors(n):\n        total = 1  # 1 is a proper divisor of all numbers\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:  # Add the quotient only if it's different from i\n                    total += n // i\n        return total\n    \n    amicable_sum = 0\n    # Iterate through numbers from 2 to the specified upper limit\n    for i in range(2, upper):\n        partner = sum_of_proper_divisors(i)\n        # Check if the number is amicable\n        if i == sum_of_proper_divisors(partner) and i != partner:\n            amicable_sum += i + partner\n    return amicable_sum // 2  # Each pair is counted twice, so divide by 2", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        divisors_sum = 1\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if i * (n // i) == n:\n                    divisors_sum = divisors_sum + i + n//i\n                else:\n                    divisors_sum = divisors_sum + i + n//i\n                i += 1\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through all numbers from 1 to upper_limit\n    for i in range(2, upper_limit + 1):\n        sum1 = sum_of_divisors(i)\n        sum2 = sum_of_divisors(sum1)\n        \n        # Check if the pair is amicable and not repeated\n        if (i == sum2 and sum1 != sum2):\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to find the sum of proper divisors of n\n    def sum_of_divisors(n):\n        total = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n\n    # List to store amicable numbers\n    amicable_nums = []\n    \n    # Iterate through numbers to find amicable pairs\n    for a in range(2, upper_limit):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_nums.append(a)\n            amicable_nums.append(b)\n    \n    # Calculate the sum of all unique amicable numbers\n    return sum(set(amicable_nums))", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(num):\n        total = 1  # Start with 1 as it is a proper divisor of all numbers\n        sqrt_num = int(num ** 0.5) + 1  # Only need to check up to the square root\n        for i in range(2, sqrt_num):\n            if num % i == 0:\n                total += i\n                if i != num // i:  # Add the corresponding divisor pair\n                    total += num // i\n        return total\n\n    # Find and sum all amicable numbers from 1 to upper_limit\n    amicable_sum = 0\n    for num in range(2, upper_limit):\n        amicable_pair = sum_of_divisors(num)\n        if sum_of_divisors(amicable_pair) == num and num < amicable_pair:\n            amicable_sum += num\n            amicable_sum += amicable_pair\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(x):\n        total = 1  # 1 is a proper divisor of any number\n        i = 2\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                if i * (x // i) == x:\n                    total = total + i + x // i\n                else:\n                    total = total + i + x // i\n                i += 1\n        return total\n\n    sum_amicable = 0\n    # Iterate through all numbers from 2 to n\n    for i in range(2, n + 1):\n        j = sum_of_divisors(i)\n        # Check if the sum of divisors of i equals j and j equals i\n        if i == sum_of_divisors(j) and i != j:\n            sum_amicable += i + j\n    # Return the sum of all amicable numbers up to n\n    return sum_amicable // 2", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of proper divisors of n\n    def sum_of_divisors(n):\n        total = 1  # Start with 1 because it is a proper divisor for all n > 1\n        for i in range(2, int(n**0.5) + 1):  # Only go up to the square root of n\n            if n % i == 0:\n                total += i\n                if i != n // i:  # Avoid adding the square root twice for perfect squares\n                    total += n // i\n        return total\n    \n    total_sum = 0  # Initialize the total sum of amicable numbers\n    for a in range(2, upper_limit):  # Start from 2 because 1 is not considered amicable\n        b = sum_of_divisors(a)\n        if a != b and a == sum_of_divisors(b):\n            total_sum += a  # Only add a if it is part of an amicable pair and not already added\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    # Function to calculate sum of proper divisors of n\n    def sum_of_divisors(n):\n        # Start with 1 as it's a proper divisor for all numbers\n        total_sum = 1\n        # Loop from 2 to square root of n to find other divisors\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total_sum += i\n                # Add the divisor pair if it's different from i\n                if i != n // i:\n                    total_sum += n // i\n        return total_sum\n    \n    # Dictionary to store amicable pairs\n    amicable_pairs = {}\n    for number in range(2, limit + 1):\n        # Check if number is not already in dictionary to avoid reprocessing\n        if number not in amicable_pairs:\n            # Calculate sum of divisors for the current number\n            div_sum = sum_of_divisors(number)\n            # Check if the calculated sum has a corresponding sum that is a divisor of the number\n            if sum_of_divisors(div_sum) == number and number != div_sum:\n                # Add both numbers as amicable pairs\n                amicable_pairs[number] = div_sum\n                amicable_pairs[div_sum] = number\n    \n    # Sum all unique amicable numbers\n    return sum(amicable_pairs.keys())", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(N):\n    # Helper function to calculate the sum of divisors excluding the number itself\n    def sum_of_divisors(n):\n        result = 1  # 1 is a divisor for all numbers\n        sqrt_n = int(n ** 0.5)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                result += i\n                if i != n // i:\n                    result += n // i\n        return result\n\n    # Set to store amicable numbers\n    amicable_set = set()\n    for num in range(2, N + 1):\n        # Calculate the sum of divisors for the current number\n        div_sum = sum_of_divisors(num)\n        # Check if the sum of divisors is within the range and forms an amicable pair\n        if num != div_sum and num == sum_of_divisors(div_sum):\n            amicable_set.add(num)\n            amicable_set.add(div_sum)\n\n    # Return the sum of all amicable numbers\n    return sum(amicable_set)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        sum = 1  # Start with 1 because it's a proper divisor for all n > 1\n        i = 2\n        # Only need to check up to the square root of n\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if i * (n // i) == n:  # Check to avoid adding the square root twice for perfect squares\n                    sum = sum + i + n // i\n                else:\n                    sum = sum + i + n // i\n                i += 1\n        return sum\n    \n    amicable_sum = 0\n    # Iterate through numbers from 1 to upper_limit\n    for n in range(1, upper_limit):\n        sum1 = sum_of_divisors(n)\n        # Check if the sum of divisors of sum1 is n and n is not equal to sum1\n        if (sum_of_divisors(sum1) == n and n != sum1):\n            amicable_sum += n\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of proper divisors of a number\n    def divisors_sum(num):\n        total = 1  # 1 is a proper divisor of any number\n        for divisor in range(2, int(num ** 0.5) + 1):\n            if num % divisor == 0:\n                total += divisor\n                if divisor != num // divisor:  # Check to avoid adding the square root twice\n                    total += num // divisor\n        return total\n    \n    total_sum = 0  # Initialize the sum of amicable numbers\n    \n    # Iterate through all numbers up to the upper limit\n    for number in range(2, upper_limit + 1):\n        # Calculate the sum of divisors of the current number\n        div_sum = divisors_sum(number)\n        # Check if the number is amicable\n        if div_sum != number and divisors_sum(div_sum) == number:\n            total_sum += number\n    \n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Helper function to calculate the sum of proper divisors of n\n    def sum_of_divisors(x):\n        divisors_sum = 1  # Start with 1 since it's a proper divisor of all numbers\n        i = 2\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                if i * (x // i) == x:\n                    divisors_sum = divisors_sum + i + x // i\n                else:\n                    divisors_sum = divisors_sum + i + x // i\n                i += 1\n        return divisors_sum\n    \n    # Iterate through all numbers from 1 to n-1\n    return sum(x for x in range(1, n) if sum_of_divisors(x) != x and sum_of_divisors(sum_of_divisors(x)) == x)", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    # Initialize sum of divisors with 1, as it's a proper divisor of every number\n    sum = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            # If divisors are equal, add only one\n            if i * (n // i) == n:\n                sum = sum + i + n // i\n            else:\n                # Add both divisors\n                sum = sum + i + n // i\n            i += 1\n    return sum\ndef amicable_numbers_sum(upper_limit):\n    # Initialize total sum of amicable numbers\n    sum_amicable = 0\n    # Iterate through numbers up to the upper limit\n    for num in range(2, upper_limit + 1):\n        # Check if the number is amicable\n        if sum_proper_divisors(num) != num and sum_proper_divisors(sum_proper_divisors(num)) == num:\n            sum_amicable += num\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Helper function to calculate the sum of divisors of a number\n    def sum_divisors(n):\n        # Initialize sum with 1 because 1 is a divisor for all n > 1\n        sum = 1\n        # Iterate from 2 to the square root of n\n        i = 2\n        while i * i <= n:\n            # If i divides n, add both divisors\n            if n % i == 0:\n                if i * i != n:\n                    sum = sum + i + n // i\n                else:\n                    sum = sum + i\n            i = i + 1\n        return sum\n\n    # Initialize sum of amicable numbers\n    amicable_sum = 0\n    # Iterate through numbers from 1 to n-1\n    for i in range(1, n):\n        # Check if the number is amicable\n        if sum_divisors(i) != i and sum_divisors(sum_divisors(i)) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # 1 is a proper divisor of any number\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:  # Add the complement divisor if it's different\n                    total += n // i\n        return total\n\n    # List to store amicable numbers within the range\n    amicable_numbers = []\n    \n    # Iterate through the range to find amicable numbers\n    for i in range(2, upper_limit + 1):\n        if i not in amicable_numbers:\n            partner = sum_of_divisors(i)\n            if partner != i and sum_of_divisors(partner) == i:\n                amicable_numbers.append(i)\n                amicable_numbers.append(partner)\n    \n    # Sum all amicable numbers found\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to calculate the sum of divisors of a number\n    def sum_of_divisors(x):\n        sum = 1\n        i = 2\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                if i * (x // i) == x:\n                    sum = sum + i + x // i\n                else:\n                    sum = sum + i + x // i\n                i += 1\n        return sum\n    \n    # Calculate the sum of all amicable numbers up to n\n    amicable_sum = 0\n    for num in range(1, n + 1):\n        # Get the sum of divisors of num\n        div_sum = sum_of_divisors(num)\n        # Check if the sum of divisors is amicable\n        if div_sum != num and sum_of_divisors(div_sum) == num:\n            amicable_sum += num\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    # Function to find the sum of divisors of a number excluding the number itself\n    def sum_of_divisors(n):\n        sum = 1\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if i * (n // i) == n:\n                    sum = sum + i + n // i\n                else:\n                    sum = sum + i + n // i\n                i += 1\n        return sum\n    \n    # List to store amicable numbers\n    amicable = []\n    \n    # Loop through all numbers from 1 to the limit\n    for a in range(1, limit + 1):\n        # Find the sum of divisors of a\n        sum_a = sum_of_divisors(a)\n        \n        # Check if the sum of divisors of sum_a is a and not equal to a\n        if sum_of_divisors(sum_a) == a and a != sum_a:\n            # Ensure a is not already in the amicable list\n            if a not in amicable:\n                amicable.append(a)\n            # Ensure sum_a is not already in the amicable list\n            if sum_a not in amicable:\n                amicable.append(sum_a)\n    \n    # Sum all unique amicable numbers and return the result\n    return sum(amicable)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to find the sum of proper divisors of a number\n    def sum_divisors(num):\n        total = 1  # 1 is always a divisor\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                total += i\n                if i != num // i:  # Add the pair divisor if it's different from i\n                    total += num // i\n        return total\n    \n    # Initialize sum of amicable numbers\n    amicable_sum = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(2, n + 1):\n        # Find the sum of divisors of i\n        sum_i = sum_divisors(i)\n        \n        # Check if the sum of divisors of sum_i is i and not equal to i itself\n        if sum_i != i and sum_divisors(sum_i) == i:\n            amicable_sum += i\n            \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of divisors of a number\n    def sum_of_divisors(num):\n        # Initialize the sum with 1 because it is a proper divisor\n        total = 1\n        # Check for divisors from 2 to the square root of the number\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                total += i\n                # If the divisor is not the square root of the number, add both divisors\n                if i != num // i:\n                    total += num // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    total_amicable = 0\n    # Iterate through all numbers from 2 to the upper limit\n    for num in range(2, upper_limit + 1):\n        # Calculate the sum of divisors of the current number\n        a = sum_of_divisors(num)\n        # Check if the sum of divisors of the sum equals the original number and they are not the same\n        if sum_of_divisors(a) == num and a != num:\n            total_amicable += num\n    \n    # Return the total sum of amicable numbers\n    return total_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(upper_limit):\n    # Helper function to calculate the sum of divisors of n\n    def getDivisorSum(n):\n        total = 1  # 1 is always a divisor\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                if i * (n // i) == n:\n                    total += i + n // i\n                else:\n                    total += i\n                    total += n // i\n                i += 1\n        return total\n\n    total_sum = 0\n    # Iterate through numbers to find amicable pairs\n    for num in range(1, upper_limit):\n        sum1 = getDivisorSum(num)\n        sum2 = getDivisorSum(sum1)\n        if num == sum2 and num != sum1:\n            total_sum += num\n    return total_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 85.36199095022624, "dps_norm": 77.0, "pass@1": 98.0, "profiled": [{"solution": "def long_words(n, string):\n    # Split the input string into a list of words\n    words_list = string.split(\" \")\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    # Filter words that are longer than n characters and return them\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split(\" \")\n    # Use list comprehension to filter words longer than 'n' characters\n    longer_words = [word for word in words if len(word) > n]\n    # Return the list of filtered words\n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    # Use list comprehension to filter out words longer than n characters\n    long_word_list = [word for word in words if len(word) > n]\n    # Return the list of long words\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    # Split the string into individual words\n    words = str.split(\" \")\n    # Initialize an empty list to store words longer than n characters\n    result = []\n    # Iterate over each word in the list\n    for word in words:\n        # If the length of the word is greater than n, add it to the result list\n        if len(word) > n:\n            result.append(word)\n    # Return the list of words longer than n characters\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    # Filter words longer than n characters and return the list\n    longer_words = list(filter(lambda x: len(x) > n, words))\n    return longer_words", "matching_cluster_idx": 2}, {"solution": "def long_words(n, string):\n    # Split the string into a list of words\n    words = string.split(\" \")\n    # Filter and return words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    # Split the input string into a list of words\n    str = str.split(\" \")\n    # Filter words that are longer than 'n' characters using list comprehension\n    result = [word for word in str if len(word) > n]\n    # Return the filtered list of words\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, x):\n    # Initialize an empty list to store words longer than n characters\n    result = []\n    # Iterate over each word in the given list\n    for word in x.split():\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If so, add the word to the result list\n            result.append(word)\n    # Return the list of words longer than n characters\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split(\" \")\n    \n    # Filter and return words that are longer than n characters\n    return list(filter(lambda x: len(x) > n, words))", "matching_cluster_idx": 2}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    \n    # Use list comprehension to filter out words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, x):\n    # Use list comprehension to filter words longer than n characters\n    result = [i for i in x.split(\" \") if len(i) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    # Return the list of long words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the string into words using space as a delimiter\n    words = string.split(\" \")\n    # Filter words to include only those longer than n characters\n    longer_words = list(filter(lambda x: len(x) > n, words))\n    return longer_words", "matching_cluster_idx": 2}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words = str1.split(\" \")\n    # Use list comprehension to filter words longer than 'n' characters\n    long_words_list = [word for word in words if len(word) > n]\n    # Return the list of filtered words\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    # Split the input string into a list of words\n    words = str.split(\" \")\n    # Use list comprehension to filter and select words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str):\n    # Split the input string into a list of words\n    str = str.split(\" \")\n    # Use list comprehension to filter words longer than n characters\n    longword = [word for word in str if len(word) > n]\n    return longword", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Split the input string into a list of words\n    words_list = str1.split(\" \")\n    \n    # Filter the list to include only words longer than n characters\n    resultant_list = [word for word in words_list if len(word) > n]\n    \n    return resultant_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, str1):\n    # Use list comprehension to filter words longer than 'n' characters\n    result = [word for word in str1.split() if len(word) > n]\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 92.38520408163265, "dps_norm": 99.0, "pass@1": 36.0, "profiled": [{"solution": "def magic_square_test(M):\n    def magic_square(M):\n        n = len(M)\n        s = sum(M[0])  # Sum of the first row as reference\n\n        # Check sums of rows\n        for i in range(1, n):\n            if sum(M[i]) != s:\n                return False\n\n        # Check sums of columns\n        for j in range(n):\n            if sum(M[i][j] for i in range(n)) != s:\n                return False\n\n        # Check sum of main diagonal\n        if sum(M[i][i] for i in range(n)) != s:\n            return False\n\n        # Check sum of secondary diagonal\n        if sum(M[i][n - i - 1] for i in range(n)) != s:\n            return False\n\n        return True\n\n    return magic_square(M)", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(array):\n    # Calculate the size of the matrix\n    size = len(array)\n    \n    # Calculate the magic sum using the first element\n    magic_sum = sum(array[0])\n    \n    # Function to check the sum of elements in a row\n    def row_sum(array, i):\n        return sum(array[i])\n    \n    # Function to check the sum of elements in a column\n    def column_sum(array, i):\n        return sum(array[j][i] for j in range(size))\n    \n    # Function to check the sum of elements in the main diagonal\n    def main_diagonal_sum(array):\n        return sum(array[i][i] for i in range(size))\n    \n    # Function to check the sum of elements in the secondary diagonal\n    def secondary_diagonal_sum(array):\n        return sum(array[i][size - i - 1] for i in range(size))\n    \n    # Check the sums of all rows, columns, and diagonals\n    for i in range(size):\n        if row_sum(array, i) != magic_sum:\n            return False\n        if column_sum(array, i) != magic_sum:\n            return False\n    \n    if main_diagonal_sum(array) != magic_sum:\n        return False\n    if secondary_diagonal_sum(array) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(mat):\n    # Check if the given matrix is a magic square\n    n = len(mat)\n    m = len(mat[0])\n    \n    # Check if the matrix is square\n    if n != m:\n        return False\n    \n    # Calculate the sum of the elements in the first row\n    s = sum(mat[0])\n    \n    # Check the sums of the elements in the other rows\n    for i in range(1, n):\n        if sum(mat[i]) != s:\n            return False\n    \n    # Check the sums of the elements in the columns\n    for i in range(n):\n        if sum(mat[j][i] for j in range(n)) != s:\n            return False\n    \n    # Check the sums of the elements in the diagonals\n    if sum(mat[i][i] for i in range(n)) != s:\n        return False\n    if sum(mat[i][n-i-1] for i in range(n)) != s:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(test_matrix): \n    size = len(test_matrix)  # Get the size of the matrix\n    sum_magic = sum(test_matrix[0])  # Calculate the sum of the first row as the reference\n\n    # Check if the sum of each row is the same\n    for i in range(1, size): \n        if sum(test_matrix[i]) != sum_magic: \n            return False \n\n    # Check if the sum of each column is the same\n    for i in range(size): \n        sum_col = 0\n        for j in range(size): \n            sum_col += test_matrix[j][i] \n        if sum_col != sum_magic: \n            return False \n\n    # Check if the sum of the main diagonal is the same\n    sum_diag1 = 0\n    for i in range(size): \n        sum_diag1 += test_matrix[i][i] \n\n    # Check if the sum of the secondary diagonal is the same\n    sum_diag2 = 0\n    for i in range(size): \n        sum_diag2 += test_matrix[i][size - i - 1] \n\n    # Check if the sum of the main diagonal and the secondary diagonal are equal to the reference sum\n    if sum_diag1 != sum_magic or sum_diag2 != sum_magic: \n        return False \n\n    # If all checks pass, return True\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(n):\n    # Check if each row has the same sum\n    for x in range(len(n)):\n        if sum(n[x]) != sum(n[0]):\n            return False\n    \n    # Check if each column has the same sum\n    for x in range(len(n)):\n        sum1 = 0\n        for y in range(len(n)):\n            sum1 += n[y][x]\n        if sum1 != sum(n[0]):\n            return False\n    \n    # Check if the sum of the diagonals are the same\n    sum1 = 0\n    sum2 = 0\n    for x in range(len(n)):\n        sum1 += n[x][x]\n        sum2 += n[x][len(n) - x - 1]\n    \n    if sum1 != sum(n[0]) or sum2 != sum(n[0]):\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(magic_square):\n    # Sum of the elements in the first row to be used as a reference\n    n = len(magic_square)\n    magic_sum = 0\n    for num in magic_square[0]:\n        magic_sum += num\n    \n    # Check sums of all rows\n    for i in range(1, n):\n        row_sum = 0\n        for num in magic_square[i]:\n            row_sum += num\n        if row_sum != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for i in range(n):\n        col_sum = 0\n        for j in range(n):\n            col_sum += magic_square[j][i]\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sums of the two diagonals\n    d1_sum = sum(magic_square[i][i] for i in range(n))\n    if d1_sum != magic_sum:\n        return False\n    \n    d2_sum = sum(magic_square[i][n-i-1] for i in range(n))\n    if d2_sum != magic_sum:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    magic_sum = sum(matrix[0])  # Calculate the sum of the first row as the magic sum\n    n = len(matrix)  # Get the size of the matrix\n    \n    # Check the sum of all rows\n    for row in range(1, n):\n        if sum(matrix[row]) != magic_sum:\n            return False\n    \n    # Check the sum of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(arr):\n    n = len(arr)\n    s = sum(arr[0])\n    \n    # Check sums of each row\n    for i in range(1, n):\n        if sum(arr[i]) != s:\n            return False\n    \n    # Check sums of each column\n    for i in range(n):\n        if sum(arr[j][i] for j in range(n)) != s:\n            return False\n    \n    # Check sum of main diagonal\n    if sum(arr[i][i] for i in range(n)) != s:\n        return False\n    \n    # Check sum of secondary diagonal\n    if sum(arr[i][n-i-1] for i in range(n)) != s:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(grid):\n    # Function to check if a matrix is a magic square\n    n = len(grid)  # Number of rows/columns in the matrix\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(grid[0])\n    \n    # Check sums of all rows\n    for row in grid:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(grid[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(grid[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(grid[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(grid):\n    # Calculate the length of the grid\n    n = len(grid)\n    \n    # Calculate the magic constant by summing the first row\n    magic_constant = sum(grid[0])\n    \n    # Check the sum of each row\n    for row in grid:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(grid[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(grid[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(grid[i][n-1-i] for i in range(n)) != magic_constant:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(m):\n    # Get the size of the matrix\n    n = len(m)\n    # Calculate the magic sum using the first row\n    sum_of_magic = sum(m[0])\n    \n    # Check each row for the magic sum\n    for i in range(1, n):\n        if sum(m[i]) != sum_of_magic:\n            return False\n    \n    # Check each column for the magic sum\n    for i in range(n):\n        if sum(m[j][i] for j in range(n)) != sum_of_magic:\n            return False\n    \n    # Check the main diagonal\n    if sum(m[i][i] for i in range(n)) != sum_of_magic:\n        return False\n    \n    # Check the secondary diagonal\n    if sum(m[i][n - i - 1] for i in range(n)) != sum_of_magic:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(test_matrix):\n    # Check if the matrix is square\n    if len(test_matrix) != len(test_matrix[0]):\n        return False\n    \n    size = len(test_matrix)\n    magic_constant = 0\n    \n    # Calculate the magic constant using the first row\n    for num in test_matrix[0]:\n        magic_constant += num\n    \n    # Check the sum of each row\n    for row in test_matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(size):\n        if sum(test_matrix[row][col] for row in range(size)) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(test_matrix[i][i] for i in range(size)) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(test_matrix[i][size - i - 1] for i in range(size)) != magic_constant:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(grid):\n    magic = 0\n    n = len(grid)\n    \n    # Sum the first row to set as the magic sum\n    magic = sum(grid[0])\n    \n    # Check if sum of each row is the same\n    for i in range(1, n):\n        if sum(grid[i]) != magic:\n            return False\n    \n    # Check if sum of each column is the same\n    for i in range(n):\n        if sum(grid[j][i] for j in range(n)) != magic:\n            return False\n    \n    # Check if sum of diagonal (top-left to bottom-right) is the same\n    if sum(grid[i][i] for i in range(n)) != magic:\n        return False\n    \n    # Check if sum of anti-diagonal (top-right to bottom-left) is the same\n    if sum(grid[i][n-1-i] for i in range(n)) != magic:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the size of the matrix\n    size = len(matrix)\n    \n    # Calculate the sum of the first row to use as a reference\n    total_sum = sum(matrix[0])\n    \n    # Check sums of the other rows\n    for row in matrix[1:]:\n        if sum(row) != total_sum:\n            return False\n    \n    # Check sums of the columns\n    for col in range(size):\n        if sum(matrix[row][col] for row in range(size)) != total_sum:\n            return False\n    \n    # Check sums of the diagonals\n    if sum(matrix[i][i] for i in range(size)) != total_sum:\n        return False\n    if sum(matrix[i][size - 1 - i] for i in range(size)) != total_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(magic_square):\n    n = len(magic_square)\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(magic_square[0])\n    \n    # Check sums of rows\n    for row in magic_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of columns\n    for col in range(n):\n        if sum(magic_square[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(magic_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(magic_square[i][n-1-i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Initialize the magic constant with the sum of the first row\n    magic_constant = sum(matrix[0])\n    n = len(matrix)\n    \n    # Calculate the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Calculate the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Calculate the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Calculate the sum of the secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(arr):\n    n = len(arr)\n    # Calculate the sum of the first row for the magic constant\n    magic_constant = sum(arr[0])\n    \n    # Check sums of all rows\n    for i in range(1, n):\n        if sum(arr[i]) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for i in range(n):\n        if sum(arr[j][i] for j in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of main diagonal\n    if sum(arr[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of secondary diagonal\n    if sum(arr[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(magic_square):\n    # Calculate the size of the matrix\n    n = len(magic_square)\n    \n    # Calculate the magic number by summing the first row and dividing by n\n    magic_number = sum(magic_square[0])\n    \n    # Check sums of all rows\n    for row in magic_square:\n        if sum(row) != magic_number:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(magic_square[row][col] for row in range(n)) != magic_number:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(magic_square[i][i] for i in range(n)) != magic_number:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(magic_square[i][n-i-1] for i in range(n)) != magic_number:\n        return False\n    \n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix): \n    # Determine the size of the square matrix\n    n = len(matrix) \n    \n    # Calculate the sum of the first row for comparison\n    total_sum = sum(matrix[0]) \n    \n    # Check sums of all rows\n    for row in range(1, n): \n        if sum(matrix[row]) != total_sum: \n            return False\n    \n    # Check sums of all columns\n    for col in range(n): \n        if sum(matrix[row][col] for row in range(n)) != total_sum: \n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != total_sum: \n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - i - 1] for i in range(n)) != total_sum: \n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(arr):\n    # Calculate the size of the matrix\n    N = len(arr)\n    \n    # Calculate the sum of the first row for reference\n    magic_sum = sum(arr[0])\n    \n    # Calculate sums of each row\n    for row in arr:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Calculate sums of each column\n    for col in range(N):\n        if sum(arr[row][col] for row in range(N)) != magic_sum:\n            return False\n    \n    # Calculate sum of the main diagonal\n    if sum(arr[i][i] for i in range(N)) != magic_sum:\n        return False\n    \n    # Calculate sum of the secondary diagonal\n    if sum(arr[i][N - 1 - i] for i in range(N)) != magic_sum:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 72.71300448430493, "dps_norm": 66.66666666666667, "pass@1": 74.0, "profiled": [{"solution": "def max_occurrences(arr):\n    # Create a dictionary to store the frequency of each item\n    freq = {}\n    \n    # Iterate over the array to count the frequency of each item\n    for item in arr:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    \n    # Initialize variables to keep track of the item with the maximum frequency\n    max_item = 0\n    max_val = 0\n    \n    # Iterate over the dictionary to find the item with the maximum frequency\n    for item, value in freq.items():\n        if value > max_val:\n            max_val = value\n            max_item = item\n    \n    # Return the item with the maximum frequency\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(arr):\n    # Initialize a dictionary to store the frequency of each item\n    d = {}\n    # Iterate over each item in the list\n    for i in arr:\n        # Increment the count of the item in the dictionary\n        d[i] = d.get(i, 0) + 1\n    \n    # Find the maximum value in the dictionary\n    max_value = max(d.values())\n    \n    # Iterate over the dictionary to find the item(s) with the maximum frequency\n    for (k, v) in d.items():\n        if v == max_value:\n            # Return the item with the maximum frequency\n            return k", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef max_occurrences(nums):\n    # Create a dictionary to store the frequency of each item\n    freq = defaultdict(int)\n    \n    # Iterate through the list and count the frequency of each item\n    for i in nums:\n        freq[i] += 1\n    \n    # Initialize variables to store the item with maximum frequency and its count\n    max_count = 0\n    max_item = None\n    \n    # Iterate through the dictionary to find the item with the highest frequency\n    for item, count in freq.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    # Return the item with the maximum frequency\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    # Use Counter to count occurrences of each item\n    count_dict = Counter(nums)\n    # Find the item with the maximum occurrence\n    res = max(count_dict, key=count_dict.get)\n    return res", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(list1):\n    # Using the max function with key parameter to find the element with the maximum frequency\n    return max(list1, key=list1.count)", "matching_cluster_idx": 1}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    # Count occurrences of each element in the list\n    frequency = Counter(nums)\n    # Find the element with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import defaultdict\ndef max_occurrences(nums):\n    # Dictionary to store frequency of each element\n    my_dict = defaultdict(int)\n    \n    # Count frequency of each element\n    for num in nums:\n        my_dict[num] += 1\n    \n    # Return the element with the maximum frequency\n    return max(my_dict, key=my_dict.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    # Use a dictionary to store the frequency of each number\n    frequency = {}\n    \n    # Iterate over each number in the list\n    for num in nums:\n        # If the number is already in the dictionary, increment its count\n        if num in frequency:\n            frequency[num] += 1\n        # If the number is not in the dictionary, add it with a count of 1\n        else:\n            frequency[num] = 1\n    \n    # Return the key (number) with the maximum value (frequency)\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    # Use Counter to count occurrences of each number in the list\n    frequency = Counter(nums)\n    # Return the number with the maximum occurrence\n    return max(frequency, key=frequency.get)", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(nums):\n    # Create a counter object to count occurrences of each item\n    count = Counter(nums)\n    # Find the item with the maximum frequency\n    max_item = max(count, key=count.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(arr):\n    # Initialize a dictionary to store the frequency of each element\n    count = {}\n    for i in arr:\n        count[i] = count.get(i, 0) + 1\n    \n    # Initialize variables to keep track of the item with maximum frequency and its count\n    max_count = 0\n    max_item = arr[0]\n    \n    # Iterate through the dictionary to find the item with the maximum frequency\n    for i in count:\n        if count[i] > max_count:\n            max_count = count[i]\n            max_item = i\n    \n    # Return the item with maximum frequency\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(input_list):\n    # Initialize a dictionary to keep track of item frequencies\n    dict = {}\n    \n    # Iterate over each item in the input list\n    for item in input_list:\n        # If the item is already in the dictionary, increment its count\n        if item in dict:\n            dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            dict[item] = 1\n    \n    # Find the maximum frequency among all items\n    max_value = max(dict.values())\n    \n    # Initialize a variable to store the item with the maximum frequency\n    max_item = -1\n    \n    # Iterate over the dictionary items to find the item with the maximum frequency\n    for (key, value) in dict.items():\n        if max_value == value:\n            # Return the item with the maximum frequency\n            return key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    # Create a dictionary to store the frequency of each number\n    freq = dict()\n    # Find the maximum frequency\n    max_freq = 0\n    # Iterate over each number in the list\n    for num in nums:\n        # Increment the frequency of the current number\n        freq[num] = freq.get(num, 0) + 1\n        # Update the maximum frequency if necessary\n        if freq[num] > max_freq:\n            max_freq = freq[num]\n    \n    # Iterate over the list again to find the number with the maximum frequency\n    for num in nums:\n        if freq[num] == max_freq:\n            return num", "matching_cluster_idx": 3}, {"solution": "from collections import defaultdict\ndef max_occurrences(arr):\n    # Create a dictionary to store the frequency of each item\n    frequency = defaultdict(int)\n    \n    # Iterate over each item in the array\n    for item in arr:\n        # Increment the count for the current item\n        frequency[item] += 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    # Use dictionary to store the frequency of each element\n    mp = {}\n    \n    # Traverse through the list and count the frequency of each element\n    for x in nums:\n        if x in mp:\n            mp[x] += 1\n        else:\n            mp[x] = 1\n    \n    # Initialize a variable to store the maximum frequency found\n    max_freq = -1\n    # Initialize a variable to store the item with maximum frequency\n    x = 0\n    \n    # Iterate through the dictionary to find the item with the maximum frequency\n    for key, value in mp.items():\n        if value > max_freq:\n            max_freq = value\n            x = key\n    \n    # Return the item with the maximum frequency\n    return x", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(arr):\n    # Dictionary to store the frequency of each element\n    freq = {}\n    for i in arr:\n        if i in freq:\n            # Increment the count if the element is already in the dictionary\n            freq[i] += 1\n        else:\n            # Initialize the count to 1 if the element is not in the dictionary\n            freq[i] = 1\n    \n    # Return the key with the maximum value from the dictionary\n    return max(freq, key=freq.get)", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    count_dict = {}\n    \n    # Count the frequency of each item\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    max_occurrence = max(count_dict.values())\n    max_key = None\n    \n    # Find the item with the maximum frequency\n    for key, value in count_dict.items():\n        if value == max_occurrence:\n            max_key = key\n            break\n    \n    return max_key", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(nums):\n    # Create a dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # If the number is already in the dictionary, increment its count\n        if num in freq_dict:\n            freq_dict[num] += 1\n        # Otherwise, add the number to the dictionary with a count of 1\n        else:\n            freq_dict[num] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(freq_dict, key=freq_dict.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(test_list):\n    # Initialize result and frequency counter\n    res = 0\n    freq = -float('inf')\n    \n    # Iterate through the list\n    for ele in test_list:\n        # Count occurrences of each element\n        temp = test_list.count(ele)\n        \n        # Update result and frequency if current element's frequency is higher\n        if temp > freq:\n            res = ele\n            freq = temp\n    \n    return res", "matching_cluster_idx": 1}, {"solution": "def max_occurrences(arr):\n    # Dictionary to store the frequency of each element\n    dict = {}\n    \n    # Count the frequency of each element\n    for i in arr:\n        if i not in dict:\n            dict[i] = 0\n        dict[i] += 1\n    \n    # Initialize variables to store the maximum frequency and its corresponding element\n    max_key = arr[0]\n    max_val = dict[arr[0]]\n    \n    # Find the element with the maximum frequency\n    for (key, value) in dict.items():\n        if value > max_val:\n            max_val = value\n            max_key = key\n    \n    return max_key", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/140": {"dps": 74.48757763975155, "dps_norm": 74.375, "pass@1": 98.0, "profiled": [{"solution": "def extract_singly(data):\n    # Initialize an empty set to store unique numbers\n    res = set()\n    # Iterate through each sublist in the list of lists\n    for i in range(len(data)):\n        # Update the set with elements from the current sublist\n        res.update(data[i])\n    # Return the set containing unique numbers\n    return res", "matching_cluster_idx": 6}, {"solution": "from itertools import chain\ndef extract_singly(list_of_lists):\n    # Flatten the list of lists and convert it into a set to remove duplicates\n    return set(chain.from_iterable(list_of_lists))", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lst):\n    # Use list comprehension to iterate through each sublist\n    # Use set to remove duplicates and flatten the list of lists into a single set\n    result = set(i for j in lst for i in j)\n    return result", "matching_cluster_idx": 5}, {"solution": "def extract_singly(test_list):\n    # Flatten the list of lists using a list comprehension\n    res = [ele for sublist in test_list for ele in sublist]\n    return res", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Use a generator expression to iterate through each tuple in the list\n    # and then through each element in the tuple to flatten the list of lists\n    # Finally, convert the flattened elements into a set to remove duplicates\n    return set(i for j in lst for i in j)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_list):\n    # Initialize an empty list to store the flattened elements\n    num_list = []\n    \n    # Iterate through each sublist in the list of lists\n    for i in range(len(list_of_list)):\n        # Extend the num_list with the elements of the current sublist\n        num_list.extend(list_of_list[i])\n    \n    # Convert the list to a set to remove duplicates and return it\n    return set(num_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(lst):\n    # Convert each tuple in the list to a set to remove duplicates within each tuple,\n    # then use the union of sets to combine all elements into a single set without duplicates.\n    return set([y for x in lst for y in x])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Flatten the list of lists and convert to a set to remove duplicates\n    return set(number for sublist in nested_list for number in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    # Use a set comprehension to flatten the list of lists into a single set of numbers\n    return {val for tup in lst for val in tup}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Initialize an empty set to store unique elements\n    single_set = set()\n    \n    # Iterate through each sublist in the nested list\n    for sub_list in nested_list:\n        # Add each element of the sublist to the set\n        for element in sub_list:\n            single_set.add(element)\n    \n    # Return the set of unique elements\n    return single_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(test_list):\n    # Initialize an empty list to store unique elements\n    res = []\n    \n    # Iterate through each sublist in the input list of lists\n    for sub in test_list:\n        # Use a set comprehension to collect unique elements\n        res.extend({ele for ele in sub})\n    \n    # Return the list containing unique elements as a set\n    return set(res)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(given_list):\n    # Flatten the list of lists into a single list\n    flat_list = [element for sublist in given_list for element in sublist]\n    # Convert the flat list into a set to remove duplicates\n    result_set = set(flat_list)\n    return result_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(test_list):\n    # Flatten the list of lists and convert it to a set\n    res = set(item for sublist in test_list for item in sublist)\n    return res", "matching_cluster_idx": 5}, {"solution": "def extract_singly(test_list):\n    # Use set comprehension to flatten the list of lists into a single set\n    res = {ele for sub_list in test_list for ele in sub_list}\n    return res", "matching_cluster_idx": 5}, {"solution": "def extract_singly(A):\n    # Initialize an empty set to store unique numbers\n    res = set()\n    \n    # Iterate through each sublist in the list of lists\n    for i in range(len(A)):\n        for j in range(len(A[i])):\n            # Add each number to the set\n            res.add(A[i][j])\n    \n    # Return the set containing unique numbers\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lst):\n    # Flatten the list of lists using a generator expression\n    flattened = (x for y in lst for x in y)\n    # Convert the flattened sequence to a set to remove duplicates\n    output = set(flattened)\n    return output", "matching_cluster_idx": 5}, {"solution": "def extract_singly(test_list):\n    # Flatten the list of lists and convert to a set to remove duplicates\n    res = set(num for sub in test_list for num in sub)\n    return res", "matching_cluster_idx": 5}, {"solution": "def extract_singly(test_list):\n    # Flatten the list of lists and convert it into a set of numbers\n    res = {ele for sub in test_list for ele in sub}\n    return res", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Flatten the list of lists and convert it to a set\n    return set(val for sublist in list_of_lists for val in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lis):\n    # Initialize an empty list to store the flattened elements\n    singly = []\n    # Iterate through each sublist in the list of lists\n    for sub_lis in lis:\n        # Extend the singly list with each element from the sublist\n        singly.extend(sub_lis)\n    # Convert the list to a set to remove duplicates and return it\n    return set(singly)", "matching_cluster_idx": 6}]}, "Mbpp/141": {"dps": 84.31885574742718, "dps_norm": 46.15384615384615, "pass@1": 13.0, "profiled": [{"solution": "def pancake_sort(A):\n    # Get the number of elements in the list\n    cur_size = len(A)\n    \n    # Traverse through the list from the end to the beginning\n    while cur_size > 1:\n        # Find the index of the maximum element in the unsorted portion of the list\n        mi = A.index(max(A[0:cur_size]))\n        \n        # If the maximum element is not already in the correct position\n        if mi != cur_size - 1:\n            # Flip the list up to the position of the maximum element\n            A[0:mi+1] = reversed(A[0:mi+1])\n            # Flip the entire unsorted portion of the list\n            A[0:cur_size] = reversed(A[0:cur_size])\n        \n        # Reduce the size of the unsorted portion\n        cur_size -= 1\n    \n    # Return the sorted list\n    return A", "matching_cluster_idx": 3}, {"solution": "def flip(lst, k):\n    # Flip the elements up to index k\n    temp = lst[:k]\n    temp.reverse()\n    lst[:k] = temp\n    return lst\ndef pancake_sort(lst):\n    # Start with the unsorted portion of the list\n    for curr_size in range(len(lst), 1, -1):\n        # Find the index of the maximum element in the unsorted part\n        max_index = lst.index(max(lst[:curr_size]))\n        # Flip the list up to the found index\n        lst = flip(lst, max_index + 1)\n        # Flip the list to move the maximum element to its correct position\n        lst = flip(lst, curr_size)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Loop through the array from the end to the beginning\n    for i in range(len(arr) - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:i + 1]))\n        \n        # If the maximum element is not already in its correct position\n        if max_index != i:\n            # Flip the array up to the index of the maximum element\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            # Flip the array up to the current position\n            arr[:i + 1] = reversed(arr[:i + 1])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    # Reverse the elements from 0 to k\n    return arr[:k+1][::-1] + arr[k+1:]\ndef pancake_sort(arr):\n    # Get the length of the list\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = arr.index(max(arr[:n]))\n        # If the maximum element is not already in its correct position\n        if max_index != n - 1:\n            # Flip the list up to the position of the maximum element\n            arr = flip(arr, max_index)\n            # Flip the entire unsorted part of the list\n            arr = flip(arr, n - 1)\n        # Decrement the size of the unsorted part\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k): \n    # Reverse the sub-list from 0 to k\n    sub_list = arr[:k+1]\n    sub_list.reverse()\n    arr[:k+1] = sub_list\n    return arr\ndef pancake_sort(arr): \n    # Function to perform pancake sort\n    n = len(arr)\n    while n > 1: \n        # Find the index of the maximum element in arr\n        mi = arr.index(max(arr[0:n])) \n  \n        # Move the maximum number to end of array \n        # if it is not already at the end \n        if mi != n-1: \n            # First move maximum number to beginning \n            arr = flip(arr, mi) \n            \n            # Now move the maximum number to end by reversing current array \n            arr = flip(arr, n-1) \n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, i):\n    # Reverse the elements from the start of the array up to and including index i\n    start = 0\n    while start < i:\n        arr[start], arr[i] = arr[i], arr[start]\n        start += 1\n        i -= 1\n    return arr\ndef pancake_sort(arr):\n    # Start from the end of the array and work towards the beginning\n    arr_len = len(arr)\n    while arr_len > 1:\n        # Find the index of the maximum element in arr\n        max_index = arr.index(max(arr[:arr_len]))\n        # Flip the maximum element to the beginning\n        arr = flip(arr, max_index)\n        # Flip the maximum element to its correct position at the end of the array\n        arr = flip(arr, arr_len - 1)\n        # Move to the next unsorted element\n        arr_len -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Initialize the size of the array to be sorted\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..i-1]\n        max_index = arr.index(max(arr[:i]))\n        \n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index != i - 1:\n            # First move the maximum number to the beginning\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            # Now move the maximum number to its correct position\n            arr[:i] = reversed(arr[:i])\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Function to reverse the elements from the start to the given index\n    def flip(sub_arr, k):\n        sub_arr[:k+1] = sub_arr[:k+1][::-1]\n    \n    # Start sorting from the last element\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in arr[0..n-1]\n        mi = arr.index(max(arr[0:n]))\n        \n        # Move the maximum element to the end of current array\n        if mi != n-1:\n            # First move the maximum number to the beginning\n            flip(arr, mi)\n            # Now move the maximum number to the end by reversing current array\n            flip(arr, n-1)\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, i):\n    # Reverse the elements from the start to the i-th element\n    temp = arr[:i + 1]\n    temp.reverse()\n    arr[:i + 1] = temp\n    return arr\ndef pancake_sort(arr):\n    # Start from the complete array and reduce size by one in each iteration\n    curr_size = len(arr)\n    while curr_size > 1:\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        mi = arr.index(max(arr[:curr_size]))\n        \n        # Move the maximum number to end of current array if it's not already at the end\n        if mi != curr_size - 1:\n            # First move maximum number to beginning\n            arr = flip(arr, mi)\n            \n            # Now move the maximum number to end by reversing current array\n            arr = flip(arr, curr_size - 1)\n        curr_size -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(sub_li, k):\n    # Function to reverse elements from 0 to k\n    start = 0\n    end = k\n    while start < end:\n        sub_li[start], sub_li[end] = sub_li[end], sub_li[start]\n        start += 1\n        end -= 1\n    return sub_li\ndef pancake_sort(arr):\n    # Initialize the array size\n    arr_len = len(arr)\n    # One by one reduce size of array\n    while arr_len > 1:\n        # Find the index of maximum element in arr[0..arr_len-1]\n        mi = arr.index(max(arr[0:arr_len]))\n        # Move the maximum number to end of current array if it's not already at the end\n        if mi != arr_len-1:\n            # First move maximum number to beginning\n            arr = flip(arr, mi)\n            # Now move the maximum number to end by reversing current array\n            arr = flip(arr, arr_len-1)\n        arr_len -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Function to flip the array from 0 to i\n    def flip(sub_arr, i):\n        start = 0\n        end = i\n        while start < end:\n            # Swap the elements at start and end indices\n            sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start]\n            start += 1\n            end -= 1\n    \n    # Loop through the array to sort it\n    for i in range(len(arr), 1, -1):\n        # Find the index of the maximum element in arr[0..i-1]\n        max_index = arr.index(max(arr[:i]))\n        \n        # Move the maximum element to the beginning\n        flip(arr, max_index)\n        \n        # Move the maximum element to its correct position\n        flip(arr, i - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(lst, i):\n    # Reverse elements from the start of the list up to the i-th element\n    return lst[:i+1][::-1] + lst[i+1:]\ndef find_max_index(lst, n):\n    # Find the index of the maximum element in the first n elements\n    max_index = 0\n    for i in range(1, n):\n        if lst[i] > lst[max_index]:\n            max_index = i\n    return max_index\ndef pancake_sort(arr):\n    # Sort the array using the pancake sort algorithm\n    curr_size = len(arr)\n    while curr_size > 1:\n        # Find the index of the maximum element in the current unsorted part of the array\n        mi = find_max_index(arr, curr_size)\n        # If the maximum element is not already at the end, move it to the end\n        if mi != curr_size - 1:\n            arr = flip(arr, mi)\n            arr = flip(arr, curr_size - 1)\n        curr_size -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(A):\n    # Iterate through the list from the end to the beginning\n    for i in range(len(A) - 1, 0, -1):\n        # Find the index of the maximum element in the unsorted portion of the list\n        max_index = A.index(max(A[0:i + 1]))\n        \n        # If the maximum element is not already at the end, flip it to the front\n        if max_index != i:\n            # Flip the list up to the maximum element\n            A[:max_index + 1] = A[:max_index + 1][::-1]\n            # Flip the list up to the end of the unsorted portion\n            A[:i + 1] = A[:i + 1][::-1]\n    return A", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.75999999999999, "dps_norm": 53.75, "pass@1": 84.0, "profiled": [{"solution": "def find_even_pair(a):\n    # Initialize count of pairs\n    count = 0\n    \n    # Iterate through each pair\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            # Check if XOR of the pair is even\n            if (a[i] ^ a[j]) % 2 == 0:\n                # Increment count if condition is met\n                count += 1\n    \n    # Return the total count of such pairs\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    ans = 0\n    # Iterate through all possible pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                ans += 1\n    return ans", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    # Iterate over each pair combination\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                # Increment the count if true\n                count += 1\n    # Return the total count of pairs with an even XOR\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize count of pairs\n    count = 0\n    # Iterate over each pair of numbers in the list\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            # Check if the XOR of the pair is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Initialize count of pairs with even xor result\n    cnt = 0\n    # Calculate the number of even and odd numbers in the list\n    even = sum(n & 1 == 0 for n in nums)\n    odd = len(nums) - even\n    # The number of pairs with even xor is the sum of products of even and odd counts\n    cnt = even * (even - 1) // 2 + odd * (odd - 1) // 2\n    return cnt", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of even XOR pairs to 0\n    count = 0\n    \n    # Iterate over all pairs of integers in the list\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Calculate the XOR of the pair and check if it's even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                # If even, increment the count\n                count += 1\n                \n    # Return the total count of even XOR pairs\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize a counter for pairs with an even XOR\n    count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with all other elements\n        for j in range(i + 1, len(arr)):\n            # XOR the two elements and check if the result is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                # Increment the counter if the result is even\n                count += 1\n    # Return the total count of such pairs\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(array):\n    count = 0\n    n = len(array)\n    \n    # Iterate over each element in the array\n    for i in range(n):\n        # Compare the current element with the rest of the elements\n        for j in range(i + 1, n):\n            # Check if the XOR of the current pair is even\n            if (array[i] ^ array[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the counter for pairs whose XOR is even\n    even_count = 0\n    \n    # Iterate through the array\n    for i in range(len(arr)):\n        # Compare each element with every other element in the array\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the current pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                # Increment the counter if the condition is met\n                even_count += 1\n    \n    # Return the total count of pairs\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize a counter to keep track of the number of valid pairs\n    count = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the current pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                # Increment the counter if the condition is met\n                count += 1\n                \n    # Return the total count of pairs whose XOR is even\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize a counter for the number of pairs with an even XOR\n    cnt = 0\n    \n    # Iterate over the array with two nested loops to check all pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the current pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                cnt += 1\n    \n    # Return the total count of pairs with an even XOR\n    return cnt", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize count of even xor pairs\n    ans = 0\n    \n    # Iterate through the list\n    for i in range(len(arr)):\n        # Iterate through the list from the next element\n        for j in range(i + 1, len(arr)):\n            # Calculate xor of the current pair\n            xor = arr[i] ^ arr[j]\n            # Check if the xor is even\n            if xor % 2 == 0:\n                # Increment the count if even\n                ans += 1\n    \n    # Return the total count of even xor pairs\n    return ans", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0  # Initialize count of pairs whose XOR is even\n    \n    # Iterate over each pair of elements in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1  # Increment count if the XOR is even\n    \n    return count  # Return the total count of even XOR pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Initialize count of even XOR pairs to 0\n    count = 0\n    # Use nested loops to compare each pair in the list\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            # Check if XOR of the current pair is even\n            if ((lst[i] ^ lst[j]) & 1) == 0:\n                # Increment count if XOR is even\n                count += 1\n    # Return the total count of even XOR pairs\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize counter for pairs with even XOR\n    count = 0\n    \n    # Iterate over each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with the rest of the array\n        for j in range(i + 1, len(arr)):\n            # Calculate the XOR of the current pair\n            xor = arr[i] ^ arr[j]\n            # Check if the XOR is even\n            if xor % 2 == 0:\n                # Increment the counter if even XOR\n                count += 1\n                \n    # Return the total count of pairs with even XOR\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs whose XOR is even\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with all other elements\n        for j in range(i + 1, len(arr)):\n            # XOR the current pair of elements\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                # If the XOR is even, increment the count\n                count += 1\n    \n    # Return the total count of pairs with an even XOR\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # Count the number of pairs with an even xor result\n    return sum((nums[i] ^ nums[j]) % 2 == 0 for i in range(len(nums)) for j in range(i + 1, len(nums)))", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize count of pairs\n    cnt = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the current pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                cnt += 1\n    \n    # Return the total count of pairs with an even XOR\n    return cnt", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Count the number of even and odd elements in the array\n    odd = 0\n    even = 0\n    for num in arr:\n        if num % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    \n    # The number of pairs that have an even XOR is the sum of:\n    # - The number of ways to choose 2 even numbers\n    # - The number of ways to choose 2 odd numbers\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(arr):\n    # Initialize count to zero\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with the rest of the array\n        for j in range(i + 1, len(arr)):\n            # Calculate the XOR of the pair\n            xor_result = arr[i] ^ arr[j]\n            \n            # Check if the XOR result is even\n            if xor_result % 2 == 0:\n                # Increment the count if the XOR is even\n                count += 1\n                \n    # Return the total count of pairs with even XOR\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 62.572463768115945, "dps_norm": 80.0, "pass@1": 97.0, "profiled": [{"solution": "def sum_range_list(lst, l, r):\n    # Calculate the sum of elements in the list within the specified range [l, r]\n    return sum(lst[l:r + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of elements from start_index to end_index (inclusive)\n    # It is assumed that the input indices are valid and within the list bounds\n    total_sum = sum(lst[start_index:end_index + 1])\n    return total_sum", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, left, right):\n    # Initialize the sum to zero\n    total = 0\n    # Iterate over the sublist from index 'left' to 'right' (inclusive)\n    for i in range(left, right + 1):\n        total += numbers[i]  # Add the current element to the total sum\n    return total  # Return the computed sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(lst, left, right):\n    # Initialize the sum to 0\n    sum1 = 0\n    # Iterate over the sublist from index left to right (inclusive)\n    for i in range(left, right + 1):\n        sum1 += lst[i]\n    # Return the computed sum\n    return sum1", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of elements from index 'start' to 'end' (inclusive)\n    return sum(lst[i] for i in range(start, end + 1))", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(numbers, start, end):\n    # Use list slicing to extract the sublist and the sum function to calculate its sum\n    total = sum(numbers[start:end+1])\n    return total", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(input_list, range_start, range_end):\n    # Initialize sum to 0\n    total_sum = 0\n    # Iterate through the specified range of indices\n    for i in range(range_start, range_end + 1):\n        # Add the element at the current index to the total sum\n        total_sum += input_list[i]\n    # Return the total sum of the elements within the specified range\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(numbers, start, end):\n    # Initialize the sum to zero\n    res = 0\n    # Iterate over the range from start to end (inclusive)\n    for i in range(start, end + 1):\n        # Add the current number in the list to the result\n        res += numbers[i]\n    # Return the final sum\n    return res", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, a, b):\n    # Calculate the sum of elements in the list from index a to index b (inclusive)\n    return sum(nums[a:b+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(arr, l, r):\n    # Initialize a variable to store the sum of the elements within the specified range\n    sum = 0\n    \n    # Iterate over the specified range in the list\n    for i in range(l, r + 1):\n        # Add the element at the current index to the sum\n        sum += arr[i]\n    \n    # Return the calculated sum\n    return sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(list, start, end):\n    # Calculate the sum of elements from start index to end index (inclusive)\n    return sum(list[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, L, R):\n    # Initialize the sum variable to store the sum of the elements within the specified range\n    s = 0\n    # Iterate over the range from L to R (inclusive) and add each element to the sum\n    for i in range(L, R + 1):\n        s += nums[i]\n    # Return the calculated sum\n    return s", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(num_list, m, n):\n    # Calculate the sum of elements in the range [m, n] inclusive\n    total = sum(num_list[m:n+1])\n    return total", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, left, right):\n    # Use list slicing to extract the sublist from index 'left' to 'right' (inclusive)\n    sublist = lst[left:right + 1]\n    \n    # Initialize a variable to store the sum of the sublist\n    summation = 0\n    \n    # Iterate over each number in the sublist\n    for num in sublist:\n        # Add the current number to the summation\n        summation += num\n    \n    # Return the total sum of the sublist\n    return summation", "matching_cluster_idx": 5}, {"solution": "def sum_range_list(l, i, j):\n    # Calculate the sum of elements in the list l from index i to index j (inclusive)\n    result = sum(l[i:j + 1])\n    return result", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, low, high):\n    # Initialize a variable to store the sum of the elements in the specified range\n    total_sum = 0\n    # Iterate over the range from low to high (inclusive)\n    for i in range(low, high + 1):\n        # Add the current element to the total sum\n        total_sum += nums[i]\n    # Return the total sum of the elements in the specified range\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start, end):\n    # Iterate through the list from the start index to the end index (inclusive)\n    # Sum the elements that fall within the specified range\n    return sum(nums[i] for i in range(start, end + 1))", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, l, r):\n    # Calculate the sum of numbers in the list from index l to r (inclusive)\n    return sum(nums[l:r+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, L, R):\n    # Initialize sum to zero\n    sum = 0\n    # Iterate over the range from L to R (inclusive)\n    for i in range(L, R + 1):\n        # Add the current element to the sum\n        sum += nums[i]\n    # Return the calculated sum\n    return sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(arr, left, right):\n    # Calculate the sum of elements in the list from index 'left' to 'right' (inclusive)\n    sum_val = sum(arr[left:right + 1])\n    return sum_val", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 74.57364341085271, "dps_norm": 31.42857142857143, "pass@1": 99.0, "profiled": [{"solution": "def odd_values_string(str):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, value in enumerate(str):\n        # Check if the index is even (0-based index)\n        if index % 2 == 0:\n            # Append the character at the even index to the result string\n            result += value\n    \n    # Return the final result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for i, c in enumerate(str1):\n        # Check if the index is even (odd index values)\n        if i % 2 == 0:\n            # Append the character at the even index to the result string\n            result = result + c\n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    # Create a new string with characters from even index values\n    result_str = ''\n    for index in range(len(str1)):\n        if index % 2 == 0:\n            result_str += str1[index]\n    return result_str", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Join characters at even indices (0-based indexing)\n    return \"\".join([str[i] for i in range(len(str)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str1):\n        # Check if the index is even (since index starts from 0, even indices correspond to odd positions)\n        if index % 2 == 0:\n            # Append the character at the even index to the result string\n            result += char\n    # Return the resulting string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string using index and character\n    for i in range(len(str)):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Append the character at the even index to the result string\n            result += str[i]\n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Join characters with even indices (0, 2, 4, ...) using a list comprehension\n    return \"\".join([str[i] for i in range(len(str)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for index, character in enumerate(str1):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character at the even index to the result string\n            result += character\n    # Return the resulting string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Use string slicing to get characters at even indices (0, 2, 4, ...)\n    result = str[::2]\n    return result", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string with index\n    for index in range(len(str1)):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character at the current index to the result string\n            result += str1[index]\n    # Return the resulting string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    # Use list comprehension to select characters at even indices\n    result = str1[::2]\n    return result", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store characters with even indices\n    result = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str1):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character at even index to the result string\n            result += char\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate through the string using index\n    for i in range(len(str1)):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Append the character at the even index to the result string\n            result += str1[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Using list comprehension to filter characters at even indices (0-based)\n    return \"\".join([str[i] for i in range(len(str)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    # Use string slicing to select characters at even indices\n    return input_str[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input):\n    # Using slicing to select characters with even indices\n    return input[0::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(str1):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over the string using enumerate to get both index and character\n    for index, character in enumerate(str1):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += character\n    # Return the resulting string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(str):\n        # Check if the index is even (thereby the character is at an odd position in human-readable counting)\n        if index % 2 == 0:\n            result += char\n    \n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for i, v in enumerate(str):\n        # Check if the index is even (i.e., odd character position)\n        if i % 2 == 0:\n            # Append the character to the result string\n            result += v\n    \n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result_string = \"\"\n    # Iterate over the string using enumerate to get both index and character\n    for i, char in enumerate(input_string):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Append the character to the result string\n            result_string += char\n    # Return the resulting string\n    return result_string", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 95.95238095238095, "dps_norm": 98.125, "pass@1": 99.0, "profiled": [{"solution": "def replace_blank(input_string, input_char):\n    # Replace all blank spaces in the string with the specified character\n    result = input_string.replace(\" \", input_char)\n    return result", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    # Replace all blank spaces in the string 's' with the character 'c'\n    s = s.replace(' ', c)\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, ch):\n    # Replace each blank space in the string with the given character\n    return string.replace(\" \", ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    # Replace blank spaces in the string 's' with the character 'c'\n    s = s.replace(' ', c)\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_blank(my_string, ch):\n    # Replace all blank spaces (' ') in the string with the specified character\n    my_string = my_string.replace(\" \", ch)\n    # Return the modified string\n    return my_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(str, c):\n    # Replace all blank spaces in the string with the given character\n    return str.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(st, ch):\n    # Replace all blank spaces in the string 'st' with the character 'ch'\n    res = st.replace(' ', ch)\n    return res", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    # Replace each blank space in the string with the specified character\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(st, c):\n    # Replace each blank space (' ') in the string with the specified character (c)\n    result = st.replace(' ', c)\n    return result", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    # Replace all blank spaces in the string 's' with the character 'c'\n    s = s.replace(' ', c)\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    # Replace all blank spaces in the string with the specified character\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    # Initialize an empty string to store the result\n    result_string = ''\n    \n    # Iterate through each character in the input string\n    for char_in_string in string:\n        # Check if the current character is a blank space\n        if char_in_string == ' ':\n            # If it is, append the specified character to the result string\n            result_string += char\n        else:\n            # If it is not, append the current character to the result string\n            result_string += char_in_string\n    \n    # Return the modified string\n    return result_string", "matching_cluster_idx": 4}, {"solution": "def replace_blank(str1, char1):\n    # Replace all occurrences of blank spaces in the string with the specified character\n    result = str1.replace(\" \", char1)\n    return result", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all occurrences of blank spaces with the specified character\n    modified_string = input_string.replace(' ', replacement_char)\n    return modified_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Use the replace() method to replace blank spaces with the specified character\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, character):\n    # Replace all blank spaces in the string with the specified character\n    text = text.replace(\" \", character)\n    return text", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, s):\n    # Replace all blank spaces in the input string with the specified character\n    return text.replace(\" \", s)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(str1, ch):\n    # Use the replace() method to replace all blank spaces with the specified character\n    result = str1.replace(\" \", ch)\n    # Return the modified string\n    return result", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    # Replace all blank spaces in the input string with the specified character\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(str, c):\n    # Use the string's replace method to substitute ' ' (blank spaces) with the specified character 'c'\n    return str.replace(' ', c)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 83.62068965517241, "dps_norm": 82.5, "pass@1": 32.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store the number of sequences of length i with the last element j\n    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    \n    # Base case: There's one way to form a sequence of length 1 with any element 1 to m\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    \n    # Fill the dp table\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            # Sum the number of ways to form a sequence of length i-1 with elements up to j/2\n            dp[i][j] = sum(dp[i - 1][k] for k in range(1, j // 2 + 1))\n    \n    # Return the total number of sequences of length n with elements up to m\n    return sum(dp[n][i] for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize the solution matrix with zeros\n    sol = [[0 for i in range(n + 1)] for i in range(m + 1)]\n    \n    # Iterate through each possible end value of the sequence\n    for i in range(1, m + 1):\n        # Calculate the number of sequences of length 1\n        sol[i][1] = i\n    \n    # Iterate through each possible sequence length\n    for i in range(1, m + 1):\n        # Iterate through each possible end value of the sequence\n        for j in range(2, n + 1):\n            # Calculate the number of sequences of length j ending with i\n            sol[i][j] = sol[i - 1][j] + sol[i // 2][j - 1]\n    \n    # Return the number of sequences of length n ending with m\n    return sol[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(max_value, sequence_length):\n    # Initialize a 2D list to store the number of sequences\n    dp = [[0 for _ in range(sequence_length + 1)] for _ in range(max_value + 1)]\n    \n    # Fill the DP table\n    for i in range(1, max_value + 1):\n        for j in range(1, sequence_length + 1):\n            if j == 1:\n                # Base case: there's only one way to form a sequence of length 1 with any value\n                dp[i][j] = i\n            else:\n                # Calculate the number of sequences ending with the current value i\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the total number of sequences of the given length\n    return dp[max_value][sequence_length]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store intermediate results\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Iterate over all possible values of m and n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Base case: If the sequence length is 1, there is only one possibility\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Calculate the number of sequences by summing up\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the total number of sequences of length n for values up to m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D array to store intermediate results\n    # dp[i][j] will store the number of valid sequences of length j using integers up to i\n    dp = [[0 for i in range(n + 1)] for j in range(m + 1)]\n    \n    # Fill the table\n    for i in range(m + 1):\n        for j in range(n + 1):\n            # If there is only one element in the sequence, all integers up to m are valid\n            if j == 1:\n                dp[i][j] = i\n            # If the sequence length is more than one, calculate the number of valid sequences\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the total number of valid sequences of length n using integers up to m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n): \n    # Initialize a 2D list to store the count of sequences\n    count = [[0 for x in range(n + 1)] for x in range(m + 1)] \n    \n    # Loop through each possible sequence length\n    for length in range(1, n + 1): \n        # Loop through each possible maximum value in the sequence\n        for maximum in range(1, m + 1): \n            if length == 1: \n                # For length 1, the count is equal to the maximum value\n                count[maximum][length] = maximum \n            else: \n                # For length greater than 1, calculate the count based on previous values\n                count[maximum][length] = count[maximum - 1][length] + count[maximum // 2][length - 1] \n    \n    # Return the total number of sequences of length n and maximum value m\n    return count[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list with zeros\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: there's one way to form a sequence of length 1\n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    # Fill the dp table\n    for i in range(2, m + 1):\n        for j in range(2, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the total number of sequences of length n with maximum value m\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list with zeros\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    \n    # Iterate over each value from 0 to m\n    for i in range(1, m + 1):\n        # Iterate over each sequence length from 1 to n\n        for j in range(1, n + 1):\n            # If it's the first element, there's only one way to choose it\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Calculate the number of sequences ending with the current value i\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the number of sequences of length n with values up to m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store the number of sequences\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Iterate over possible maximum elements in the sequence\n    for i in range(1, m + 1):\n        # Iterate over possible sequence lengths\n        for j in range(1, n + 1):\n            # Initialize the first element of the sequence\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Sum up the number of sequences for smaller maximum elements and lengths\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the number of possible sequences of length n with maximum element m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(max_value, sequence_length):\n    # Initialize a 2D list to store results of subproblems\n    dp = [[0 for i in range(sequence_length + 1)] for i in range(max_value + 1)]\n    \n    # Iterate over all possible maximum values of sequence elements\n    for i in range(1, max_value + 1):\n        # Iterate over all possible lengths of sequences\n        for j in range(1, sequence_length + 1):\n            # If sequence length is 1, any value up to max_value is valid\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Calculate the number of valid sequences\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # The result is the number of sequences of length n with elements up to m\n    return dp[max_value][sequence_length]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a table to store the number of sequences\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Fill the table\n    for i in range(1, m + 1):\n        dp[i][1] = i  # There are i sequences of length 1 with values from 1 to i\n    \n    for i in range(2, m + 1):\n        for j in range(2, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array with (m+1) rows and (n+1) columns\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Loop through each possible element value from 1 to m\n    for i in range(1, m + 1):\n        # Loop through each sequence length from 1 to n\n        for j in range(1, n + 1):\n            # Set the first element of the DP array\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Calculate the number of valid sequences\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n\n    # Return the total number of valid sequences of length n\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D array to store the number of sequences\n    dp = [[0 for i in range(n + 1)] for j in range(m + 1)]\n    \n    # Iterate over the possible values of elements in the sequence\n    for i in range(1, m + 1):\n        # Iterate over the possible lengths of the sequence\n        for j in range(1, n + 1):\n            # If there is only one element in the sequence\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # If the length of the sequence is more than one\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the total number of sequences\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n): \n    # Initialize a 2D list with zeros to store the number of sequences\n    dp = [[0 for i in range(n + 1)] for j in range(m + 1)] \n    \n    # Iterate through the 2D list and fill it with the number of sequences\n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n            if j == 1: \n                # Base case: There is one sequence of length 1 for each number\n                dp[i][j] = i \n            else: \n                # Calculate the number of sequences by summing up the sequences of smaller lengths\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1] \n                \n    # Return the total number of sequences of length n\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list with zeros\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    \n    # Base case: There is one way to form a sequence of length 1 with any number up to m\n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(2, n + 1):\n            # Calculate the number of sequences ending with i of length j\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # The answer is the total number of sequences of length n that can end with any number up to m\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list with (m+1) rows and (n+1) columns with 0s\n    dp = [[0 for i in range(n + 1)] for j in range(m + 1)]\n    \n    # Loop through all possible values of i and j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # If the sequence length is 1, the number of sequences is i\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Calculate the number of sequences by adding the number of sequences\n                # with the previous element being less than or equal to i\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the total number of sequences of length n with elements between 1 and m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a 2D list to store the number of sequences\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    \n    # Initialize the first row of the dp table\n    for i in range(1, m + 1):\n        dp[i][1] = i\n    \n    # Fill the dp table using a nested loop\n    for i in range(2, m + 1):\n        for j in range(2, n + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the number of sequences of length n where elements are between 1 and m\n    return dp[m][n]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n): \n    # Initialize a 2D list with (m+1) rows and (n+1) columns\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)] \n  \n    # Loop through each element in the 2D list\n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n            if j == 1: \n                # Base case: only one way to form a sequence of length 1 with any m\n                dp[i][j] = i \n            else: \n                # Calculate the number of sequences ending with i\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1] \n  \n    # Return the total number of sequences of length n with elements up to m\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store the number of sequences\n    dp = [[0 for x in range(n + 1)] for x in range(m + 1)]\n    \n    # Iterate over possible values of m and n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # If j is 1, all values of i are valid sequences\n            if j == 1:\n                dp[i][j] = i\n            else:\n                # Calculate the number of sequences using dynamic programming\n                dp[i][j] = dp[i - 1][j] + dp[i // 2][j - 1]\n    \n    # Return the number of possible sequences of length n\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D list to store the results of subproblems\n    T = [[0 for j in range(n + 1)] for i in range(m + 1)]\n    \n    # Iterate over each element value i\n    for i in range(1, m + 1):\n        # Iterate over each sequence length j\n        for j in range(1, n + 1):\n            # If the sequence length is 1, all values are valid\n            if j == 1:\n                T[i][j] = i\n            else:\n                # Calculate the number of sequences ending with value i\n                T[i][j] = T[i - 1][j] + T[i // 2][j - 1]\n    \n    # Return the total number of sequences of length n with elements between 1 and m\n    return T[m][n]", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 77.50000000000001, "dps_norm": 87.22222222222221, "pass@1": 92.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(nums1, nums2):\n    # Replace the last element of nums1 with the elements of nums2\n    nums1[-1:] = nums2\n    return nums1", "matching_cluster_idx": 7}, {"solution": "def replace_list(nums, nums1):\n    # Replace the last element of the first list with the elements of the second list\n    nums[-1:] = nums1\n    # Return the modified first list\n    return nums", "matching_cluster_idx": 7}, {"solution": "def replace_list(input_list1, input_list2):\n    # Assign the elements of the second list to replace the last element of the first list\n    input_list1[-1:] = input_list2\n    return input_list1", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef replace_list(nums1: List[int], nums2: List[int]) -> List[int]:\n    # Replace the last element of nums1 with the elements of nums2\n    nums1[-1:] = nums2\n    return nums1", "matching_cluster_idx": 7}, {"solution": "def replace_list(arr1, arr2):\n    # Replace the last element of the first list with the elements of the second list\n    arr1[-1:] = arr2\n    return arr1", "matching_cluster_idx": 7}, {"solution": "def replace_list(input1, input2):\n    # Replace the last element of input1 with all elements of input2\n    input1[-1:] = input2\n    return input1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with all elements from list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with all elements of list2\n    list1[-1:] = list2\n    # Return the modified list1\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with all elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(input_list, add_list):\n    # Replace the last element of the input_list with elements from add_list\n    input_list[-1:] = add_list\n    return input_list", "matching_cluster_idx": 7}, {"solution": "def replace_list(num_list, sub_list):\n    # Replace the last element of num_list with the elements of sub_list\n    num_list[-1:] = sub_list\n    return num_list", "matching_cluster_idx": 7}, {"solution": "def replace_list(A, B):\n    # Replacing the last element of list A with all elements of list B\n    A[-1:] = B\n    # Returning the modified list A\n    return A", "matching_cluster_idx": 7}, {"solution": "def replace_list(arr, arr1):\n    # Replace the last element of arr with the elements of arr1\n    arr[-1:] = arr1\n    return arr", "matching_cluster_idx": 7}, {"solution": "def replace_list(A, B):\n    # Replace the last element of list A with all elements of list B\n    A[:-1] = A[:-1]\n    A[-1:] = B\n    return A", "matching_cluster_idx": 4}, {"solution": "def replace_list(numbers, new_elements):\n    # Replace the last element of the first list with elements of the second list\n    numbers[-1:] = new_elements\n    return numbers", "matching_cluster_idx": 7}, {"solution": "def replace_list(test_list1, test_list2):\n    # Replace the last element of the first list with the elements of the second list\n    test_list1[-1:] = test_list2\n    return test_list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with all elements from list2\n    list1[-1:] = list2\n    # Return the modified list1\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(nums1, nums2):\n    # Replace the last element of the first list with the second list\n    nums1[-1:] = nums2\n    return nums1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    # Return the modified list1\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 59.252873563218394, "dps_norm": 69.44444444444444, "pass@1": 89.0, "profiled": [{"solution": "def insert_element(test_list, K):\n    # Using list comprehension to insert K before each element in the list\n    res = [y for x in test_list for y in (K, x)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    res = []\n    # Iterate through each item in the input list\n    for x in lst:\n        # Append the element first\n        res.append(element)\n        # Then append the current item\n        res.append(x)\n    # Return the resulting list\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    # Create an empty list to store the result\n    res = []\n    # Iterate through each element in the input list\n    for val in lst:\n        # Append the current element and the insert element to the result list\n        res.extend([elem, val])\n    # Return the modified list\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n    # Use list comprehension to iterate through list1 and insert 'element' before each item\n    result = [value for item in list1 for value in (element, item)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    res = []\n    \n    # Iterate over each element in the input list\n    for val in lst:\n        # Append the specified element followed by the current list element to the result list\n        res.extend([element, val])\n    \n    # Return the modified list\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(lists, element):\n    # Initialize an empty list to store the result\n    list2 = []\n    # Iterate through each element in the input list\n    for i in range(len(lists)):\n        # Insert the specified element before the current element in the input list\n        list2.extend([element, lists[i]])\n    # Return the resulting list\n    return list2", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    # Using list comprehension to insert the element before each element in the list\n    res = [value for item in lst for value in (element, item)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def insert_element(test_list, K):\n    # Create a list comprehension to insert K before each element in test_list\n    res_list = [val for ele in test_list for val in (K, ele)]\n    return res_list", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    # Iterate over the list in reverse order\n    for i in range(len(lst) - 1, -1, -1):\n        # Insert the element before the current index\n        lst.insert(i, element)\n    # Return the modified list\n    return lst", "matching_cluster_idx": 0}, {"solution": "def insert_element(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    # Iterate over each element in the test_list\n    for ele in test_list:\n        # Append K and then the current element to the result list\n        res.extend([K, ele])\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.extend([element, item])\n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each element in the input list\n    for item in lst:\n        # Append the element before each item in the input list\n        result.append(element)\n        result.append(item)\n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(test_list, K):\n    # Extend the list by inserting the element K before each existing element\n    test_list = [item for element in test_list for item in (K, element)]\n    return test_list", "matching_cluster_idx": 5}, {"solution": "import copy\ndef insert_element(L, num):\n    # Initialize the result list\n    result = []\n    # Iterate through each element in the input list\n    for ele in L:\n        # Append the element before the current item\n        result.extend([num, ele])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    # Iterate through each element in the test list\n    for ele in test_list:\n        # Insert K before the current element and append it to the result list\n        res.extend([K, ele])\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, x):\n    # Initialize an empty list to store the result\n    res = []\n    # Iterate through each element in the input list\n    for ele in lst:\n        # Append 'x' and then the current element to the result list\n        res.extend([x, ele])\n    # Return the resulting list\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(test_list, K):\n    # Using list comprehension to insert K before each element in the test_list\n    res = [value for item in test_list for value in (K, item)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def insert_element(list, element):\n    # Create a new list with the element inserted before each element in the original list\n    res = [item for ele in list for item in (element, ele)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the given element and then the item to the result list\n        result.extend([element, item])\n    # Return the modified result list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(items, item):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each element in the input list\n    for e in items:\n        # Append the specified item and the current element to the result list\n        result += [item, e]\n    \n    # Return the modified list\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 70.82191780821918, "dps_norm": 67.05882352941177, "pass@1": 85.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    # Initialize a list to keep track of prime numbers\n    primes = []\n    \n    # Iterate through numbers from 2 to n-1\n    for i in range(2, n):\n        # Assume the number is prime until proven otherwise\n        prime_flag = True\n        \n        # Check if the number is divisible by any number up to its square root\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                # If divisible, it's not a prime number\n                prime_flag = False\n                break\n        \n        # If still considered prime, add it to the list\n        if prime_flag:\n            primes.append(i)\n    \n    # Return the total count of prime numbers found\n    return len(primes)", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Counting prime numbers less than n\n    count = 0\n    for number in range(2, n):\n        if is_prime(number):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Create a list of boolean values to represent whether each number is prime\n    isprime = [True] * n\n    # Initialize the count of prime numbers\n    prime_count = 0\n    \n    # Skip the first two indices (0 and 1) which are not prime\n    for i in range(2, n):\n        # If the number is still marked as prime\n        if isprime[i]:\n            # Increment the count\n            prime_count += 1\n            # Mark all multiples of i as not prime\n            for j in range(i * 2, n, i):\n                isprime[j] = False\n    \n    # Return the count of prime numbers\n    return prime_count", "matching_cluster_idx": 12}, {"solution": "def count_Primes_nums(n):\n    # Check if the input number is less than 3, in which case there are no prime numbers less than it\n    if n < 3:\n        return 0\n    \n    # Create a list of boolean values to represent whether each number is prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    # Iterate over the numbers starting from 2 to n-1\n    for i in range(2, int(n**0.5) + 1):\n        # If the number is prime, mark all multiples of it as not prime\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count and return the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    # Check if the input number is less than 2\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to keep track of prime status for each number up to n\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    \n    # Implement the Sieve of Eratosthenes algorithm\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            primes[i*i::i] = [False] * (((n - 1) // i) - (i - 1))\n    \n    # Count the number of True values in the primes list\n    count = sum(primes)\n    \n    # Return the count of prime numbers less than n\n    return count", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    count = 0\n    for num in range(2, n):\n        for i in range(2, num):\n            if (num % i) == 0:\n                break\n        else:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Primes_nums(num):\n    # Check if the input number is less than 2\n    if num < 2:\n        return 0\n    \n    # List to keep track of prime numbers\n    primes = []\n    for i in range(2, num):\n        # Assume the number is prime\n        is_prime = True\n        for j in range(2, int(i ** 0.5) + 1):\n            # If divisible by any number, it's not prime\n            if i % j == 0:\n                is_prime = False\n                break\n        \n        # If prime, add to the list\n        if is_prime:\n            primes.append(i)\n    \n    # Return the count of prime numbers\n    return len(primes)", "matching_cluster_idx": 8}, {"solution": "def is_prime(x):\n    if x < 2:\n        return False\n    if x <= 3:\n        return True\n    if x % 2 == 0 or x % 3 == 0:\n        return False\n    for i in range(5, int(x**0.5) + 1, 6):\n        if x % i == 0 or x % (i + 2) == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(num):\n    # Helper function to check if a number is prime\n    def helper(n):\n        # Special case for 0 and 1, which are not prime numbers\n        if n < 2:\n            return False\n        # Check for divisibility up to the square root of n\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    # Count prime numbers less than num\n    return sum(helper(n) for n in range(num))", "matching_cluster_idx": 8}, {"solution": "import math\ndef count_Primes_nums(n): \n    # Initialize a list to keep track of prime status\n    primes = [1] * n \n    result = 0\n    \n    # Check for corner cases where n is less than 2\n    if n < 2:\n        return result\n    \n    # Set the status of 0 and 1 to 0 (not prime)\n    primes[0] = 0\n    primes[1] = 0\n    \n    # Iterate over numbers from 2 to the square root of n\n    for i in range(2, int(math.sqrt(n)) + 1): \n        # If the number is marked as prime\n        if primes[i] == 1: \n            # Mark all multiples of i as not prime\n            for j in range(i * i, n, i): \n                primes[j] = 0\n    \n    # Count and return the number of primes found\n    for i in range(2, n): \n        if primes[i] == 1: \n            result += 1\n            \n    return result", "matching_cluster_idx": 13}, {"solution": "import math\ndef count_Primes_nums(N):\n    # Edge case: 0 and 1 are not prime numbers\n    if N <= 2:\n        return 0\n    \n    # Initialize a list to keep track of prime numbers\n    is_prime = [True] * N\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime\n    \n    # Implement the Sieve of Eratosthenes algorithm\n    for i in range(2, int(math.sqrt(N)) + 1):\n        if is_prime[i]:\n            for j in range(i * i, N, i):\n                is_prime[j] = False\n    \n    # Count and return the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    # Create a boolean array \"prime[0..n-1]\" and initialize\n    # all entries it as true. A value in prime[i] will\n    # finally be false if i is Not a prime, else true.\n    prime = [True for i in range(n)]\n    p = 2\n    while (p * p <= n):\n        # If prime[p] is not changed, then it is a prime\n        if (prime[p] == True):\n            # Updating all multiples of p to not prime\n            for i in range(p * p, n, p):\n                prime[i] = False\n        p += 1\n\n    # Counting the number of prime numbers less than n\n    count = 0\n    for p in range(2, n):\n        if prime[p]:\n            count += 1\n\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(num):\n    # Check if the number is less than 2\n    if num < 2:\n        return 0\n    \n    # Initialize a list to track prime status of numbers\n    primes = [True] * num\n    \n    # The first prime number is 2\n    primes[0] = primes[1] = False\n    \n    # Use the Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(num ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, num, i):\n                primes[j] = False\n    \n    # Count the number of prime numbers\n    count = sum(primes)\n    \n    return count", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    # If n is less than 3, there are no prime numbers less than n\n    if n < 3:\n        return 0\n    # Initialize a list to keep track of prime numbers\n    primes = [True] * n\n    p = 2\n    # Use the Sieve of Eratosthenes algorithm to find all prime numbers less than n\n    while p * p < n:\n        if primes[p]:\n            for i in range(p * p, n, p):\n                primes[i] = False\n        p += 1\n    # Count the number of prime numbers found\n    return sum(primes) - 2  # Subtract 2 because primes[0] and primes[1] are not considered prime", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    # Check if the number is less than 2, in which case there are no prime numbers\n    if (n <= 2):\n        return 0\n\n    # Initialize an array to store the prime status of numbers\n    prime = [0] * n\n    count = 0\n\n    # Marking all numbers as prime initially\n    for i in range(2, n):\n        prime[i] = 1\n\n    # Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(n ** 0.5) + 1):\n        if (prime[i] == 1):\n            for j in range(i * i, n, i):\n                prime[j] = 0\n\n    # Counting the number of prime numbers\n    for i in range(2, n):\n        if prime[i] == 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_Primes_nums(n):\n    # Check for edge case\n    if n <= 2:\n        return 0\n    \n    # Initialize a list to mark non-prime numbers\n    prime_nums = [True] * n\n    prime_nums[0], prime_nums[1] = False, False\n    \n    # Use the Sieve of Eratosthenes algorithm to find all primes\n    for i in range(2, int(n**0.5) + 1):\n        if prime_nums[i]:\n            for j in range(i*i, n, i):\n                prime_nums[j] = False\n    \n    # Count and return the number of primes\n    return sum(prime_nums)", "matching_cluster_idx": 14}, {"solution": "def is_prime(num):\n    # Check if a number is prime\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    # Count the number of prime numbers less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(num):\n    count = 0\n    \n    # Helper function to check if a number is prime\n    def prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    # Iterate through numbers from 2 to num-1\n    for i in range(2, num):\n        if prime(i):\n            count += 1\n            \n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is a prime\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    # Count the number of prime numbers less than the given number\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    # List to hold prime numbers\n    prime_nums = []\n    \n    # Iterate through numbers to find primes\n    for num in range(2, n):\n        is_prime = True\n        # Check divisibility for each number\n        for i in range(2, num):\n            if num % i == 0:\n                is_prime = False\n                break\n        # If the number is prime, add to the list\n        if is_prime:\n            prime_nums.append(num)\n    \n    # Return the count of prime numbers\n    return len(prime_nums)", "matching_cluster_idx": 2}]}, "Mbpp/265": {"dps": 98.54651162790698, "dps_norm": 99.16666666666667, "pass@1": 36.0, "profiled": [{"solution": "def list_split(L, n):\n    # Split the list into sublists of length n\n    return [L[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Split the list into chunks of size n and return a list of these chunks\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Use list comprehension to split the list into sublists of length n\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Split the list into sublists where each sublist contains every nth element\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Using list comprehension to slice the list from index 0 to len(lst) with step n\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(test_list, N):\n    res = [test_list[i::N] for i in range(N)]\n    return res", "matching_cluster_idx": 4}, {"solution": "def list_split(data, n):\n    # Split the list into parts where each part contains elements spaced by 'n'\n    return [data[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Split the list into sublists where each sublist contains elements at every nth index\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(data_list, n):\n    # Using list slicing to create chunks of size n\n    return [data_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Split the list into sublists where each sublist contains every nth element\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def list_split(inlist, n):\n    # Split the list by taking every nth element\n    return [inlist[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(list1, n):\n    # Use list comprehension to split the list into sublists of size 'n'\n    result = [list1[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    # Use list comprehension to create new lists split by every nth element\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Using list comprehension and range to split the list every nth element\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(test_list, N):\n    # Split the list into sublists of length N\n    res = [test_list[i::N] for i in range(N)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Split the list into sublists of length n\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, nth):\n    # Create sublists for every nth element using list comprehension\n    result = [input_list[i::nth] for i in range(nth)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def list_split(test_list, N):\n    # Slice the list from the start to the end with a step of N\n    res = [test_list[i::N] for i in range(N)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Create a list of lists by iterating through 'lst' and taking every 'n'th element\n    res = [lst[i::n] for i in range(n)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Use list comprehension to split the list into sublists\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}]}, "Mbpp/281": {"dps": 91.6, "dps_norm": 86.36363636363636, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(data):\n    # Check if all elements in the list are unique by comparing the length of the list\n    # with the length of the set created from the list. A set automatically removes duplicates.\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Create an empty dictionary to store occurrences of each element\n    occurrences = {}\n    \n    # Iterate through each element in the data list\n    for value in data:\n        # Check if the value is already in the dictionary\n        if value in occurrences:\n            # If it is, return False indicating not all elements are unique\n            return False\n        # If not, add the value to the dictionary\n        else:\n            occurrences[value] = 1\n    \n    # If the loop completes without finding duplicates, return True\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(data):\n    # Create a set to store unique elements\n    seen = set()\n    # Iterate over each element in the list\n    for x in data:\n        # If the element is already in the set, it's not unique\n        if x in seen:\n            return False\n        # Add the element to the set\n        seen.add(x)\n    # If no duplicates were found, return True\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates and compare its length to the original list\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(my_list):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is less than the original list, duplicates exist\n    if len(set(my_list)) < len(my_list):\n        return False\n    return True", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates and compare its length to the original list\n    return len(set(data)) == len(data)", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Initialize an empty list to keep track of seen items\n    seen = []\n    \n    # Iterate through each item in the input list\n    for x in data:\n        # Check if the item is already in the seen list\n        if x in seen:\n            return False  # Return False if duplicate found\n        else:\n            seen.append(x)  # Add item to the seen list if not duplicate\n    \n    return True  # Return True if no duplicates found", "matching_cluster_idx": 7}, {"solution": "def all_unique(data):\n    # Using a set to track unique elements\n    unique = set()\n    \n    # Iterate over each element in the input list\n    for item in data:\n        # If the item is already in the set, return False indicating non-uniqueness\n        if item in unique:\n            return False\n        # Otherwise, add the item to the set\n        unique.add(item)\n    \n    # If the loop completes, all items were unique, return True\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(data):\n    # Create an empty set to store unique elements\n    seen = set()\n    # Iterate over each element in the list\n    for x in data:\n        # Check if the element is already in the set\n        if x in seen:\n            return False\n        # Add the element to the set\n        seen.add(x)\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates\n    # If the lengths of the list and the set are equal, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates\n    # Compare the length of the set with the length of the list\n    return len(set(data)) == len(data)", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicate elements\n    # If the lengths are equal, all elements were unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates and compare lengths\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Use a set to track seen elements\n    seen = set()\n    # Iterate over each element in the list\n    for x in data:\n        # If the element is already in the set, return False\n        if x in seen:\n            return False\n        # Add the element to the set\n        seen.add(x)\n    # If no duplicates were found, return True\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(data):\n    # Create an empty set to store elements\n    seen = set()\n    # Iterate over each element in the list\n    for x in data:\n        # Check if the element is already in the set\n        if x in seen:\n            return False\n        # Add the element to the set\n        seen.add(x)\n    # If the loop completes without finding duplicates, return True\n    return True", "matching_cluster_idx": 10}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is the same as the list, all elements are unique\n    return len(set(data)) == len(data)", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list\n    return len(set(data)) == len(data)", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates and compare its length to the original list\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 60.51282051282051, "dps_norm": 81.66666666666667, "pass@1": 86.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    # Initialize count to 0\n    count = 0\n    \n    # Iterate through the array with two nested loops\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # Check if the pair (arr[i], arr[j]) is an inversion\n            if arr[i] > arr[j]:\n                count += 1\n    \n    # Return the total count of inversions\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(A):\n    # Initialize inversion count to zero\n    inv_count = 0\n    n = len(A)\n    \n    # Traverse through all elements of the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Increment inversion count if an inversion is found\n            if A[i] > A[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    \n    # Iterate through the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n                \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\"\n    This function merges two subarrays and counts inversions\n    \"\"\"\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n    \n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            # There will be mid - i inversions, because all the remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += mid - i + 1\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    This function returns the number of inversions in array arr[]\n    \"\"\"\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    \"\"\"\n    An auxiliary recursive function that sorts the input array and returns the number of inversions in the array\n    \"\"\"\n    inv_count = 0\n    if left < right:\n        mid = (left + right)//2\n        \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    \n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Helper function to merge two halves and count inversions\n    def merge_and_count(arr, l, m, r):\n        n1 = m - l + 1\n        n2 = r - m\n        \n        # Create temp arrays\n        L = [0] * n1\n        R = [0] * n2\n        \n        # Copy data to temp arrays L[] and R[]\n        for i in range(0, n1):\n            L[i] = arr[l + i]\n        for j in range(0, n2):\n            R[j] = arr[m + 1 + j]\n        \n        i = 0     # Initial index of first subarray\n        j = 0     # Initial index of second subarray\n        k = l     # Initial index to merge back\n        inv_count = 0\n        \n        # Merge the temp arrays back into arr[l..r]\n        while i < n1 and j < n2:\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                # There are n1 - i inversions, because all the remaining elements in L[]\n                # are greater than R[j]\n                arr[k] = R[j]\n                j += 1\n                inv_count += n1 - i\n            k += 1\n        \n        # Copy the remaining elements of L[], if there are any\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        \n        # Copy the remaining elements of R[], if there are any\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n        \n        return inv_count\n    \n    # Helper function to divide the array into halves and count inversions\n    def merge_sort_and_count(arr, l, r):\n        inv_count = 0\n        if l < r:\n            m = (l + r) // 2\n            \n            inv_count += merge_sort_and_count(arr, l, m)\n            inv_count += merge_sort_and_count(arr, m + 1, r)\n            \n            inv_count += merge_and_count(arr, l, m, r)\n        \n        return inv_count\n    \n    # Check if the array is not empty\n    if not arr:\n        return 0\n    \n    # Call the merge sort and count function\n    return merge_sort_and_count(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count of inversions to 0\n    inv_count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with all elements that follow it\n        for j in range(i + 1, len(arr)):\n            # If the current element is greater than the next element, it's an inversion\n            if arr[i] > arr[j]:\n                inv_count += 1\n    # Return the total count of inversions\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count to zero\n    count = 0\n    \n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment count\n            if arr[i] > arr[j]:\n                count += 1\n    \n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Base case: if the array has 1 or 0 elements, no inversions exist\n    if len(arr) < 2:\n        return 0\n    \n    mid = len(arr) // 2  # Find the middle index to divide the array\n    left = arr[:mid]  # Split the array into left and right halves\n    right = arr[mid:]\n    \n    # Recursively count inversions in the left and right halves\n    left_count = get_Inv_Count(left)\n    right_count = get_Inv_Count(right)\n    \n    merge_count = 0  # Initialize inversion count for the merge process\n    i = j = k = 0  # Initialize pointers for the merge process\n    \n    # Merge the two halves and count inversions\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            merge_count += len(left) - i  # Count inversions when left[i] > right[j]\n            j += 1\n        k += 1\n    \n    # Copy any remaining elements from the left half\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    \n    # Copy any remaining elements from the right half\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n    \n    # Return the total inversion count\n    return left_count + right_count + merge_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize a counter for inversions\n    inv_count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the counter\n            if arr[i] > arr[j]:\n                inv_count += 1\n    # Return the total number of inversions\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left     \n    j = mid + 1  \n    k = left     \n    inv_count = 0\n \n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    ans = 0\n    \n    # Iterate through the array\n    for i in range(0, n):\n        for j in range(i+1, n):\n            # If the current pair (i, j) is an inversion, increment the count\n            if arr[i] > arr[j]:\n                ans += 1\n                \n    return ans", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(A):\n    # Initialize a variable to count inversions\n    inv_count = 0\n    # Loop through each element in the array except the last one\n    for i in range(len(A)-1):\n        # For each element, compare it with all elements ahead of it\n        for j in range(i+1, len(A)):\n            # If an inversion is found, increment the count\n            if A[i] > A[j]:\n                inv_count += 1\n    # Return the total count of inversions found\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Function to count inversions using merge sort\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all the remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array and assign it to arr[] so that the original array is not modified\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr)-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count to zero\n    inv_count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n                \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    \"\"\"\n    A utility function that merges two sorted halves and counts inversions in them.\n    \"\"\"\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n    \n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all the remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n    \n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    \"\"\"\n    A utility function that sorts the array and counts inversions in the array.\n    \"\"\"\n    inv_count = 0\n    if left < right:\n        mid = (left + right)//2\n        \n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        \n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    \n    return inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    \"\"\"\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(A):\n    n = len(A)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i] > A[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Helper function to merge and count inversions\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        return inv_count\n    \n    # Helper function to merge and count inversions during merge\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n        \n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all the remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n        \n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n        \n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n        \n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n        \n        return inv_count\n    \n    # Temporary array to store elements of original array\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Function to merge two halves and count inversions\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all the remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    # Function to divide the array elements into 2 halves and call _merge Sort and _merge function\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Initialize the temporary array\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Helper function to merge two halves and count inversions\n    def mergeSortAndCount(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += mergeSortAndCount(arr, temp_arr, left, mid)\n            inv_count += mergeSortAndCount(arr, temp_arr, mid + 1, right)\n            inv_count += mergeAndCount(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    # Helper function to merge two subarrays and count inversions\n    def mergeAndCount(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all the remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid-i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    # Initialize temporary array for merge sort\n    temp_arr = [0] * len(arr)\n    return mergeSortAndCount(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inversion_count = 0\n    \n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inversion_count += 1\n    \n    # Return the total number of inversions\n    return inversion_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 74.62068965517241, "dps_norm": 62.5, "pass@1": 55.0, "profiled": [{"solution": "def large_product(nums1, nums2, k):\n    # Combine both lists and sort them in descending order of their product\n    combined = sorted([(a * b, a, b) for a in nums1 for b in nums2], reverse=True)\n    # Extract the first k products and return them\n    result = [product for product, _, _ in combined[:k]]\n    return result", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, N):\n    # Generate all possible products by multiplying one element from each list\n    total = [list1[i] * list2[j] for i in range(len(list1)) for j in range(len(list2))]\n    # Sort the list of products in descending order and select the first N elements\n    ans = sorted(total, reverse=True)[:N]\n    return ans", "matching_cluster_idx": 2}, {"solution": "import itertools\ndef large_product(A, B, K):\n    # Generate all possible pairs of elements from the two lists\n    result = itertools.product(A, B)\n    # Calculate the product for each pair\n    result = [x * y for x, y in result]\n    # Sort the products in descending order\n    result.sort(reverse=True)\n    # Return the top K largest products\n    return result[:K]", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, num):\n    # Create a list of all possible products between elements of the two lists\n    products = [x * y for x in list1 for y in list2]\n    # Use nlargest from heapq to find the 'num' largest products\n    return nlargest(num, products)", "matching_cluster_idx": 4}, {"solution": "from heapq import nlargest\nfrom itertools import product\ndef large_product(list1, list2, N):\n    # Generate all possible products from the two lists\n    products = list(product(list1, list2))\n    # Use heapq to find the N largest products\n    large_pro = nlargest(N, products, key=lambda x: x[0] * x[1])\n    # Extract the product values from the tuples\n    result = [product[0] * product[1] for product in large_pro]\n    return result", "matching_cluster_idx": 2}, {"solution": "def large_product(nums1, nums2, k):\n    # Initialize an empty list to store the products\n    result = []\n    # Iterate over each number in nums1\n    for x in nums1:\n        # Iterate over each number in nums2\n        for y in nums2:\n            # Append the product to the result list\n            result.append(x * y)\n    # Sort the result list in descending order\n    result.sort(reverse=True)\n    # Return the first k elements from the sorted result list\n    return result[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, k):\n    # Generate all possible products by selecting one factor from each list\n    result = [a * b for a in nums1 for b in nums2]\n    # Sort the products in descending order and return the first k products\n    return sorted(result, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, K):\n    # Create a list of all possible products between elements of nums1 and nums2\n    product_list = sorted([x * y for x in nums1 for y in nums2], reverse=True)\n    # Return the first K elements from the sorted list of products\n    return product_list[:K]", "matching_cluster_idx": 3}, {"solution": "def large_product(arr1, arr2, k):\n    # Generate all possible products of elements from the two lists\n    list2 = [arr1[i] * arr2[j] for i in range(len(arr1)) for j in range(len(arr2))]\n    \n    # Sort the list of products in descending order\n    list2.sort(reverse=True)\n    \n    # Return the first 'k' products from the sorted list\n    return list2[:k]", "matching_cluster_idx": 2}, {"solution": "from itertools import product\ndef large_product(nums1, nums2, k):\n    # Compute all possible products of one element from each list\n    lst = [i * j for i, j in product(nums1, nums2)]\n    # Sort the products in descending order and take the top 'k' products\n    lst.sort(reverse=True)\n    return lst[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by iterating over both lists\n    products = [list1[i] * list2[j] for i in range(len(list1)) for j in range(len(list2))]\n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    # Return the first 'k' products from the sorted list\n    return products[:k]", "matching_cluster_idx": 2}, {"solution": "def large_product(a, b, k):\n    # Calculate all possible products from pairs of numbers from the two lists\n    c = sorted([i * j for i in a for j in b], reverse=True)\n    # Return the first k elements from the sorted list of products\n    return c[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Sort both input lists in descending order\n    sorted_list1 = sorted(list1, reverse=True)\n    sorted_list2 = sorted(list2, reverse=True)\n    \n    # Calculate all possible products and store them in a list\n    products = [i * j for i in sorted_list1 for j in sorted_list2]\n    \n    # Return the first k elements from the sorted list of products\n    return sorted(products, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, count):\n    # Calculate all possible products between elements of the two lists\n    # Use heapq.nlargest to find the 'count' largest products\n    return heapq.nlargest(count, [x * y for x in list1 for y in list2])", "matching_cluster_idx": 4}, {"solution": "def large_product(nums1, nums2, k):\n    # Use list comprehension to create a list of all possible products\n    products = [nums1[i] * nums2[j] for i in range(len(nums1)) for j in range(len(nums2))]\n    \n    # Sort the list of products in ascending order and take the last k elements\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the last k elements from the sorted list\n    return sorted_products[:k]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, k):\n    # Calculate all possible products from pairs of elements from list1 and list2\n    result = [x * y for x in list1 for y in list2]\n    \n    # Sort the result list in descending order to get the largest products first\n    result.sort(reverse=True)\n    \n    # Return the first 'k' products from the sorted list\n    return result[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(l1, l2, n):\n    # Combine each element of the first list with each element of the second list\n    res = [i * j for i in l1 for j in l2]\n    # Sort the resulting list in descending order and select the top 'n' elements\n    return sorted(res, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(A, B, k):\n    # Use heapq to find the k largest products\n    result = heapq.nlargest(k, (a * b for a in A for b in B))\n    return result", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, k):\n    # Calculate all possible products of one element from each list\n    products = sorted([nums1[i] * nums2[j] for i in range(len(nums1)) for j in range(len(nums2))], reverse=True)\n    \n    # Return the first 'k' largest products\n    return products[:k]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, no_of_products):\n    # Generate all possible products by multiplying each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the list of products in descending order and select the specified number of largest products\n    largest_products = sorted(products, reverse=True)[:no_of_products]\n    return largest_products", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 94.01408450704226, "dps_norm": 97.6923076923077, "pass@1": 48.0, "profiled": [{"solution": "def get_max_sum(n):\n    # Dictionary to store computed results for memoization\n    dict_values = {0: 0, 1: 1}\n    \n    def compute_value(x):\n        # If the result is already computed, return it\n        if x in dict_values:\n            return dict_values[x]\n        \n        # Calculate the maximum sum recursively\n        max_sum = max(compute_value(x // 2) + compute_value(x // 3) + compute_value(x // 4) + compute_value(x // 5), x)\n        \n        # Store the computed result in the dictionary\n        dict_values[x] = max_sum\n        \n        return max_sum\n    \n    # Start computation with the input number\n    return compute_value(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store already computed results\n    table = [0] * (n + 1)\n    \n    def maximum_sum(number):\n        nonlocal table  # Use nonlocal keyword to modify the outer function's variable\n        \n        # Base case: if the number is less than 2, return the number itself\n        if number < 2:\n            return number\n        \n        # Check if the result is already computed and stored in the table\n        if table[number] != 0:\n            return table[number]\n        \n        # Recursive calculation using the given formula\n        result = max(maximum_sum(number // 2) + maximum_sum(number // 3) + maximum_sum(number // 4) + maximum_sum(number // 5), number)\n        \n        # Store the result in the table for future reference\n        table[number] = result\n        \n        return result\n    \n    # Call the recursive function with the input number\n    return maximum_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create an array to store previously computed values\n    dp = [-1] * (n + 1)\n    \n    # Function to recursively calculate the maximum sum\n    def find_max(n):\n        # Base case: if the value is already computed, return it\n        if dp[n] != -1:\n            return dp[n]\n        \n        # Base case: if n is less than or equal to 0, return 0\n        if n <= 0:\n            return 0\n        \n        # Calculate the maximum sum using the given equation\n        dp[n] = max(n, find_max(n // 2) + find_max(n // 3) + find_max(n // 4) + find_max(n // 5))\n        return dp[n]\n    \n    # Call the recursive function to get the maximum sum for n\n    return find_max(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a list to store the maximum sums for numbers up to n\n    dp = [0] * (n + 1)\n    \n    # Iterate through each number from 1 to n to fill the dp array\n    for i in range(1, n + 1):\n        # Calculate the maximum sum using the given formula\n        dp[i] = max(dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5], i)\n    \n    # Return the maximum sum for the given number n\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "import sys\ndef get_max_sum(n):\n    \"\"\"\n    This function calculates the maximum sum possible for a given number using the equation f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n).\n    \n    Parameters:\n    n (int): The number for which to calculate the maximum sum.\n    \n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    # Dictionary to store computed results for memoization\n    dp = {0: 0, 1: 1}\n    \n    def helper(x):\n        \"\"\"\n        Helper function to calculate the sum using memoization.\n        \n        Parameters:\n        x (int): The number to calculate the sum for.\n        \n        Returns:\n        int: The calculated sum.\n        \"\"\"\n        if x not in dp:\n            # Recursively calculate the sum using memoized results\n            dp[x] = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n        return dp[x]\n    \n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Base case: if n is 0 or 1, return n\n    if n <= 1:\n        return n\n    \n    # Check if the result is already computed and stored in the memo dictionary\n    if n not in memo:\n        # Recursive case: compute the maximum sum using the given equation\n        memo[n] = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)\n    \n    # Return the computed result\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a list to store maximum sums\n    lookup = [0 for i in range(n + 1)]\n    \n    def max_sum(num):\n        # Base case: if num is less than or equal to 0, return 0\n        if num <= 0:\n            return 0\n        # If the result is already computed, return it\n        if lookup[num] != 0:\n            return lookup[num]\n        \n        # Compute the maximum sum using the given equation\n        lookup[num] = max(max_sum(num // 2) + max_sum(num // 3) + max_sum(num // 4) + max_sum(num // 5), num)\n        return lookup[num]\n    \n    # Call the helper function with the given number\n    return max_sum(n)", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store previously computed results\n    dp = {}\n    dp[0] = 0  # Base case: f(0) = 0\n    dp[1] = 1  # Base case: f(1) = 1\n    \n    # Define a recursive function to compute f(n)\n    def get_sum(n):\n        # If n is already computed, return the result\n        if n in dp:\n            return dp[n]\n        # Otherwise, compute it recursively\n        else:\n            dp[n] = max(n, get_sum(n // 2) + get_sum(n // 3) + get_sum(n // 4) + get_sum(n // 5))\n            return dp[n]\n    \n    # Compute the result for the given n\n    result = get_sum(n)\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a list to store results of subproblems\n    dp = [-1] * (n + 1)\n    \n    def calculate_sum(n):\n        # If the result for this n is already calculated, return it\n        if dp[n] != -1:\n            return dp[n]\n        \n        # Calculate the maximum sum using the given equation\n        if n == 0:\n            dp[n] = 0\n        elif n == 1:\n            dp[n] = 1\n        else:\n            dp[n] = max(calculate_sum(n // 2) + calculate_sum(n // 3) + calculate_sum(n // 4) + calculate_sum(n // 5), n)\n        \n        return dp[n]\n    \n    # Call the helper function with the given number n\n    return calculate_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the maximum sums\n    max_sum_dict = {0: 0, 1: 1}\n\n    # Function to get the maximum sum using memoization\n    def memoized_max_sum(n):\n        if n not in max_sum_dict:\n            # Calculate the maximum sum for n using the given equation\n            max_sum = max(n, memoized_max_sum(n // 2) + memoized_max_sum(n // 3) + memoized_max_sum(n // 4) + memoized_max_sum(n // 5))\n            max_sum_dict[n] = max_sum\n        return max_sum_dict[n]\n\n    # Call the memoized function to get the maximum sum for n\n    return memoized_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store the maximum sum for each number\n    dp = [0 for i in range(n + 1)]\n    \n    # Define a recursive function to compute the maximum sum\n    def helper(x):\n        # If the value is already computed, return it\n        if x <= 1:\n            return x\n        # If the value is not computed, compute it using the given equation\n        if dp[x] == 0:\n            dp[x] = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n        return dp[x]\n    \n    # Call the helper function to compute the maximum sum for 'n'\n    return helper(n)", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store computed results\n    dp = {0: 0, 1: 1}\n    \n    # Helper function to calculate the maximum sum using memoization\n    def max_sum(n):\n        # Base case: if n is already computed, return the stored result\n        if n in dp:\n            return dp[n]\n        \n        # Recursive case: compute the result using the given formula\n        dp[n] = max(n, max_sum(n // 2) + max_sum(n // 3) + max_sum(n // 4) + max_sum(n // 5))\n        return dp[n]\n    \n    # Call the helper function with the given number\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "import math\ndef get_max_sum(n):\n    # Dictionary to store the computed values of f(n)\n    dp = dict()\n\n    # Recursive function to calculate the maximum sum\n    def helper(n):\n        # Base case: if n is 0, return 0\n        if n == 0:\n            return 0\n        # Base case: if n is 1, return 1\n        if n == 1:\n            return 1\n        # Check if the value has already been computed\n        if n in dp:\n            return dp[n]\n        # Recursively calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        # and compare it with n to decide the maximum sum\n        dp[n] = max(helper(int(n / 2)) + helper(int(n / 3)) + helper(int(n / 4)) + helper(int(n / 5)), n)\n        return dp[n]\n\n    # Start the recursion with the given number n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store computed results\n    dp = dict()\n\n    def compute(n):\n        # Check if the result is already computed\n        if n in dp:\n            return dp[n]\n        # Base case: if n is less than 2, return n\n        elif n < 2:\n            return n\n        else:\n            # Compute the maximum sum using the given formula\n            dp[n] = max(compute(n // 2) + compute(n // 3) + compute(n // 4) + compute(n // 5), n)\n            return dp[n]\n\n    # Call the recursive function with the initial input\n    return compute(n)", "matching_cluster_idx": 12}, {"solution": "memory = {}\ndef get_max_sum(n):\n    # Check if the result for n is already computed and stored\n    if n in memory:\n        return memory[n]\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        result = n\n    else:\n        # Recursive case: calculate the maximum sum using the given formula\n        result = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n    # Store the result in the dictionary for future reference\n    memory[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store computed values\n    f = {0: 0, 1: 1}\n    \n    # Helper function to compute the maximum sum\n    def fmax(n):\n        # Check if the value is already computed\n        if n in f:\n            return f[n]\n        \n        # Recursively compute the maximum sum using the given formula\n        f[n] = max(fmax(n // 2) + fmax(n // 3) + fmax(n // 4) + fmax(n // 5), n)\n        \n        return f[n]\n    \n    # Return the result of the helper function for the given input n\n    return fmax(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store the maximum sum values\n    dp = {}\n    \n    # Helper function to calculate the maximum sum recursively\n    def max_sum_helper(num):\n        # Base case: if num is less than or equal to 0, return 0\n        if num <= 0:\n            return 0\n        # If the value is already computed, return it from the dictionary\n        if num in dp:\n            return dp[num]\n        \n        # Recursively calculate the maximum sum using the given equation\n        dp[num] = max(max_sum_helper(num // 2) + max_sum_helper(num // 3) + max_sum_helper(num // 4) + max_sum_helper(num // 5), num)\n        return dp[num]\n    \n    # Calculate the maximum sum for the given number n\n    return max_sum_helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a dictionary to store computed results for dynamic programming\n    dp = {}\n    \n    # Helper function to compute the maximum sum\n    def f(n):\n        # If the result is already computed, return it\n        if n in dp:\n            return dp[n]\n        # Base case: if n is less than or equal to 0, the sum is n\n        elif n <= 0:\n            return n\n        else:\n            # Compute the sum using the recursive formula and store it in the dictionary\n            dp[n] = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n            return dp[n]\n    \n    # Call the helper function with the input n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store previously computed results\n    memo = {}\n    \n    def helper(n):\n        # Check if the result is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Base case\n        if n <= 1:\n            return n\n        \n        # Compute the sum using the given formula\n        result = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n        \n        # Store the computed result in the dictionary\n        memo[n] = result\n        \n        return result\n    \n    # Call the helper function with the input n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store already computed sums\n    dp = {}\n    \n    def find_maximum(n):\n        # Check if the result is already computed\n        if n in dp:\n            return dp[n]\n        \n        # Base cases\n        if n <= 1:\n            return n\n        \n        # Recursively calculate the sum\n        result = max((find_maximum(n // 2) + find_maximum(n // 3) + find_maximum(n // 4) + find_maximum(n // 5)), n)\n        # Store the result in the dictionary\n        dp[n] = result\n        return result\n    \n    # Call the recursive function with the given number\n    return find_maximum(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 89.48275862068965, "dps_norm": 71.875, "pass@1": 98.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Iterate over the string and populate the frequency dictionary\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate over the string again and return the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count the occurrence of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # Return None if no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Initialize a list to store character counts\n    char_count = [0] * 256\n    \n    # Iterate over the string to count each character's occurrences\n    for i in range(len(s)):\n        char_count[ord(s[i])] += 1\n    \n    # Iterate over the string again to find the first character with a count of 1\n    for i in range(len(s)):\n        if char_count[ord(s[i])] == 1:\n            return s[i]\n    \n    # Return None if no non-repeated character is found\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(s):\n    # Initialize a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string again to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the frequency of each character\n    dict = {}\n    \n    # Iterate over each character in the string\n    for char in str1:\n        # If the character is already in the dictionary, increment its count\n        if char in dict:\n            dict[char] += 1\n        # Otherwise, add the character to the dictionary with a count of 1\n        else:\n            dict[char] = 1\n    \n    # Iterate over each character in the string again\n    for char in str1:\n        # If the character's count in the dictionary is 1, it's the first non-repeated character\n        if dict[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    freq = {}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the dictionary, increment its count\n        if char in freq:\n            freq[char] += 1\n        # If the character is not in the dictionary, add it with a count of 1\n        else:\n            freq[char] = 1\n    \n    # Iterate over each character in the string again\n    for char in s:\n        # Check if the frequency of the current character is 1\n        if freq[char] == 1:\n            # If it is, return that character\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    # Create an ordered dictionary to store character counts\n    count = OrderedDict()\n    \n    # Count occurrences of each character in the string\n    for ch in s:\n        if ch in count:\n            count[ch] += 1\n        else:\n            count[ch] = 1\n    \n    # Return the first character with a count of 1\n    for ch, freq in count.items():\n        if freq == 1:\n            return ch\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character in the string\n    char_frequency = defaultdict(int)\n    \n    # Iterate over the string and count the frequency of each character\n    for char in s:\n        char_frequency[char] += 1\n    \n    # Iterate over the string again and return the first character with a frequency of 1\n    for char in s:\n        if char_frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to count occurrences of each character\n    count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    \n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character counts\n    dic = {}\n    \n    # First pass to populate the dictionary with counts of each character\n    for x in s:\n        dic[x] = dic.get(x, 0) + 1\n    \n    # Second pass to find the first character with a count of 1\n    for x in s:\n        if dic[x] == 1:\n            return x\n    \n    # Return None if no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Initialize an empty dictionary to store character counts\n    counts = {}\n    \n    # Loop through the string to count occurrences of each character\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n    \n    # Iterate through the string again to find the first character with a count of 1\n    for c in s:\n        if counts[c] == 1:\n            return c\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    d = {}\n    \n    # Iterate over the characters in the string\n    for char in s:\n        if char in d:\n            # If character is already in dictionary, increment its count\n            d[char] += 1\n        else:\n            # If character is not in dictionary, add it with count 1\n            d[char] = 1\n    \n    # Iterate over the characters in the string again\n    for char in s:\n        # Check if the count of the character is 1\n        if d[char] == 1:\n            # If count is 1, return the character\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Iterate through the string\n    for i in range(len(s)):\n        # Check if the current character is the only one in the string\n        if s.count(s[i]) == 1:\n            return s[i]\n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 1}, {"solution": "from collections import OrderedDict\ndef first_non_repeating_character(s):\n    # Create an ordered dictionary to maintain the order of characters and their counts\n    counts = OrderedDict()\n    \n    # Count occurrences of each character in the string\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in counts:\n        if counts[char] == 1:\n            return char\n    \n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_str):\n    # Create a dictionary to store character frequencies\n    char_freq = {}\n    \n    # Iterate over each character in the input string\n    for char in input_str:\n        if char in char_freq:\n            # Increment the frequency of the character if it's already in the dictionary\n            char_freq[char] += 1\n        else:\n            # Initialize the frequency of the character to 1 if it's not in the dictionary\n            char_freq[char] = 1\n    \n    # Iterate over the string again to find the first character with a frequency of 1\n    for char in input_str:\n        if char_freq[char] == 1:\n            # Return the first non-repeating character\n            return char\n    \n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(str1):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate through the string and return the first character with a count of 1\n    for char in str1:\n        if char_count[char] == 1:\n            return char\n    \n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    count = {}\n    for char in s:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    \n    # Iterate over the string and return the first character with a count of 1\n    for char in s:\n        if count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Initialize a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the dictionary, increment its count\n        if char in frequency:\n            frequency[char] += 1\n        # Otherwise, add the character to the dictionary with a count of 1\n        else:\n            frequency[char] = 1\n    \n    # Iterate over each character in the string again\n    for char in s:\n        # If the count of the character in the dictionary is 1, return it\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store character counts\n    character_count = {}\n    \n    # First loop to count occurrences of each character\n    for char in s:\n        if char in character_count:\n            character_count[char] += 1\n        else:\n            character_count[char] = 1\n    \n    # Second loop to find the first non-repeating character\n    for char in s:\n        if character_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    # Count the frequency of each character in the string\n    frequency = Counter(s)\n    \n    # Iterate through the string and return the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 95.96153846153847, "dps_norm": 96.25, "pass@1": 98.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple using the 'in' keyword\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple, element):\n    # Use the 'in' keyword to check if the element exists in the tuple\n    return element in tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, K):\n    # Check if the element K exists in the tuple test_tup using the 'in' keyword\n    res = (K in test_tup)\n    return res", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple and return the result\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, K):\n    # Check if the element is in the tuple and return the result\n    res = K in test_tup\n    return res", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, K):\n    # Use the 'in' keyword to check if the element is in the tuple and return the result\n    res = K in test_tup\n    return res", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple, element):\n    # Check if the element exists in the tuple and return the result\n    return element in tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    result = element in tuplex\n    return result", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple using the 'in' keyword\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Iterate through each item in the tuple\n    for item in tuplex:\n        # Check if the current item matches the element\n        if (item == element):\n            # If a match is found, return True\n            return True\n    # If no match is found after checking all items, return False\n    return False", "matching_cluster_idx": 0}, {"solution": "def check_tuplex(tuplex, element):\n    # Return True if the element is in the tuple, otherwise False\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple and return True if found\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple and return the result\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Use the 'in' operator to check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element exists in the tuple\n    if element in tuplex:\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 63.41614906832298, "dps_norm": 77.22222222222223, "pass@1": 99.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    # Iterate over each item in the first sequence\n    for value in seq1:\n        # Check if the item is in the second sequence\n        if value in seq2:\n            # If found, return True indicating an overlap\n            return True\n    # If no overlap found, return False\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Check if there is any common element between list1 and list2\n    return bool(set(list1) & set(list2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Use set intersection to find common elements between the two sequences\n    if len(set(seq1) & set(seq2)):\n        return True  # Return True if there are any overlapping values\n    else:\n        return False  # Return False if there are no overlapping values", "matching_cluster_idx": 5}, {"solution": "def overlapping(test_list1, test_list2):\n    # Check if there is any element in test_list1 that is also in test_list2\n    res = any(x in test_list2 for x in test_list1)\n    return res", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Use set intersection to find common elements\n    common_elements = set(list1) & set(list2)\n    # Return True if there are common elements, False otherwise\n    return bool(common_elements)", "matching_cluster_idx": 5}, {"solution": "def overlapping(list1, list2):\n    # Initialize a variable to track if there is an overlapping element\n    flag = 0\n    # Iterate over each element in the first list\n    for i in list1:\n        # Check if the current element is in the second list\n        if i in list2:\n            # If found, set the flag to 1 (True) and break the loop\n            flag = 1\n            break\n    # Return True if an overlap is found, otherwise False\n    if flag == 1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Check if there is any overlap between list1 and list2\n    return bool(set(list1) & set(list2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(test_list1, test_list2):\n    # Check if any element in test_list1 is also in test_list2\n    res = any(i in test_list2 for i in test_list1)\n    return res", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Use set to find intersection of two lists\n    if set(list1) & set(list2):\n        return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(test_list1, test_list2):\n    # Use set intersection to check for common elements\n    res = bool(set(test_list1) & set(test_list2))\n    return res", "matching_cluster_idx": 5}, {"solution": "def overlapping(test_list1, test_list2):\n    # Check if any element from test_list2 exists in test_list1\n    res = any(item in test_list1 for item in test_list2)\n    return res", "matching_cluster_idx": 8}, {"solution": "def overlapping(list1, list2):\n    # Create a set from the first list for O(1) average-case complexity for lookups\n    list1_set = set(list1)\n    # Check each element in the second list against the set\n    return any(element in list1_set for element in list2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    # Loop through each element in the first sequence\n    for x in seq1:\n        # Check if the current element is in the second sequence\n        if x in seq2:\n            return True\n    # If no common elements are found, return False\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Initialize a variable to indicate if there's any overlap\n    flag = 0\n    \n    # Iterate through each element in the first list\n    for i in list1:\n        # Check if the current element is in the second list\n        if i in list2:\n            # If found, set the flag to 1 (True) and break the loop\n            flag = 1\n            break\n    \n    # Return the result: True if flag is 1, otherwise False\n    return bool(flag)", "matching_cluster_idx": 7}, {"solution": "def overlapping(test_list1, test_list2):\n    # Check if any element from test_list1 exists in test_list2\n    res = any([ele in test_list2 for ele in test_list1])\n    return res", "matching_cluster_idx": 2}, {"solution": "def overlapping(test_list1, test_list2):\n    # Check if any value in test_list1 exists in test_list2 using set intersection\n    res = bool(set(test_list1) & set(test_list2))\n    return res", "matching_cluster_idx": 5}, {"solution": "def overlapping(list1, list2):\n    # Using set intersection to check if any value exists in both lists\n    if set(list1) & set(list2):\n        return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(list1, list2):\n    # Iterate through each element in the first list\n    for element in list1:\n        # Check if the element is present in the second list\n        if element in list2:\n            return True  # Return True if the element is found\n    return False  # Return False if no common element is found", "matching_cluster_idx": 7}, {"solution": "def overlapping(test_list1, test_list2):\n    # Initialize result as False\n    res = False\n    # Iterate through each element in the first list\n    for ele in test_list1:\n        # Check if the element is in the second list\n        if ele in test_list2:\n            # If found, set result to True and break the loop\n            res = True\n            break\n    # Return the result\n    return res", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Iterate over each element in the first list\n    for i in list1:\n        # Check if the element is present in the second list\n        if i in list2:\n            return True\n    # Return False if no common element is found\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 39.876543209876544, "dps_norm": 75.71428571428571, "pass@1": 93.0, "profiled": [{"solution": "def concatenate_tuple(test_tup):\n    # Convert each element in the tuple to a string and join them with a hyphen as the delimiter\n    res = '-'.join(str(ele) for ele in test_tup)\n    return str(res)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    # Concatenate each element of the tuple into a single string with a dash delimiter\n    res = '-'.join(str(ele) for ele in test_tup)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    # Join each element of the tuple into a string with '-' as the delimiter\n    res = '-'.join(str(ele) for ele in test_tup)\n    return str(res)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element of the tuple to string and join them with '-'\n    res = '-'.join(str(ele) for ele in test_tup)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element in the tuple to string and join with '-'\n    res = '-'.join(map(str, test_tup))\n    return str(res)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(test_tup):\n    # Initialize an empty string to store the result\n    res = \"\"\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Convert the element to string and concatenate it with the result\n        # Add a hyphen as a delimiter\n        res += str(ele) + '-'\n    # Return the result string, removing the trailing hyphen\n    return res[:-1]", "matching_cluster_idx": 3}, {"solution": "def concatenate_tuple(test_tup):\n    # Initialize an empty string as the result\n    res = ''\n    # Iterate over each element in the tuple\n    for ele in test_tup:\n        # Convert the element to string and concatenate it to res with a hyphen\n        res += str(ele) + '-'\n    # Return the result string, removing the trailing hyphen\n    return res[:-1]", "matching_cluster_idx": 3}, {"solution": "def concatenate_tuple(test_tup):\n    # Using join() to concatenate tuple elements with '-'\n    res = '-'.join(str(ele) for ele in test_tup)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert each element of the tuple to string and concatenate with '-'\n    result = '-'.join(str(element) for element in tup)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element in the tuple to a string\n    res = '-'.join(str(ele) for ele in test_tup)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(Tup):\n    # Initialize an empty string to store the result\n    res = ''\n    # Iterate through each element in the tuple\n    for ele in Tup:\n        # Convert each element to string and concatenate with a hyphen\n        res += str(ele) + '-'\n    # Return the result string, slicing to remove the trailing hyphen\n    return res[:-1]", "matching_cluster_idx": 3}, {"solution": "def concatenate_tuple(test_tup):\n    # Using the join() method to concatenate tuple elements with '-' as a delimiter\n    res = '-'.join([str(ele) for ele in test_tup])\n    return str(res)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Convert each element of the tuple to string and join them with '-'\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(items):\n    # Convert each element of the tuple to a string and join them with a hyphen as the delimiter\n    return '-'.join(map(str, items))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(test_tup):\n    # Convert each element to string and join them with the delimiter '-'\n    res = '-'.join([str(ele) for ele in test_tup])\n    return str(res)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(test_tup):\n    # Use the join() method with '-' as the delimiter to concatenate elements of the tuple\n    res = '-'.join([str(ele) for ele in test_tup])\n    return str(res)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(test_tup):\n    # Check if the tuple contains any non-string elements\n    res = '-'.join(map(str, test_tup))\n    return res", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(test_tup):\n    # Initialize a result variable as an empty string\n    res = \"\"\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Convert the element to string and concatenate with the result\n        res += str(ele) + \"-\"\n    # Return the result string, removing the trailing delimiter\n    return res[:-1]", "matching_cluster_idx": 3}, {"solution": "def concatenate_tuple(input_tuple):\n    # Joining tuple elements into a string with '-' as the delimiter\n    result = '-'.join(str(element) for element in input_tuple)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(items):\n    # Convert each element in the tuple to string and join them with '-'\n    return '-'.join(map(str, items))", "matching_cluster_idx": 6}]}, "Mbpp/424": {"dps": 92.74368231046931, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(test_tup):\n    # Using list comprehension and indexing to extract the last character of each string in the tuple\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(input_tuple):\n    # Use list comprehension to extract the last character of each string in the tuple\n    result = [element[-1] for element in input_tuple]\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Using list comprehension to iterate over each string in the tuple and extract the last character\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Extracting the last element from each string in the tuple\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Using list comprehension to iterate through each string in the tuple\n    # and extracting the last character of each string\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Using list comprehension to extract the last character of each string in the tuple\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Extract the last element of each string in the tuple\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    # Extract the last character of each string in the tuple using list comprehension\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Extracting the last element from each string in the tuple using list comprehension\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Extract the last element of each string in the tuple using list comprehension\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Using list comprehension to extract the last character of each string\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Initialize an empty list to store the last elements\n    res = []\n    # Iterate through each string in the tuple\n    for ele in test_tup:\n        # Append the last character of each string to the result list\n        res.append(ele[-1])\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    # Use list comprehension to iterate through each string in the tuple\n    # The [-1] index selects the last character of each string\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Initialize an empty list to store the last characters\n    res = []\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Append the last character of the string to the result list\n        res.append(ele[-1])\n    # Return the list containing the last characters\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    # Use list comprehension to iterate over each string in the tuple and get the last character\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Extract the last character from each string in the tuple using list comprehension\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Use list comprehension to iterate over each string in the tuple\n    # and extract the last character using slicing (-1)\n    res = [el[-1] for el in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tup):\n    # Using list comprehension to iterate through each string in the tuple\n    # and extracting the last character (reversed index -1) of each string.\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 4}, {"solution": "def extract_rear(words):\n    # Use a list comprehension to iterate through each word in the tuple\n    return [word[-1] for word in words]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(words_tuple):\n    # Using list comprehension to iterate over each word in the tuple\n    # The [-1] index is used to access the last character of each word\n    rear_elements = [word[-1] for word in words_tuple]\n    # Returning the list of last characters\n    return rear_elements", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 95.7396449704142, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(my_list, element):\n    # Initialize a counter to keep track of sublists containing the element\n    counter = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in my_list:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # If found, increment the counter\n            counter += 1\n    \n    # Return the total count of sublists containing the element\n    return counter", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Using the sum function and a list comprehension to count occurrences\n    count = sum(1 for sublist in list1 if element in sublist)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nums, x):\n    # Use the sum function with a generator expression to count occurrences of x in sublists\n    count = sum(1 for sublist in nums if x in sublist)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, x):\n    # Initialize a counter to keep track of the number of sublists containing the element x\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element x is in the current sublist\n        if x in sublist:\n            # If found, increment the counter\n            count += 1\n    # Return the total count of sublists containing the element x\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    count = 0  # Initialize count of sublists containing the element\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            count += 1  # Increment count if the element is found\n    return count  # Return the total count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Count elements in the list of lists\n    return sum(x.count(element) for x in lst)", "matching_cluster_idx": 3}, {"solution": "def count_element_in_list(test_list, K):\n    # Use the sum function to count how many sublists contain the element K\n    res = sum(1 for sub in test_list if K in sub)\n    return res", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Use the sum function with a generator expression to count sublists containing the element\n    return sum(1 for sub_list in list1 if element in sub_list)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef count_element_in_list(lst: List[List[int]], element: int) -> int:\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    # Iterate through each sublist in the list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, n):\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    \n    # Iterate through each sublist in the list\n    for sublist in lst:\n        # Check if the element 'n' is in the current sublist\n        if n in sublist:\n            # If the element is found, increment the counter\n            count += 1\n            \n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(test_list, K):\n    # Initialize a counter to keep track of sublists containing the element K\n    res = 0\n    # Iterate over each sublist in the main list\n    for sublist in test_list:\n        # Check if the element K is in the current sublist\n        if K in sublist:\n            # Increment the counter if K is found\n            res += 1\n    # Return the total count of sublists containing the element K\n    return res", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lis, x):\n    # Initialize a count variable to zero\n    count = 0\n    \n    # Iterate through each sublist in the list\n    for sublist in lis:\n        # Check if the element x is in the current sublist\n        if x in sublist:\n            # Increment the count if x is found\n            count += 1\n            \n    # Return the total count of sublists containing the element x\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Using list comprehension to count sublists containing the specific element\n    count = sum(1 for sublist in list1 if element in sublist)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    # Use a generator expression to count sublists that contain the specified element\n    return sum(1 for sub_list in input_list if element in sub_list)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, x):\n    # Count the number of sublists that contain the element x\n    return sum(x in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    count = 0\n    # Loop through each sublist in the main list\n    for sublist in input_list:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            count += 1\n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, x):\n    # Use the sum function to count how many sublists contain the element x\n    return sum(1 for s in lst if x in s)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, x):\n    # Initialize count to zero\n    count = 0\n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # If x is found in the sublist, increment the count\n        if x in sublist:\n            count += 1\n    # Return the total count of sublists containing x\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(input_list, element):\n    # Initialize a counter to keep track of sublists containing the element\n    counter = 0\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Check if the element is present in the current sublist\n        if element in sublist:\n            # If the element is found, increment the counter\n            counter += 1\n    \n    # Return the total count of sublists containing the element\n    return counter", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    # Initialize a counter to keep track of occurrences\n    counter = 0\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            counter += 1\n    \n    # Return the total count of sublists containing the element\n    return counter", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 90.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    \n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            \n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Get the length of the array\n    n = len(arr)\n    \n    # Start with a large gap, then reduce the gap\n    gap = n // 2\n    \n    # Perform a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Get the length of the array\n    n = len(arr)\n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Continue until the gap is 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Continue until the gap is 0\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Start with a large gap, then reduce the gap\n    \n    # Continue while the gap is greater than 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Initialize the gap size\n    gap = len(arr) // 2\n    \n    # Continue until the gap is 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Get the number of elements in the array\n    n = len(arr)\n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    # Keep reducing the gap until it becomes 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            temp = arr[i]\n            j = i\n            \n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n    \n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr) // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr) // 2\n    \n    # Keep reducing the gap until it becomes 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Continue with the gap until it becomes 0\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Get the length of the array\n    n = len(arr)\n    gap = n // 2\n    \n    # Continue until the gap is 0\n    while gap > 0:\n        # Perform insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next element\n        gap //= 2\n    \n    # Return the sorted array\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    # Keep reducing the gap until it becomes 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Calculate the initial gap size\n    gap = len(arr) // 2\n    \n    # Continue until the gap is 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            \n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        \n        # Reduce the gap for the next round\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements arr[0..gap-1] are already in gapped order\n        # keep adding one more element until the entire array is gap sorted\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Continue until the gap is 0\n    while gap > 0:\n        # Perform a gapped insertion sort\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 68.33060556464811, "dps_norm": 73.84615384615384, "pass@1": 13.0, "profiled": [{"solution": "def check_greater(arr, x):\n    # Iterate through each element in the array\n    for i in arr:\n        # If the element is greater than or equal to x, return False\n        if i >= x:\n            return False\n    # If no element is greater than or equal to x, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, x):\n    # Use a generator expression to check if x is greater than all elements in arr\n    return all(x > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, N):\n    # Iterate through each element in the array\n    for i in arr:\n        # Check if the current element is greater than or equal to N\n        if i >= N:\n            return False\n    # If no element is greater than or equal to N, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(nums, k):\n    # Check if all elements in the array are less than the given number k\n    result = all([k > num for num in nums])\n    return result", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    # Return True if the maximum element in the array is less than num, else False\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, target):\n    # Iterate through each element in the array\n    for i in range(len(array)):\n        # Check if the target is less than or equal to the current element\n        if target <= array[i]:\n            # Return False if the target is not greater than the current element\n            return False\n    # Return True if the target is greater than all elements in the array\n    return True", "matching_cluster_idx": 1}, {"solution": "def check_greater(arr, x):\n    # Loop through each element in the array\n    for i in range(len(arr)):\n        # Check if the element is greater than or equal to x\n        if arr[i] >= x:\n            # Return False if any element is greater than or equal to x\n            return False\n    # Return True if no element is greater than or equal to x\n    return True", "matching_cluster_idx": 1}, {"solution": "def check_greater(test_list, K):\n    # Loop through each element in the list\n    for ele in test_list:\n        # Check if the current element is greater than or equal to K\n        if ele >= K:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Iterate through each element in the array\n    for x in arr:\n        # If the current element is greater than or equal to the number, return False\n        if x >= num:\n            return False\n    # If no element is greater than the number, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, n):\n    # Check if the number n is greater than all elements in the array arr\n    return all(x < n for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    # Iterate through the array\n    for i in arr:\n        # Check if the number n is less than or equal to any element in the array\n        if n <= i:\n            return False\n    # If the number n is greater than all elements in the array, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    # Check if all elements in the array are less than the number\n    result = all(number > n for n in array)\n    return result", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, key):\n    # Check if the key is greater than all elements in the array\n    if all(key > ele for ele in arr):\n        return True\n    # If the key is not greater than all elements, return False\n    else:\n        return False", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 69.26470588235294, "dps_norm": 24.0, "pass@1": 38.0, "profiled": [{"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    res = ''\n    \n    # Iterate over each character in the string, starting from index 1\n    for i in range(1, len(s) + 1):\n        # If the index is even (considering 1-based indexing), append the character to the result\n        if i % 2 == 0:\n            res += s[i-1]\n    \n    # Return the result string\n    return res", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty list to store even-indexed characters\n    res = []\n    \n    # Iterate over the string, considering the index\n    for i in range(len(s)):\n        # Check if the index is even (i.e., character is at an even position)\n        if i % 2 == 1:\n            # Append the character at the even index to the result list\n            res.append(s[i])\n    \n    # Join the list of characters into a string and return it\n    return ''.join(res)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to select characters at even indices (0, 2, 4, ...)\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(str):\n    # Filter out characters at even indices (odd positions) using list comprehension\n    return ''.join(str[i] for i in range(len(str)) if i % 2 != 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(S):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using its index\n    for i in range(len(S)):\n        # Check if the index is even (odd characters in 1-based indexing)\n        if i % 2 != 0:\n            # Append the character at the even index to the result string\n            result += S[i]\n    \n    # Return the result string which contains only the even-indexed characters\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(test_str):\n    # Use list comprehension to filter out odd positioned characters (1-based index)\n    # and join the characters to form the new string\n    res = ''.join([test_str[i] for i in range(len(test_str)) if (i + 1) % 2 == 0])\n    return res", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out characters at odd indices\n    return \"\".join([ch for idx, ch in enumerate(s) if idx % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use a list comprehension to filter out characters at even indices\n    # Starting from index 1 to remove characters at odd positions (1-based indexing)\n    return ''.join([s[i] for i in range(len(s)) if i % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(str1):\n    # Initialize an empty string to store even-indexed characters\n    result = \"\"\n    # Loop through the string, starting from index 1 to remove odd characters\n    for i in range(1, len(str1) + 1):\n        if i % 2 == 0:\n            result += str1[i - 1]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through the string using enumerate to get both index and character\n    for i, char in enumerate(input_string):\n        # Check if the index is even (since Python uses 0-based indexing, even index means odd position)\n        if i % 2 == 1:\n            # Append the character at the even index to the result string\n            result += char\n    \n    # Return the result string with odd characters removed\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Filter out odd-indexed characters and join the result\n    return ''.join(c for i, c in enumerate(s) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(test_str):\n    # Using a list comprehension to filter out odd-indexed characters (even positions)\n    res = ''.join([char for idx, char in enumerate(test_str) if idx % 2 == 1])\n    return res", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove odd characters from a string, considering index-based parity (1-indexed).\n    \n    Args:\n    s (str): The input string from which odd characters will be removed.\n    \n    Returns:\n    str: A new string containing only the characters at even indices of the original string.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using an index\n    for i in range(len(s)):\n        # Check if the character is at an even index (considering 0-indexing)\n        if (i + 1) % 2 == 0:\n            # Append the character to the result string\n            result += s[i]\n    \n    # Return the result string\n    return result", "matching_cluster_idx": -1}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the input string using an index\n    for i in range(len(input_string)):\n        # Check if the current index is even\n        if i % 2 == 1:\n            # Append the character at the current index to the result string\n            result += input_string[i]\n    \n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    res = \"\"\n    \n    # Iterate over the string using enumerate to get both index and character\n    for i, j in enumerate(s):\n        # Check if the index is even (i.e., the character is at an odd position)\n        if i % 2 != 0:\n            # Append the character to the result string\n            res += j\n    \n    # Return the result string with characters at odd positions removed\n    return res", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over the string with index\n    for i in range(len(s)):\n        # Check if the index is even (since indices are 0-based, even indices represent odd characters in the problem statement)\n        if i % 2 == 1:\n            # Append the character at the even index to the result string\n            result += s[i]\n    # Return the result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(my_string):\n    # Use list comprehension to filter out odd indexed characters\n    result = [my_string[i] for i in range(len(my_string)) if i % 2 == 1]\n    # Join the list back into a string\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def remove_odd(S):\n    # Initialize an empty string to store the result\n    output = ''\n    # Iterate over the string using enumerate to get both index and character\n    for i, s in enumerate(S):\n        # Check if the index is even (odd character positions in human terms)\n        if i % 2 != 0:\n            # Append the character at even index to the result string\n            output += s\n    return output", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty list to store even-indexed characters\n    output_list = []\n    \n    # Iterate over the string, starting from index 1 to ignore the first character\n    for index in range(1, len(input_string), 2):\n        # Append the character at the current index to the output list\n        output_list.append(input_string[index])\n    \n    # Join the list into a string and return it\n    return ''.join(output_list)", "matching_cluster_idx": 2}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out characters at odd indices\n    return \"\".join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}]}, "Mbpp/440": {"dps": 88.63636363636364, "dps_norm": 91.25, "pass@1": 57.0, "profiled": [{"solution": "import re\ndef find_adverb_position(text):\n    # Use regex to find the first occurrence of an adverb and its position\n    match = re.search(r\"\\w+ly\", text)\n    if match:\n        # Return the start position, end position, and the matched adverb\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # Return None if no adverb is found\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all occurrences of words ending with 'ly'\n    adverbs = re.findall(r\"\\w+ly\", sentence)\n    # Iterate over the adverbs found\n    for adverb in adverbs:\n        # Find the starting and ending positions of the adverb in the sentence\n        start_pos = sentence.find(adverb)\n        end_pos = start_pos + len(adverb)\n        # Return the positions and the adverb itself\n        return (start_pos, end_pos, adverb)", "matching_cluster_idx": 1}, {"solution": "def find_adverb_position(text):\n    # Using regular expression to find all occurrences of adverbs\n    import re\n    adverbs = re.findall(r\"\\w+ly\", text)\n    \n    # Check if there are adverbs in the text\n    if not adverbs:\n        return None\n    else:\n        # Iterate through each adverb found\n        for adverb in adverbs:\n            # Find the starting position of the adverb in the text\n            start = text.find(adverb)\n            # Find the ending position of the adverb in the text\n            end = start + len(adverb)\n            # Return the starting, ending positions, and the adverb itself\n            return (start, end, adverb)", "matching_cluster_idx": 1}, {"solution": "import re\ndef find_adverb_position(string):\n    # Use regular expression to find the first occurrence of an adverb and its position\n    for m in re.finditer(r\"\\w+ly\", string):\n        # Return the start and end positions, along with the adverb itself\n        return (m.start(), m.end(), m.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(string):\n    # Use regular expression to find adverbs ending in 'ly'\n    for match in re.finditer(r\"\\w+ly\", string):\n        # Return the start and end positions along with the matched adverb\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}, {"solution": "def find_adverb_position(text):\n    # Find the position of the first adverb using regular expression\n    import re\n    pos = re.search(r\"\\w+ly\", text)\n    \n    # If an adverb is found, return its start, end positions, and the adverb itself\n    if pos:\n        return (pos.start(), pos.end(), pos.group(0))\n    else:\n        # Return None if no adverb is found\n        return None", "matching_cluster_idx": 3}, {"solution": "def find_adverb_position(text):\n    # Import the regex module to work with regular expressions\n    import re\n    \n    # Use regex to search for words ending with 'ly', which are adverbs\n    for match in re.finditer(r\"\\w+ly\", text):\n        # Return the start and end positions, along with the matched adverb\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(text):\n    # Use regular expression to find all occurrences of adverbs and their starting and ending positions\n    results = re.finditer(r\"\\w+ly\", text)\n    # Check if any adverb is found\n    if results is not None:\n        # Iterate over all matches found\n        for result in results:\n            # Return the start position, end position, and the adverb itself\n            return result.start(), result.end(), result.group(0)\n    # Return None if no adverb is found\n    return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Define a regex pattern to match adverbs\n    pattern = r\"\\w+ly\"\n    # Search for the pattern in the sentence\n    match = re.search(pattern, sentence)\n    \n    if match:\n        # If a match is found, return the start position, end position, and the adverb itself\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # If no match is found, return None\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(string):\n    # Regular expression pattern to match words ending in 'ly'\n    pattern = r\"([a-z]+ly)\"\n    # Search for the first occurrence of the pattern\n    for m in re.finditer(pattern, string):\n        # Return the start and end positions of the match, along with the matched word\n        return (m.start(), m.end(), m.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Define a regular expression pattern to match words ending in 'ly'\n    pattern = r\"\\w+ly\"\n    \n    # Use re.search to find the first occurrence that matches the pattern\n    match = re.search(pattern, sentence)\n    \n    if match:\n        # If a match is found, return the starting position, ending position, and the adverb itself\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(s):\n    # Use regular expression to find all occurrences of words ending with 'ly'\n    for match in re.finditer(r\"\\w+ly\", s):\n        # Return the start and end positions, and the matched adverb\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(string):\n    # Use regular expression to find adverbs and their positions\n    for match in re.finditer(r\"\\w+ly\", string):\n        # Return the start and end positions, along with the adverb\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Define a regular expression pattern to find adverbs\n    pattern = r\"\\w+ly\"\n    # Find all matches of the pattern in the sentence\n    adverbs = re.findall(pattern, sentence)\n    \n    # If there are no adverbs, return None\n    if not adverbs:\n        return None\n    \n    # Define another regular expression pattern to find the exact position of the first adverb\n    loc_pattern = re.compile(r\"\\w+ly\")\n    # Search for the first occurrence of the adverb pattern\n    location = loc_pattern.search(sentence)\n    \n    # Return a tuple with the start and end positions, and the found adverb\n    return (location.start(), location.end(), location.group(0))", "matching_cluster_idx": 0}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Regular expression to find adverbs and their start position\n    for match in re.finditer(r\"\\w+ly\", sentence):\n        # Return the start and end positions along with the adverb found\n        return match.start(), match.end(), match.group(0)", "matching_cluster_idx": 3}, {"solution": "def find_adverb_position(text):\n    # Use regular expression to find words ending with 'ly'\n    import re\n    match = re.search(r\"\\w+ly\", text)\n    if match:\n        # If a match is found, return start and end positions along with the adverb\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Using regular expression to find the first adverb and its position\n    match = re.search(r\"\\w+ly\", sentence)\n    if match:\n        # Returning the start, end position and the adverb itself\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # Returning None if no adverb is found\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(string):\n    # Using regular expression to find the first adverb and its position\n    adverb = re.search(r\"\\w+ly\", string)\n    \n    if adverb:\n        # Extracting the starting index and the adverb itself\n        s = adverb.start()\n        e = adverb.end()\n        return (s, e, adverb.group(0))\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(text):\n    # Use regular expression to find adverbs and their start and end positions\n    for position in re.finditer(r\"\\w+ly\", text):\n        # Return the start and end position, along with the matched adverb\n        return (position.start(), position.end(), position.group(0))", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(text):\n    # Use regular expression to find all occurrences of adverbs ending in 'ly'\n    match = re.search(r\"\\w+ly\", text)\n    \n    # If a match is found, return the start and end positions along with the adverb\n    if match:\n        return (match.start(), match.end(), match.group(0))", "matching_cluster_idx": 3}]}, "Mbpp/446": {"dps": 92.66009852216749, "dps_norm": 69.0, "pass@1": 22.0, "profiled": [{"solution": "from collections import Counter\ndef count_Occurrence(test_tup, K):\n    # Count occurrences of each element in the tuple\n    count = Counter(test_tup)\n    \n    # Initialize result to 0\n    res = 0\n    \n    # Iterate through each element in the provided list K\n    for ele in K:\n        # Add the count of each element in K to the result\n        res += count[ele]\n    \n    return res", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(test_tup, K):\n    # Initialize a counter variable to store the total count\n    res = 0\n    \n    # Iterate over each element in the list\n    for ele in K:\n        # Count the occurrences of the element in the tuple and add to the result\n        res += test_tup.count(ele)\n    \n    # Return the total count of occurrences\n    return res", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef count_Occurrence(test_tup: Tuple[str], K: List[str]) -> int:\n    # Use list comprehension and the count method to sum occurrences\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Convert the tuple into a list to enable counting\n    res = [i.count(j) for i, j in zip([test_tup] * len(K), K)]\n    \n    # Sum up the counts and return the result\n    return sum(res)", "matching_cluster_idx": 2}, {"solution": "from collections import defaultdict\ndef count_Occurrence(test_tup, K):\n    # Initialize a defaultdict to count occurrences of each element in the list\n    res = defaultdict(int)\n    \n    # Count occurrences of each element in the tuple\n    for ele in test_tup:\n        res[ele] += 1\n    \n    # Sum the occurrences of elements present in the list K\n    res = sum(res[ele] for ele in K if ele in res)\n    \n    return res", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(test_tup, K):\n    # Count occurrences of elements in the tuple that are present in the list\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Count occurrences using sum and generator expression\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple, list):\n    # Initialize a counter to zero\n    counter = 0\n    \n    # Loop through each element in the list\n    for ele in list:\n        # If the element is in the tuple, increment the counter by the count of that element in the tuple\n        counter += tuple.count(ele)\n    \n    # Return the total count\n    return counter", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Initialize result to 0\n    res = 0\n    # Iterate through each element in the list K\n    for ele in K:\n        # Count occurrences of each element in the tuple test_tup\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple1, list1):\n    count = 0  # Initialize a counter to keep track of occurrences\n    for x in tuple1:  # Iterate through each element in the tuple\n        for y in list1:  # Iterate through each element in the list\n            if x == y:  # Check if the current element in the tuple matches the current element in the list\n                count += 1  # Increment the counter if there is a match\n    return count  # Return the total count of occurrences", "matching_cluster_idx": 1}, {"solution": "def count_Occurrence(test_tup, K):\n    # Count each element in the tuple\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(given_tuple, list_values):\n    # Count the occurrences of each element in the tuple using Counter\n    frequency = Counter(given_tuple)\n    \n    # Initialize a variable to accumulate the total occurrences\n    result = 0\n    \n    # Iterate through each value in the list and add its frequency to the result\n    for value in list_values:\n        result += frequency[value]\n    \n    # Return the total count of occurrences\n    return result", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(test_tup, K):\n    # Use a dictionary comprehension to count occurrences of each element in the tuple\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Using sum() to count occurrences of elements in list K within tuple test_tup\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Count occurrences of each element in the tuple\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(test_tup, K):\n    # Using Counter to count occurrences of each element in the tuple\n    res = sum([test_tup.count(ele) for ele in K])\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Initialize counter for occurrences\n    res = 0\n    # Iterate through each element in the list\n    for ele in K:\n        # Count occurrences of each element in the tuple\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Count the total occurrence of elements from K in test_tup\n    res = sum(test_tup.count(ele) for ele in K)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, K):\n    # Initialize result dictionary\n    res = dict()\n    \n    # Iterate over the tuple and count occurrences of each element\n    for ele in test_tup:\n        if ele in res:\n            res[ele] += 1\n        else:\n            res[ele] = 1\n    \n    # Count the occurrences of the specified elements in K\n    count = 0\n    for ele in K:\n        if ele in res:\n            count += res[ele]\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef count_Occurrence(given_tuple, elements):\n    # Initialize a counter with the given_tuple\n    counter = Counter(given_tuple)\n    \n    # Initialize count to 0\n    count = 0\n    \n    # Iterate through each element in the elements list\n    for ele in elements:\n        # If the element is in the counter, add its count to the total count\n        if ele in counter:\n            count += counter[ele]\n    \n    # Return the total count of specified elements\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/451": {"dps": 74.91525423728814, "dps_norm": 85.0, "pass@1": 60.0, "profiled": [{"solution": "def remove_whitespaces(s):\n    # Use the join method to concatenate characters, excluding whitespaces\n    return ''.join(char for char in s if char != ' ')", "matching_cluster_idx": 2}, {"solution": "def remove_whitespaces(s):\n    # Replace all whitespace characters in the string with an empty string\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(str1):\n    # Remove all whitespaces from the given string using str.replace()\n    str2 = str1.replace(' ', '')\n    return str2", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input):\n    # Initialize an empty string to store the result\n    res = \"\"\n    # Iterate through each character in the input string\n    for i in input:\n        # Check if the character is not a whitespace\n        if i != \" \":\n            # Append the character to the result string\n            res += i\n    # Return the result string with all whitespaces removed\n    return res", "matching_cluster_idx": 2}, {"solution": "def remove_whitespaces(s):\n    # Replace all white spaces with an empty string\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Replace all whitespace characters in the string with an empty string\n    s = s.replace(\" \", \"\")\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    # Replace all whitespace characters in the string with an empty string\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    # Remove all whitespaces from the input string\n    input_str = input_str.replace(\" \", \"\")\n    return input_str", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    # Initialize an empty string to store the result\n    res = \"\"\n    # Iterate through each character in the input string\n    for ch in string:\n        # Check if the character is not a whitespace\n        if ch != ' ':\n            # Append the character to the result string\n            res += ch\n    # Return the result string without whitespaces\n    return res", "matching_cluster_idx": 2}, {"solution": "def remove_whitespaces(text):\n    # Initialize an empty string to store the result\n    res = ''\n    # Iterate through each character in the input string\n    for i in range(len(text)):\n        # Check if the current character is not a whitespace\n        if text[i] != ' ':\n            # Append non-whitespace characters to the result string\n            res += text[i]\n    # Return the resulting string without any whitespaces\n    return res", "matching_cluster_idx": 1}, {"solution": "def remove_whitespaces(test_str):\n    # Replace all whitespace characters (spaces, tabs, newlines) with an empty string\n    res = test_str.replace(\" \", \"\")\n    return res", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    # Using the translate method with str.maketrans to remove all whitespaces\n    return input_str.translate(str.maketrans('', '', ' '))", "matching_cluster_idx": 3}, {"solution": "def remove_whitespaces(str):\n    # Use the translate method with str.maketrans to remove all whitespaces\n    result = str.translate(str.maketrans('', '', ' ')) \n    return result", "matching_cluster_idx": 3}, {"solution": "def remove_whitespaces(str1):\n    # Use the join method to concatenate characters that are not whitespace\n    return \"\".join(char for char in str1 if char != \" \")", "matching_cluster_idx": 2}, {"solution": "def remove_whitespaces(test_str):\n    # Using the replace method to remove all whitespaces from the string\n    res = test_str.replace(\" \", \"\")\n    return res", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Use the replace method to remove all whitespace characters from the string\n    s = s.replace(' ', '')\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    # The replace method is used to substitute all occurrences of whitespace\n    # with an empty string, effectively removing them\n    return string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(str1):\n    # Use the replace method to remove all whitespaces from the string\n    result = str1.replace(\" \", \"\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Join all characters in the string except for whitespace\n    return ''.join([char for char in input_string if char != ' '])", "matching_cluster_idx": 2}, {"solution": "def remove_whitespaces(test_str):\n    # Remove all whitespaces from the input string using string's replace method\n    res = test_str.replace(\" \", \"\")\n    return res", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(test_list):\n    # Using list comprehension to reverse each string in the list\n    res = [word[::-1] for word in test_list]\n    return res", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(test_list):\n    # Using list comprehension to reverse each string in the list\n    res = [i[::-1] for i in test_list]\n    return res", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    # Using list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(test_list):\n    # Using list comprehension to reverse each string using slicing\n    res = [ele[::-1] for ele in test_list]\n    return res", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(color_list):\n    # Using list comprehension to reverse each string in the list\n    return [i[::-1] for i in color_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(colors):\n    # Using list comprehension and slicing to reverse each string in the list\n    result = [i[::-1] for i in colors]\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(color_list):\n    # Reverse each string in the list using list comprehension\n    reversed_list = [i[::-1] for i in color_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Using list comprehension to reverse each string in the list\n    return [i[::-1] for i in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Using list comprehension to reverse each string in the list\n    reverse_list = [s[::-1] for s in string_list]\n    return reverse_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string):\n    # Use list comprehension to reverse each string in the list\n    reversed_strings = [i[::-1] for i in string]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use list comprehension to reverse each string in the list\n    result = [string[::-1] for string in string_list]\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(colors):\n    # Reverse each string in the list using list comprehension\n    result = [i[::-1] for i in colors]\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use list comprehension to reverse each string in the list\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using list comprehension\n    result = [word[::-1] for word in string_list]\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(colors):\n    # Reverse each string in the list using list comprehension\n    return [x[::-1] for x in colors]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(stringList):\n    # Reverse each string in the list using a list comprehension\n    reversed_list = [item[::-1] for item in stringList]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    # Reverse each string in the list using list comprehension and slicing\n    reversed_list = [i[::-1] for i in str_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Initialize an empty list to store reversed strings\n    reversed_list = []\n    \n    # Iterate through each string in the input list\n    for s in string_list:\n        # Reverse the string and append to the reversed_list\n        reversed_list.append(s[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(colors):\n    # Using list comprehension to reverse each string in the list\n    return [i[::-1] for i in colors]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using list comprehension and slicing\n    reversed_strings = [s[::-1] for s in string_list]\n    return reversed_strings", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 66.25, "dps_norm": 87.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    # Use a list comprehension to iterate through each sublist\n    # and extract the first element using the index [0]\n    return [element[0] for element in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate over each sublist and extract the first element\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Use a list comprehension to iterate through each sublist\n    # and extract the first element using index 0\n    return [ele[0] for ele in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(test_list):\n    # Use list comprehension to iterate over each sublist in the main list\n    # and extract the first element of each sublist\n    res = [sublist[0] for sublist in test_list]\n    return res", "matching_cluster_idx": 4}, {"solution": "def Extract(test_list):\n    # Using list comprehension to iterate through each sublist and extract the first element\n    res = [sublist[0] for sublist in test_list]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(test_list):\n    # Using list comprehension to iterate through each sublist and get the first element\n    res = [sublist[0] for sublist in test_list]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(list):\n    # Use a list comprehension to iterate over each sublist and extract the first element\n    result = [sublist[0] for sublist in list]\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist and extract the first element\n    res = [sublist[0] for sublist in lst]\n    # Return the list of first elements\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element from each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(test_list):\n    # Using list comprehension to extract the first element from each sublist\n    res = [sublist[0] for sublist in test_list]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    # Using list comprehension to extract the first element from each sublist\n    res = [sublist[0] for sublist in lists]\n    return res", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    # Using list comprehension to extract the first element from each sublist\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(test_list):\n    # Using list comprehension to iterate through each sublist\n    # and extracting the first element using indexing\n    res = [sublist[0] for sublist in test_list]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to iterate through each sublist and extract the first element\n    first_elements = [sublist[0] for sublist in lst]\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to iterate through each sublist and extract the first element\n    res = [i[0] for i in lst]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist\n    # and extract the first element\n    res = [sublist[0] for sublist in lst]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Extract the first element of each sublist using list comprehension\n    res = [x[0] for x in lst]\n    return res", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist in the input list\n    # and extract the first element (index 0) of each sublist\n    result = [sublist[0] for sublist in lst]\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate over each sublist and extract the first element\n    result = [sublist[0] for sublist in lst]\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(test_list):\n    # Use list comprehension to extract the first element from each sublist\n    res = [sub[0] for sub in test_list]\n    return res", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 68.5609756097561, "dps_norm": 70.71428571428571, "pass@1": 98.0, "profiled": [{"solution": "def replace_char(string, char1, char2):\n    # Replace all occurrences of char1 with char2 in the string\n    new_string = string.replace(char1, char2)\n    return new_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    string = string.replace(old_char, new_char)\n    return string", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, old, new):\n    # Iterate over the indices of the string\n    for i in range(len(str)):\n        # Check if the current character matches the old character\n        if str[i] == old:\n            # Replace the old character with the new character\n            str = str[:i] + new + str[i+1:]\n    # Return the modified string\n    return str", "matching_cluster_idx": -1}, {"solution": "def replace_char(str, old, new):\n    # Replace occurrences of 'old' character with 'new' character in the string\n    str = str.replace(old, new)\n    return str", "matching_cluster_idx": 6}, {"solution": "def replace_char(str1, char1, char2):\n    # Replace occurrences of char1 with char2 in the string str1\n    result = str1.replace(char1, char2)\n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in the string\n    new_string = string.replace(old_char, new_char)\n    return new_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(st, p, r):\n    # Initialize an empty string to store the result\n    str1 = \"\"\n    # Iterate through each character in the string\n    for i in range(len(st)):\n        # Check if the current character matches the one to be replaced\n        if st[i] == p:\n            # Append the replacement character to the result string\n            str1 += r\n        else:\n            # Append the current character to the result string\n            str1 += st[i]\n    # Return the modified string\n    return str1", "matching_cluster_idx": 0}, {"solution": "def replace_char(str1, char1, char2):\n    # Replace occurrences of char1 with char2 in str1\n    res = str1.replace(char1, char2)\n    return res", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, old_char, new_char):\n    # Replace all occurrences of old_char with new_char in the string\n    for i in range(len(str)):\n        if str[i] == old_char:\n            str = str[:i] + new_char + str[i+1:]\n    return str", "matching_cluster_idx": -1}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace old_char with new_char in the given string\n    string = string.replace(old_char, new_char)\n    return string", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Check if the old character is present in the string\n    if old_char not in string:\n        return string\n    \n    # Initialize an empty string for the result\n    res = ''\n    \n    # Iterate through each character in the string\n    for char in string:\n        # Replace the old character with the new character\n        res += char if char != old_char else new_char\n    \n    return res", "matching_cluster_idx": 2}, {"solution": "def replace_char(s, old, new):\n    # Initialize an empty string to store the result\n    final = \"\"\n    \n    # Iterate through each character in the string\n    for i in s:\n        # If the character matches the old character, replace it with the new character\n        if i == old:\n            final = final + new\n        else:\n            # Otherwise, keep the character as is\n            final = final + i\n    \n    # Return the modified string\n    return final", "matching_cluster_idx": 2}, {"solution": "def replace_char(str, a, b):\n    # Replace all occurrences of 'a' with 'b' in the string\n    str = str.replace(a, b)\n    # Return the modified string\n    return str", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, oldchar, newchar):\n    # Replace occurrences of oldchar with newchar in the string\n    for i in range(len(str)):\n        if str[i] == oldchar:\n            str = str[:i] + newchar + str[i+1:]\n    return str", "matching_cluster_idx": -1}, {"solution": "def replace_char(str1, old_char, new_char):\n    # Replace occurrences of old_char with new_char in str1\n    str2 = str1.replace(old_char, new_char)\n    return str2", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Create a new string where all occurrences of old_char are replaced with new_char\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, c1, c2):\n    # Replace each occurrence of c1 with c2 in the string s\n    s = s.replace(c1, c2)\n    return s", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, old, new):\n    # Count the number of occurrences of the old character\n    count = 0\n    for i in range(len(str)):\n        # Check if the current character is the old character\n        if str[i] == old:\n            count += 1\n\n    # If the old character does not exist in the string, return the original string\n    if count == 0:\n        return str\n\n    # Convert the string to a character array for easy manipulation\n    str = list(str)\n\n    # Replace all occurrences of the old character with the new character\n    for i in range(len(str)):\n        if str[i] == old:\n            str[i] = new\n\n    # Convert the character array back to a string\n    return ''.join(str)", "matching_cluster_idx": 0}, {"solution": "def replace_char(str1, old_char, new_char):\n    # Replace occurrences of old_char with new_char in str1\n    str1 = str1.replace(old_char, new_char)\n    return str1", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 91.89597315436242, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(nums):\n    # Calculate the sum of the maximum and minimum values in the array\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(input_list):\n    # Initialize max with the first element of the list\n    maximum = input_list[0]\n    # Initialize min with the first element of the list\n    minimum = input_list[0]\n    \n    # Iterate through the list starting from the second element\n    for i in input_list[1:]:\n        # Update maximum if the current element is greater\n        if i > maximum:\n            maximum = i\n        # Update minimum if the current element is smaller\n        elif i < minimum:\n            minimum = i\n    \n    # Return the sum of the maximum and minimum values\n    return maximum + minimum", "matching_cluster_idx": 3}, {"solution": "def big_sum(nums):\n    # Sort the array to access the smallest and largest values easily\n    nums.sort()\n    # Return the sum of the smallest and largest values\n    return nums[0] + nums[-1]", "matching_cluster_idx": 1}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the largest and smallest values in the array\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    # Calculate the sum of the largest and smallest numbers in the list\n    result = max(lst) + min(lst)\n    return result", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest value in the array\n    min_value = min(arr)\n    # Find the largest value in the array\n    max_value = max(arr)\n    # Calculate the sum of the smallest and largest values\n    total_sum = min_value + max_value\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Calculate the sum of the largest and smallest values in the array\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the largest and smallest numbers in the array\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the largest and smallest numbers in the list\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Calculate the sum of the maximum and minimum values in the array\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Calculate the sum of the maximum and minimum values in the array\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the maximum and minimum values in the list\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Find the sum of the largest and smallest elements in the list\n    return (max(nums) + min(nums))", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array has two or more elements\n    if len(arr) >= 2:\n        # Calculate the sum of the largest and smallest elements\n        return (max(arr) + min(arr))\n    else:\n        # If the array has fewer than two elements, return None\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the maximum and minimum values in the list\n    result = max(nums) + min(nums)\n    return result", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the maximum and minimum values in the list\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Find the minimum and maximum elements in the array\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    # Find the smallest and largest numbers in the array\n    smallest_number = min(numbers)\n    largest_number = max(numbers)\n    # Return the sum of the smallest and largest number\n    return smallest_number + largest_number", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    # Calculate the sum of the maximum and minimum values in the array\n    return max(nums) + min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 92.23880597014926, "dps_norm": 98.0, "pass@1": 64.0, "profiled": [{"solution": "def is_lower(text):\n    # Check if all characters in the text are lowercase\n    if text == text.lower():\n        return text\n    else:\n        # Convert the text to lowercase if not already\n        return text.lower()", "matching_cluster_idx": 3}, {"solution": "def is_lower(string):\n    # Convert the string to lowercase using the lower() method\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Using the built-in lower() method of string to convert it to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(word):\n    # Use the lower() method to convert all characters in the string to lowercase\n    return word.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    # Convert the string to lower case using the built-in lower() method\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(a):\n    # Check if all characters in the string are in lowercase\n    if a.islower():\n        return a\n    # If not, convert the string to lowercase and return\n    else:\n        return a.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    s = s.lower()\n    return s", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    # Use the lower() method to convert the string to lower case\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str1):\n    # Check if all characters in the string are lower case\n    if str1.islower():\n        return str1\n    else:\n        # Convert the string to lower case if not already\n        return str1.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n    # Check if all characters in the text are lowercase\n    if text.islower():\n        return text\n    else:\n        # Return the text converted to lowercase\n        return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(a):\n    # Use the built-in lower() method to convert the string to lowercase\n    return a.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    # Convert the given string to lower case\n    str = str.lower()\n    return str", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Use the built-in lower() method to convert the string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(st):\n    # Initialize a flag to track if the string is all lowercase\n    flag = 0\n    # Iterate through each character in the string\n    for i in range(len(st)):\n        # Check if the current character is uppercase\n        if st[i] >= 'A' and st[i] <= 'Z':\n            # Set the flag to 1 if an uppercase character is found\n            flag = 1\n            break\n    # If no uppercase characters are found, return the original string\n    if flag == 0:\n        return st\n    else:\n        # Convert the string to lowercase if an uppercase character is found\n        return st.lower()", "matching_cluster_idx": 3}, {"solution": "def is_lower(str):\n    # Use the str.lower() method to convert the string to lowercase\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    # Use the lower() method to convert the string to lowercase\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(a):\n    # Use the lower() method to convert the string to lower case\n    return a.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    # Use the lower() method to convert the string to lower case\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    # Convert the given string to lower case and return\n    return string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 81.12021857923497, "dps_norm": 78.63636363636363, "pass@1": 36.0, "profiled": [{"solution": "import re\ndef extract_values(str1):\n    # Use regular expression to find all values enclosed in quotation marks\n    return re.findall(r'\"(.*?)\"', str1)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all values within double quotes\n    results = re.findall(r'\\\"(.*?)\\\"', text)\n    return results", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all occurrences of text within quotation marks\n    result = re.findall(r'\"(.*?)\"', s)\n    return result", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all sequences of characters within quotation marks\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Using regex to find all occurrences of text enclosed in double quotes\n    values = re.findall(r'\"([^\"]*)\"', string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings between quotation marks\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find values between quotation marks\n    values = re.findall(r'\"(.*?)\"', string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all values enclosed in quotation marks\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 8}, {"solution": "def extract_values(text):\n    result = []\n    start_index = 0\n    \n    # Iterate over the string to find values between quotation marks\n    while start_index < len(text):\n        if text[start_index] == '\"':\n            start_index += 1  # Skip the opening quotation mark\n            end_index = text.find('\"', start_index)\n            if end_index != -1:\n                # Extract the value between quotation marks\n                value = text[start_index:end_index]\n                result.append(value)\n                start_index = end_index + 1  # Move to the next character after closing quotation mark\n            else:\n                break  # No closing quotation mark found, stop the loop\n        else:\n            start_index += 1  # Move to the next character if not a quotation mark\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all words surrounded by double quotes\n    words = re.findall(r'\\\"(.*?)\\\"', text)\n    return words", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    result = re.findall(r'\"(.*?)\"', s)\n    return result", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    This function extracts values enclosed in quotation marks from a given string.\n    \n    Args:\n    s (str): The input string from which values enclosed in quotation marks are to be extracted.\n    \n    Returns:\n    list: A list of strings that were enclosed in quotation marks in the input string.\n    \"\"\"\n    # Using regular expression to find all substrings enclosed in quotation marks\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(data):\n    # Use regular expression to find all occurrences of text enclosed in double quotes\n    result = re.findall(r'\"(.*?)\"', data)\n    return result", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(items):\n    # Use regular expression to find all sequences that are enclosed in double quotes\n    values = re.findall(r'\"(.*?)\"', items)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Using regular expression to find values between quotation marks\n    match = re.findall(r'\"(.*?)\"', text)\n    return match", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find values enclosed in double quotes\n    results = re.findall(r'\"(.*?)\"', text)\n    return results", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(my_string):\n    # Using regular expression to find all occurrences of values enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', my_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all values within double quotation marks\n    return re.findall(r'\\\"(.*?)\\\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Using regular expression to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\\\"(.*?)\\\"', s)\n    # Returning the list of matched values\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(sentence):\n    # Use regular expression to find all occurrences of text within double quotation marks\n    result = re.findall(r'\\\"(.*?)\\\"', sentence)\n    return result", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 3.0, "profiled": []}, "Mbpp/578": {"dps": 77.71428571428571, "dps_norm": 68.63636363636364, "pass@1": 97.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    # Combine all three lists into one\n    list_all = list1 + list2 + list3\n    # Create an empty list to store the result\n    lst = []\n    # Loop through each index in the combined list\n    for i in range(len(list_all) // 3):\n        # Append elements from each list at the current index to the result list\n        lst.append(list1[i])\n        lst.append(list2[i])\n        lst.append(list3[i])\n    return lst", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(lst1, lst2, lst3):\n    # Create a flat list by interleaving elements from the three input lists\n    flat_list = [item for sublist in zip(lst1, lst2, lst3) for item in sublist]\n    return flat_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    # Iterate over the range of the length of the lists (assuming they are of the same length)\n    for i in range(len(list1)):\n        # Append elements from list1, list2, and list3 in order to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    # Return the interleaved list\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(arr1, arr2, arr3):\n    n = len(arr1)  # Determine the length of the input lists\n    inter_list = []  # Initialize an empty list to store the interleaved elements\n    # Iterate through the length of the lists\n    for i in range(n):\n        inter_list.append(arr1[i])  # Append element from the first list\n        inter_list.append(arr2[i])  # Append element from the second list\n        inter_list.append(arr3[i])  # Append element from the third list\n    return inter_list  # Return the interleaved list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(nums1, nums2, nums3):\n    # Initialize an empty list to store the result\n    res = []\n    \n    # Iterate over the length of the lists using the range of the first list's length\n    for i in range(len(nums1)):\n        # Append elements from each list to the result list one by one\n        res.append(nums1[i])\n        res.append(nums2[i])\n        res.append(nums3[i])\n    \n    # Return the interleaved list\n    return res", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []  # Initialize an empty list to store the interleaved result\n    for i in range(len(list1)):\n        # Append elements from each list in the current iteration to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result  # Return the interleaved list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Create a new list to store the interleaved elements\n    interleaved_list = []\n    \n    # Iterate through the lists using zip to combine them\n    for a, b, c in zip(list1, list2, list3):\n        # Append each element from the three lists to the interleaved list\n        interleaved_list.append(a)\n        interleaved_list.append(b)\n        interleaved_list.append(c)\n    \n    # Return the interleaved list\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Use zip to iterate over all three lists simultaneously\n    # Extend each element from the lists into a single flat list\n    result = [i for lists in zip(list1, list2, list3) for i in lists]\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave elements from three lists using list comprehension\n    result = [item for triplet in zip(list1, list2, list3) for item in triplet]\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Create an empty list to store the interleaved result\n    result = []\n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index to the result list\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "import itertools\ndef interleave_lists(list1, list2, list3):\n    # Using itertools.chain.from_iterable to interleave the lists\n    # Then converting the iterator to a list before returning\n    return list(itertools.chain.from_iterable(zip(list1, list2, list3)))", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(a, b, c):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    \n    # Determine the length of the lists (assuming all lists are of the same length)\n    length = len(a)\n    \n    # Iterate through the indices of the lists\n    for i in range(length):\n        # Append the i-th element from each list to the result list\n        result.append(a[i])\n        result.append(b[i])\n        result.append(c[i])\n    \n    # Return the interleaved list\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists have the same length\n    if len(list1) == len(list2) == len(list3):\n        # Use zip to combine lists elementwise and flatten the result using sum with a list comprehension\n        return [item for sublist in zip(list1, list2, list3) for item in sublist]\n    else:\n        # If lists are not of the same length, raise a ValueError\n        raise ValueError(\"All lists must have the same length\")", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Combine the three lists using list comprehension\n    result = [item for sublist in zip(list1, list2, list3) for item in sublist]\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(nums1, nums2, nums3):\n    # Initialize an empty list to store the interleaved elements\n    result = []\n    \n    # Determine the length of the lists\n    n = len(nums1)\n    \n    # Iterate over the indices of the lists\n    for i in range(n):\n        # Append elements from each list to the result list\n        result.append(nums1[i])\n        result.append(nums2[i])\n        result.append(nums3[i])\n    \n    # Return the interleaved list\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved results\n    inter_list = []\n    \n    # Iterate over the range of the length of any of the lists (assuming they are the same length)\n    for i in range(len(list1)):\n        # Append the i-th element from each list to the inter_list\n        inter_list.extend([list1[i], list2[i], list3[i]])\n    \n    # Return the interleaved list\n    return inter_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(A, B, C):\n    # Using list comprehension to interleave elements from A, B, and C\n    res = [ele for tup in zip(A, B, C) for ele in tup]\n    return res", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(a, b, c):\n    # Use list comprehension to interleave elements from the three lists\n    return [j for i in zip(a, b, c) for j in i]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(A, B, C):\n    # Interleave elements from three lists A, B, and C\n    interleaved_list = [item for sublist in zip(A, B, C) for item in sublist]\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(A, B, C):\n    # Using list comprehension to interleave elements from all three lists\n    res = [j for i in zip(A, B, C) for j in i]\n    return res", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 92.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    # Split the array at the nth element and concatenate the second part with the first part\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(Arr, N):\n    # Create a new list that starts from index N to the end of the original list\n    A1 = Arr[N:]\n    # Concatenate the new list with the part from the start of the original list to index N\n    A2 = A1 + Arr[0:N]\n    # Return the concatenated list\n    return A2", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n): \n    # Split the list at the nth element and store the second part\n    sec_part = arr[n:] \n    # Get the first part of the list up to the nth element\n    first_part = arr[:n] \n    # Concatenate the second part with the first part\n    return sec_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, N):\n    # Split the list into two parts\n    first_part = lst[:N]\n    second_part = lst[N:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    # Return the concatenated list\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(A, N):\n    # Use slicing to split the array at index N and swap the parts\n    A = A[N:] + A[:N]\n    return A", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the list at the Nth element and rearrange\n    return arr[N:] + arr[:N]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(input_list, N):\n    # Slice the list from the Nth element to the end\n    left_part = input_list[N:]\n    # Slice the list from the beginning to the Nth element\n    right_part = input_list[:N]\n    # Concatenate the left part with the right part\n    output_list = left_part + right_part\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the array at the Nth element\n    split_arr = arr[N:] + arr[:N]\n    return split_arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Slicing the array to get the part after the nth element and the part before the nth element\n    # Then concatenating these two parts in reversed order\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the list into two parts at the Nth element\n    res = arr[N:] + arr[:N]\n    return res", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the array at index N and concatenate the two parts\n    return arr[N:] + arr[:N]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the array at the N-th element and concatenate the two parts\n    result = arr[N:] + arr[:N]\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    part1 = arr[:n]\n    part2 = arr[n:]\n    # Concatenate the second part with the first part\n    return part2 + part1", "matching_cluster_idx": 6}, {"solution": "def split_Arr(A, N):\n    # Split the list at the nth element\n    B = A[N:] + A[:N]\n    return B", "matching_cluster_idx": 6}, {"solution": "def split_Arr(test_list, N):\n    # Splitting the list at the Nth element\n    res = test_list[N:] + test_list[:N]\n    return res", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Splitting the array at index N\n    part = arr[:N]\n    # Adding the first part to the end of the array\n    arr = arr[N:] + part\n    return arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(array, N):\n    # Slice the array from the Nth element to the end\n    A = array[N:]\n    # Slice the array from the start to the Nth element\n    B = array[:N]\n    # Concatenate the slices and return the result\n    result = A + B\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(Arr, N):\n    # Split the array at the Nth element\n    return Arr[N:] + Arr[:N]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the array into two parts at the Nth element\n    a1 = arr[N:]  # Elements from N to the end of the array\n    a2 = arr[:N]  # Elements from the start of the array to N\n    # Concatenate the second part with the first part\n    a3 = a1 + a2\n    return a3", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, N):\n    # Split the array at the Nth element and concatenate the parts\n    return arr[N:] + arr[:N]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 73.64864864864865, "dps_norm": 92.5, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple and return it\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Use the tuple() constructor to convert the list to a tuple\n    res = tuple(test_list)\n    # Return the resulting tuple\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple using the tuple() function\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list1):\n    # Convert the list to a tuple\n    tuple1 = tuple(list1)\n    return tuple1", "matching_cluster_idx": 2}, {"solution": "def list_tuple(test_list):\n    # Converting the list to a tuple using the tuple() function\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(items):\n    # Use the tuple() function to convert the list to a tuple\n    t = tuple(items)\n    # Return the resulting tuple\n    return t", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple and return it\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def list_tuple(test_list):\n    # Converting the list to a tuple using the tuple() function\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(l1):\n    # Convert the list to a tuple and return it\n    t1 = tuple(l1)\n    return t1", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple and return the result\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the input list to a tuple and return\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert list to tuple using tuple() function\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef list_tuple(x: List[int]) -> Tuple[int]:\n    # Convert the list 'x' into a tuple and return it\n    return tuple(x)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple using the tuple() function\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple\n    res = tuple(test_list)\n    # Return the resulting tuple\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple using tuple() and return the result\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(items):\n    # Convert the list to a tuple and return the result\n    return tuple(items)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(test_list):\n    # Convert the list to a tuple using the tuple() function\n    res = tuple(test_list)\n    return res", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lis):\n    # Convert the list to a tuple and return it\n    return tuple(lis)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(items):\n    # Convert the list to a tuple and return it\n    return tuple(items)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 92.33944954128441, "dps_norm": 96.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    result = max(nums) - min(nums)\n    return result", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    # Return the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Initialize the minimum value to the first element of the list\n    min = nums[0]\n    \n    # Initialize the maximum value to the first element of the list\n    max = nums[0]\n    \n    # Iterate through the list starting from the second element\n    for x in nums[1:]:\n        # Update the minimum value if the current element is smaller\n        min = min if min < x else x\n        \n        # Update the maximum value if the current element is larger\n        max = max if max > x else x\n    \n    # Return the difference between the maximum and minimum values\n    return max - min", "matching_cluster_idx": 3}, {"solution": "def big_diff(nums):\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Return the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Check if the list is empty\n    if len(nums) == 0:\n        return 0\n    \n    # Initialize the minimum and maximum elements with the first element of the list\n    min_element = nums[0]\n    max_element = nums[0]\n    \n    # Iterate through the list starting from the second element\n    for i in range(1, len(nums)):\n        # Update the minimum and maximum elements\n        if nums[i] < min_element:\n            min_element = nums[i]\n        if nums[i] > max_element:\n            max_element = nums[i]\n    \n    # Return the difference between the maximum and minimum elements\n    return max_element - min_element", "matching_cluster_idx": 3}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the difference between the largest and smallest numbers in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 51.73333333333334, "dps_norm": 48.0, "pass@1": 10.0, "profiled": [{"solution": "def factorial(n):\n    # Base case: factorial of 0 or 1\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    # Iterative calculation of factorial\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef binomialCoeff(n, k):\n    # Calculate binomial coefficient using factorial\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef sum_Of_product(n):\n    sum1 = 0\n    # Calculate the sum of the product of consecutive binomial coefficients\n    for i in range(1, n + 1):\n        sum1 = sum1 + (binomialCoeff(n, i) * binomialCoeff(n, i - 1))\n    return sum1", "matching_cluster_idx": 0}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    # Iterate through the range from 0 to n\n    for i in range(n + 1):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, i) * comb(n, i + 1)\n        # Add the product to the total sum\n        total_sum += product\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(n):\n    # Initialize the result to 0\n    result = 0\n    \n    # Loop through the range from 0 to n-1\n    for k in range(n):\n        # Calculate the product of two binomial coefficients and add it to the result\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    \n    return result\ndef binomial_coefficient(n, k):\n    # Calculate binomial coefficient using a nested loop\n    res = 1\n    \n    # If k is greater than n-k, then it is more efficient to calculate C(n, n-k)\n    if (k > n - k):\n        k = n - k\n    \n    # Calculate the value of binomial coefficient C(n, k)\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n    \n    return res", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    res = 1  # Initialize result\n    # Update result using an efficient formula\n    if k > n - k:\n        k = n - k\n    for i in range(k):\n        res *= (n - i)\n        res //= (i + 1)\n    return res\ndef sum_Of_product(n):\n    if n < 1:\n        return 0\n    sum = 0\n    # Loop through all possible pairs of consecutive binomial coefficients\n    for i in range(1, n + 1):\n        sum += (binomial_coefficient(n, i) * binomial_coefficient(n, i - 1))\n    return sum", "matching_cluster_idx": 4}, {"solution": "from math import factorial\ndef sum_Of_product(N):\n    # Initialize the result variable to store the sum of products\n    result = 0\n    \n    # Iterate through each number from 0 to N-1\n    for i in range(0, N):\n        # Calculate the product of consecutive binomial coefficients using the factorial function\n        binom_prod = (factorial(N) // (factorial(i) * factorial(N - i))) * (factorial(N) // (factorial(i + 1) * factorial(N - i - 1)))\n        \n        # Add the product to the result\n        result += binom_prod\n    \n    # Return the computed result\n    return result", "matching_cluster_idx": 2}, {"solution": "from math import comb\ndef sum_Of_product(N):\n    # Initialize the sum to 0\n    sum = 0\n    \n    # Iterate through the range from 0 to N-1\n    for i in range(N):\n        # Calculate the product of binomial coefficients for the current and next term\n        sum += comb(N, i) * comb(N, i + 1)\n    \n    # Return the final sum of products\n    return sum", "matching_cluster_idx": 5}, {"solution": "def sum_Of_product(N):\n    # Initialize the result variable to store the sum of products\n    result = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for r in range(1, N + 1):\n        result += (binomial_coefficient(N, r) * binomial_coefficient(N, r - 1))\n    \n    return result\ndef binomial_coefficient(n, k):\n    # Helper function to calculate the binomial coefficient C(n, k)\n    result = 1\n    \n    # If k is greater than n-k, use symmetry property C(n, k) = C(n, n-k)\n    if k > n - k:\n        k = n - k\n    \n    # Calculate the binomial coefficient using the formula C(n, k) = n! / (k! * (n-k)!)\n    for i in range(k):\n        result *= (n - i)\n        result //= (i + 1)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def nCr(n, r):\n    # Initialize result\n    res = 1\n\n    # Since C(n, r) = C(n, n-r)\n    if r > n - r:\n        r = n - r\n\n    # Calculate value of [n*(n-1)*---*(n-r+1)] / [r*(r-1)*---*1]\n    for i in range(r):\n        res *= (n - i)\n        res //= (i + 1)\n\n    return res\ndef sum_Of_product(n):\n    # Calculate the sum of product of consecutive binomial coefficients\n    res = 0\n    for r in range(1, n + 1):\n        res += (nCr(n, r) * nCr(n, r - 1))\n    return res", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum of products\n    sum = 0\n    \n    # Iterate over the range from 0 to n (inclusive)\n    for i in range(0, n + 1):\n        # Calculate the product of consecutive binomial coefficients\n        # and add it to the sum\n        sum += comb(n, i) * comb(n, i + 1)\n    \n    # Return the final sum of products\n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0  # Initialize the sum to zero\n    \n    # Iterate over each possible value of k from 1 to n\n    for k in range(1, n + 1):\n        # Calculate the product of the binomial coefficients for two consecutive k values\n        # and add it to the total sum\n        total_sum += comb(n, k - 1) * comb(n, k)\n    \n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 13.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate both arrays\n    combined = arr1 + arr2\n    \n    # Sort the concatenated array\n    combined.sort()\n    \n    # Return the kth element (index k-1 because list indices are 0-based)\n    return combined[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine both arrays\n    result = arr1 + arr2\n    # Sort the combined array\n    result.sort()\n    # Return the kth element from the sorted array\n    return result[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Merge nums1 and nums2 into a sorted list\n    merged = sorted(nums1 + nums2)\n    # Return the k-th element in the merged list (adjusted for 0-based indexing)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(A, B, k):\n    # Merge the two sorted arrays into one sorted array\n    merged = sorted(A + B)\n    \n    # Return the kth element from the merged sorted array\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate the two sorted arrays\n    combined = sorted(arr1 + arr2)\n    # Return the k-1 element (since list indices start at 0)\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate both arrays and sort them\n    result = sorted(arr1 + arr2)\n    # Return the k-1 index element (since indexing starts from 0)\n    return result[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Join the two arrays\n    arr = arr1 + arr2\n    \n    # Sort the combined array\n    arr.sort()\n    \n    # Return the kth element (adjust index by subtracting 1)\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate the two arrays\n    merged = arr1 + arr2\n    \n    # Sort the merged array\n    merged.sort()\n    \n    # Return the kth element (0-based index)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Combine both lists\n    nums3 = nums1 + nums2\n    # Sort the combined list\n    nums3.sort()\n    # Return the kth element (1-based index, hence nums3[k-1])\n    return nums3[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge both arrays\n    merged_array = arr1 + arr2\n    # Sort the merged array\n    merged_array.sort()\n    # Return the kth element (adjust for 0-based indexing)\n    return merged_array[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Merge the two sorted arrays and create a new list\n    result = sorted(nums1 + nums2)\n    # Return the kth element from the merged list\n    return result[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine both arrays and sort them\n    combined_sorted = sorted(arr1 + arr2)\n    \n    # Return the k-th element (1-based index), subtract 1 for 0-based index\n    return combined_sorted[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged_arr = sorted(arr1 + arr2)\n    \n    # Return the kth element, adjusting for zero-based indexing\n    return merged_arr[k - 1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 85.68181818181819, "dps_norm": 97.0, "pass@1": 25.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words, reverse the list, and join it back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words using split(), reverse the list using reverse(), and then join them back with join()\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    # Split the input string into words\n    words = input_string.split()\n    # Reverse the list of words and join them back into a string\n    reversed_string = ' '.join(reversed(words))\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the reversed list of words back into a string\n    reversed_string = ' '.join(words)\n    # Return the resulting string\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "import sys\ndef reverse_words(s):\n    # Splitting the string into words and reversing the order\n    words = s.split()\n    reversed_words = words[::-1]\n    # Joining the reversed words back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed words back into a string\n    reversed_string = ' '.join(words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words and reverse the order\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the input string into words, reverse the list of words, and then join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the input string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    words = words[::-1]\n    \n    # Join the reversed words to form the output string\n    s = ' '.join(words)\n    \n    return s", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 66.85736079328757, "dps_norm": 73.6842105263158, "pass@1": 19.0, "profiled": [{"solution": "def remove_kth_element(mylist, K):\n    # Calculate the index to remove\n    mylist.pop(K - 1)\n    return mylist", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    # Initialize an empty list to store the result\n    temp_list = []\n    # Iterate through the original list\n    for i in range(len(lst)):\n        # Check if the current index is not equal to the k-1 index\n        if i != k-1:\n            # Append the current element to the result list\n            temp_list.append(lst[i])\n    # Return the result list without the k'th element\n    return temp_list", "matching_cluster_idx": 0}, {"solution": "def remove_kth_element(lst, k):\n    # Check if k is within the valid range\n    if k <= 0 or k > len(lst):\n        raise ValueError(\"k must be in the range 1 to the length of the list\")\n    \n    # Create a new list excluding the k'th element\n    new_list = lst[:k-1] + lst[k:]\n    return new_list", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(mylist, k):\n    # Remove the k-th element from the list\n    # k is 0-based index, so k-1 is used\n    del mylist[k-1]\n    return mylist", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(nums, k):\n    # Remove the k'th element from the list (index k-1)\n    del nums[k - 1]\n    # Return the modified list\n    return nums", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(list1, k):\n    # Initialize a temporary list to store elements except the k-th one\n    temp = []\n    for i in range(len(list1)):\n        # Check if the current index is not equal to k-1 (since list index is 0-based)\n        if i != (k - 1):\n            temp.append(list1[i])\n    return temp", "matching_cluster_idx": 0}, {"solution": "def remove_kth_element(numbers, k):\n    # Create a new list that is a copy of the original list\n    new_list = numbers[:]\n    \n    # Remove the k'th element from the new list (Python uses 0-based indexing)\n    del new_list[k - 1]\n    \n    # Return the modified list\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(l1, K):\n    # Remove the K'th element from the list (1-based index)\n    l1.pop(K - 1)\n    # Return the modified list\n    return l1", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(test_list, K):\n    # Iterate over the list and use list comprehension to exclude the k'th element\n    res = [ele for ind, ele in enumerate(test_list) if ind != K - 1]\n    return res", "matching_cluster_idx": 1}, {"solution": "def remove_kth_element(input_list, k):\n    # Create a copy of the input list to avoid modifying the original list\n    result = input_list[:]\n    \n    # Convert the k index to be zero-based since list indices in Python start at 0\n    k -= 1\n    \n    # Check if the k index is within the bounds of the list\n    if k >= 0 and k < len(result):\n        # Remove the k'th element from the list\n        del result[k]\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_kth_element(nums, k):\n    # Create a copy of the list using slicing\n    result = nums[:]\n    # Remove the k'th element by deleting it at index k-1 (since Python indices start at 0)\n    del result[k - 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(nums, k):\n    # Remove the element at the k-1 index\n    nums.pop(k - 1)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(lst, k):\n    # Remove the element at index k-1 from the list\n    del lst[k-1]\n    # Return the modified list\n    return lst", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(nums, k):\n    # Remove the k'th element from the list\n    del nums[k-1]\n    return nums", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(nums, k):\n    # Calculate the index of the element to remove\n    index_to_remove = k - 1  # Adjusting index to zero-based\n    \n    # Remove the k'th element\n    nums.pop(index_to_remove)\n    \n    # Return the modified list\n    return nums", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(test_list, K):\n    # Check if the value of K is greater than the length of the list\n    if K > len(test_list) or K < 1:\n        return test_list\n    \n    # Initialize an empty list to store the modified elements\n    res = []\n    \n    # Iterate over the list and append elements to the result list\n    for idx in range(len(test_list)):\n        if idx != K - 1:  # Skip the K'th element\n            res.append(test_list[idx])\n    \n    return res", "matching_cluster_idx": 0}, {"solution": "def remove_kth_element(lis, k):\n    # Remove the element at the index k-1 (since index is 0-based)\n    del lis[k-1]\n    return lis", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(nums, k):\n    # Remove the element at the (k-1)th index from the list\n    nums.pop(k - 1)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(test_list, K):\n    # Use list comprehension to iterate through the list and include only elements not at the K-1 index\n    res = [ele for idx, ele in enumerate(test_list) if idx != K - 1]\n    return res", "matching_cluster_idx": 1}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    # Use a generator expression to iterate through each row of the matrix\n    # and extract the nth element from each row, then find the maximum of those elements.\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(lst, n):\n    # Extract the nth column from each sublist and find the maximum value\n    max_val = max(sublist[n] for sublist in lst)\n    return max_val", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(list1, n):\n    # Extracts the nth column from the list of lists and returns the maximum value\n    return max(i[n] for i in list1)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Use a generator expression to iterate over the nth column and find the maximum value\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(lst, N):\n    # Use a generator expression to extract the N-th element from each sublist in the matrix\n    # and find the maximum value using the max() function\n    return max(row[N] for row in lst)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef max_of_nth(matrix: List[List[int]], n: int) -> int:\n    # Use a generator expression to iterate through the nth column and find the maximum value\n    return max(x[n] for x in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the nth column from the matrix using list comprehension\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(lst, n):\n    # Extract the nth column from the list of lists\n    nth_column = [x[n] for x in lst]\n    # Return the maximum value from the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Initialize a list to store the nth elements of each row\n    nth_elements = []\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Check if the row has enough elements to access the nth column\n        if len(row) > n:\n            # Append the nth element of the row to the list\n            nth_elements.append(row[n])\n    \n    # Return the maximum value found in the list of nth elements\n    return max(nth_elements)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(lst, n):\n    # Use a generator expression to extract the nth element from each sublist and find the maximum\n    return max(item[n] for item in lst)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is empty or if n is out of the valid column range\n    if not matrix or n >= len(matrix[0]):\n        return None\n    # Find the maximum element in the nth column using a generator expression\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Use the map function to extract the nth element from each row in the matrix\n    # Use max function to find the maximum value among the nth elements\n    return max(map(lambda x: x[n], matrix))", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(arr, n):\n    # Extract the n-th column from the matrix\n    nth_column = [row[n] for row in arr]\n    # Return the maximum value from the n-th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Initialize the maximum value to the first element of the nth column\n    max_value = matrix[0][n]\n    \n    # Iterate through each row of the matrix\n    for i in range(len(matrix)):\n        # Update the maximum value if the current element is greater\n        if matrix[i][n] > max_value:\n            max_value = matrix[i][n]\n    \n    # Return the maximum value found in the nth column\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Use list comprehension to extract the nth element from each row and then find the maximum\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(input_list, N):\n    # Extract the N'th element from each sublist using list comprehension\n    return max([sub_list[N] for sub_list in input_list])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Use a generator expression to extract the nth element from each sublist and find the maximum\n    return max(sublist[n] for sublist in matrix if n < len(sublist))", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(lst, n):\n    # Initialize the maximum value to negative infinity\n    max_val = float('-inf')\n    \n    # Iterate through each row in the list\n    for x in lst:\n        # Check if the current column has a value greater than the max_val\n        if len(x) > n and x[n] > max_val:\n            # Update the maximum value\n            max_val = x[n]\n    \n    # Return the maximum value found\n    return max_val", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the nth column from each row and find the maximum value\n    return max(row[n] for row in matrix if len(row) > n)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the nth column from the matrix\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value from the nth column\n    return max(nth_column)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 93.33333333333331, "dps_norm": 96.25, "pass@1": 52.0, "profiled": [{"solution": "def replace_spaces(input_str):\n    # Check if the input string contains any spaces\n    if ' ' in input_str:\n        # Replace spaces with underscores if they exist\n        return input_str.replace(' ', '_')\n    else:\n        # Replace underscores with spaces if no spaces exist\n        return input_str.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(test_str):\n    # Check if the string contains underscores\n    if '_' in test_str:\n        # Replace underscores with spaces\n        res = test_str.replace('_', ' ')\n    else:\n        # Replace spaces with underscores\n        res = test_str.replace(' ', '_')\n    return res", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    # Check if the string contains spaces, if so, replace them with underscores\n    if ' ' in s:\n        return s.replace(' ', '_')\n    # If no spaces are found, replace underscores with spaces\n    else:\n        return s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(text):\n    # Check if the string contains spaces\n    if ' ' in text:\n        # Replace spaces with underscores\n        return text.replace(' ', '_')\n    # If no spaces, replace underscores with spaces\n    else:\n        return text.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Replace all whitespaces with underscores\n    str1 = input_string.replace(' ', '_')\n    # Replace all underscores with whitespaces\n    str2 = input_string.replace('_', ' ')\n    \n    # Check which transformation was applied and return the result accordingly\n    if input_string == str1:\n        return str2\n    else:\n        return str1", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(str1):\n    # Check if the input string contains spaces\n    if ' ' in str1:\n        # Replace spaces with underscores\n        str1 = str1.replace(' ', '_')\n    else:\n        # Replace underscores with spaces\n        str1 = str1.replace('_', ' ')\n    return str1", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(test_str):\n    # Check if the string contains any spaces\n    if \" \" in test_str:\n        # Replace spaces with underscores if present\n        res = test_str.replace(\" \", \"_\")\n    else:\n        # Replace underscores with spaces if no spaces are present\n        res = test_str.replace(\"_\", \" \")\n    return res", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(str1):\n    # Split the string into a list of words\n    a = list(str1.split(\" \"))\n    # Join the words with underscores\n    b = \"_\".join(a)\n    # Split the string by underscores into a list\n    c = list(str1.split(\"_\"))\n    # Join the words with spaces\n    d = \" \".join(c)\n    \n    # Check which operation was performed and return the appropriate result\n    if str1 == b:\n        return d\n    else:\n        return b", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Check if the string contains spaces\n    if ' ' in s:\n        # Replace all spaces with underscores\n        s = s.replace(' ', '_')\n    else:\n        # Replace all underscores with spaces\n        s = s.replace('_', ' ')\n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if the input string contains spaces\n    if ' ' in input_string:\n        # Replace spaces with underscores\n        output_string = input_string.replace(' ', '_')\n    else:\n        # Replace underscores with spaces\n        output_string = input_string.replace('_', ' ')\n    return output_string", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if the input string contains spaces\n    if ' ' in input_string:\n        # Replace spaces with underscores\n        return input_string.replace(' ', '_')\n    # If no spaces, replace underscores with spaces\n    return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if the input string contains spaces\n    if ' ' in input_string:\n        # Replace spaces with underscores\n        return input_string.replace(' ', '_')\n    else:\n        # Replace underscores with spaces\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(string):\n    # Check if the string contains spaces, if so, replace spaces with underscores\n    if \" \" in string:\n        return string.replace(\" \", \"_\")\n    else:\n        # If no spaces, replace underscores with spaces\n        return string.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(str1):\n    # Check if the string contains any space\n    if \" \" in str1:\n        # Replace spaces with underscores\n        return str1.replace(\" \", \"_\")\n    else:\n        # Replace underscores with spaces\n        return str1.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_str):\n    # Check if there are any spaces in the input string\n    if ' ' in input_str:\n        # Replace spaces with underscores if spaces are found\n        return input_str.replace(' ', '_')\n    else:\n        # Replace underscores with spaces if no spaces are found\n        return input_str.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if the string contains spaces and replace them with underscores\n    if ' ' in input_string:\n        return input_string.replace(' ', '_')\n    # If no spaces, replace underscores with spaces\n    else:\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(str1):\n    # Check if there are any whitespaces in the string\n    if str1.find(' ') >= 0:\n        # Replace whitespaces with underscores\n        return str1.replace(' ', '_')\n    else:\n        # Replace underscores with whitespaces\n        return str1.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    # Check if the input string contains any spaces\n    if ' ' in input_string:\n        # Replace all spaces with underscores\n        return input_string.replace(' ', '_')\n    else:\n        # Replace all underscores with spaces\n        return input_string.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(str1):\n    # Use the replace method to substitute spaces with underscores\n    if ' ' in str1:\n        # Replace spaces with underscores if they exist\n        return str1.replace(' ', '_')\n    # Replace underscores with spaces if spaces do not exist\n    else:\n        return str1.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(str1):\n    # Replace spaces with underscores and vice versa\n    if ' ' in str1:\n        result_str = str1.replace(' ', '_')\n    else:\n        result_str = str1.replace('_', ' ')\n    return result_str", "matching_cluster_idx": 7}]}, "Mbpp/632": {"dps": 95.1219512195122, "dps_norm": 97.14285714285714, "pass@1": 96.0, "profiled": [{"solution": "def move_zero(nums):\n    i = 0  # Initialize pointer to track the position to place the next non-zero element\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i], nums[j] = nums[j], nums[i]  # Swap non-zero element with the element at position i\n            i += 1  # Move the pointer to the next position\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Move all zeroes to the end of the list\n    non_zero_pos = 0  # Position to place the next non-zero element\n    \n    # Iterate through the list and place non-zero elements at non_zero_pos\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_pos] = nums[i]\n            non_zero_pos += 1\n    \n    # Fill the remaining positions with zeroes\n    for i in range(non_zero_pos, len(nums)):\n        nums[i] = 0\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Filter out non-zero elements and count zeros\n    non_zeros = [x for x in arr if x != 0]\n    num_zeros = len(arr) - len(non_zeros)\n    \n    # Create the new list with non-zeros followed by zeros\n    result = non_zeros + [0] * num_zeros\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Use list comprehension to filter out non-zero elements\n    non_zero = [i for i in nums if i != 0]\n    \n    # Calculate the number of zeroes to append\n    num_zeros = len(nums) - len(non_zero)\n    \n    # Extend the non-zero list with zeroes\n    return non_zero + [0] * num_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Remove all zeroes and count them\n    non_zeroes = [x for x in lst if x != 0]\n    num_zeroes = len(lst) - len(non_zeroes)\n    \n    # Create a new list with non-zeroes and append the correct number of zeroes\n    result = non_zeroes + [0] * num_zeroes\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize the position to place the next non-zero element\n    place_at = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # If the current number is not zero, place it at the current position and increment the position\n        if num != 0:\n            nums[place_at] = num\n            place_at += 1\n    \n    # Fill the remaining positions with zeros\n    for i in range(place_at, len(nums)):\n        nums[i] = 0\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a pointer to keep track of the position to place the next non-zero element\n    position = 0\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # If the current number is not zero, place it at the 'position' index and increment the position\n        if num != 0:\n            nums[position] = num\n            position += 1\n    \n    # Fill the remaining positions in the list with zero\n    while position < len(nums):\n        nums[position] = 0\n        position += 1\n    \n    # Return the modified list\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a pointer for the position to place non-zero elements\n    j = 0\n    \n    # Move all non-zero elements to the beginning of the list\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[i], nums[j] = nums[j], nums[i]  # Swap non-zero element to the front\n            j += 1\n    \n    # Fill the rest of the list with zeros\n    for i in range(j, len(nums)):\n        nums[i] = 0\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Count the number of zeroes in the array\n    count_zero = arr.count(0)\n    # Create a new list without zeroes and return it\n    return [i for i in arr if i != 0] + [0] * count_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeroes in the list\n    count = nums.count(0)\n    # Filter out zeroes and create a new list without zeroes\n    new_list = [num for num in nums if num != 0]\n    # Extend the new list with zeroes\n    new_list.extend([0] * count)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeroes in the list\n    count = nums.count(0)\n    \n    # Remove all zeroes from the list\n    nums = [x for x in nums if x != 0]\n    \n    # Append the counted zeroes to the end of the list\n    return nums + [0] * count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeroes in the list\n    num_zeroes = nums.count(0)\n    # Remove all zeroes from the list\n    nums = [num for num in nums if num != 0]\n    # Append the counted zeroes to the end of the list\n    nums += [0] * num_zeroes\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeroes in the list\n    count = lst.count(0)\n    # Remove all zeroes from the list\n    while 0 in lst:\n        lst.remove(0)\n    # Append the same number of zeroes to the end of the list\n    while count:\n        lst.append(0)\n        count -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def move_zero(nums):\n    non_zero_index = 0  # Initialize an index to place the next non-zero element\n    \n    # Move all non-zero elements to the beginning of the list\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index] = nums[i]\n            non_zero_index += 1\n    \n    # Fill the remaining positions in the list with zeros\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeroes in the list\n    zeroes = nums.count(0)\n    # Remove all zeroes from the list\n    nums = [num for num in nums if num != 0]\n    # Extend the list with the count of zeroes\n    nums.extend([0] * zeroes)\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    n = len(arr)  # Get the length of the list\n    \n    count = 0  # Initialize a count to track the number of non-zero elements\n    \n    # Traverse the array from the start\n    for i in range(n):\n        # If the current element is non-zero, move it to the position of count\n        if arr[i] != 0:\n            arr[count] = arr[i]\n            count += 1\n    \n    # Fill the remaining positions with zeroes\n    while count < n:\n        arr[count] = 0\n        count += 1\n    \n    return arr  # Return the modified array with all zeroes at the end", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Calculate the number of zeroes in the list\n    zeroes = lst.count(0)\n    # Remove all zeroes from the list\n    lst = [i for i in lst if i != 0]\n    # Append the count of zeroes to the end of the list\n    lst += [0] * zeroes\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Count the number of zeroes in the array\n    cnt = arr.count(0)\n    \n    # Filter out zeroes and extend the list with the same number of zeroes\n    arr = [i for i in arr if i != 0] + [0] * cnt\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeroes in the list\n    zero_count = lst.count(0)\n    # Remove all zeroes from the list\n    lst = [x for x in lst if x != 0]\n    # Append the number of zeroes to the end of the list\n    return lst + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Count the number of zeroes in the list\n    count_zeroes = nums.count(0)\n    # Filter out zeroes and collect the rest of the numbers\n    result = [num for num in nums if num != 0]\n    # Extend the result list with zeroes\n    result.extend([0] * count_zeroes)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 95.8130081300813, "dps_norm": 60.83333333333333, "pass@1": 52.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result to 0\n    xor_sum = 0\n    \n    # Iterate over each bit position from 0 to 31 (since we are dealing with 32-bit integers)\n    for i in range(32):\n        # Initialize counters for the number of times bit i is set to 0 and 1\n        count0 = 0\n        count1 = 0\n        \n        # Count the number of 1s and 0s at the i-th bit position in the list\n        for j in range(n):\n            if arr[j] & (1 << i):\n                count1 += 1\n            else:\n                count0 += 1\n        \n        # Calculate the contribution of the i-th bit to the overall XOR sum\n        xor_sum += (count0 * count1 * (1 << i))\n    \n    # Return the total XOR sum\n    return xor_sum", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum of XOR to 0\n    sum_xor = 0\n    \n    # Iterate over all pairs (i, j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR for the current pair and add it to the sum\n            sum_xor += (arr[i] ^ arr[j])\n    \n    # Return the total sum of XOR for all pairs\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the answer\n    ans = 0\n    \n    # Iterate over all bits of an integer\n    for i in range(32):\n        # Count the number of elements which have ith bit set\n        cnt = 0\n        for j in range(n):\n            if arr[j] & (1 << i):\n                cnt += 1\n        \n        # If ith bit is set in any number, then contribute\n        # (cnt * (n - cnt) * pow(2, i)) to the answer\n        if cnt > 0:\n            ans += cnt * (n - cnt) * (1 << i)\n    \n    # Return the final sum\n    return ans", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize result\n    res = 0\n    \n    # Traverse all bits\n    for i in range(0, 32):\n        # Find count of set bits at i'th position in all numbers\n        count = 0\n        for j in range(0, n):\n            if (arr[j] & (1 << i)):\n                count += 1\n        \n        # Add \"count * (n - count) * (1 << i)\" to result\n        res += count * (n - count) * (1 << i)\n    \n    return res", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result variable\n    res = 0\n    \n    # Iterate through all pairs\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            # Calculate the xor and add it to the result\n            res += (arr[i] ^ arr[j])\n    \n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum variable to store the sum of XOR values\n    sum = 0\n    \n    # Iterate through each element of the array\n    for i in range(n):\n        # Iterate through each element of the array after the current element\n        for j in range(i + 1, n):\n            # Calculate the XOR of the current pair and add it to the sum\n            sum += (arr[i] ^ arr[j])\n    \n    # Return the total sum of XOR values of all pairs\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    # Calculate the total sum of XORs of all pairs\n    xorSum = sum(nums[i] ^ nums[j] for i in range(n) for j in range(i + 1, n))\n    return xorSum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, size): \n    xor_sum = 0  # Initialize the sum of XOR values\n\n    # Iterate through the list\n    for i in range(size): \n        # For each element, check all other elements\n        for j in range(i + 1, size): \n            # Compute the XOR of the current pair and add to the sum\n            xor_sum = xor_sum + (nums[i] ^ nums[j]) \n                \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the answer with 0\n    answer = 0\n    \n    # Iterate over each bit position (31 to 0 for 32-bit integers)\n    for i in range(32):\n        # Count the number of elements with the i-th bit set\n        c1 = 0\n        for j in range(n):\n            if arr[j] & (1 << i):\n                c1 += 1\n        \n        # Calculate the number of pairs with the i-th bit set in XOR\n        c2 = c1 * (n - c1)\n        \n        # Add to the answer considering the contribution of the i-th bit\n        answer += (c2 << i)\n    \n    return answer", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(A, N):\n    # Iterate over all possible pairs using two nested loops\n    sum = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate the XOR of the current pair and add it to the sum\n            sum += A[i] ^ A[j]\n    # Return the total sum of XOR of all pairs\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, N):\n    # Calculate the sum of XOR of all pairs\n    return sum((arr[i] ^ arr[j]) for i in range(N) for j in range(i + 1, N))", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result\n    result = 0\n    \n    # Iterate through the array from the first to the second last element\n    for i in range(n - 1):\n        # Iterate through the array from the element next to i to the last element\n        for j in range(i + 1, n):\n            # XOR the elements at i and j and add the result to the total result\n            result += arr[i] ^ arr[j]\n    \n    # Return the total XOR sum of all pairs\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_Sum = 0  # Initialize the variable to store the sum of XORs\n    \n    # Iterate over all pairs using nested loops\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_Sum += (arr[i] ^ arr[j])  # XOR the current pair and add to the sum\n    \n    return xor_Sum  # Return the computed sum of XORs", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n): \n    # Calculate the sum of xor of all pairs \n    res = 0\n    for i in range(n): \n        # For each bit position \n        for j in range(i, n): \n            # Calculate the xor of the current pair and add it to the result \n            res += arr[i] ^ arr[j] \n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, N):\n    # Initialize the sum of XOR values\n    res = 0\n    \n    # Iterate over each bit position (0 to 31)\n    for i in range(32):\n        # Count the number of elements with the i-th bit set\n        cnt = 0\n        for j in range(N):\n            if arr[j] & (1 << i):\n                cnt += 1\n        \n        # Calculate the number of pairs with the i-th bit set\n        res += (1 << i) * cnt * (N - cnt)\n    \n    # Return the final result\n    return res", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize total_sum to 0\n    total_sum = 0\n    \n    # Iterate over each bit position from 0 to 31 (for 32-bit numbers)\n    for i in range(32):\n        # Initialize count of 1s to 0\n        set_bit = 0\n        \n        # Iterate over each element in the array\n        for j in range(n):\n            # Count how many numbers have the i-th bit set\n            if arr[j] & (1 << i):\n                set_bit += 1\n        \n        # Calculate the contribution of this bit to the total sum\n        total_sum += set_bit * (n - set_bit) * (1 << i)\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, N):\n    ans = 0\n    # Iterate over each bit position from 0 to 31 (32 bits)\n    for i in range(32):\n        # Count the number of elements with the i-th bit set\n        count = 0\n        for j in range(N):\n            if (arr[j] & (1 << i)):\n                count += 1\n        # Calculate the contribution of the i-th bit to the final answer\n        ans += (1 << i) * count * (N - count)\n    return ans", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum of XOR results\n    result = 0\n    \n    # Iterate over all possible pairs (i, j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the current pair and add to the result\n            result += arr[i] ^ arr[j]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    s = 0\n    \n    # Iterate over each element in the array\n    for i in range(n):\n        # Iterate over the elements that come after the current element\n        for j in range(i + 1, n):\n            # Add the xor of the current pair to the sum\n            s += arr[i] ^ arr[j]\n    \n    # Return the total sum of xor for all pairs\n    return s", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, N):\n    # Initialize sum of xor of all pairs to 0\n    S = 0\n    \n    # Iterate over the array to find xor of all pairs\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate xor of the pair and add to the sum\n            S += (arr[i] ^ arr[j])\n    \n    # Return the total sum of xor of all pairs\n    return S", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 48.324468085106375, "dps_norm": 65.66666666666667, "pass@1": 75.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, K):\n    # Reverse the elements from the start up to K\n    arr[:K] = arr[:K][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, K):\n    # Reverse elements from index 0 to K-1\n    array[:K] = reversed(array[:K])\n    return array", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements from index 0 to k-1 using slicing\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Loop through the array from the start to the index k (exclusive)\n    for i in range(k // 2):\n        # Swap the elements at the current index i and k-i-1\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(array, K):\n    # Reverse the elements from the start to the Kth position (exclusive)\n    array[:K] = array[:K][::-1]\n    return array", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(A, K):\n    # Reverse the elements from the start to the K-th index\n    A[0:K] = A[K-1::-1]\n    return A", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Create a copy of the array to avoid modifying the original array\n    new_arr = arr.copy()\n    \n    # Reverse the elements from index 0 to k-1\n    for i in range(k // 2):\n        new_arr[i], new_arr[k - 1 - i] = new_arr[k - 1 - i], new_arr[i]\n    \n    return new_arr", "matching_cluster_idx": 5}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse elements from 0 to k-1\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(A, K):\n    # Reverse elements from the start up to index K (inclusive)\n    for i in range(0, K // 2):\n        A[i], A[K - i - 1] = A[K - i - 1], A[i]\n    # Return the modified array\n    return A", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    # Iterate through the array up to the K-th element\n    for i in range(0, K//2):\n        # Swap the elements at the current position and the corresponding position from the end\n        arr[i], arr[K-i-1] = arr[K-i-1], arr[i]\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Loop through the array from the start to the k-th position\n    for i in range(int(k / 2)):\n        # Swap elements at positions i and k-i-1\n        arr[i], arr[k - i - 1] = arr[k - i - 1], arr[i]\n    # Return the modified array\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(A, K):\n    # Initialize start and end pointers\n    start = 0\n    end = K - 1\n    \n    # Loop to reverse elements from start to end\n    while start < end:\n        # Swap elements at start and end\n        A[start], A[end] = A[end], A[start]\n        # Move the start pointer to the right\n        start += 1\n        # Move the end pointer to the left\n        end -= 1\n    \n    # Return the modified array\n    return A", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Slice the array up to position k and reverse it\n    # Concatenate it with the rest of the array unchanged\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    # Loop through the first K elements of the array\n    for i in range(K // 2):\n        # Swap the elements at indices i and K-i-1\n        arr[i], arr[K-i-1] = arr[K-i-1], arr[i]\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    # Reverse the elements from index 0 to K-1\n    i = 0\n    while i < K // 2:\n        temp = arr[i]\n        arr[i] = arr[K - i - 1]\n        arr[K - i - 1] = temp\n        i += 1\n    return arr", "matching_cluster_idx": 4}, {"solution": "def reverse_Array_Upto_K(A, K):\n    # Reverse the elements of the array from the start up to and including the Kth position\n    for i in range(0, K // 2):\n        A[i], A[K - i - 1] = A[K - i - 1], A[i]\n    # Return the modified array\n    return A", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Create a copy of the array up to the k-th element (index k-1)\n    lst = arr[:k]\n    \n    # Reverse the copied array\n    lst = lst[::-1]\n    \n    # Extend the reversed array with the remaining elements of the original array\n    lst.extend(arr[k:])\n    \n    # Return the modified array\n    return lst", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    # Reverse the subarray from index 0 to K-1\n    arr[:K] = reversed(arr[:K])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, K):\n    # Reverse the elements from the start up to the Kth index\n    return arr[:K][::-1] + arr[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(A, K):\n    # Loop through the array from the start to the K-th element\n    for i in range(int(K / 2)):\n        # Swap elements symmetrically from the start and end of the array\n        A[i], A[K - i - 1] = A[K - i - 1], A[i]\n    # Return the modified array with the first K elements reversed\n    return A", "matching_cluster_idx": 6}]}, "Mbpp/720": {"dps": 48.24175824175824, "dps_norm": 72.0, "pass@1": 99.0, "profiled": [{"solution": "def add_dict_to_tuple(test_tup, K):\n    # Extend the tuple by converting it to a list, appending the dictionary, and then converting back to a tuple\n    res = tuple(list(test_tup) + [K])\n    return res", "matching_cluster_idx": 2}, {"solution": "def add_dict_to_tuple(test_tup, dict_to_add):\n    # Convert the tuple to a list, append the dictionary, and convert back to a tuple\n    res = tuple(list(test_tup) + [dict_to_add])\n    return res", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(test_tup, add_dict):\n    # Append the dictionary to the tuple using tuple concatenation\n    res = test_tup + (add_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, dict_val):\n    \"\"\"\n    This function takes a tuple and a dictionary as input and returns a new tuple\n    with the dictionary added as its last element.\n    \"\"\"\n    # Append the dictionary to the tuple\n    res = test_tup + (dict_val,)\n    \n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, dict_add):\n    \"\"\"\n    Add a dictionary to the tuple and return the updated tuple.\n\n    Args:\n    test_tup (tuple): The original tuple to which the dictionary will be added.\n    dict_add (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The updated tuple with the dictionary added as its last element.\n    \"\"\"\n    # Convert the tuple to a list, append the dictionary, then convert back to a tuple\n    res = tuple(list(test_tup) + [dict_add])\n    return res", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list\n    temp_list = list(tup)\n    # Append the dictionary to the list\n    temp_list.append(dictionary)\n    # Convert the list back to a tuple\n    return tuple(temp_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, dictx):\n    # Using the '+=' operator to concatenate a tuple containing the dictionary\n    test_tup += (dictx,)\n    return test_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, res_dict):\n    # Concatenate the tuple with the dictionary inside another tuple\n    res = test_tup + (res_dict,)\n    return (res)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, dict_test):\n    # Convert the tuple to a list to allow modification\n    res = list(test_tup)\n    # Append the dictionary to the list\n    res.append(dict_test)\n    # Convert the list back to a tuple\n    res = tuple(res)\n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, K):\n    # Append the dictionary to the tuple\n    res = test_tup + (K,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, dic):\n    # Convert the tuple to a list, append the dictionary to the list, and convert back to a tuple\n    res = tuple(list(test_tup) + [dic])\n    return res", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(test_tup, res_dict):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(test_tup)\n    \n    # Append the dictionary to the list\n    temp_list.append(res_dict)\n    \n    # Convert the list back to a tuple\n    res = tuple(temp_list)\n    \n    return res", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, K):\n    \"\"\"\n    This function takes a tuple and a dictionary as arguments and returns a new tuple with the dictionary added as its last element.\n    \n    :param test_tup: Tuple to which the dictionary will be added.\n    :param K: Dictionary to be added to the tuple.\n    :return: A new tuple with the dictionary added.\n    \"\"\"\n    # Convert the tuple to a list, append the dictionary, and convert back to a tuple\n    res = tuple(list(test_tup) + [K])\n    return res", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    \"\"\"\n    This function takes a tuple and a dictionary as arguments and returns a new tuple\n    with the dictionary appended as its last element.\n    \n    :param test_tup: Tuple to which the dictionary will be appended\n    :param test_dict: Dictionary to be appended to the tuple\n    :return: New tuple with the dictionary appended\n    \"\"\"\n    # Append the dictionary to the tuple\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, res_dict):\n    # Convert the tuple to a list, append the dictionary, and convert back to a tuple\n    res = tuple(list(test_tup) + [res_dict])\n    return res", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(test_tup, dic):\n    # Convert the tuple to a list, append the dictionary, and convert back to a tuple\n    res = tuple(list(test_tup) + [dic])\n    return res", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(test_tup, res_dict):\n    # Add the dictionary to the tuple using the + operator\n    res = test_tup + (res_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "from copy import deepcopy\ndef add_dict_to_tuple(test_tup, K):\n    # Creating a deep copy of the tuple to avoid modifying the original tuple\n    res = deepcopy(test_tup)\n    # Appending the dictionary to the copied tuple\n    res += (K,)\n    return res", "matching_cluster_idx": 0}, {"solution": "def add_dict_to_tuple(test_tup, dict_to_add):\n    \"\"\"\n    This function takes a tuple and a dictionary as arguments.\n    It converts the tuple into a list, appends the dictionary to the list,\n    and then converts the list back into a tuple.\n    \n    Args:\n    test_tup (tuple): The original tuple to which the dictionary will be added.\n    dict_to_add (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original elements and the added dictionary.\n    \"\"\"\n    # Convert the tuple to a list\n    res = list(test_tup)\n    \n    # Append the dictionary to the list\n    res.append(dict_to_add)\n    \n    # Convert the list back to a tuple\n    return tuple(res)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, dict_to_add):\n    # Append the dictionary to the tuple and convert it back to a tuple\n    res = tuple(test_tup + (dict_to_add,))\n    return res", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 65.40983606557377, "dps_norm": 69.375, "pass@1": 35.0, "profiled": [{"solution": "import re\ndef extract_quotation(word):\n    # Use regular expression to find all occurrences of text between quotation marks\n    return re.findall(r'\"(.*?)\"', word)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use a regular expression to find all occurrences of text between quotation marks\n    res = re.findall(r'\"(.*?)\"', s)\n    return res", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Find all occurrences of text enclosed in double quotes\n    data = re.findall(r'\"(.*?)\"', text)\n    return data", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all values between quotation marks\n    result = re.findall(r'\\\"(.*?)\\\"', text)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(text):\n    # Initialize an empty list to store the extracted values\n    words = []\n    \n    # Convert the text to a list of characters for easier manipulation\n    l = list(text)\n    \n    # Variables to track the positions of the quotation marks\n    open_index = 0\n    close_index = 0\n    \n    # Iterate through the list of characters\n    for i in range(len(l)):\n        if l[i] == '\"':\n            # Toggle the state between open and close quotation mark\n            if close_index == 0:\n                open_index = i\n                close_index = 1\n            else:\n                close_index = 0\n                # Extract the substring between the quotation marks\n                words.append(text[open_index + 1 : i])\n                open_index = 0\n    \n    # Return the list of extracted words\n    return words", "matching_cluster_idx": 2}, {"solution": "import re\ndef extract_quotation(input_str):\n    # Use regular expression to find all values enclosed in double quotes\n    result = re.findall(r'\"(.*?)\"', input_str)\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_str):\n    # Use regular expression to find all occurrences of text within double quotation marks\n    matched_items = re.findall(r'\"(.*?)\"', input_str)\n    return matched_items", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(mstr):\n    # Use regular expression to find all words enclosed in quotation marks\n    return re.findall(r'\"(.*?)\"', mstr)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all text between quotation marks\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(str1):\n    # Using regular expression to find all text enclosed in quotation marks\n    result = re.findall(r'\"(.*?)\"', str1)\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings within quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find text within quotation marks\n    pattern = '[\"](.*?)[\"]'\n    # Find all matches in the input string\n    match = re.findall(pattern, input_string)\n    \n    return match", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(strings):\n    # Use regular expression to find all sequences of characters\n    # enclosed in double quotes and return them as a list\n    return re.findall(r'\"(.*?)\"', strings)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    # Using regular expression to find all text within quotation marks\n    result = re.findall(r'\"(.*?)\"', string)\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(data):\n    # Use regular expression to find all substrings between double quotation marks\n    res = re.findall(r'\"(.*?)\"', data)\n    return res", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all occurrences of text within quotation marks\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(str1):\n    # Use a regular expression to find text within quotation marks\n    result = re.findall(r'\"(.*?)\"', str1)\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regex to find all sequences of characters between quotation marks\n    result = re.findall(r'\"(.*?)\"', s)\n    # Return the list of extracted values\n    return result", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all words within double quotes\n    words_within_quotes = re.findall(r'\\\"(.*?)\\\"', text)\n    return words_within_quotes", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    # Initialize an empty list to store the extracted values\n    arr = []\n    # Initialize indices to track the current position in the string\n    i, j = 0, 0\n    \n    # Loop through the string to find pairs of quotation marks\n    while i < len(s) and j < len(s):\n        # Find the next opening quotation mark\n        i = s.find('\"', j)\n        # If no opening quotation mark is found, break the loop\n        if i == -1:\n            break\n        # Find the following closing quotation mark\n        j = s.find('\"', i + 1)\n        # If no closing quotation mark is found, break the loop\n        if j == -1:\n            break\n        \n        # Extract the value between the quotation marks and add it to the list\n        arr.append(s[i + 1 : j])\n        # Move the index j forward to continue searching for more pairs\n        j += 1\n    \n    # Return the list of extracted values\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/732": {"dps": 70.03875968992249, "dps_norm": 83.5, "pass@1": 87.0, "profiled": [{"solution": "def replace_specialchar(s):\n    # Using the replace method to substitute spaces, commas, and dots with a colon\n    s = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(test_str):\n    # Replace spaces, commas, or dots with a colon\n    res = test_str.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")\n    return res", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(test_str):\n    # Replace spaces, commas, and dots with a colon\n    res = test_str.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return res", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(S):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(\"[ ,.]\", \":\", S)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(input_string):\n    # Replace spaces, commas, and dots with a colon using string replacement\n    replaced_string = input_string.replace(' ', ':').replace(',', ':').replace('.', ':')\n    # Return the modified string\n    return replaced_string", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Using regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(\"[ ,.]\", \":\", text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(S):\n    # Replace all spaces, commas, and dots with a colon using the translate method\n    res = S.translate(S.maketrans(' ,.', ':::'))\n    return res", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, or dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace all occurrences of spaces, commas, or dots with a colon\n    s = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    # Replace all spaces, commas, and dots with a colon\n    new_string = string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")\n    return new_string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Using the translate method with a translation table\n    # That maps space, comma, and dot to a colon\n    return s.translate(str.maketrans(\" ,.\", \"|||\")).replace(\"|\", \":\")", "matching_cluster_idx": 7}, {"solution": "def replace_specialchar(street):\n    # Replace spaces, commas, and dots with a colon\n    return street.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r\"[ ,.]\", \":\", text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(S):\n    # Replace all spaces, commas, or dots with a colon\n    S = S.replace(\" \", \":\")\n    S = S.replace(\",\", \":\")\n    S = S.replace(\".\", \":\")\n    return S", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    # Using re.sub() to replace spaces, commas, or dots with a colon\n    return re.sub('[ ,.]', ':', text)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(st):\n    # Replace spaces, commas, and dots with colons\n    return st.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(str1):\n    # Replace spaces, commas, and dots with a colon\n    result = str1.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces with colons\n    s = s.replace(' ', ':')\n    # Replace commas with colons\n    s = s.replace(',', ':')\n    # Replace dots with colons\n    s = s.replace('.', ':')\n    # Return the modified string\n    return s", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(test_str):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    result = re.sub(\"[ ,.]\", \":\", test_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "import re\ndef replace_specialchar(string):\n    # Replace spaces, commas, and dots with a colon\n    return re.sub(\"[ ,.]\", \":\", string)", "matching_cluster_idx": 4}]}, "Mbpp/740": {"dps": 74.52727272727273, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "from typing import Tuple, Dict\ndef tuple_to_dict(test_tup: Tuple[int, ...]) -> Dict[int, int]:\n    \"\"\"\n    Convert a tuple of adjacent elements into a dictionary.\n\n    Parameters:\n    test_tup (Tuple[int, ...]): A tuple containing elements to be converted into a dictionary.\n\n    Returns:\n    Dict[int, int]: A dictionary with key-value pairs derived from the tuple.\n    \"\"\"\n    # Using dictionary comprehension to create the dictionary\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary to store the result\n    res = {}\n    # Iterate over the tuple with a step of 2 to create key-value pairs\n    for i in range(0, len(test_tup), 2):\n        res[test_tup[i]] = test_tup[i + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary to store the key-value pairs\n    res = {}\n    \n    # Iterate over the tuple elements using a step of 2 to get pairs\n    for ele in range(0, len(test_tup), 2):\n        # Assign the current element as key and the next element as value\n        res[test_tup[ele]] = test_tup[ele + 1]\n    \n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary\n    res = dict()\n    # Iterate over the tuple in steps of 2 to create key-value pairs\n    for ele in range(0, len(test_tup), 2):\n        # Assign each pair to the dictionary\n        res[test_tup[ele]] = test_tup[ele + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements.\n    \n    Parameters:\n    test_tup (tuple): A tuple with even number of elements.\n    \n    Returns:\n    dict: A dictionary with elements from the tuple as key-value pairs.\n    \"\"\"\n    # Using dictionary comprehension to create key-value pairs\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Create a dictionary using dict comprehension\n    # Zip function pairs up elements from two tuples, effectively\n    # treating the tuple as key-value pairs.\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup) - 1, 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary to store the result\n    res = {}\n    # Iterate over the tuple using a loop\n    for idx in range(0, len(test_tup) - 1, 2):\n        # Use the current element as the key and the next element as the value\n        res[test_tup[idx]] = test_tup[idx + 1]\n    # Return the resulting dictionary\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Create a dictionary using dictionary comprehension and zip function\n    res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup) - 1, 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Convert tuple to dictionary using dictionary comprehension\n    res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))\n    return res", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary\n    res_dict = {}\n    # Iterate through the tuple in steps of 2 to pair elements\n    for ele in range(0, len(test_tup), 2):\n        # Assign each pair of adjacent elements to the dictionary\n        res_dict[test_tup[ele]] = test_tup[ele + 1]\n    return res_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary\n    res = dict()\n    # Iterate over the tuple in steps of 2\n    for ele in range(0, len(test_tup), 2):\n        # Assign adjacent elements as key-value pairs\n        res[test_tup[ele]] = test_tup[ele + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Convert the tuple into a dictionary using a dictionary comprehension\n    # The comprehension iterates over pairs of elements, taking the first as the key and the second as the value\n    res = dict(test_tup[idx:idx + 2] for idx in range(0, len(test_tup), 2))\n    return res", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(test_tup):\n    # Using dictionary comprehension to create a dictionary from the tuple\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup) - 1, 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Using dictionary comprehension to convert tuple pairs into key-value dictionary\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Using dictionary comprehension to pair adjacent elements\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup) - 1, 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Use the zip function to pair each element with its successor\n    # Slice the tuple to stop one element short to avoid pairing with an empty tuple\n    res = dict(zip(test_tup[0::2], test_tup[1::2]))\n    return res", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(test_tup):\n    # Using dictionary comprehension to pair adjacent elements\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup) - 1, 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Use zip function to pair adjacent elements and convert to dictionary\n    res = dict(test_tup[idx:idx + 2] for idx in range(0, len(test_tup), 2))\n    return res", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(test_tup):\n    # Initialize an empty dictionary to store the key-value pairs\n    res = dict()\n    \n    # Iterate over the tuple in steps of 2 to form key-value pairs\n    for ele in range(0, len(test_tup), 2):\n        # Assign the current element as key and the next element as value\n        res[test_tup[ele]] = test_tup[ele + 1]\n    \n    # Return the resulting dictionary\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Using dictionary comprehension to convert tuple to dictionary\n    # Adjacent elements are converted into key-value pairs\n    res = {test_tup[idx]: test_tup[idx + 1] for idx in range(0, len(test_tup) - 1, 2)}\n    return res", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 28.32191780821918, "dps_norm": 50.833333333333336, "pass@1": 90.0, "profiled": [{"solution": "def check_none(test_tup):\n    # Initialize result as False\n    res = False\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element is None\n        if ele is None:\n            # Set result to True if any element is None\n            res = True\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if 'None' is present in the tuple\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    # Check if any element in the tuple is None\n    res = any(val is None for val in test_tuple)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if 'None' is present in the tuple\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    # Use the 'any()' function to check if any element in the tuple is 'None'\n    if any(ele is None for ele in tup):\n        return True  # Return True if a None value is found\n    return False  # Return False if no None value is found", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Initialize a variable to keep track of whether a None value is found\n    flag = 0\n    \n    # Loop through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element is None\n        if ele is None:\n            # If None is found, set the flag to 1 and break the loop\n            flag = 1\n            break\n    \n    # Return whether a None value was found\n    return bool(flag)", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if 'None' is present in the tuple\n    res = any(var is None for var in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    # Use the any() function to check if any element in the tuple is None\n    return any(i is None for i in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    # Check if the tuple contains any None values\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tup):\n    # Using any() function to check if there is any None value in the tuple\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    # Check if the tuple contains the value None\n    if None in tup:\n        return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if None is present in the tuple and return the result\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if there is any 'None' value in the tuple\n    res = any(i is None for i in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    # Check if 'None' is present in the input tuple using 'in' keyword\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tup):\n    # Check if the 'None' value exists in the tuple\n    res = any(val is None for val in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    # Use a generator expression to check if 'None' is in the tuple\n    res = any(item is None for item in test_tuple)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    # Iterate through each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is None\n        if element is None:\n            # If a None value is found, return True\n            return True\n    # If no None values are found, return False\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tuple):\n    # Check if 'None' is present in the tuple\n    res = None in test_tuple\n    return res", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tup):\n    # Check if None is in the tuple using any()\n    res = any(val is None for val in test_tup)\n    return res", "matching_cluster_idx": 1}]}, "Mbpp/750": {"dps": 86.05442176870748, "dps_norm": 85.83333333333333, "pass@1": 96.0, "profiled": [{"solution": "def add_tuple(list1, tuple1):\n    # Concatenate the list and the tuple, then return the result as a list\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tup1):\n    # Append the tuple to the list\n    list1 += tup1\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Extend the list with elements from the tuple\n    test_list.extend(test_tup)\n    # Return the modified list\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, K):\n    # Extend the test list by appending each element of the tuple K\n    for ele in K:\n        test_list.append(ele)\n    return test_list", "matching_cluster_idx": 0}, {"solution": "def add_tuple(given_list, given_tuple):\n    # Extend the list by adding each element of the tuple\n    given_list.extend(given_tuple)\n    # Return the updated list\n    return given_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list by appending elements from the tuple\n    lst.extend(tup)\n    # Return the modified list\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(nums_list, nums_tuple):\n    # Extend the list with elements of the tuple\n    nums_list.extend(nums_tuple)\n    return nums_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Use list.extend() to add all elements of the tuple to the list\n    lst.extend(tup)\n    # Return the updated list\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Use the extend method to add elements of the tuple to the list\n    test_list.extend(test_tup)\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, K):\n    # Extend the list by unpacking the tuple\n    test_list.extend(K)\n    # Return the modified list\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Extend the list with elements from the tuple\n    res = test_list.extend(test_tup)\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(int_list, int_tuple):\n    # Extend the list by iterating over each element in the tuple and appending it\n    int_list.extend(int_tuple)\n    return int_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Extend the list by appending each element of the tuple\n    test_list.extend(test_tup)\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(nums_list, tuple_nums):\n    # Extend the list by appending each element from the tuple\n    nums_list.extend(tuple_nums)\n    # Return the updated list\n    return nums_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, tup):\n    # Extend the list by adding the elements of the tuple\n    test_list.extend(tup)\n    # Return the updated list\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(given_list, given_tuple):\n    # Extend the list by appending each element of the tuple\n    given_list.extend(given_tuple)\n    # Return the updated list\n    return given_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_input, tuple_input):\n    # Extend the list by appending each element of the tuple\n    list_input.extend(tuple_input)\n    # Return the updated list\n    return list_input", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Extend the list by appending each element of the tuple\n    [test_list.append(ele) for ele in test_tup]\n    return test_list", "matching_cluster_idx": -1}, {"solution": "def add_tuple(test_list, test_tup):\n    # Concatenate the list and tuple into a new list\n    res = test_list + list(test_tup)\n    return res", "matching_cluster_idx": 2}, {"solution": "def add_tuple(given_list, given_tuple):\n    # Extend the given list by appending the given tuple\n    given_list.extend(given_tuple)\n    return given_list", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 82.91946308724832, "dps_norm": 71.25, "pass@1": 86.0, "profiled": [{"solution": "def min_k(test_list, N):\n    # Sorting the list of tuples based on the second element in ascending order\n    res = sorted(test_list, key = lambda x: x[1])[:N]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second element of each tuple and select the first K elements\n    res = sorted(test_list, key=lambda x: x[1])[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(list1, k):\n    # Use the sorted function to sort the list based on the second element of each tuple\n    # Then, return the first k elements from the sorted list\n    return sorted(list1, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, N):\n    # Sort the list of tuples based on the second element in ascending order and select the first N elements\n    res = sorted(test_list, key=lambda x: x[1])[:N]\n    return res", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, K):\n    # Sorting the list of tuples based on the second element (scores) in ascending order\n    res = sorted(test_list, key=lambda x: x[1])\n    # Slicing the first K elements from the sorted list\n    res = res[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Use the sorted function to sort the list of tuples based on the second element\n    # The [0:K] slice is then used to get the first K tuples from the sorted list\n    result = sorted(test_list, key=lambda x: x[1])[0:K]\n    return result", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second element in each tuple\n    res = sorted(test_list, key=lambda x: x[1])\n    \n    # Return the first K elements from the sorted list\n    return res[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second element of each tuple in ascending order\n    res = sorted(test_list, key=lambda ele: ele[1])[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, N):\n    # Sort the list of tuples based on the second item in each tuple\n    res = sorted(test_list, key=lambda x: x[1])[:N]\n    # Return the first N elements from the sorted list\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second element in ascending order\n    res = sorted(test_list, key=lambda x: x[1])\n    # Select the first K elements from the sorted list\n    res = res[:K]\n    return res", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, N):\n    # Use the sorted function to sort the list of tuples based on the second element (i.e., the score)\n    # Then, use slicing to select the first N tuples from the sorted list\n    res = sorted(test_list, key=lambda x: x[1])[:N]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second element of each tuple\n    res = sorted(test_list, key = lambda ele: ele[1])\n    # Slice the first K elements from the sorted list\n    res = res[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Using list comprehension to filter and sort the first K elements\n    res = sorted(test_list, key=lambda x: x[1])[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, K):\n    # Use the sorted function with a lambda function to sort by the second element in each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second element of each tuple\n    res = sorted(test_list, key=lambda x: x[1])\n    # Slice the list to get the first K elements, which will be the smallest\n    res = res[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sorting the list of tuples based on the second element in ascending order\n    res = sorted(test_list, key=lambda x: x[1])[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the tuple list based on the second element of each tuple (i.e., the score)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Use the sorted function to sort the list based on the second item (price) in ascending order\n    # Then slice the first K items from the sorted list to get the minimum K records\n    res = sorted(test_list, key=lambda x: x[1])[:K]\n    return res", "matching_cluster_idx": 1}, {"solution": "def min_k(test_list, K):\n    # Sort the list of tuples based on the second item in each tuple\n    res = sorted(test_list, key=lambda ele: ele[1])\n    \n    # Slice the first K elements to get the minimum K records\n    res = res[:K]\n    \n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Use the sorted function to sort the list of tuples based on the second element of each tuple in ascending order\n    # Take the first K elements from the sorted list to get the minimum K records\n    res = sorted(test_list, key=lambda x: x[1])[:K]\n    return res", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 94.3103448275862, "dps_norm": 93.125, "pass@1": 34.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_index = []\n    \n    # Iterate through the indices of the lists up to the minimum length\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index in all three lists are the same\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common elements list\n            common_index.append(l1[i])\n    \n    # Return the list of common elements\n    return common_index", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use list comprehension to filter elements that are common at the same index in all three lists\n    res = [x for x, y, z in zip(l1, l2, l3) if x == y == z]\n    return res", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(lst1, lst2, lst3):\n    # Use list comprehension to find elements that are the same at each index\n    common_elements = [lst1[i] for i in range(min(len(lst1), len(lst2), len(lst3))) if lst1[i] == lst2[i] == lst3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(list1, list2, list3):\n    # Initialize an empty list to store common elements\n    common = []\n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min(len(list1), len(list2), len(list3))):\n        # Check if the elements at the current index are the same\n        if list1[i] == list2[i] == list3[i]:\n            # If they are the same, add the element to the common list\n            common.append(list1[i])\n    # Return the list of common elements\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(A, B, C):\n    # Iterate through the elements of the lists using zip\n    # Append the element to the result if it is the same in all three lists\n    result = [a for a, b, c in zip(A, B, C) if a == b == c]\n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(a, b, c):\n    # Use a list comprehension to find elements that are common at the same index in all three lists\n    common_elements = [x for x, y, z in zip(a, b, c) if x == y == z]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(lst1, lst2, lst3):\n    # Use the zip function to iterate over the three lists in parallel\n    # Use list comprehension to check if all elements at the current index are the same\n    return [tup[0] for tup in zip(lst1, lst2, lst3) if tup[0] == tup[1] == tup[2]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Using list comprehension to find common elements at the same index\n    # for all three lists\n    res = [i for i, j, k in zip(l1, l2, l3) if i == j == k]\n    return res", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(nums1, nums2, nums3):\n    # Iterate through the indices of the lists\n    return [nums1[i] for i in range(min(len(nums1), len(nums2), len(nums3))) if nums1[i] == nums2[i] == nums3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use list comprehension to filter and return elements that are equal at the same index in all three lists\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(list1, list2, list3):\n    # Use zip to iterate over the three lists simultaneously\n    # Use the expression (x == y == z) to check if the elements at the same index are the same\n    # Filter the results to only include True values (i.e., elements that are common in all three lists)\n    result = [x for x, y, z in zip(list1, list2, list3) if (x == y == z)]\n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(lst1, lst2, lst3):\n    # Use list comprehension to find elements at the same index in all three lists\n    res = [lst1[i] for i in range(min(len(lst1), len(lst2), len(lst3))) \n           if lst1[i] == lst2[i] == lst3[i]]\n    return res", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(arr1, arr2, arr3):\n    # Initialize an empty list to store the result\n    res = []\n    # Get the length of the shortest array\n    length = min(len(arr1), len(arr2), len(arr3))\n    # Iterate through the arrays up to the length of the shortest array\n    for i in range(length):\n        # Check if the elements at the current index are the same in all three arrays\n        if arr1[i] == arr2[i] == arr3[i]:\n            # If they are the same, add the element to the result list\n            res.append(arr1[i])\n    # Return the list of common elements\n    return res", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use zip to iterate over all three lists simultaneously and compare elements at each index\n    # Filter elements that are equal in all three lists using a lambda function\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use list comprehension to filter elements\n    # Check if elements at the same index are equal in all three lists\n    result = [l1[i] for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use zip to iterate through all three lists in parallel\n    # Use list comprehension to filter elements that are equal across all lists\n    result = [i for i, j, k in zip(l1, l2, l3) if i == j == k]\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List\ndef extract_index_list(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    # Find the common elements at the same index in all three lists\n    common_elements = [list1[i] for i in range(min(len(list1), len(list2), len(list3))) if list1[i] == list2[i] == list3[i]]\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(list1, list2, list3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min(len(list1), len(list2), len(list3))):\n        # Check if the elements at the current index are the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # If they are the same, append the element to the common_elements list\n            common_elements.append(list1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Use a generator expression to iterate over the zipped lists\n    # Filter elements that appear in all three lists at the same index\n    result = [x for x, y, z in zip(l1, l2, l3) if x == y == z]\n    return result", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(list1, list2, list3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Calculate the minimum length among the three lists\n    length = min(len(list1), len(list2), len(list3))\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(length):\n        # Check if the elements at the current index are the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # If they are, append the element to the common_elements list\n            common_elements.append(list1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 59.65642894325872, "dps_norm": 76.47058823529412, "pass@1": 17.0, "profiled": [{"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set and back to a list\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, return None as we can't find the second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the list of unique numbers\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates by converting the list to a set and then back to a list\n    unique_numbers = list(set(numbers))\n    \n    # Sort the unique numbers\n    unique_numbers.sort()\n    \n    # Check if there are at least two unique numbers\n    if len(unique_numbers) >= 2:\n        return unique_numbers[1]  # Return the second smallest\n    else:\n        return None  # Return None if there's no second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Initialize first and second smallest to a large number\n    first = second = float('inf')\n    \n    # Iterate through each number in the list\n    for x in numbers:\n        # Update the smallest number if the current number is smaller\n        if x < first:\n            second = first  # Move the current smallest to second\n            first = x  # Update first with the new smallest number\n        # Update the second smallest if the current number is between first and second\n        elif first < x < second:\n            second = x\n    \n    # If second still equals infinity, it means there's no second smallest number\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(arr):\n    # Convert the list to a set to remove duplicates\n    arr = set(arr)\n    # Convert the set back to a list and sort it\n    arr = list(arr)\n    arr.sort()\n    # Return the second element if the list has at least two elements, otherwise return None\n    return arr[1] if len(arr) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Sort the list in ascending order\n    numbers.sort()\n    # Initialize the second smallest number to None\n    second_smallest = None\n    # Iterate through the sorted list\n    for num in numbers:\n        # Check if the number is greater than the smallest number and not equal to it\n        if num > min(numbers) and (second_smallest is None or num < second_smallest):\n            # Update the second smallest number\n            second_smallest = num\n    return second_smallest", "matching_cluster_idx": -1}, {"solution": "def second_smallest(numbers):\n    # Check if the list has fewer than 2 elements\n    if len(numbers) < 2:\n        return None\n    \n    # Initialize the first and second smallest to None\n    first, second = None, None\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Update the first smallest if found smaller than current first\n        if first is None or num < first:\n            first, second = num, first\n        # Update the second smallest if num is greater than first but smaller than second\n        elif (second is None or num < second) and num != first:\n            second = num\n    \n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Convert the list to a set to remove duplicates and then back to a list\n    unique_numbers = list(set(numbers))\n    \n    # If there are less than 2 unique numbers, return None as there's no second smallest\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Sort the unique numbers list\n    unique_numbers.sort()\n    \n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Check if the list has less than 2 unique elements\n    if len(set(numbers)) < 2:\n        return None  # Return None if not enough unique elements\n    # Remove duplicates and sort the list\n    unique_numbers = sorted(set(numbers))\n    # Return the second element, which is the second smallest\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Check if the list contains at least two distinct elements\n    if len(numbers) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest to None\n    smallest = second_smallest = float('inf')\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Update the smallest and second smallest values\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    # Check if a valid second smallest was found\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize minimum and second_minimum with None\n    minimum, second_minimum = None, None\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Update minimum and second_minimum accordingly\n        if minimum is None or num < minimum:\n            second_minimum = minimum\n            minimum = num\n        elif (second_minimum is None or num < second_minimum) and num != minimum:\n            second_minimum = num\n    \n    # Return the second smallest number if found, else return None\n    return second_minimum", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    # Sort the set to find the second smallest number\n    sorted_numbers = sorted(unique_numbers)\n    # Return the second smallest number if it exists, otherwise return None\n    return sorted_numbers[1] if len(sorted_numbers) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Initialize the minimum and second minimum to None\n    min1 = min2 = None\n    \n    # Iterate through each number in the list\n    for x in numbers:\n        # Check if the number is None or less than the current min1\n        if min1 is None or x < min1:\n            # Update min2 to the current min1 and update min1 to the current number\n            min2 = min1\n            min1 = x\n        # Check if the number is not equal to min1 and is smaller than the current min2\n        elif (min2 is None or x < min2) and x != min1:\n            # Update min2 to the current number\n            min2 = x\n    \n    # Return the second smallest number\n    return min2", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Use set to remove duplicates and then convert back to list\n    numbers = list(set(numbers))\n    # Check if there are at least two unique numbers\n    if len(numbers) < 2:\n        return None\n    # Initialize first and second smallest to positive infinity\n    first, second = float('inf'), float('inf')\n    # Iterate through the list to find the smallest and second smallest numbers\n    for x in numbers:\n        if x <= first:\n            first, second = x, first\n        elif x < second:\n            second = x\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest elements to None\n    smallest = second_smallest = None\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # If the current number is None, or the smallest is None, update the smallest\n        if smallest is None or num < smallest:\n            second_smallest = smallest\n            smallest = num\n        # If the current number is not equal to the smallest and is either None or greater than the second smallest, update the second smallest\n        elif num != smallest and (second_smallest is None or num < second_smallest):\n            second_smallest = num\n    \n    # Return the second smallest number found\n    return second_smallest", "matching_cluster_idx": 2}, {"solution": "def second_smallest(list1):\n    # Remove duplicates by converting the list to a set\n    list1 = list(set(list1))\n    \n    # Sort the list in ascending order\n    list1.sort()\n    \n    # Return the second smallest element if it exists, otherwise return None\n    if len(list1) < 2:\n        return None\n    else:\n        return list1[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Initialize both first and second smallest to None\n    first, second = None, None\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # If the number is smaller than 'first' (or if 'first' is None), update 'first' and 'second'\n        if first is None or num < first:\n            first, second = num, first\n        # If the number is between 'first' and 'second' (or if 'second' is None), update 'second'\n        elif (second is None or num < second) and num != first:\n            second = num\n    \n    # Return the second smallest number found\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Remove duplicate numbers by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If there are fewer than 2 unique numbers, return None (not enough elements)\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Convert the set back to a list and sort it\n    sorted_numbers = list(unique_numbers)\n    sorted_numbers.sort()\n    \n    # Return the second element from the sorted list\n    return sorted_numbers[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": 80.04672897196262, "dps_norm": 29.23076923076923, "pass@1": 36.0, "profiled": [{"solution": "def count_reverse_pairs(mylist):\n    # Initialize a counter for reverse pairs\n    count = 0\n    \n    # Iterate over each pair of elements in the list\n    for i in range(len(mylist)):\n        for j in range(i + 1, len(mylist)):\n            # Check if one string is the reverse of the other\n            if mylist[i] == mylist[j][::-1]:\n                count += 1\n    \n    # Return the total count of reverse pairs found\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    # Use dictionary to store the frequency of reversed strings\n    reversed_freq = {}\n    count = 0\n    \n    for s in string_list:\n        # Reverse the current string\n        reversed_str = s[::-1]\n        \n        # If the reversed string is already in the dictionary, increment the count\n        if reversed_str in reversed_freq:\n            count += reversed_freq[reversed_str]\n        \n        # Increment the frequency of the current string in the dictionary\n        if s in reversed_freq:\n            reversed_freq[s] += 1\n        else:\n            reversed_freq[s] = 1\n    \n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(arr):\n    count = 0  # Initialize count of reverse pairs\n    for i in range(len(arr)):  # Iterate through the list\n        for j in range(i + 1, len(arr)):  # Compare with subsequent elements\n            # Check if the current element is the reverse of the subsequent element\n            if arr[i][::-1] == arr[j]:\n                count += 1  # Increment count if a reverse pair is found\n    return count  # Return the total count of reverse pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    # Initialize a counter for reverse pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Iterate through each element after the current one\n        for j in range(i + 1, len(arr)):\n            # Check if the current element is the reverse of any following element\n            if arr[i][::-1] == arr[j]:\n                # If so, increment the counter\n                count += 1\n    \n    # Return the total count of reverse pairs found\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    # Initialize count to 0\n    count = 0\n    \n    # Iterate through each word in the list\n    for i in range(len(words)):\n        # Iterate through each word in the list after the current word\n        for j in range(i + 1, len(words)):\n            # Check if the current word is the reverse of the next word\n            if words[i] == words[j][::-1]:\n                count += 1  # Increment count if reverse pair is found\n    \n    return count  # Return the total count of reverse pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    # Initialize a counter for reverse pairs\n    count = 0\n    \n    # Iterate through each string in the list\n    for i in range(len(str_list)):\n        # Iterate through the remaining strings in the list\n        for j in range(i + 1, len(str_list)):\n            # Check if one string is the reverse of the other\n            if str_list[i] == str_list[j][::-1]:\n                # If so, increment the counter\n                count += 1\n                \n    # Return the total count of reverse pairs found\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(a):\n    # Count the number of reverse pairs in the list\n    return sum(a[i] == ''.join(reversed(a[j])) for i in range(len(a)) for j in range(i + 1, len(a)))", "matching_cluster_idx": -1}, {"solution": "def count_reverse_pairs(list):\n    # Initialize the count of reverse pairs\n    res = 0\n    \n    # Iterate through the list to compare each string with the rest\n    for i in range(len(list)):\n        for j in range(i + 1, len(list)):\n            # Check if the current string is the reverse of another string in the list\n            if list[i] == list[j][::-1]:\n                # Increment the count if a pair is found\n                res += 1\n                \n    # Return the total count of reverse pairs\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    # Initialize count to 0\n    count = 0\n    \n    # Iterate over each string in the list\n    for i in range(len(str_list)):\n        # Compare the current string with all subsequent strings in the list\n        for j in range(i + 1, len(str_list)):\n            # Check if the reverse of the current string matches any subsequent string\n            if str_list[i] == str_list[j][::-1]:\n                # If a match is found, increment the count\n                count += 1\n                \n    # Return the total count of reverse pairs found\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    # Initialize a counter to keep track of reverse pairs\n    count = 0\n    \n    # Loop through each word in the list\n    for i in range(len(word_list)):\n        # Loop through each word again starting from the next word\n        for j in range(i + 1, len(word_list)):\n            # Check if the current word is the reverse of the other word\n            if word_list[i] == word_list[j][::-1]:\n                # If they are, increment the counter\n                count += 1\n    \n    # Return the total count of reverse pairs\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(a):\n    # Initialize a counter for reverse pairs\n    count = 0\n    \n    # Iterate over each string in the list\n    for i in range(len(a)):\n        # Iterate over each string after the current one\n        for j in range(i + 1, len(a)):\n            # Check if the string at index i is the reverse of the string at index j\n            if a[i] == a[j][::-1]:\n                # If so, increment the counter\n                count += 1\n                \n    # Return the total count of reverse pairs\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    # Iterate through the list\n    for i in range(0, len(input_list)):\n        # Compare each element with the rest of the elements in the list\n        for j in range(i + 1, len(input_list)):\n            # Check if the current element is the reverse of the element at index j\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    # Count the number of pairs of strings that are reverses of each other\n    return sum(1 for i in range(len(string_list)) for j in range(i + 1, len(string_list)) if string_list[i][::-1] == string_list[j])", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    # Initialize a count for reverse pairs\n    count = 0\n    # Iterate through each string in the list\n    for i in range(len(string_list)):\n        # Iterate through each string after the current one\n        for j in range(i + 1, len(string_list)):\n            # Check if the current string is the reverse of another string in the list\n            if string_list[i] == string_list[j][::-1]:\n                # If true, increment the count\n                count += 1\n    # Return the total count of reverse pairs\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    # Count the number of pairs where one string is the reverse of another\n    return sum([1 for i in range(len(str_list)) for j in range(i + 1, len(str_list)) if str_list[i] == str_list[j][::-1]])", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(test_list):\n    # Initialize counter for reverse pairs\n    res = 0\n    # Iterate through each pair of strings in the list\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            # Check if one string is the reverse of the other\n            if test_list[i] == test_list[j][::-1]:\n                res += 1\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    reverse_count = 0\n    for i in range(len(word_list)):\n        for j in range(i + 1, len(word_list)):\n            # Check if one word is the reverse of another\n            if word_list[i] == word_list[j][::-1]:\n                reverse_count += 1\n    return reverse_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    # Initialize a counter to keep track of the number of reverse pairs\n    cnt = 0\n    \n    # Iterate through the string list\n    for i in range(len(string_list)):\n        # For each string, check all other strings in the list\n        for j in range(i + 1, len(string_list)):\n            # Check if the current string is the reverse of another string\n            if string_list[i] == string_list[j][::-1]:\n                # If it is, increment the counter\n                cnt += 1\n    \n    # Return the total count of reverse pairs\n    return cnt", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strlist):\n    # Create a dictionary to store the reverse strings and their counts\n    strdict = {}\n    count = 0\n    \n    # Iterate through the list of strings\n    for i in range(len(strlist)):\n        # Get the reverse of the current string\n        strv = strlist[i][::-1]\n        \n        # Check if the reversed string exists in the dictionary\n        if strv in strdict:\n            # Increment the count for this reversed string\n            count += strdict[strv]\n        \n        # Add the current string to the dictionary with its count\n        strdict[strlist[i]] = strdict.get(strlist[i], 0) + 1\n    \n    # Return the total count of reverse string pairs\n    return count", "matching_cluster_idx": 11}, {"solution": "def count_reverse_pairs(string_list):\n    # Initialize a counter for reverse pairs\n    count = 0\n    \n    # Iterate over each word in the list\n    for i in range(len(string_list)):\n        # Iterate over each word that comes after the current word\n        for j in range(i + 1, len(string_list)):\n            # Check if the current word is the reverse of the next word\n            if string_list[i] == string_list[j][::-1]:\n                # Increment the counter if a reverse pair is found\n                count += 1\n                \n    # Return the total count of reverse pairs\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 59.54633204633204, "dps_norm": 71.875, "pass@1": 97.0, "profiled": [{"solution": "def unique_sublists(lst):\n    # Using dict comprehension to count occurrences of each sublist\n    return {tuple(x): lst.count(x) for x in lst}", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(input_list):\n    # Initialize an empty dictionary to store the counts of each tuple\n    occurrences = {}\n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple, as tuples are hashable and can be dictionary keys\n        current_tuple = tuple(sublist)\n        # If the tuple is not already in the dictionary, add it with a count of 1\n        if current_tuple not in occurrences:\n            occurrences[current_tuple] = 1\n        # If the tuple is already in the dictionary, increment its count by 1\n        else:\n            occurrences[current_tuple] += 1\n    # Return the dictionary containing tuples and their counts\n    return occurrences", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    # Create a dictionary to store the tuples and their frequency\n    list_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple so it can be a dictionary key\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in list_dict:\n            list_dict[tuple_sublist] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            list_dict[tuple_sublist] = 1\n    \n    # Return the dictionary containing the tuples and their frequencies\n    return list_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    # Initialize a dictionary to store count of each tuple form of sublist\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple and count its occurrences\n        # Use .get() method to avoid KeyError and set default count to 0\n        count_dict[tuple(sublist)] = count_dict.get(tuple(sublist), 0) + 1\n    \n    # Return the dictionary containing tuples and their counts\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Convert each sublist in the list to a tuple and store in a dictionary with count\n    res = {tuple(sub): lst.count(sub) for sub in lst}\n    return res", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(lst):\n    # Create a dictionary to store the frequency of each tuple\n    res = {}\n    \n    # Iterate over each sublist in the list\n    for sub in lst:\n        # Convert the sublist to a tuple and count its occurrences\n        res[tuple(sub)] = res.get(tuple(sub), 0) + 1\n    \n    # Return the dictionary containing tuples and their frequencies\n    return res", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(given_list):\n    # Create an empty dictionary to store the result\n    result = {}\n    # Iterate over the given list\n    for sublist in given_list:\n        # Convert each sublist to a tuple and count its occurrences\n        # Using the tuple as a key in the dictionary\n        result.setdefault(tuple(sublist), 0)\n        result[tuple(sublist)] += 1\n    return result", "matching_cluster_idx": 4}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    # Dictionary to store the frequency of each tuple\n    freq = defaultdict(int)\n    \n    # Convert each sublist to a tuple and count its occurrences\n    for sublist in lst:\n        # Convert sublist to a tuple and increment its count in the dictionary\n        freq[tuple(sublist)] += 1\n    \n    # Convert defaultdict back to a regular dictionary\n    return dict(freq)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    # Create an empty dictionary to store the result\n    result = {}\n    # Iterate over each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple since lists are not hashable\n        tuple_version = tuple(sublist)\n        # If the tuple is already in the dictionary, increment its count\n        if tuple_version in result:\n            result[tuple_version] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            result[tuple_version] = 1\n    # Return the dictionary with sublists as tuples and their counts\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(input_list):\n    # Convert each sublist in the list to a tuple and count their occurrences\n    sublists_count = {tuple(sublist): input_list.count(sublist) for sublist in input_list}\n    return sublists_count", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(sublist):\n    # Use a dictionary to store the count of each tuple version of a sublist\n    sublist_count = {}\n    # Iterate over each sublist in the provided list\n    for sublist in sublist:\n        # Convert the sublist to a tuple to make it hashable and add to the dictionary\n        # Increment the count for this tuple, starting at 0 if it's not already in the dictionary\n        sublist_count[tuple(sublist)] = sublist_count.get(tuple(sublist), 0) + 1\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    # Create a dictionary to store the count of each unique sublist\n    count_dict = {}\n    # Iterate over each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be used as dictionary keys)\n        tuple_form = tuple(sublist)\n        # If the tuple is not already a key in the dictionary, add it with a count of 0\n        count_dict[tuple_form] = count_dict.get(tuple_form, 0) + 1\n    # Return the dictionary containing the counts of each unique sublist\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list1):\n    # Create an empty dictionary to store tuples as keys and their counts as values\n    res = {}\n    # Iterate through each sublist in the input list\n    for ele in list1:\n        # Convert the sublist to a tuple and assign it a count of 1 if it's not already in the dictionary,\n        # otherwise increment the existing count\n        res[tuple(ele)] = res.get(tuple(ele), 0) + 1\n    # Return the resulting dictionary\n    return res", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list1):\n    result = {}\n    # Iterate through each sublist in the input list\n    for sublist in list1:\n        # Convert sublist to a tuple and check its occurrence\n        if tuple(sublist) in result:\n            result[tuple(sublist)] += 1\n        else:\n            result[tuple(sublist)] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list1):\n    # Create a dictionary to store the count of each unique sublist\n    result = dict()\n    \n    # Iterate through each sublist in the input list\n    for sublist in list1:\n        # Convert the sublist to a tuple to make it hashable and thus usable as a dictionary key\n        t = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if t in result:\n            result[t] += 1\n        else:\n            # Otherwise, add the tuple to the dictionary with a count of 1\n            result[t] = 1\n    \n    # Return the dictionary containing the count of each unique sublist\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Use a dictionary to count occurrences of list tuples\n    result = {}\n    for sublist in lst:\n        # Convert list to tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        # Count the occurrences\n        result[tuple_sublist] = result.get(tuple_sublist, 0) + 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(list1):\n    # Initialize an empty dictionary to store the result\n    dict1 = {}\n    # Iterate through each list in the input list\n    for sublist in list1:\n        # Convert the sublist to a tuple and store it in the dictionary\n        # Increment the count of this tuple in the dictionary\n        dict1[tuple(sublist)] = dict1.get(tuple(sublist), 0) + 1\n    # Return the dictionary containing tuples and their counts\n    return dict1", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Convert each list in the input list to a tuple and count occurrences\n    return {tuple(i): lst.count(i) for i in lst}", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(lists):\n    # Convert each sublist in the list to a tuple\n    tuples = [tuple(i) for i in lists]\n    # Create a dictionary to store tuples and their counts\n    return dict((x, tuples.count(x)) for x in set(tuples))", "matching_cluster_idx": 2}, {"solution": "def unique_sublists(sub_li):\n    # Initialize an empty dictionary to store the results\n    result = {}\n    \n    # Iterate through each sublist in the list of lists\n    for sub in sub_li:\n        # Convert the sublist to a tuple since lists are not hashable\n        temp = tuple(sub)\n        \n        # Check if the tuple is already in the dictionary\n        if temp in result:\n            # If it is, increment its count\n            result[temp] += 1\n        else:\n            # If it's not, add it with a count of 1\n            result[temp] = 1\n    \n    # Return the dictionary with tuples as keys and their counts as values\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 85.47445255474453, "dps_norm": 80.625, "pass@1": 92.0, "profiled": [{"solution": "def unique_Element(lst):\n    # Check if the length of the set of the list is equal to 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    # Check if all elements in the list are the same\n    return all(input_list[i] == input_list[0] for i in range(len(input_list)))", "matching_cluster_idx": 2}, {"solution": "def unique_Element(nums):\n    # Use a set to find unique elements\n    s = set(nums)\n    # Check if the size of the set is 1 (all elements are the same)\n    return len(s) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list1):\n    # Convert the list to a set and check if the length is 1\n    return len(set(list1)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the set of the list contains only one unique element\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the list contains only one distinct element\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(list1):\n    # Check if all elements in the list are the same by comparing the first element with the rest\n    return all(list1[i] == list1[0] for i in range(len(list1)))", "matching_cluster_idx": 2}, {"solution": "def unique_Element(test_list):\n    # Use set() to remove duplicates and check if the length of the set is 1\n    res = len(set(test_list)) == 1\n    return res", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the length of the set created from the list is 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Use a set to find unique elements and check if there is only one unique element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the length of the set of numbers is equal to 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the length of the set created from the list is equal to 1\n    # A set in Python does not allow duplicate elements\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the set of numbers has only one unique element\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(input_list):\n    # Use a set to find unique elements\n    unique_elements = set(input_list)\n    # Return True if the number of unique elements is 1, False otherwise\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if all elements in the list are equal\n    return all(nums[0] == num for num in nums)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(nums):\n    # Check if the number of unique elements in the list is equal to 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the set of numbers has a length of 1, meaning all elements are the same\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Check if the number of unique elements in the list is exactly 1\n    if len(set(nums)) == 1:\n        return True\n    return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates and check if its length is 1\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(test_list):\n    # Check if all elements in the list are the same by comparing the set of the list with a set containing the first element\n    res = len(set(test_list)) == 1\n    return res", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 99.0, "profiled": [{"solution": "def number_ctr(str):\n    num = 0  # Initialize a counter for digits\n    for i in str:  # Loop through each character in the string\n        if i.isdigit():  # Check if the character is a digit\n            num += 1  # Increment the digit counter\n    return num  # Return the total count of digits", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    # Initialize a counter for digits\n    c = 0\n    # Iterate over each character in the string\n    for char in string:\n        # Check if the character is a digit\n        if char.isdigit():\n            c += 1\n    # Return the count of digits\n    return c", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    ctr = 0\n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it's a digit\n            ctr += 1\n    # Return the total count of digits\n    return ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    # Initialize a counter to zero\n    ctr = 0\n    # Iterate over each character in the string\n    for char in str1:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it's a digit\n            ctr += 1\n    # Return the total count of digits\n    return ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(S):\n    # Initialize a counter for digits\n    dig_ctr = 0\n    # Iterate through each character in the string\n    for ele in S:\n        # Check if the character is a digit\n        if ele.isdigit():\n            # Increment the digit counter\n            dig_ctr += 1\n    # Return the total count of digits\n    return dig_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    # Initialize a counter to zero\n    num = 0\n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if the character is a digit\n            num += 1\n    # Return the total count of digits\n    return num", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    # Use the sum function with a generator expression to count digits\n    return sum(char.isdigit() for char in str1)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for i in range(len(s)):\n        # Check if the character is a digit\n        if s[i].isdigit():\n            # Increment the counter if it is a digit\n            count += 1\n    \n    # Return the total count of digits\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(st): \n    count = 0  # Initialize counter to 0\n    for i in st: \n        if i.isdigit():  # Check if the character is a digit\n            count += 1  # Increment counter if it is a digit\n    return count  # Return the total count of digits", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    # Use a generator expression to count digits in the string\n    return sum(c.isdigit() for c in str)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    cnt = 0\n    # Iterate through each character in the string\n    for i in s:\n        # Check if the character is a digit using isdigit() method\n        if i.isdigit():\n            # Increment the counter if the character is a digit\n            cnt += 1\n    # Return the total count of digits\n    return cnt", "matching_cluster_idx": 2}, {"solution": "def number_ctr(n):\n    # Initialize a counter for digits\n    number_ctr = 0\n    # Iterate through each character in the string\n    for i in range(len(n)):\n        # Check if the character is a digit using isdigit() method\n        if n[i].isdigit():\n            number_ctr += 1\n    # Return the count of digits\n    return number_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    # Initialize a counter for digits\n    number_ctr = 0\n    # Iterate through each character in the string\n    for char in str1:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it is a digit\n            number_ctr += 1\n    # Return the total count of digits\n    return number_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    # Initialize a counter to count the number of digits\n    counter = 0\n    # Iterate through each character in the string\n    for i in string:\n        # Check if the character is a digit\n        if i.isdigit():\n            # Increment the counter if it is a digit\n            counter += 1\n    # Return the total count of digits\n    return counter", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    # Initialize a counter for digits\n    total = 0\n    # Iterate through each character in the string\n    for char in str1:\n        # Check if the character is a digit\n        if char.isdigit():\n            total += 1\n    # Return the total count of digits\n    return total", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    # Initialize a counter to zero\n    n_ctr = 0\n    \n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it is a digit\n            n_ctr += 1\n            \n    # Return the total count of digits\n    return n_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    # Initialize a counter for digits\n    num_ctr = 0\n    # Iterate through each character in the string\n    for i in str1:\n        # Check if the character is a digit\n        if i.isdigit():\n            num_ctr += 1\n    # Return the total count of digits\n    return num_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str1):\n    # Count the number of digits in the string using a generator expression\n    return sum(c.isdigit() for c in str1)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(text):\n    # Initialize a counter for digits\n    count = 0\n    \n    # Iterate through each character in the text\n    for i in text:\n        # Check if the character is a digit\n        if i.isdigit():\n            # Increment the counter if it is a digit\n            count += 1\n    \n    # Return the total count of digits\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    # Initialize counter to 0\n    ctr = 0\n    # Iterate through each character in the string\n    for char in str:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if the character is a digit\n            ctr += 1\n    # Return the total count of digits\n    return ctr", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 84.4392523364486, "dps_norm": 80.0, "pass@1": 95.0, "profiled": [{"solution": "def pair_wise(input_list):\n    # Use list comprehension to generate pairs of consecutive items\n    result = [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]\n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_wise(test_list):\n    # Use list comprehension with zip to create pairs of consecutive items\n    res = list(zip(test_list, test_list[1:]))\n    return res", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive items\n    # Starting from the first element and stepping by 1\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(nums):\n    # Initialize an empty list to store the pairs of consecutive items\n    result = []\n    # Iterate through the list, stopping one element before the end\n    for i in range(len(nums) - 1):\n        # Append the current item and the next item as a tuple\n        result.append((nums[i], nums[i + 1]))\n    # Return the list of tuples\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(l):\n    # Use list comprehension to iterate through pairs of consecutive elements\n    result = [(l[i], l[i + 1]) for i in range(len(l) - 1)]\n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_wise(test_list):\n    # Create a list of pairs using list comprehension\n    res = [(x, y) for x, y in zip(test_list, test_list[1:])]\n    return res", "matching_cluster_idx": 4}, {"solution": "def pair_wise(test_list):\n    # Using list comprehension to create pairs of consecutive elements\n    res = [(test_list[idx], test_list[idx + 1]) for idx in range(len(test_list) - 1)]\n    return res", "matching_cluster_idx": 3}, {"solution": "from itertools import islice, tee\ndef pair_wise(nums):\n    # Create two iterators from the input list\n    a, b = tee(nums)\n    # Advance the second iterator by one element\n    next(b, None)\n    # Use zip to pair elements from the two iterators\n    return list(zip(a, b))", "matching_cluster_idx": 5}, {"solution": "from itertools import pairwise\ndef pair_wise(nums):\n    # Use pairwise from itertools to generate all consecutive pairs\n    return list(pairwise(nums))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to iterate over pairs of consecutive elements in the list\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "from itertools import islice, tee\ndef pair_wise(iterable):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    iterable (list): The input list of items.\n    \n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    # Create two iterators, one to take each element from the iterable and one that starts one item ahead\n    a, b = tee(iterable, 2)\n    # Skip the first item in the second iterator using islice\n    next(b, None)\n    # Use zip to pair items from both iterators and return as a list\n    return list(zip(a, b))", "matching_cluster_idx": 5}, {"solution": "from itertools import islice, tee\ndef pair_wise(lst):\n    # Check if the input list is empty\n    if not lst:\n        return []\n    \n    # Create two iterators, one advanced by one element\n    iter1, iter2 = tee(iter(lst))\n    next(iter2, None)\n    \n    # Create a list of tuples containing consecutive elements\n    pairs = list(zip(iter1, iter2))\n    return pairs", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    # Use zip to pair each element with its next one, then convert to list\n    return list(zip(items[:-1], items[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(nums):\n    # Use zip to create pairs of consecutive items in the list\n    res = list(zip(nums, nums[1:]))\n    return res", "matching_cluster_idx": 5}, {"solution": "def pair_wise(array):\n    # Initialize an empty list to store the pairs\n    res = []\n    # Iterate through the array using the enumerate function to get indices and values\n    for i in range(len(array)):\n        # Check if the current index is not the last index\n        if i != len(array) - 1:\n            # Append a tuple of the current element and the next element to the result list\n            res.append((array[i], array[i + 1]))\n    # Return the list of pairs\n    return res", "matching_cluster_idx": 1}, {"solution": "def pair_wise(test_list):\n    # Use list comprehension with zip to generate pairs of consecutive elements\n    res = [(test_list[idx], test_list[idx + 1]) for idx in range(len(test_list) - 1)]\n    return res", "matching_cluster_idx": 3}, {"solution": "def pair_wise(nums):\n    # Use zip to create pairs of consecutive items\n    return list(zip(nums[:-1], nums[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to iterate through the list with a step of 1\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(test_list):\n    # Using zip to create pairs of consecutive elements\n    res = list(zip(test_list, test_list[1:]))\n    return res", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Use list comprehension and zip to create pairs of consecutive elements\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 85.75999999999999, "dps_norm": 62.85714285714286, "pass@1": 86.0, "profiled": [{"solution": "def odd_position(nums):\n    # Loop through the list, considering only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the current odd index is odd\n        if nums[i] % 2 == 0:\n            # If an even number is found at an odd index, return False\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, focusing on odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, considering only odd indices\n    for x in range(1, len(nums), 2):\n        # Check if the element at the odd index is not odd\n        if nums[x] % 2 == 0:\n            # Return False if any odd index does not contain an odd number\n            return False\n    # Return True if all odd indices contain odd numbers\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking elements at odd indices\n    for i in range(1, len(nums), 2):\n        # If an odd index has an even number, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all checks pass, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list using enumerate to get both index and value\n    for i, x in enumerate(nums):\n        # Check if the index is odd and the number at the index is not odd\n        if i % 2 != 0 and x % 2 == 0:\n            return False\n    # Return True if all conditions are satisfied\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking elements at odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the element at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # Return True if all elements at odd indices are odd\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices (1, 3, 5, ...)\n    for i in range(1, len(nums), 2):\n        # If the value at an odd index is not odd, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all odd-index values are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list using index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is not odd\n        if index % 2 == 1 and value % 2 == 0:\n            # Return False if the condition is met\n            return False\n    # Return True if no such condition is met in the list\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    # Iterate over the list with index\n    for i in range(len(nums)):\n        # Check if the index is odd and the number at that index is even\n        if i % 2 != 0 and nums[i] % 2 == 0:\n            return False\n    # If all checks pass, return True\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking elements at odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the element at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # If all elements at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, skipping the first element and checking every second element\n    for i in range(1, len(nums), 2):\n        # Check if the current element at an odd index is not an odd number\n        if nums[i] % 2 == 0:\n            # Return False if the condition is not met\n            return False\n    # Return True if all conditions are met\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking each odd index\n    for i in range(1, len(nums), 2):\n        # Check if the number at the current index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # If all odd indices have odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the current odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # If the loop completes without returning False, all odd indices contain odd numbers\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list using enumerate to get both index and value\n    for i, x in enumerate(nums):\n        # Check if the index is odd and the number at that index is even\n        if i % 2 != 0 and x % 2 == 0:\n            return False  # Return False if an odd index contains an even number\n    return True  # Return True if all odd indices contain odd numbers", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    # Check if every odd index contains an odd number\n    return all(x % 2 for x in nums[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking elements at odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the element at an odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # Return True if all odd-index elements are odd\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list using enumerate to get both index and value\n    for i, x in enumerate(nums):\n        # Check if the index is odd and the number is not odd\n        if i % 2 != 0 and x % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Iterate over each element in the list except the first one\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Loop through the list using range and step to check only odd indices\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Check each element at an odd index to see if it's an odd number\n    return all(x % 2 for i, x in enumerate(nums) if i % 2)", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/781": {"dps": 71.61417322834646, "dps_norm": 62.0, "pass@1": 88.0, "profiled": [{"solution": "import math\ndef count_divisors(n):\n    # Initialize count of divisors\n    c = 0\n    # Iterate over possible divisors\n    for i in range(1, int(math.sqrt(n)) + 1):\n        # If i divides n, increment count\n        if n % i == 0:\n            c += 1\n            # If i is not the square root of n, increment count for the complement divisor\n            if i != n // i:\n                c += 1\n    # Check if count of divisors is even\n    return c % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize a counter to keep track of divisors\n    i = 1\n    count = 0\n    # Iterate from 1 to n to find divisors\n    while i <= n:\n        if n % i == 0:\n            # If i is a divisor, increment the count\n            count += 1\n        i += 1\n    # Return True if the count of divisors is even, False otherwise\n    if count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": -1}, {"solution": "def count_divisors(n):\n    # Initialize count of divisors\n    count = 0\n    \n    # Iterate through possible divisors\n    for i in range(1, int(n**0.5) + 1):\n        # If 'i' is a divisor of 'n'\n        if n % i == 0:\n            # If both divisors are the same, increment count by 1\n            if i == n // i:\n                count += 1\n            else:\n                # If different, increment count by 2\n                count += 2\n                \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize divisor count to 0\n    cnt = 0\n    \n    # Iterate from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            cnt += 1\n    \n    # Return True if the count of divisors is even, False otherwise\n    return (cnt % 2 == 0)", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the number of divisors\n    divisor_count = 0\n    \n    # Iterate through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        # If i divides n evenly, it is a divisor\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the number of divisors is even\n    if divisor_count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize counter for divisors\n    count = 0\n    \n    # Iterate through possible divisors up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # Check if the corresponding divisor (n // i) is different\n            if n // i != i:\n                # If it's different, increment count again\n                count += 1\n                \n    # Check if the total count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    # Loop through possible divisors up to the square root of n\n    i = 1\n    while i * i <= n:\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If divisors are the same, increment count by 1\n            if i == n // i:\n                count += 1\n            # If divisors are different, increment count by 2\n            else:\n                count += 2\n        i += 1\n    # Return True if count is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "from math import sqrt\ndef count_divisors(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Iterate from 1 to the square root of n\n    for i in range(1, int(sqrt(n)) + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If i and n//i are different, increment count again\n            if i != n // i:\n                count += 1\n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    divisor_count = 0\n    \n    # Iterate through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the number of divisors is even\n    if divisor_count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    # Initialize the count of divisors\n    divisor_count = 0\n    \n    # Loop through potential divisors up to the square root of n\n    i = 1\n    while i * i <= n:\n        # If i is a divisor of n\n        if n % i == 0:\n            # If both divisors are the same, count only once\n            if i == n // i:\n                divisor_count += 1\n            else:\n                # Count both divisors\n                divisor_count += 2\n        i += 1\n    \n    # Return True if the count of divisors is even, otherwise False\n    return divisor_count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "import math\ndef count_divisors(num):\n    # Initialize count of divisors\n    cnt = 0\n    # Iterate over possible divisors\n    for i in range(1, int(math.sqrt(num)) + 1):\n        # If 'i' is a divisor of 'num'\n        if (num % i == 0):\n            # If 'i' and 'num/i' are the same, increment cnt by 1\n            if (i == num // i):\n                cnt += 1\n            else:\n                # Increment cnt by 2 for both divisors\n                cnt += 2\n    # Check if the count of divisors is even\n    if (cnt % 2 == 0):\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    c = 0\n    \n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            c += 1\n    \n    # Check if the count of divisors is even\n    return c % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Iterate over possible divisors up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        # If i is a divisor of n\n        if n % i == 0:\n            # If both divisors are the same, increment count by 1\n            if n // i == i:\n                count += 1\n            # If divisors are different, increment count by 2\n            else:\n                count += 2\n    # Check if the count of divisors is even\n    if count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):  \n    # Initialize divisor count to 0\n    divisor_count = 0\n    # Loop through possible divisors\n    for i in range(1, n + 1): \n        # If i is a divisor of n, increment divisor count\n        if n % i == 0: \n            divisor_count += 1\n    # Check if the divisor count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n): \n    # Initialize the counter\n    c = 0\n    # Loop to iterate through possible divisors\n    for i in range(1, n + 1): \n        # Check if i is a divisor of n\n        if n % i == 0: \n            # Increment counter if i is a divisor\n            c += 1\n    # Return True if the count of divisors is even, otherwise False\n    return c % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count of divisors is even\n    if count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    count = 0\n    \n    # Loop through numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If divisors are equal, increment count by 1\n            if i == n // i:\n                count += 1\n            else:\n                # Increment count by 2 if divisors are not equal\n                count += 2\n                \n    # Check if the count of divisors is even\n    if count % 2 == 0:\n        return True\n    else:\n        return False", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    divisors_count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i divides n without a remainder, it is a divisor\n        if (n % i == 0):\n            divisors_count += 1\n    \n    # Return True if the count of divisors is even, False otherwise\n    return divisors_count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n): \n    # Initialize divisor count to 0\n    count = 0\n    \n    # Iterate through possible divisors\n    for i in range(1, int(n ** 0.5) + 1): \n        if (n % i == 0): \n            # If divisors are equal, count only once\n            if (n / i == i): \n                count += 1\n            # If divisors are different, count both\n            else: \n                count += 2\n    \n    # Check if the number of divisors is even\n    if count % 2 == 0: \n        return 1\n    else: \n        return 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize count of divisors\n    c = 0\n    # Iterate from 1 to the number\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if (n % i == 0):\n            c += 1\n    # Return True if the count of divisors is even, otherwise False\n    return bool(c % 2 == 0)", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 76.86567164179104, "dps_norm": 70.0, "pass@1": 76.0, "profiled": [{"solution": "def remove_all_spaces(s):\n    # Using the join method to concatenate characters excluding spaces\n    return ''.join([char for char in s if char != ' '])", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(text):\n    # Use the replace method to substitute all whitespace characters with an empty string\n    result = text.replace(\" \", \"\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input):\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate through each character in the input string\n    for i in input:\n        # Check if the character is not a whitespace\n        if i != ' ':\n            # Append non-whitespace characters to the result string\n            result += i\n    # Return the result string without any whitespaces\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # The translate method removes all characters in the string that are present in the translation table.\n    # str.maketrans creates a translation table that can be used with str.translate to replace specified characters.\n    # Here, it is used to remove all whitespace characters.\n    return s.translate(str.maketrans('', '', ' '))", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(text):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in text:\n        # Check if the character is not a whitespace\n        if char != \" \":\n            # Append the non-whitespace character to the result string\n            result += char\n    \n    # Return the result string without any whitespaces\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(str1):\n    # Use the replace method to remove all spaces from the string\n    return str1.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces from the input string using string's replace method\n    # The replace method takes two arguments: the substring to be replaced and the substring to replace with\n    # By passing an empty string as the second argument, all occurrences of the first argument are replaced\n    input_string = input_string.replace(\" \", \"\")\n    return input_string", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str1):\n    # Using the replace method to remove all spaces from the string\n    return str1.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str1):\n    # The replace() method is used to replace all occurrences of a specified substring with another substring.\n    # In this case, it removes all spaces (' ') from the input string.\n    return str1.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(str):\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate through each character in the input string\n    for i in str:\n        # Check if the character is not a space\n        if i != ' ':\n            # If not a space, add it to the result string\n            result += i\n    # Return the result string with all spaces removed\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(text):\n    # Use the replace method to remove all whitespace characters from the string\n    return text.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(text):\n    # Use the translate method with str.maketrans to remove all spaces\n    return text.translate(str.maketrans('', '', ' '))", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(input_str):\n    # Using the join method to concatenate characters that are not spaces\n    return ''.join([char for char in input_str if char != ' '])", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(string):\n    # Remove all whitespaces from the string using replace method\n    string = string.replace(\" \", \"\")\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Initialize an empty string to store the result\n    s1 = ''\n    # Iterate through each character in the input string\n    for char in s:\n        # If the character is not a whitespace, add it to the result string\n        if char != ' ':\n            s1 = s1 + char\n    # Return the result string without any whitespaces\n    return s1", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to substitute spaces with no space character\n    result = input_string.replace(' ', '')\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to substitute all whitespace characters with an empty string\n    result_string = input_string.replace(' ', '')\n    return result_string", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Initialize an empty string to store the result\n    s1 = \"\"\n    # Iterate through each character in the input string\n    for i in s:\n        # If the character is not a space, add it to the result string\n        if i != \" \":\n            s1 += i\n    # Return the result string without any spaces\n    return s1", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(input_string):\n    # Replace all whitespace characters with no space and return the result\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 71.5807560137457, "dps_norm": 85.0, "pass@1": 81.0, "profiled": [{"solution": "def max_sum_list(list):\n    # Initialize an empty list to store the list with the maximum sum\n    max_sum_list = []\n    # Initialize the maximum sum to a very small value\n    max_sum = float('-inf')\n\n    # Iterate through each list in the list of lists\n    for lst in list:\n        # Calculate the sum of the current list\n        sum = 0\n        for i in lst:\n            sum += i\n\n        # Check if the current sum is greater than the maximum sum found so far\n        if max_sum < sum:\n            # If yes, update the maximum sum and the list with the maximum sum\n            max_sum = sum\n            max_sum_list = lst\n\n    # Return the list with the maximum sum\n    return max_sum_list", "matching_cluster_idx": 1}, {"solution": "def max_sum_list(input_list):\n    # Check if the input list is empty\n    if not input_list:\n        return None\n    \n    # Sort the list of lists based on the sum of elements in descending order\n    input_list.sort(key=lambda x: sum(x), reverse=True)\n    \n    # Return the first list from the sorted list (the one with the highest sum)\n    return input_list[0]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list1):\n    # Initialize the list with the first sublist and set max_sum to its sum\n    max_sum = sum(list1[0])\n    res = list1[0]\n    \n    # Iterate over the list of lists\n    for i in list1[1:]:\n        # Calculate the sum of the current sublist\n        cur_sum = sum(i)\n        \n        # Check if the current sum is greater than the max_sum found so far\n        if cur_sum > max_sum:\n            max_sum = cur_sum\n            res = i\n    \n    # Return the sublist with the highest sum\n    return res", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Calculate the sum of elements in each sublist and find the index of the sublist with the maximum sum\n    return lst[[sum(i) for i in lst].index(max([sum(i) for i in lst]))]", "matching_cluster_idx": 2}, {"solution": "def max_sum_list(lists):\n    # Find the maximum sum among all sublists\n    max_sum = max([sum(sublist) for sublist in lists])\n    # Return the sublist with the maximum sum\n    return [sublist for sublist in lists if sum(sublist) == max_sum][0]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef max_sum_list(lists: List[List[int]]) -> List[int]:\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=lambda x: sum(x))\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum using a generator expression\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "from copy import deepcopy\ndef max_sum_list(test_list):\n    # Using list comprehension to create a deep copy of the input list\n    res = deepcopy(test_list)\n    \n    # Sorting the copied list based on the sum of elements in each sublist in descending order\n    res.sort(key=sum, reverse=True)\n    \n    # Returning the first sublist from the sorted list, which has the highest sum\n    return res[0]", "matching_cluster_idx": 0}, {"solution": "def max_sum_list(lists):\n    # Initialize a list to keep track of lists with positive sums\n    positive_sum_lists = [lst for lst in lists if sum(lst) > 0]\n    \n    # If no positive sum lists are found, return the original list\n    if not positive_sum_lists:\n        return lists[0]\n    \n    # Return the list with the highest sum of elements\n    return max(positive_sum_lists, key=sum)", "matching_cluster_idx": 2}, {"solution": "def max_sum_list(lists):\n    # Use the max function with key parameter to find the list with the maximum sum of elements\n    max_sum_list = max(lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize max_sum to a very small number to ensure any sum of the lists will be higher\n    max_sum = float('-inf')\n    # Initialize max_index to -1 to mark that no list has been checked yet\n    max_index = -1\n    \n    # Iterate over the list of lists\n    for index, lst in enumerate(list_of_lists):\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # Check if the current sum is greater than the max_sum found so far\n        if current_sum > max_sum:\n            # Update max_sum and max_index\n            max_sum = current_sum\n            max_index = index\n    \n    # Return the list with the highest sum of elements\n    return list_of_lists[max_index]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize a variable to keep track of the maximum sum\n    max_sum = -float('inf')\n    # Initialize a variable to store the list with the maximum sum\n    result = []\n    \n    # Iterate through each list in the list of lists\n    for sublist in lst:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        # Update the maximum sum and result if the current sum is higher\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result = sublist\n    \n    # Return the list with the highest sum\n    return result", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of each sublist and find the maximum sum\n    max_sum = max(sum(lst) for lst in lists)\n    # Return the sublist that has the maximum sum\n    return [lst for lst in lists if sum(lst) == max_sum][0]", "matching_cluster_idx": 2}, {"solution": "def max_sum_list(list1):\n    # Find the list with the maximum sum of elements\n    max_element = max(list1, key=sum)\n    return max_element", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Find the list with the maximum sum of elements using max function and key parameter\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Find the list with the maximum sum of elements using the max function and a lambda function as the key\n    res = max(lst, key=lambda i: sum(i))\n    return res", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(test_list):\n    # Use a generator expression to calculate the sum of each sublist\n    # Find the sublist with the maximum sum and return it\n    res = max(test_list, key=sum)\n    return res", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Find the maximum sum among the sublists using the max function with a key that calculates the sum of each sublist\n    return max(lst, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 22.894736842105264, "dps_norm": 66.66666666666667, "pass@1": 95.0, "profiled": [{"solution": "def check_K(test_tup, K):\n    # Use the any() function to check if K is present in the tuple\n    res = any(K == ele for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_K(test_tup, K):\n    # Check if the integer K is present in the tuple test_tup\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tuple, K):\n    # Check if the element K is in the tuple test_tuple using the 'in' keyword\n    res = K in test_tuple\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if the element K is in the tuple test_tup\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Initialize a flag to False\n    res = False\n    \n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element is equal to K\n        if ele == K:\n            # If found, set the flag to True and break the loop\n            res = True\n            break\n    \n    # Return the result\n    return res", "matching_cluster_idx": 2}, {"solution": "def check_K(test_tup, K):\n    # Check if the element K is present in the tuple test_tup\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Use the 'in' keyword to check if 'K' is present in 'test_tup'\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Initialize a flag to False, assuming k is not in the tuple\n    res = False\n    # Loop through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element is equal to k\n        if ele == K:\n            # Set the flag to True and break out of the loop\n            res = True\n            break\n    # Return the result indicating whether k was found in the tuple\n    return (res)", "matching_cluster_idx": 3}, {"solution": "def check_K(test_tup, K):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Increment the counter if the element is equal to K\n        if ele == K:\n            count += 1\n    # Return True if any element was equal to K, otherwise False\n    return (count >= 1)", "matching_cluster_idx": -1}, {"solution": "def check_K(test_tup, K):\n    # Use the any() function to check if K is in the tuple\n    res = any(elem == K for elem in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_K(test_tup, K):\n    # Use the any() function to check if K is in the tuple\n    res = any(item == K for item in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_K(test_tup, K):\n    # Initialize a result variable to False\n    res = False\n    \n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element is equal to K\n        if ele == K:\n            res = True\n            break  # Exit the loop if K is found\n    \n    return res", "matching_cluster_idx": 3}, {"solution": "def check_K(test_tup, K):\n    # Check if the element K is present in the tuple test_tup\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Initialize a result variable to False\n    res = False\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element equals the target value K\n        if ele == K:\n            res = True\n            break  # Exit the loop if K is found\n    return res", "matching_cluster_idx": 3}, {"solution": "def check_K(test_tup, K):\n    # Check if the tuple contains the element K\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the current element is equal to k\n        if ele == K:\n            # Return True if k is found in the tuple\n            return True\n    # Return False if k is not found in the tuple\n    return False", "matching_cluster_idx": 3}, {"solution": "def check_K(test_tup, K):\n    # Use the any() function to check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}]}}}