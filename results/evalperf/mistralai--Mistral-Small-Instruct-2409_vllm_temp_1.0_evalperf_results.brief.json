{"date": "2024-10-19 16:32", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 82.25625421641564, "dps_norm": 78.98044554401069, "pass@1": 69.51694915254237}, "eval": {"HumanEval/9": {"dps": 74.84227129337539, "dps_norm": 72.77777777777777, "pass@1": 98.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = [float('-inf')] * len(numbers)\n    rolling_max_list = []\n\n    for i in range(len(numbers)):\n        max_so_far[i] = max(numbers[:i+1])\n        rolling_max_list.append(max_so_far[i])\n\n    return rolling_max_list", "matching_cluster_idx": 1}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    max_so_far = float('-inf')\n\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n\n    for i in range(1, len(numbers)):\n        rolling_max_list.append(max(rolling_max_list[-1], numbers[i]))\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n\n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = numbers[0]\n\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    max_value = numbers[0]\n\n    for number in numbers:\n        if number > max_value:\n            max_value = number\n        rolling_max_list.append(max_value)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = []\n    current_max = float('-inf')\n\n    for num in numbers:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_list = [numbers[0]]\n\n    for i in range(1, len(numbers)):\n        if numbers[i] > max_list[-1]:\n            max_list.append(numbers[i])\n        else:\n            max_list.append(max_list[-1])\n\n    return max_list", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    # Initialize the result list with the first element\n    rolling = [numbers[0]]\n\n    # Iterate through the list starting from the second element\n    for num in numbers[1:]:\n        # Append the maximum between the current maximum and the current number\n        rolling.append(max(rolling[-1], num))\n\n    return rolling", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = [numbers[0]]\n    for i in range(1, len(numbers)):\n        max_so_far.append(max(max_so_far[-1], numbers[i]))\n\n    return max_so_far", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 85.69767441860465, "dps_norm": 87.14285714285714, "pass@1": 98.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list first to facilitate the comparison of close elements\n    numbers.sort()\n\n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i + 1] - numbers[i]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sorting the list for easier comparison\n    numbers.sort()\n\n    # Iterate through the list and check the absolute difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    Args:\n        numbers (List[float]): List of numbers to check.\n        threshold (float): Threshold for closeness.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the list and check the difference with the next number\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list (O(n log n) complexity)\n    numbers.sort()\n\n    # Iterate over the sorted list and check the difference between consecutive elements\n    for i in range(1, len(numbers)):\n        if abs(numbers[i] - numbers[i - 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to minimize the distance checks\n    numbers.sort()\n\n    # Iterate through the list and check if any two consecutive numbers\n    # have a distance less than the threshold\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    if n < 2:\n        return False\n\n    numbers.sort()\n\n    for i in range(n - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 61.598101265822784, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    # Check if the input list is empty\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_val = sum(numbers) / len(numbers)\n\n    # Calculate the mean absolute deviation\n    mad = sum(abs(num - mean_val) for num in numbers) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n\n    mean = sum(numbers) / n\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / n", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a center point (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty\")\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    n = len(numbers)\n    mean_value = sum(numbers) / n\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    return sum(absolute_deviations) / n", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    if not numbers:\n        return 0\n\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean_value) for num in numbers]\n    return sum(deviations) / len(numbers)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the mean absolute deviation\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    if not numbers:\n        raise ValueError(\"The input list is empty\")\n\n    n = len(numbers)\n    mean_value = sum(numbers) / n\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    return sum(absolute_deviations) / n", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviation for each number\n    deviations = [abs(x - mean_value) for x in numbers]\n\n    # Calculate the mean of the absolute deviations\n    mad = sum(deviations) / len(deviations)\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    abs_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(abs_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty\")\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mean_absolute_deviation = sum(absolute_deviations) / len(numbers)\n\n    return mean_absolute_deviation", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        return 0.0\n\n    mean = sum(numbers) / n\n    return sum(abs(x - mean) for x in numbers) / n", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    n = len(numbers)\n    mean_val = sum(numbers) / n\n    absolute_deviations = [abs(x - mean_val) for x in numbers]\n    mad = sum(absolute_deviations) / n\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    if n == 0:\n        raise ValueError(\"The list of numbers cannot be empty\")\n\n    mean = sum(numbers) / n\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / n\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty\")\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviation = [abs(num - mean_value) for num in numbers]\n\n    return sum(absolute_deviation) / len(absolute_deviation)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean_value) for num in numbers]\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_val = sum(numbers) / len(numbers)\n    return sum(abs(x - mean_val) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 95.81395348837209, "dps_norm": 96.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_string)\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    lower_case_string = string.lower()\n\n    # Use a set to track distinct characters\n    distinct_chars = set()\n\n    for char in lower_case_string:\n        distinct_chars.add(char)\n\n    # The length of the set gives the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ensure case-insensitivity\n    string = string.lower()\n    # Use a set to keep track of unique characters\n    distinct_characters = set(string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case differences\n    lower_string = string.lower()\n\n    # Use a set to store unique characters\n    unique_characters = set(lower_string)\n\n    # The length of the set is the number of distinct characters\n    return len(unique_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lower_string = string.lower()\n    # Use a set to find distinct characters\n    distinct_characters = set(lower_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    lower_string = string.lower()\n\n    # Use a set to store unique characters\n    distinct_characters = set(lower_string)\n\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    lower_string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase\n    lower_string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_string)\n\n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_string)\n\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Normalize the string to lower case\n    normalized_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_characters = set(normalized_string)\n\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_case_string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_case_string)\n\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case and use a set to find distinct characters\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case sensitivity\n    lower_string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_string)\n\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ignore case sensitivity\n    string = string.lower()\n\n    # Use a set to keep track of distinct characters\n    distinct_characters = set(string)\n\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case and use a set to store distinct characters\n    distinct_chars = set(string.lower())\n\n    # The number of distinct characters is the size of the set\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lower_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(lower_string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case and use a set to keep only distinct characters\n    distinct_chars = set(string.lower())\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to consider characters case-insensitively\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    lower_string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n\n    # The length of the set is the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to track distinct characters\n    distinct_characters = set(lower_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 92.10653753026634, "dps_norm": 94.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements\")\n\n    # Sort the list to simplify the closest element search\n    numbers.sort()\n\n    # Initialize min_diff and closest_pair\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        current_diff = numbers[i + 1] - numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # First sort the list\n    numbers.sort()\n\n    # Initialize the smallest difference to a large number and the closest pair\n    smallest_difference = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    # Check all pairs\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < smallest_difference:\n            smallest_difference = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()  # Sort the list first\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    for i in range(len(numbers) - 1):\n        current_diff = numbers[i + 1] - numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    # Sort the list to ease the comparison\n    sorted_numbers = sorted(numbers)\n\n    # Initialize the minimum difference and the pair of closest elements\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    # Compare each element with the next one\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\n    # Ensure the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements\")\n\n    # Sort the list to find the minimum difference\n    numbers.sort()\n\n    # Initialize the closest pair and the minimum difference\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n\n    # Check all consecutive pairs for the minimum difference\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            closest_pair = (numbers[i], numbers[i + 1])\n            min_diff = diff\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Ensure the list is sorted to find the minimum difference\n    numbers.sort()\n\n    # Initialize the minimum difference and the pair of closest elements\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate through the sorted list to find the minimum difference\n    for i in range(len(numbers) - 1):\n        current_diff = numbers[i + 1] - numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    # Ensure the pair is returned in sorted order\n    if closest_pair[0] > closest_pair[1]:\n        closest_pair = (closest_pair[1], closest_pair[0])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\n    # Sort the list\n    sorted_numbers = sorted(numbers)\n\n    # Initialize minimum difference\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    # Iterate through the sorted list to find the minimum difference\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    numbers.sort()\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    numbers.sort()  # Sort the list\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    # Sort the list to make the comparison easier\n    numbers.sort()\n\n    # Compare each pair of adjacent numbers\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    # Sort the list to enable easy comparison of adjacent elements\n    sorted_numbers = sorted(numbers)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers\")\n\n    # Initialize the minimum difference and closest elements\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    # Sort the list (in-place) to facilitate finding the closest pair\n    numbers.sort()\n\n    # Iterate through the list to find the smallest difference\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list\n    numbers.sort()\n\n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    # Compare each pair of consecutive elements\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    min_diff = float('inf')\n    closest_pair = (0, 0)\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}]}, "HumanEval/24": {"dps": 78.2312925170068, "dps_norm": 50.0, "pass@1": 99.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(10)\n    5\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(20)\n    10\n    >>> largest_divisor(25)\n    5\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    # Start from n/2 and go down to 1, checking divisibility\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, which shouldn't happen for positive n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(22)\n    11\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    # Iterate from n//2 down to 1 to find the largest divisor\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, which shouldn't happen for positive integers > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(16)\n    8\n    >>> largest_divisor(23)\n    1\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, return 1 as the default largest divisor smaller than n", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisor smaller than n if n is less than or equal to 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case of prime numbers, 1 is the largest divisor smaller than n", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"Input must be greater than or equal to 2\")\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        return None  # or you can raise an error if you prefer\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is a prime number", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start with the largest possible number smaller than n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback if n is prime", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    1\n    >>> largest_divisor(20)\n    10\n    >>> largest_divisor(23)\n    1\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(20)\n    10\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input should be greater than 1\")\n\n    largest = 1\n    for i in range(2, n // 2 + 1):\n        if n % i == 0:\n            largest = i\n\n    return largest", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisors for numbers <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This should never be reached if n > 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, should not happen for positive integers greater than 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None\n\n    # Start with n/2 and go downwards\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(22)\n    11\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Iterate from n//2 down to 1 to find the largest divisor\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}]}, "HumanEval/26": {"dps": 92.8, "dps_norm": 97.5, "pass@1": 75.0, "profiled": [{"solution": "from typing import List\nfrom collections import defaultdict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 4, 1, 2, 2, 3, 1])\n    [3]\n    >>> remove_duplicates([1])\n    [1]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    count_dict = defaultdict(int)\n    for number in numbers:\n        count_dict[number] += 1\n\n    result = []\n    for number in numbers:\n        if count_dict[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = Counter(numbers)\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n    # Return a list of numbers that occur only once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    result = []\n\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count = Counter(numbers)\n\n    # Filter out numbers that occur more than once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    Args:\n    numbers (List[int]): Input list of integers.\n\n    Returns:\n    List[int]: List with duplicates removed.\n\n    Examples:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = Counter(numbers)\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Dictionary to count occurrences of each number\n    count_dict = {}\n    result = []\n\n    # Count occurrences of each number\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Append numbers that occur only once to the result list\n    for num in numbers:\n        if count_dict[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    result = []\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n\n    for number in numbers:\n        if count[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = {}\n    result = []\n    for num in numbers:\n        if num in seen:\n            seen[num] += 1\n        else:\n            seen[num] = 1\n\n    for num in numbers:\n        if seen[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    result = []\n\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = Counter(numbers)\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = Counter(numbers)\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = Counter(numbers)\n\n    # Filter out numbers that appear more than once\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    result = []\n\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    for num in numbers:\n        if count[num] == 1:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    result = []\n    for number in numbers:\n        if number not in count:\n            count[number] = 1\n            result.append(number)\n        elif count[number] == 1:\n            count[number] += 1\n            result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([2, 2, 3, 3, 4, 4])\n    []\n    >>> remove_duplicates([5, 6, 7, 8, 9])\n    [5, 6, 7, 8, 9]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    count = Counter(numbers)\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = {}\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            seen[number] += 1\n        else:\n            seen[number] = 1\n\n    for number in numbers:\n        if seen[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count = {}\n    result = []\n\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n\n    for number in numbers:\n        if count[number] == 1:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    from collections import Counter\n\n    # Count the occurrences of each number\n    count = Counter(numbers)\n\n    # Filter out the numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 88.10126582278481, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 92.62731481481482, "dps_norm": 81.36363636363636, "pass@1": 82.0, "profiled": [{"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    # Extract values at these indices and sort them\n    values_to_sort = sorted([l[i] for i in indices])\n    # Create a new list to store the result\n    result = l[:]\n    # Assign sorted values back to the respective indices\n    for idx, value in zip(indices, values_to_sort):\n        result[idx] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices\n    that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    values_at_thirds = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort those values\n    sorted_values = sorted(values_at_thirds)\n\n    # Replace values in the original list at indices divisible by three\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = sorted_values.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 2, 4, 8, 3, 9]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n\n    # Replace elements at indices divisible by three with the sorted values\n    for i, val in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        l[i] = val\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 3, 4, 8, 9, 2]\n    \"\"\"\n    # Extract indices that are divisible by three\n    third_indices = [i for i in range(0, len(l), 3)]\n\n    # Get values at those indices\n    third_values = [l[i] for i in third_indices]\n\n    # Sort the values\n    sorted_third_values = sorted(third_values)\n\n    # Create a copy of the list to avoid modifying the original list\n    l_prime = l.copy()\n\n    # Place sorted values back into the original indices\n    for idx, val in zip(third_indices, sorted_third_values):\n        l_prime[idx] = val\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 2, 4, 8, 3, 9]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the extracted elements\n    divisible_by_three.sort()\n\n    # Create a new list for the sorted values\n    result = l[:]\n\n    # Replace the elements at the original indices with the sorted values\n    index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = divisible_by_three[index]\n            index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n\n    # Prepare the output list\n    result = l.copy()\n\n    # Replace values at indices divisible by three with the sorted values\n    for idx, val in enumerate(sorted_elements):\n        result[idx * 3] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    third_indices_values = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the extracted values\n    sorted_third_values = sorted(third_indices_values)\n\n    # Create a new list to store the modified values\n    result = l.copy()\n\n    # Replace the values at indices divisible by 3 with the sorted values\n    for i, value in zip(range(0, len(l), 3), sorted_third_values):\n        result[i] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values\n    at the indices that are divisible by three are equal to the values of the corresponding\n    indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the extracted elements\n    sorted_third_elements = sorted(third_elements)\n\n    # Iterate over the original list and replace elements at indices divisible by 3 with sorted elements\n    result = l[:]\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third_elements.pop(0)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its\n    values at the indices that are divisible by three are equal to the values of\n    the corresponding indices of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n\n    # Copy the original list to avoid modifying it directly\n    l_copy = l[:]\n\n    # Replace the elements in l_copy at indices divisible by three with sorted elements\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_copy[i] = sorted_divisible_by_three.pop(0)\n\n    return l_copy", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort these elements\n    sorted_elements = sorted(elements_divisible_by_three)\n\n    # Create the resulting list\n    result = l[:]  # Copy the original list\n\n    # Replace elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[index]\n            index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 3, 4, 8, 9, 2]\n    \"\"\"\n    if not l:\n        return l\n\n    # Extract elements at indices divisible by 3\n    elements_at_third_indices = [l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_third_indices_elements = sorted(elements_at_third_indices)\n\n    # Create a new list with the sorted elements inserted back at the appropriate indices\n    sorted_list = l[:]\n    index = 0\n    for i in range(0, len(l), 3):\n        sorted_list[i] = sorted_third_indices_elements[index]\n        index += 1\n\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by three\n    elements_at_third_indices = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort those elements\n    sorted_third_indices_elements = sorted(elements_at_third_indices)\n\n    # Create a new list to hold the modified values\n    modified_l = l.copy()\n\n    # Replace the values at indices divisible by three with the sorted elements\n    for i, value in zip(range(0, len(l), 3), sorted_third_indices_elements):\n        modified_l[i] = value\n\n    return modified_l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    indices_divisible_by_3 = [i for i in range(len(l)) if i % 3 == 0]\n    values_divisible_by_3 = [l[i] for i in indices_divisible_by_3]\n\n    # Sort these values\n    sorted_values_divisible_by_3 = sorted(values_divisible_by_3)\n\n    # Create a list to hold the sorted elements and others as they are\n    result = l[:]\n\n    # Replace the original values at indices divisible by 3 with sorted values\n    for idx, val in zip(indices_divisible_by_3, sorted_values_divisible_by_3):\n        result[idx] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 3, 4, 8, 9, 2]\n    >>> sort_third([7, 2, 9, 5, 1, 8, 4, 6, 3])\n    [7, 2, 3, 5, 1, 8, 4, 6, 9]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    sorted_third_elements = sorted(third_elements)\n\n    # Create a list to store the result\n    result = l[:]\n\n    # Replace elements at indices divisible by three with sorted ones\n    for i, val in enumerate(sorted_third_elements):\n        result[3 * i] = val\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_divisible_by_3 = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n\n    # Create the result list with elements sorted at indices divisible by 3\n    result = l[:]\n    idx = 0\n    for i in range(len(result)):\n        if i % 3 == 0:\n            result[i] = elements_divisible_by_3[idx]\n            idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [5, 6, 3, 4, 8, 9, 2]\n    \"\"\"\n\n    # Extract elements at indices divisible by 3\n    elements_to_sort = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n\n    # Create a list to hold the final result\n    result = l[:]\n\n    # Insert the sorted elements back into the correct indices\n    for i, value in zip(range(0, len(l), 3), sorted_elements):\n        result[i] = value\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n    # Extract elements at indices divisible by three\n    elements_to_sort = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort these elements\n    elements_to_sort.sort()\n\n    # Create a new list to store the final result\n    result = l[:]\n\n    # Replace the elements at indices divisible by three with the sorted elements\n    for i in range(0, len(elements_to_sort)):\n        result[3*i] = elements_to_sort[i]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_indices_elements = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort these elements\n    sorted_third_elements = sorted(third_indices_elements)\n\n    # Create a new list with sorted elements in their respective positions,\n    # keeping other elements in their original positions\n    l_sorted = l[:]\n    index = 0\n    for i in range(0, len(l), 3):\n        l_sorted[i] = sorted_third_elements[index]\n        index += 1\n\n    return l_sorted", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_at_third_indices = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort those elements\n    sorted_elements_at_third_indices = sorted(elements_at_third_indices)\n\n    # Initialize a new list to store the result\n    result = l[:]\n\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    index = 0\n    for i in range(0, len(l), 3):\n        result[i] = sorted_elements_at_third_indices[index]\n        index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_at_third_indices = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the extracted elements\n    sorted_elements_at_third_indices = sorted(elements_at_third_indices)\n\n    # Create a result list to store the final sorted list\n    result = l[:]\n\n    # Replace elements at indices divisible by 3 with sorted elements\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements_at_third_indices[sorted_index]\n            sorted_index += 1\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n\n    >>> unique([1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5])\n    [1, 2, 3, 4, 5]\n\n    >>> unique([])\n    []\n\n    >>> unique([-1, -1, -2, -2, 0, 0, 1, 1])\n    [-2, -1, 0, 1]\n    \"\"\"\n    # Remove duplicates by converting list to a set\n    unique_elements = list(set(l))\n\n    # Sort the unique elements\n    unique_elements.sort()\n\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Remove duplicates by converting the list to a set, then sort the unique elements\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert it back to a list\n    # and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Using set to remove duplicates and then sorting the list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(l)\n    # Convert the set back to a list and sort it\n    sorted_unique_elements = sorted(unique_elements)\n    return sorted_unique_elements", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 88.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 98.0, "profiled": [{"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [5, 4, 3, 6]\n    \"\"\"\n    even_values = sorted([l[i] for i in range(0, len(l), 2)])  # Extract even indexed values and sort them\n    it = iter(even_values)\n    return [next(it) if i % 2 == 0 else l[i] for i in range(len(l))]  # Replace even indexed values with sorted ones", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements\n    even_elements = l[::2]\n\n    # Sort the even-indexed elements\n    sorted_even_elements = sorted(even_elements)\n\n    # Create a result list\n    result = l[:]  # Copy the original list\n\n    # Replace even-indexed elements in the result list with sorted elements\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_elements.pop(0)  # Pop from sorted list to keep order\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [5, 4, 3, 6]\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    result = l[:]\n    even_idx = 0\n\n    for i in range(0, len(l), 2):\n        result[i] = even_elements[even_idx]\n        even_idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    if not l:\n        return l\n\n    # Extract even indexed elements\n    even_elements = l[::2]\n    # Sort the even indexed elements\n    sorted_even_elements = sorted(even_elements)\n\n    # Initialize a list for the result\n    result = l[:]\n\n    # Iterate through the original list and replace even indexed elements with sorted elements\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_elements.pop(0)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the values at even indices\n    sorted_even_values = sorted(even_indices_values)\n\n    # Create a new list based on the input list, but with sorted even index values\n    result = l[:]\n    even_index = 0\n    for i in range(0, len(result), 2):\n        result[i] = sorted_even_values[even_index]\n        even_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list `l` and returns a list `l'` such that\n    `l'` is identical to `l` at the odd indices, while its values at the even indices\n    are equal to the values of the even indices of `l`, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return []\n\n    # Extract even indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n\n    # Construct the result list\n    result = l[:]\n    even_index = 0\n    for i in range(0, len(result), 2):\n        result[i] = even_elements[even_index]\n        even_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices\n    are equal to the values of the even indices of l, but sorted.\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    for i, e in zip(range(0, len(l), 2), even_elements):\n        l[i] = e\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([1, 3, 5, 7, 9, 2, 4, 6, 8])\n    [1, 2, 5, 4, 9, 6, 7, 8, 3]\n    \"\"\"\n    # Extract even indexed elements\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the even indexed elements\n    sorted_even_indices_values = sorted(even_indices_values)\n\n    # Reconstruct the list\n    result = l[:]\n    even_idx = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_indices_values[even_idx]\n        even_idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at even indices\n    even_values = l[::2]\n\n    # Sort the values at even indices\n    sorted_even_values = sorted(even_values)\n\n    # Combine the sorted even values with the original odd values\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(sorted_even_values[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted(l[::2])\n    result = []\n    even_index = 0\n\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n\n    # Separate even-indexed elements and odd-indexed elements\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    odd_indices = [l[i] for i in range(1, len(l), 2)]\n\n    # Sort the even-indexed elements\n    sorted_even_indices = sorted(even_indices)\n\n    # Combine the sorted even-indexed elements with the odd-indexed elements\n    result = []\n    even_idx, odd_idx = 0, 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(sorted_even_indices[even_idx])\n            even_idx += 1\n        else:\n            result.append(odd_indices[odd_idx])\n            odd_idx += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return l\n\n    # Extract the elements at even indices\n    even_elements = l[::2]\n\n    # Sort the even elements\n    even_elements.sort()\n\n    # Iterate through the original list and insert the sorted even elements\n    l_sorted = l[:]\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_sorted[i] = even_elements[even_index]\n            even_index += 1\n\n    return l_sorted", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n\n    # Extract the values at even indices\n    even_indices_values = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the values at even indices\n    sorted_even_indices_values = sorted(even_indices_values)\n\n    # Construct the result list with odd indices unchanged and even indices sorted\n    result = l.copy()\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_indices_values[even_index]\n        even_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extracting the values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    # Sorting the even indexed values\n    even_values_sorted = sorted(even_values)\n\n    # Creating a new list with sorted even indices and maintaining the odd indices\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_values_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    l_copy = l.copy()\n    even_idx = 0\n\n    for i in range(0, len(l), 2):\n        l_copy[i] = even_elements[even_idx]\n        even_idx += 1\n\n    return l_copy", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_elements = sorted(l[::2])  # Extract and sort elements at even indices\n    it = iter(even_elements)\n\n    # Create a new list, replacing even indices with sorted values\n    return [next(it) if i % 2 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return l\n\n    # Extract the even indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the even indexed elements\n    sorted_even_elements = sorted(even_elements)\n\n    # Create a new list to store the result\n    result = l[:]\n\n    # Place the sorted even indexed elements back into the result list\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even_elements[even_index]\n        even_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices_values = sorted([l[i] for i in range(0, len(l), 2)])\n    result = l.copy()\n    even_index = 0\n\n    for i in range(0, len(result), 2):\n        result[i] = even_indices_values[even_index]\n        even_index += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the values at the even indices\n    even_values = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the even values\n    sorted_even_values = sorted(even_values)\n    # Create a new list maintaining the original values at odd indices and sorted even indices\n    result = l.copy()\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result[i] = sorted_even_values[even_index]\n            even_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Separate the values at even indices and sort them\n    even_values = sorted(l[::2])\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the original list and fill in the result\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_values[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 33.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n % p using modular exponentiation to prevent overflow\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Use pow function to compute (2^n % p) efficiently\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    Args:\n    n (int): Exponent.\n    p (int): Modulus.\n\n    Returns:\n    int: 2^n % p\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Return 2^n % p using the modulo operator\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Efficient way to compute (2^n) % p using exponentiation by squaring\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Use modular exponentiation to compute 2^n mod p efficiently\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Remove vowels from the input text.\n\n    Args:\n    text (str): The input text.\n\n    Returns:\n    str: The text with vowels removed.\n\n    Examples:\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Remove vowels from the input text and return the modified text.\n\n    Args:\n        text (str): The input string from which to remove vowels.\n\n    Returns:\n        str: The input string without vowels.\n\n    Examples:\n        >>> remove_vowels('')\n        ''\n        >>> remove_vowels(\"abcdef\\nghijklm\")\n        'bcdf\\nghjklm'\n        >>> remove_vowels('abcdef')\n        'bcdf'\n        >>> remove_vowels('aaaaa')\n        ''\n        >>> remove_vowels('aaBAA')\n        'B'\n        >>> remove_vowels('zbcd')\n        'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    Remove vowels from the input text.\n\n    Args:\n        text (str): The input string to process.\n\n    Returns:\n        str: The string without vowels.\n\n    Examples:\n        >>> remove_vowels('')\n        ''\n        >>> remove_vowels(\"abcdef\\nghijklm\")\n        'bcdf\\nghjklm'\n        >>> remove_vowels('abcdef')\n        'bcdf'\n        >>> remove_vowels('aaaaa')\n        ''\n        >>> remove_vowels('aaBAA')\n        'B'\n        >>> remove_vowels('zbcd')\n        'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n\n    Args:\n        text (str): The input string from which to remove vowels.\n\n    Returns:\n        str: The input string without vowels.\n\n    Examples:\n        >>> remove_vowels('')\n        ''\n        >>> remove_vowels(\"abcdef\\nghijklm\")\n        'bcdf\\nghjklm'\n        >>> remove_vowels('abcdef')\n        'bcdf'\n        >>> remove_vowels('aaaaa')\n        ''\n        >>> remove_vowels('aaBAA')\n        'B'\n        >>> remove_vowels('zbcd')\n        'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1).intersection(set(l2))\n\n    # Convert back to a list and sort\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set operations to find the intersection of the two lists and convert it to a sorted list\n    common_elements = sorted(list(set(l1) & set(l2)))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use sets to find unique common elements\n    set1, set2 = set(l1), set(l2)\n    common_elements = sorted(set1 & set2)\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Use sets to find the intersection of the two lists, which will automatically handle uniqueness\n    common_elements = set(l1).intersection(set(l2))\n\n    # Convert the set back to a list and sort it\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find intersection of the two sets\n    common_elements = set1.intersection(set2)\n\n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set_l1, set_l2 = set(l1), set(l2)\n    common_elements = sorted(set_l1 & set_l2)\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Use set intersection to find common elements, then sort and return as a list\n    common_elements = sorted(set(l1) & set(l2))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to get unique elements and find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n\n    common_elements = set1.intersection(set2)\n\n    # Convert back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1).intersection(set(l2))\n\n    # Convert back to a list and sort\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements\n    common_elements = list(set(l1) & set(l2))\n\n    # Return sorted unique common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find intersection of two sets\n    common_elements = set1 & set2\n\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Find intersection of both lists\n    common_elements = set(l1) & set(l2)\n\n    # Return sorted unique elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find unique common elements\n    set1, set2 = set(l1), set(l2)\n\n    # Intersect the sets to find common elements\n    common_elements = set1 & set2\n\n    # Convert the set back to a list and sort it\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set_l1 = set(l1)\n    set_l2 = set(l2)\n\n    # Find intersection of both sets\n    common_elements = set_l1 & set_l2\n\n    # Return sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set_l1 = set(l1)\n    set_l2 = set(l2)\n\n    # Find intersection of two sets\n    common_elements = set_l1.intersection(set_l2)\n\n    # Convert to a sorted list\n    sorted_common_elements = sorted(common_elements)\n\n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Find common elements by converting lists to sets\n    common_elements = list(set(l1) & set(l2))\n    # Sort and return the unique common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1, set2 = set(l1), set(l2)\n    # Find intersection of sets\n    common_elements = set1 & set2\n    # Convert to sorted list and return\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Find common elements using set intersection\n    common_elements = set(l1).intersection(set(l2))\n\n    # Convert to sorted list and return\n    return sorted(common_elements)", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 83.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_factor = 1\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    while n % 3 == 0:\n        largest_factor = 3\n        n = n // 3\n    factor = 5\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        factor += 2\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Function to find all prime factors\n    def prime_factors(m):\n        factors = []\n        # Test for number of 2s that divide m\n        while m % 2 == 0:\n            factors.append(2),\n            m = m // 2\n        # n must be odd at this point\n        for i in range(3, int(m**0.5) + 1, 2):\n            while m % i == 0:\n                factors.append(i),\n                m = m // i\n        if m > 2:\n            factors.append(m)\n        return factors\n\n    # Get all prime factors\n    factors = prime_factors(n)\n    # Return the largest prime factor\n    return max(factors)", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Start checking from 2, the smallest prime number\n    largest_factor = None\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(x):\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if x <= 1:\n            return False\n        if x <= 3:\n            return True\n        if x % 2 == 0 or x % 3 == 0:\n            return False\n        i = 5\n        while i * i <= x:\n            if x % i == 0 or x % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_prime = -1\n\n    # Check for the highest power of 2 that divides n\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    # n must be odd at this point so a skip of 2 (i.e., i = i + 2) can be used in loop\n    for i in range(3, int(n**0.5) + 1, 2):\n        # While i divides n, update n and largest_prime\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    if n > 1:\n        return n\n    return factor - 1", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = None\n    # Divide n by 2 to get rid of all even factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # n must be odd at this point so we can skip even numbers\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # This condition is to handle the case when n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1 and not a prime.\")\n\n    largest_factor = None\n\n    # Divide out the smallest prime (2) first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # n must be odd at this point, so we can skip one element (i.e., 2 is already checked)\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # If n is a prime number larger than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_factor = None\n    # Check for smallest prime factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    # If n is still greater than 2, it must be prime\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_factor = None\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    while n % 3 == 0:\n        largest_factor = 3\n        n //= 3\n\n    factor = 5\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        while n % (factor + 2) == 0:\n            largest_factor = factor + 2\n            n //= factor + 2\n        factor += 6\n\n    if n > 4:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = None\n    # Remove all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Remove odd factors from 3 upwards\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    largest_factor = None\n    # Check for the smallest prime factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    largest_prime = None\n\n    # Check for the highest power of 2 that divides n\n    while n % 2 == 0:\n        largest_prime = 2\n        n //= 2\n\n    # n must be odd at this point, so we can skip even numbers\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n\n    # This condition is to handle the case when n is a prime number\n    # greater than 2\n    if n > 2:\n        largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(x: int) -> bool:\n        if x <= 1:\n            return False\n        if x <= 3:\n            return True\n        if x % 2 == 0 or x % 3 == 0:\n            return False\n        i = 5\n        while i * i <= x:\n            if x % i == 0 or x % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Remove all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Remove all factors of 3\n    while n % 3 == 0:\n        largest_factor = 3\n        n //= 3\n\n    # Check for factors from 5 to sqrt(n)\n    factor = 5\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n becomes a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # Start with the smallest prime number, which is 2\n    largest_factor = None\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n itself is a prime number and greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = -1\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n //= i\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 46.688311688311686, "dps_norm": 44.375, "pass@1": 58.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    count = 0\n\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for i, char in enumerate(s):\n        if char.lower() in vowels or (char.lower() == 'y' and i == len(s) - 1):\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the set of vowels\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    # Initialize the count of vowels\n    count = 0\n\n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        # Check if the character is a vowel\n        if char.lower() in vowels:\n            count += 1\n        # Check if 'y' is at the end of the word\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n\n    for i, char in enumerate(s):\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set(\"aeiou\")\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to handle case insensitivity\n\n    for i, char in enumerate(s):\n        if char in vowels or (char == 'y' and i == len(s) - 1):\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    if s and s[-1].lower() == 'y':\n        count += 1\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    # Iterate over each character in the string\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set(\"aeiou\")\n    count = 0\n    word_length = len(s)\n\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == word_length - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiou')\n    count = 0\n    s_lower = s.lower()\n\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s_lower) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define vowels\n    vowels = \"aeiouAEIOU\"\n    # Initialize count\n    count = 0\n    # Check for vowels\n    for char in s:\n        if char in vowels:\n            count += 1\n    # Check if 'y' or 'Y' is at the end\n    if s and s[-1] in 'yY':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = sum(1 for char in s.lower() if char in vowels)\n    return count + (1 if s.lower().endswith('y') else 0)", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n\n    for i, char in enumerate(s):\n        if char.lower() in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    if s and s[-1].lower() == 'y':\n        count += 1\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    if s and s[-1] in 'yY':\n        count += 1\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    if s and s[-1].lower() == 'y':\n        count += 1\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 84.1341463414634, "dps_norm": 85.0, "pass@1": 90.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Return the list with the fewer characters or the first list if they are equal\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    def total_char_count(lst):\n        return sum(len(s) for s in lst)\n\n    char_count_lst1 = total_char_count(lst1)\n    char_count_lst2 = total_char_count(lst2)\n\n    if char_count_lst1 < char_count_lst2:\n        return lst1\n    elif char_count_lst1 > char_count_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Compare the totals and return the list with fewer characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Determine which list has fewer total characters\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 < total_chars_lst2 or total_chars_lst1 == total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_char_count(lst):\n        return sum(len(s) for s in lst)\n\n    if total_char_count(lst1) < total_char_count(lst2):\n        return lst1\n    elif total_char_count(lst1) > total_char_count(lst2):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 5}, {"solution": "def total_match(lst1, lst2):\n    def total_length(lst):\n        return sum(len(s) for s in lst)\n\n    len1 = total_length(lst1)\n    len2 = total_length(lst2)\n\n    if len1 < len2:\n        return lst1\n    elif len2 < len1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    def total_char_count(lst):\n        return sum(len(word) for word in lst)\n\n    count1 = total_char_count(lst1)\n    count2 = total_char_count(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    chars1 = total_chars(lst1)\n    chars2 = total_chars(lst2)\n\n    if chars1 < chars2:\n        return lst1\n    elif chars2 < chars1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    if total_chars(lst1) < total_chars(lst2):\n        return lst1\n    elif total_chars(lst1) > total_chars(lst2):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 4}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    def total_char_count(lst):\n        return sum(len(s) for s in lst)\n\n    char_count_lst1 = total_char_count(lst1)\n    char_count_lst2 = total_char_count(lst2)\n\n    if char_count_lst1 < char_count_lst2:\n        return lst1\n    elif char_count_lst2 < char_count_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Return the list with the fewer characters, or the first list if they are equal\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    \"\"\"\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Compare the totals and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    # Determine which list has fewer characters or return the first list if they are equal\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    if total_chars(lst1) < total_chars(lst2):\n        return lst1\n    elif total_chars(lst2) < total_chars(lst1):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 5}]}, "HumanEval/85": {"dps": 95.69306930693068, "dps_norm": 65.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 3, 5, 7, 9]) ==> 0\n        add([2, 4, 6, 8]) ==> 2\n        add([3, 5, 7, 9]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    sum_even_odd_indices = 0\n\n    # Iterate over the list with index\n    for i in range(1, len(lst), 2):  # start from index 1 and step by 2\n        if lst[i] % 2 == 0:  # check if the element is even\n            sum_even_odd_indices += lst[i]\n\n    return sum_even_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n\n    # Iterate through the list with index\n    for i in range(1, len(lst), 2):\n        # Check if the element at the odd index is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the total sum\n            total += lst[i]\n\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    even_sum = 0\n    for i in range(1, len(lst), 2):  # Loop through odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            even_sum += lst[i]\n    return even_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Iterate through the list, summing up elements that are even and at odd indices\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize a variable to store the sum of even elements at odd indices\n    sum_even_at_odd_indices = 0\n\n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the sum\n            sum_even_at_odd_indices += value\n\n    # Return the sum\n    return sum_even_at_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    sum_even_odd_indices = 0\n\n    # Iterate over the list with both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and value is even\n        if index % 2 != 0 and value % 2 == 0:\n            sum_even_odd_indices += value\n\n    return sum_even_odd_indices", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    total_sum = 0\n\n    # Iterate over the list with index\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total_sum += lst[i]\n\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2\n        if lst[i] % 2 == 0:  # Check if the element at the current odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    sum_even_odd_indices = sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)\n    return sum_even_odd_indices", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n\n    # Iterate through the list, checking only odd indices (1, 3, 5, ...)\n    for i in range(1, len(lst), 2):\n        # Check if the element at the odd index is even\n        if lst[i] % 2 == 0:\n            # Add it to the total sum\n            total += lst[i]\n\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the list with index\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total_sum += lst[i]\n\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of the even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    sum_of_evens = 0\n    for i in range(1, len(lst), 2):  # iterate over odd indices\n        if lst[i] % 2 == 0:          # check if the element is even\n            sum_of_evens += lst[i]   # add the element to the sum\n    return sum_of_evens", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": 95.64625850340136, "dps_norm": 99.0, "pass@1": 20.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sorted_word(word):\n        return ''.join(sorted(word))\n\n    # Split the input string by spaces\n    words = s.split(' ')\n\n    # Sort each word and rejoin them with spaces\n    ordered_words = [sorted_word(word) for word in words]\n\n    # Join the ordered words back into a single string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string into words\n    words = s.split(' ')\n\n    # Process each word individually\n    ordered_words = []\n    for word in words:\n        # Sort the characters of the word based on their ASCII values\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    # Join the ordered words back into a single string with spaces\n    ordered_sentence = ' '.join(ordered_words)\n\n    return ordered_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the input string by spaces to handle words separately\n    words = s.split(' ')\n\n    # Function to sort characters of a word based on their ASCII values\n    def sort_characters(word):\n        return ''.join(sorted(word))\n\n    # Apply the sort_characters function to each word and join them back with spaces\n    result = ' '.join(sort_characters(word) for word in words)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ASCII value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    result = []\n\n    for word in words:\n        # Sort characters in the word based on ASCII value\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n\n    # Join the sorted words with spaces to form the final sentence\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def order_string(word):\n        # Return the sorted version of the word\n        return ''.join(sorted(word))\n\n    # Split the input string by spaces\n    words = s.split(' ')\n\n    # Sort each word and join them back with space\n    ordered_words = ' '.join(order_string(word) for word in words)\n\n    return ordered_words", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        # Sort characters in each word based on ASCII value\n        return ''.join(sorted(word))\n\n    # Split the string into words\n    words = s.split(' ')\n\n    # Sort each word and join them back with spaces\n    result = ' '.join(sort_word(word) for word in words)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_characters(word):\n        # Sort characters in each word by their ASCII values\n        return ''.join(sorted(word))\n\n    # Split the string into words based on spaces\n    words = s.split(' ')\n    # Apply the sort_characters function to each word\n    sorted_words = [sort_characters(word) for word in words]\n    # Join the sorted words back into a single string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    result = []\n\n    for word in words:\n        # Sort the characters of the word based on ASCII values\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        # Join the sorted characters of the word\n        return ''.join(sorted(word))\n\n    # Split the input string by spaces to get the words\n    words = s.split(' ')\n\n    # Sort each word and join them back with spaces\n    sorted_words = ' '.join(sort_word(word) for word in words)\n\n    return sorted_words", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        # Skip the word if it doesn't need to be reordered\n        if all(word[i] <= word[i + 1] for i in range(len(word) - 1)):\n            ordered_words.append(word)\n        else:\n            # Reorder characters in the word based on ASCII value\n            ordered_word = ''.join(sorted(word))\n            ordered_words.append(ordered_word)\n\n    # Join the list of words back into a single string\n    ordered_sentence = ' '.join(ordered_words)\n    return ordered_sentence", "matching_cluster_idx": 3}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        char_list = list(word)\n        char_list.sort()\n        ordered_word = ''.join(char_list)\n        ordered_words.append(ordered_word)\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_characters(word):\n        # Sort the characters of the word based on ASCII value\n        return ''.join(sorted(word))\n\n    # Split the string into words\n    words = s.split(' ')\n\n    # Sort characters in each word and join them back with spaces\n    sorted_words = [sort_characters(word) for word in words]\n\n    # Join the sorted words with spaces to get the final string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_string(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    return ' '.join(sort_string(word) for word in words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        chars = list(word)\n        chars.sort()\n        ordered_words.append(''.join(chars))\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    # Process each word\n    ordered_words = []\n    for word in words:\n        # Sort the characters in each word\n        ordered_word = ''.join(sorted(word))\n        # Append the ordered word to the list\n        ordered_words.append(ordered_word)\n    # Join the ordered words back into a single string\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_chars(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_chars(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    for i in range(len(words)):\n        words[i] = ''.join(sorted(words[i]))\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    # Split the input string by spaces to handle words separately\n    words = s.split(' ')\n\n    # Process each word individually\n    ordered_words = []\n    for word in words:\n        # Convert the word to a list of characters and sort it\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n\n    # Join the ordered words back into a single string with spaces in between\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        # Sort characters of the word based on ASCII value\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 78.22766570605188, "dps_norm": 53.57142857142858, "pass@1": 52.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n\n    for i, row in enumerate(lst):\n        row_coords = [(i, j) for j, val in enumerate(row) if val == x]\n        coordinates.extend(row_coords)\n\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n\n    # Sort the results initially by rows in ascending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort by rows, and within each row, sort by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    result = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n\n    # Sort by row in ascending order, and for ties, sort by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data as a nested list, where each row may contain a different number of columns,\n    find integers x in the list, and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple\n    is a coordinate - (row, columns), starting with 0.\n\n    Sort coordinates initially by rows in ascending order. Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n    coordinates = []\n\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort initially by rows in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n\n    # Iterate through the list of lists\n    for row_index, row in enumerate(lst):\n        # Iterate through the row elements\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort by rows in ascending order\n    coordinates.sort()\n\n    # Sort coordinates within the same row by columns in descending order\n    for i in range(len(coordinates)):\n        for j in range(i + 1, len(coordinates)):\n            if coordinates[i][0] == coordinates[j][0]:\n                if coordinates[i][1] < coordinates[j][1]:\n                    coordinates[i], coordinates[j] = coordinates[j], coordinates[i]\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n\n    # Sort by row, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        indices = [(row_index, i) for i in reversed(range(len(row))) if row[i] == x]\n        result.extend(indices)\n\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort by row in ascending order\n    coordinates.sort()\n\n    # For each row, sort coordinates by column in descending order\n    result = []\n    for row_index in range(len(lst)):\n        row_coords = [coord for coord in coordinates if coord[0] == row_index]\n        row_coords.sort(reverse=True)\n        result.extend(row_coords)\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    result = []\n    for i, row in enumerate(lst):\n        row_coords = [(i, j) for j in range(len(row)-1, -1, -1) if row[j] == x]\n        result.extend(row_coords)\n\n    result.sort()\n\n    # To sort coordinates within the same row by columns in descending order\n    result = sorted(result, key=lambda coord: (coord[0], -coord[1]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in reversed(list(enumerate(row))):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort by row, then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n\n    # Iterate through each row\n    for i, row in enumerate(lst):\n        # Iterate through each column in the row\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n\n    # Sort by rows in ascending order, and columns in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in reversed(list(enumerate(row))):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort by row index and within each row by column index (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate through the list and collect coordinates of the target value x\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort coordinates by row index first, then by column index (descending)\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort coordinates initially by rows in ascending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        row_coords = [(i, j) for j, val in enumerate(row) if val == x]\n        result.extend(row_coords)\n\n    # Sort results first by row, then by column in descending order\n    result.sort()\n    result = sorted(result, key=lambda x: (x[0], -x[1]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n\n    # Sort by rows in ascending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n\n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 71.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # because we need to shift down by 2 multiplied to two places (2*2)\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n    def shift_char(c):\n        if c.islower():\n            return alphabet[(alphabet.index(c) + shift) % 26]\n        return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 2 * 2\n    result = []\n\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            # Perform wrap-around with modulo operation\n            encrypted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            result.append(encrypted_char)\n        else:\n            result.append(char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 4  # 2 multiplied by 2 (2 * 2)\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            elif char.isupper():\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    shift = 2 * 2  # Shift letters down by 2 positions in the alphabet\n\n    encrypted_string = []\n\n    for char in s:\n        if char.islower():\n            # Find the position of the character in the alphabet\n            idx = alphabet.index(char)\n            # Calculate the new position with the shift applied\n            new_idx = (idx + shift) % len(alphabet)\n            # Append the new character to the encrypted string\n            encrypted_string.append(alphabet[new_idx])\n        else:\n            # If the character is not a lowercase letter, keep it as it is\n            encrypted_string.append(char)\n\n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_chars = []\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n    for char in s:\n        if char.islower():\n            encrypted_char = alphabet[(alphabet.index(char) + 4) % 26]\n            encrypted_chars.append(encrypted_char)\n        else:\n            encrypted_chars.append(char)  # Keep uppercase and non-alphabet characters unchanged\n\n    return ''.join(encrypted_chars)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_str = \"\"\n    shift = 4  # Shift by 4 places as described (2 multiplied by 2)\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\n    for char in s:\n        if char.islower():\n            encrypted_str += alphabet[(alphabet.index(char) + shift) % 26]\n        elif char.isupper():\n            encrypted_str += alphabet[(alphabet.index(char.lower()) + shift) % 26].upper()\n        else:\n            encrypted_str += char  # Non-alphabetic characters remain unchanged\n\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        \"\"\"Shift a single character by two places, wrapping around if necessary.\"\"\"\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_str = []\n\n    for char in s:\n        if char.islower():\n            # Shift by 2*2 = 4 places\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_str.append(new_char)\n        elif char.isupper():\n            # Shift by 2*2 = 4 places for uppercase\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_str.append(new_char)\n        else:\n            # Non-alphabetic characters remain the same\n            encrypted_str.append(char)\n\n    return ''.join(encrypted_str)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr(((ord(c) - ord('a') + 4) % 26) + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr(((ord(c) - ord('A') + 4) % 26) + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        \"\"\"Shift a character down by two times two places.\"\"\"\n        if 'a' <= c <= 'z':\n            # For lowercase letters\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            # For uppercase letters\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            # Return non-alphabet characters as they are\n            return c\n\n    # Apply the shift to each character in the string\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def shift_char(c):\n        if c.islower():\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif c.isupper():\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c  # Non-alphabetic characters are unchanged\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_str = ''\n    for char in s:\n        if char.islower():\n            # Shift down by 4 places (rotated by 2*2)\n            encrypted_str += chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n        elif char.isupper():\n            # Shift down by 4 places (rotated by 2*2)\n            encrypted_str += chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n        else:\n            # Non-alphabet characters remain the same\n            encrypted_str += char\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters\n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 2\n    result = []\n\n    for char in s:\n        if char.islower():\n            new_char = chr((ord(char) - ord('a') + shift * 2) % 26 + ord('a'))\n        elif char.isupper():\n            new_char = chr((ord(char) - ord('A') + shift * 2) % 26 + ord('A'))\n        else:\n            new_char = char\n        result.append(new_char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 58.91050583657588, "dps_norm": 51.666666666666664, "pass@1": 87.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n\n    if len(unique_sorted_lst) < 2:\n        return None\n\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Initialize the first and second smallest values\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        if num < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = num\n        elif first_smallest < num < second_smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first_min = float('inf')\n    second_min = float('inf')\n\n    for num in lst:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif first_min < num < second_min:\n            second_min = num\n\n    if second_min == float('inf'):\n        return None\n    else:\n        return second_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first_smallest, second_smallest = float('inf'), float('inf')\n\n    for num in lst:\n        if num < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = num\n        elif first_smallest < num < second_smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n    for num in lst:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n\n    for num in lst:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n    if len(lst) < 2:\n        return None\n\n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n\n    # Check if there are at least two unique elements\n    if len(unique_sorted_lst) < 2:\n        return None\n\n    # Return the second smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first_min, second_min = float('inf'), float('inf')\n\n    for num in lst:\n        if num < first_min:\n            second_min, first_min = first_min, num\n        elif first_min < num < second_min:\n            second_min = num\n\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Initialize the first and second smallest to infinity\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        if num < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = num\n        elif num < second_smallest and num != first_smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n\n    for num in lst:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n    for num in lst:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n\n    if len(lst) < 2:\n        return None\n\n    # Initialize the first and second smallest with very large values\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        if num < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = num\n        elif first_smallest < num < second_smallest:\n            second_smallest = num\n\n    # If second_smallest remains inf, then there was no second smallest element\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n    for num in lst:\n        if num < first:\n            second = first\n            first = num\n        elif num < second and num != first:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n    for num in lst:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n\n    for num in lst:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Initialize the first and second smallest to very large values\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n\n    for number in lst:\n        if number < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = number\n        elif first_smallest < number < second_smallest:\n            second_smallest = number\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Remove duplicates by converting the list to a set and back to a list\n    unique_lst = list(set(lst))\n\n    # Sort the list and get the second element (index 1)\n    unique_lst.sort()\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first_min, second_min = float('inf'), float('inf')\n\n    for num in lst:\n        if num < first_min:\n            second_min, first_min = first_min, num\n        elif first_min < num < second_min:\n            second_min = num\n\n    if second_min == float('inf'):\n        return None\n\n    return second_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first_min = second_min = float('inf')\n\n    for num in lst:\n        if num < first_min:\n            first_min, second_min = num, first_min\n        elif num < second_min and num != first_min:\n            second_min = num\n\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n\n    # Check if there is at least a 2nd smallest element\n    if len(unique_sorted_lst) < 2:\n        return None\n\n    # Return the 2nd smallest element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 99.10750507099392, "dps_norm": 69.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count_odds = sum(1 for digit in s if int(digit) % 2 != 0)\n        formatted_str = f\"the number of odd elements {count_odds}n the str{count_odds}ng {count_odds} of the {count_odds}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n\n    for s in lst:\n        count_odd = sum(1 for digit in s if int(digit) % 2 != 0)\n        result_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            count_odd, count_odd, count_odd, count_odd)\n        result.append(result_string)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for c in s if c in '13579')\n        result_str = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_count, odd_count, odd_count, odd_count\n        )\n        result.append(result_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for ch in s if int(ch) % 2 != 0)\n\n    result = []\n    for s in lst:\n        num_odds = count_odds(s)\n        result.append(f\"the number of odd elements {num_odds}n the str{num_odds}ng {num_odds} of the {num_odds}nput.\")\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if char in '13579')\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        formatted_string = template.format(odd_count, odd_count, odd_count, odd_count)\n        result.append(formatted_string)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        formatted_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        result.append(formatted_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        formatted_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if char in '13579')\n\n    results = []\n    for i, string in enumerate(lst):\n        odd_count_str = str(count_odd_digits(string))\n        result = f\"the number of odd elements {odd_count_str}n the str{odd_count_str}ng {odd_count_str} of the {odd_count_str}nput.\"\n        results.append(result)\n\n    return results", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odd_digits(s):\n        \"\"\"Helper function to count odd digits in a string.\"\"\"\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for s in lst:\n        num_odds = count_odd_digits(s)\n        result.append(f\"the number of odd elements {num_odds}n the str{num_odds}ng {num_odds} of the {num_odds}nput.\")\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_digits_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits_count, odd_digits_count, odd_digits_count, odd_digits_count)\n        result.append(template)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    def count_odd_digits(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n\n    result = []\n    for s in lst:\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for s in lst:\n        num_odds = count_odds(s)\n        template = \"the number of odd elements {}n the str{}ng {} of the {}nput.\"\n        formatted_str = template.format(num_odds, num_odds, num_odds, num_odds)\n        result.append(formatted_str)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        formatted_string = (\n            f\"the number of odd elements {odd_count}n the str{odd_count}ng \"\n            f\"{odd_count} of the {odd_count}nput.\"\n        )\n        result.append(formatted_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    result = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        formatted_string = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_count, odd_count, odd_count, odd_count)\n        result.append(formatted_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        count_odds = sum(1 for char in string if int(char) % 2 != 0)\n        template = f\"the number of odd elements {count_odds}n the str{count_odds}ng {count_odds} of the {count_odds}nput.\"\n        result.append(template)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        template = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(template)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output_str = (f\"the number of odd elements {odd_count}n the str{odd_count}ng \"\n                      f\"{odd_count} of the {odd_count}nput.\")\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    def count_odds(s):\n        return sum(1 for d in s if int(d) % 2 != 0)\n\n    result = []\n    for s in lst:\n        odd_count = count_odds(s)\n        formatted_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(formatted_str)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n\n    # Helper function to count odd digits in a string\n    def count_odds(s):\n        return sum(int(char) % 2 != 0 for char in s)\n\n    # Process each string in the list\n    result = []\n    for s in lst:\n        odd_count = count_odds(s)\n        template = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(template)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count_odd = sum(1 for digit in s if int(digit) % 2 != 0)\n        output_str = f\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 90.34883720930233, "dps_norm": 94.0, "pass@1": 79.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Concatenate in both possible orders\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    return 'Yes' if is_balanced(concat1) or is_balanced(concat2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def is_good_string(s: str) -> bool:\n    '''\n    Helper function to check if a string of parentheses is balanced.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst: list) -> str:\n    '''\n    Function to check if concatenating two strings from the list in some order can form a good string.\n    '''\n    # Check all possible concatenations\n    for order in [(lst[0] + lst[1], lst[1] + lst[0])]:\n        if is_good_string(order[0]) or is_good_string(order[1]):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    return 'Yes' if is_good(lst[0] + lst[1]) or is_good(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def is_good(s):\n    '''\n    Helper function to check if a string is balanced.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    '''\n    Given a list of two strings, checks if concatenating them in any order\n    results in a balanced string.\n    '''\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def can_form_good_string(s1, s2):\n        # Check if concatenating in both orders can result in a balanced string\n        return is_balanced(s1 + s2) or is_balanced(s2 + s1)\n\n    return 'Yes' if can_form_good_string(lst[0], lst[1]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    for perm in [lst[0] + lst[1], lst[1] + lst[0]]:\n        if is_good(perm):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    # Generate all possible concatenations of the two strings in lst\n    for s1, s2 in [(lst[0], lst[1]), (lst[1], lst[0])]:\n        if is_balanced(s1 + s2):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    balance = 0\n    for c in s:\n        if c == '(':\n            balance += 1\n        elif c == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    s1, s2 = lst\n    return 'Yes' if (is_balanced(s1 + s2) or is_balanced(s2 + s1)) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def is_good_string(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    # Generate all possible concatenations\n    concatenations = [''.join(lst[0] + lst[1]), ''.join(lst[1] + lst[0])]\n\n    # Check if any of the concatenations form a good string\n    for s in concatenations:\n        if is_good_string(s):\n            return 'Yes'\n\n    return 'No'", "matching_cluster_idx": -1}, {"solution": "def is_balanced(s: str) -> bool:\n    '''Helper function to check if the given string is balanced'''\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\ndef match_parens(lst: list[str]) -> str:\n    '''\n    Check if it is possible to concatenate the two strings in some order\n    to get a balanced string.\n    '''\n    str1, str2 = lst\n\n    # Check if concatenating str1 + str2 results in a balanced string\n    if is_balanced(str1 + str2):\n        return 'Yes'\n\n    # Check if concatenating str2 + str1 results in a balanced string\n    if is_balanced(str2 + str1):\n        return 'Yes'\n\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_good_string(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def can_be_good_concat(s1, s2):\n        if is_good_string(s1 + s2):\n            return 'Yes'\n        if is_good_string(s2 + s1):\n            return 'Yes'\n        return 'No'\n\n    return can_be_good_concat(lst[0], lst[1])", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Generate all possible concatenations of the two strings\n    possible_strings = [''.join(lst) for lst in [lst, lst[::-1]]]\n\n    # Check if any of the possible concatenations is balanced\n    return 'Yes' if any(is_balanced(s) for s in possible_strings) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try concatenating the strings in both possible orders\n    concatenated_1 = lst[0] + lst[1]\n    concatenated_2 = lst[1] + lst[0]\n\n    return 'Yes' if is_balanced(concatenated_1) or is_balanced(concatenated_2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def is_good(s):\n    '''\n    Helper function to check if a single string is balanced.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    '''\n    Checks if it is possible to concatenate the two strings in some order\n    to produce a good string.\n    '''\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check if concatenating the strings in both possible orders results in a balanced string\n    return 'Yes' if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s: str) -> bool:\n    \"\"\" Helper function to check if a single string is balanced \"\"\"\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:  # char == ')'\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst: list) -> str:\n    \"\"\"\n    Check if it is possible to concatenate two strings in some order to make a good string.\n    A string S is considered good if all parentheses in S are balanced.\n    \"\"\"\n    s1, s2 = lst\n    # Check if both individual strings are balanced\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def is_balanced(s):\n    '''\n    Check if a given string of parentheses is balanced.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\ndef match_parens(lst):\n    '''\n    Check if it is possible to concatenate the two strings in some order\n    to form a good string where all parentheses are balanced.\n    '''\n    # Concatenate the strings in both possible orders\n    order1 = lst[0] + lst[1]\n    order2 = lst[1] + lst[0]\n\n    # Check if either order produces a balanced string\n    return 'Yes' if is_balanced(order1) or is_balanced(order2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n\n    # Check if concatenating in either order can balance the parentheses\n    return 'Yes' if (is_balanced(s1 + s2) or is_balanced(s2 + s1)) else 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "HumanEval/121": {"dps": 88.69955156950672, "dps_norm": 67.14285714285714, "pass@1": 64.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the list with index\n    for i in range(len(lst)):\n        # Check if the index is even and the element is odd\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            # Add the element to the sum\n            total_sum += lst[i]\n\n    # Return the total sum\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_odd_even_positions = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices (0, 2, 4, ...)\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            sum_odd_even_positions += lst[i]\n    return sum_odd_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n\n    # Iterate over the list with index\n    for index in range(0, len(lst), 2):\n        # Check if the element is odd\n        if lst[index] % 2 != 0:\n            # Add to the total sum\n            total_sum += lst[index]\n\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements\n    that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate through the list with index\n    for index in range(0, len(lst), 2):\n        if lst[index] % 2 != 0:\n            total_sum += lst[index]\n\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Filter the list to retain elements at even positions (0-based index) and check if they are odd\n    even_position_odds = [num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0]\n    # Calculate the sum of the filtered elements\n    return sum(even_position_odds)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the list with index\n    for index in range(len(lst)):\n        # Check if the index is even and the element is odd\n        if index % 2 == 0 and lst[index] % 2 != 0:\n            # Add the element to the total sum\n            total_sum += lst[index]\n\n    # Return the total sum\n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # iterate over even indices\n        if lst[i] % 2 != 0:  # check if element at even index is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum of odd elements in even positions\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements at even positions\n    sum_odd_even_positions = 0\n\n    # Iterate through the list with index\n    for index in range(0, len(lst), 2):\n        # Check if the element is odd\n        if lst[index] % 2 != 0:\n            sum_odd_even_positions += lst[index]\n\n    return sum_odd_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize a variable to hold the sum of odd elements in even positions\n    sum_odd_even_positions = 0\n\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_even_positions += value\n\n    return sum_odd_even_positions", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    result = 0\n\n    # Iterate over the list, checking elements at even positions (0-based index)\n    for i in range(0, len(lst), 2):\n        # Check if the element is odd and in an even position\n        if lst[i] % 2 != 0:\n            result += lst[i]\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_odd_even_positions = 0\n    for i in range(0, len(lst), 2):  # Iterate through even indices\n        if lst[i] % 2 != 0:  # Check if the number is odd\n            sum_odd_even_positions += lst[i]\n    return sum_odd_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum to 0\n    total_sum = 0\n\n    # Iterate through the list with index\n    for index in range(0, len(lst), 2):\n        # Check if the element at the even index is odd\n        if lst[index] % 2 != 0:\n            total_sum += lst[index]\n\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n\n    # Iterate through the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n\n    return total", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \"\"\"\n    # Remove strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the filtered list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list by length of the words (primary sort key) and lexicographically (secondary sort key)\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the filtered list first by length, then alphabetically for words of the same length\n    sorted_list = sorted(filtered_list, key=lambda word: (len(word), word))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n\n    If two words have the same length, sort the list alphabetically.\n\n    The function should return a list of strings in sorted order.\n\n    You may assume that all words will have the same length.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the filtered list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length first, then alphabetically for same lengths\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the filtered list by length and alphabetically for same length\n    sorted_list = sorted(filtered_list, key=lambda s: (len(s), s))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the filtered list by length first, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length of the strings and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word,\n    and if two words have the same length, sort the list alphabetically.\n\n    Parameters:\n    lst (list of str): List of strings to be processed.\n\n    Returns:\n    list of str: Sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically for ties\n    sorted_list = sorted(even_length_strings, key=lambda s: (len(s), s))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the filtered list: first by length of strings, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n\n    You may assume that all words will have the same length.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list by length and then alphabetically for ties\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the filtered list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda word: (len(word), word))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n\n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n\n    The function should return a list of strings in sorted order.\n\n    Examples:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda s: (len(s), s))\n\n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 97.79661016949153, "dps_norm": 98.75, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n\n    Parameters:\n    n (int): An integer to check if it is a prime number or not.\n\n    Returns:\n    bool: True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a given number is not a prime number.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    else:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if the number is not a prime.\n\n    :param n: Integer to check\n    :return: Boolean - True if not prime, False if prime\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is a prime number\n    if n % 2 == 0:\n        return True  # even numbers greater than 2 are not prime\n\n    # Check for factors from 3 to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\" Helper function to determine if a number is prime. \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\" Function to determine if a number is not prime. \"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if the given number is not a prime number.\n\n    Parameters:\n    n (int): Number to be checked.\n\n    Returns:\n    bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(num):\n    \"\"\"\n    Function to determine if a number is not prime.\n\n    Parameters:\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if num <= 1:\n        return True\n    if num <= 3:\n        return False\n    if num % 2 == 0 or num % 3 == 0:\n        return True\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Check if a number is not a prime number.\"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    :param n: Integer to be checked.\n    :return: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is a prime number\n    if n % 2 == 0:\n        return True  # even numbers greater than 2 are not prime\n    max_divisor = int(n**0.5) + 1\n    for i in range(3, max_divisor, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine whether a number is non-prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    elif n % 2 == 0:\n        return True\n    else:\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not a prime number.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Identify if a number is not a prime number.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 91.51877133105802, "dps_norm": 82.91666666666666, "pass@1": 64.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Create a min-heap (max heap in disguise by negating values)\n    heap = [-x for x in nums]\n    heapq.heapify(heap)\n\n    # Extract the n largest elements\n    largest_elements = [-heapq.heappop(heap) for _ in range(n)]\n\n    # Sort the extracted elements to get them in descending order\n    largest_elements.sort(reverse=True)\n\n    return largest_elements\nnums = [25, 35, 22, 85, 14, 65, 75, 22, 58]\nn = 3", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Convert the list to a max heap (using negative values to simulate a max heap with heapq)\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n\n    # Extract the n largest elements\n    largest_elements = [-heapq.heappop(max_heap) for _ in range(n)]\n\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Convert the list to a max-heap using heapq with negative numbers to simulate max-heap\n    max_heap = [-x for x in nums]\n    heapq.heapify(max_heap)\n\n    # Get the n largest elements from the heap\n    largest_nums = []\n    for _ in range(n):\n        largest_nums.append(-heapq.heappop(max_heap))\n\n    # Return the result in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Transform the list into a max-heap using heapq\n    max_heap = [-num for num in numbers]\n    heapq.heapify(max_heap)\n\n    # Extract the n largest elements (smallest in the max-heap)\n    largest_numbers = [-heapq.heappop(max_heap) for _ in range(n)]\n\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Using heapq to get the n largest elements\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Convert the list to a max heap\n    heapq.heapify(nums)\n\n    # Get the n largest elements\n    n_largest = heapq.nlargest(n, nums)\n\n    # Sort in descending order\n    n_largest.sort(reverse=True)\n\n    return n_largest", "matching_cluster_idx": 8}, {"solution": "def heap_queue_largest(nums, n):\n    # Create a max heap (since Python's heapq is a min heap by default, we invert the numbers)\n    import heapq\n    max_heap = []\n\n    for num in nums:\n        heapq.heappush(max_heap, -num)\n\n    # Get the n largest elements\n    largest_n = []\n    for _ in range(n):\n        largest_n.append(-heapq.heappop(max_heap))\n\n    # Sort the result in descending order\n    largest_n.sort(reverse=True)\n\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    # Convert numbers to a negative number to use a min heap for extracting the largest elements\n    heap = [-num for num in numbers]\n    heapq.heapify(heap)\n\n    # Extract the n largest elements\n    largest_elements = [-heapq.heappop(heap) for _ in range(n)]\n\n    # Sort the largest elements in descending order\n    return sorted(largest_elements, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Negate the numbers to create a max-heap using min-heap logic\n    max_heap = [-num for num in nums]\n    # Create a min-heap\n    heapq.heapify(max_heap)\n\n    # Extract the n largest numbers (which are negative in the max-heap)\n    largest_numbers = []\n    for _ in range(n):\n        largest_numbers.append(-heapq.heappop(max_heap))\n\n    # Return the result sorted in descending order\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq to get the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    # Convert the list to a max heap\n    import heapq\n    max_heap = [-num for num in numbers]\n    heapq.heapify(max_heap)\n\n    # Extract the n largest numbers\n    largest_numbers = []\n    for _ in range(n):\n        largest_numbers.append(-heapq.heappop(max_heap))\n\n    # Return the list sorted in descending order\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    import heapq\n    # Use a min-heap to store the n largest numbers\n    heap = []\n\n    for num in nums:\n        if len(heap) < n:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:  # If current number is larger than the smallest in heap\n            heapq.heapreplace(heap, num)\n\n    # Convert the heap to a list in descending order\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Transform the list to a max-heap (min-heap of negatives)\n    max_heap = [-num for num in numbers]\n    heapq.heapify(max_heap)\n\n    # Extract the n largest elements\n    largest_elements = []\n    for _ in range(n):\n        largest_elements.append(-heapq.heappop(max_heap))\n\n    # Return in descending order\n    return sorted(largest_elements, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use a min-heap to store the n largest elements\n    largest = []\n\n    for num in nums:\n        if len(largest) < n:\n            heapq.heappush(largest, num)\n        else:\n            heapq.heappushpop(largest, num)\n\n    # The heap is sorted in ascending order, so we need to reverse it\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use a max-heap (heap queue in Python) to keep track of the n largest elements\n    max_heap = []\n\n    for num in numbers:\n        if len(max_heap) < n:\n            heapq.heappush(max_heap, num)\n        else:\n            # If max_heap already has n elements, only push the element if it's larger than the smallest in max_heap\n            if num > max_heap[0]:\n                heapq.heapreplace(max_heap, num)\n\n    # heapq.nsmallest(n, max_heap, reverse=True) will give the n largest elements in descending order\n    return heapq.nlargest(n, max_heap)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Create a min-heap (default in Python) from the list of numbers\n    heap = nums[:n]\n    heapq.heapify(heap)\n\n    # Iterate over the remaining elements\n    for num in nums[n:]:\n        if num > heap[0]:\n            # If the current number is larger than the smallest in the heap\n            heapq.heappushpop(heap, num)\n\n    # Convert the heap to a sorted list in descending order\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Create a max heap by using negative values (since heapq is a min-heap by default)\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n\n    # Extract the largest n elements\n    largest_n = [-heapq.heappop(max_heap) for _ in range(n)]\n\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list of n largest integers in descending order.\n    \"\"\"\n    # Importing the heapq module to use the nlargest function\n    import heapq\n\n    # Using heapq.nlargest to find the n largest numbers\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use a max heap by using negative numbers\n    max_heap = [-num for num in nums]\n    heapq.heapify(max_heap)\n\n    # Extract the largest n elements\n    largest_elements = [ -heapq.heappop(max_heap) for _ in range(n) ]\n\n    return sorted(largest_elements, reverse=True)", "matching_cluster_idx": 9}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(numbers, n):\n    return nlargest(n, numbers)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 58.21995464852608, "dps_norm": 52.5, "pass@1": 12.0, "profiled": [{"solution": "def find_Rotations(s: str) -> int:\n    # Find the length of the string\n    n = len(s)\n\n    # If the string is empty or has only one character, no rotation is needed\n    if n == 0 or n == 1:\n        return 0\n\n    # Find the number of unique substrings of length 1, 2, 3, ..., n\n    for i in range(1, n):\n        if s[:i] * (n // i) == s:\n            return i\n\n    # If no such substring is found, return n (the whole string)\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    # Check if the string is the same after rotation\n    if s == s[1:] + s[0]:\n        return 1\n    # Try rotating the string by increasing values of rotations\n    for i in range(2, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    # Empty string or string with one character has no rotations\n    if len(s) <= 1:\n        return 0\n\n    # Find the length of the string\n    n = len(s)\n\n    # Iterate through the string and check for rotation equivalence\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n == 0:\n        return 0\n\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n\n    # If the string is already the same after one rotation, return 1\n    if s == s[1:] + s[0]:\n        return 1\n\n    # Check for other possible rotations\n    for i in range(2, n + 1):\n        if s == s[i:] + s[:i]:\n            return i\n\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Edge cases\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 0\n\n    # Calculate the number of rotations needed to get the same string\n    rotations = len(s)\n\n    # Check if any rotation of the string can form the original string\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            rotations = i\n            break\n\n    return rotations", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    # Base case: if the string is empty or has only one character, no rotations are needed.\n    if len(s) <= 1:\n        return 0\n\n    # Get the length of the string\n    length = len(s)\n\n    # Initialize the minimum number of rotations to length of the string\n    min_rotations = length\n\n    # Check rotations up to the length of the string\n    for i in range(1, length):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            min_rotations = min(min_rotations, i)\n\n    return min_rotations", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if len(s) == 0:\n        return 0\n\n    def is_rotation(s1, s2):\n        return s1 == s1[1:] + s1[0]\n\n    for i in range(1, len(s)):\n        if is_rotation(s, s[i:] + s[:i]):\n            return i\n\n    return len(s)", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    This function returns the minimum number of rotations (greater than 0) required to get the same string.\n    If the string is already a rotation of itself, it returns the length of the string.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # If the string is the same after any rotation, the length of the string is the minimum number of rotations.\n    length = len(s)\n    if length == 0:\n        return 0\n\n    # For a string to have the same result after any rotation, it must be a repeated substring.\n    # The length of the repeated substring is the number of rotations needed.\n    for i in range(1, length + 1):\n        if length % i == 0:\n            substring = s[:i]\n            if substring * (length // i) == s:\n                return i\n\n    # If no repeated substring is found, return -1 (indicating that no such rotation exists)\n    return -1", "matching_cluster_idx": 6}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required\n    to make the string the same.\n\n    :param s: The input string\n    :return: The minimum number of rotations needed\n    \"\"\"\n    # Special case for a single character string\n    if len(s) == 1:\n        return 0\n\n    # Concatenate the string with itself and find the first non-repeating substring\n    rotated = s + s\n    for i in range(1, len(s)):\n        if rotated[i:i+len(s)] == s:\n            return i\n\n    return len(s)", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 63.0, "profiled": [{"solution": "def remove_Occ(s: str, char: str) -> str:\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n\n    # Handle cases where the character is not found or there's only one occurrence\n    if first_index == -1:\n        return s  # Character not found\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]  # Only one occurrence\n\n    # Remove both first and last occurrences\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    # Find the positions of the first and last occurrence of the given character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # If the character is not found in the string, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Remove the first and last occurrences of the character\n    if first_index < last_index:\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    else:\n        return s[:last_index] + s[first_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Parameters:\n    string (str): The input string.\n    char (str): The character to be removed.\n\n    Returns:\n    str: The modified string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Check if the character exists in the string\n    if char not in string:\n        return string\n\n    # Find the index of the first and last occurrence of the character\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n\n    # Remove the character from the string\n    modified_string = (string[:first_occurrence] + string[first_occurrence+1:last_occurrence] + string[last_occurrence+1:])\n\n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # Handle cases where the character is not found\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Remove the first and last occurrence of the character\n    # by slicing the string and concatenating the parts\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of the given character from the string.\n\n    :param s: The input string\n    :param char: The character to remove\n    :return: The modified string with the first and last occurrence of the character removed\n    \"\"\"\n    # Find the first and last index of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # Handle the case where the character does not exist\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Create the new string by slicing around the unwanted characters\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # Check if character is found\n    if first_index == -1:\n        return s\n    if last_index == -1:\n        return s\n\n    # Remove first and last occurrence\n    result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    Parameters:\n    s (str): The input string.\n    ch (str): The character to be removed.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n\n    if first_index == -1 or last_index == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Remove the first and last occurrence\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the index of the first occurrence of the character\n    first_index = string.find(char)\n    # Find the index of the last occurrence of the character\n    last_index = string.rfind(char)\n\n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return string\n\n    # Slice the string to remove the first and last occurrences\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the first and last occurrence of the character\n    first = s.find(ch)\n    last = s.rfind(ch)\n\n    # If character is not found, return the original string\n    if first == -1 or last == -1:\n        return s\n\n    # Create the modified string by removing the character at the first and last positions\n    return s[:first] + s[first + 1:last] + s[last + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    if len(s) == 0 or len(char) != 1:\n        return s\n\n    # Find the first and last occurrences of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    if first_index == -1 or last_index == -1:\n        # If the character is not found, return the original string\n        return s\n\n    # Remove the first and last occurrences\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if not string:\n        return string\n\n    # Find the first occurrence of the character\n    first_index = string.find(char)\n    if first_index == -1:\n        return string  # Character not found\n\n    # Find the last occurrence of the character\n    last_index = string.rfind(char)\n    if last_index == -1:\n        return string  # Character not found\n\n    # Create a new string without the first and last occurrences of the character\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # Handle edge cases where the character does not appear in the string\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Create a new string without the first and last occurrence of the character\n    new_string = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n\n    return new_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n\n    :param s: The input string.\n    :param char: The character to be removed.\n    :return: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    # Find the indices of the first and last occurrences of the character\n    first_idx = s.find(char)\n    last_idx = s.rfind(char)\n\n    # Handle the case where the character does not exist in the string\n    if first_idx == -1 or last_idx == -1:\n        return s\n\n    # Construct the modified string by removing the first and last occurrences\n    modified_string = s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:]\n\n    return modified_string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    # Find the positions of the first and last occurrences of the character\n    first_pos = s.find(c)\n    last_pos = s.rfind(c)\n\n    # If the character is not found, return the original string\n    if first_pos == -1 or last_pos == -1:\n        return s\n\n    # Create a new string with the first and last occurrences removed\n    return s[:first_pos] + s[first_pos + 1:last_pos] + s[last_pos + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrences of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n\n    # Check if the character exists in the string\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Construct the result string\n    result = s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_idx = s.find(ch)\n    # Find the index of the last occurrence of the character\n    last_idx = s.rfind(ch)\n\n    # If the character is not found, return the original string\n    if first_idx == -1 or last_idx == -1:\n        return s\n\n    # If both indices are the same, the character appears only once\n    if first_idx == last_idx:\n        return s[:first_idx] + s[first_idx+1:]\n\n    # Remove the first and last occurrences\n    return s[:first_idx] + s[first_idx+1:last_idx] + s[last_idx+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n\n    # Check if the character exists in the string\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Remove the first and last occurrences\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence index of the character\n    first_index = string.find(char)\n    # Find the last occurrence index of the character\n    last_index = string.rfind(char)\n\n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return string\n\n    # If the character appears only once, return the string with that character removed\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n\n    # Remove both the first and last occurrences\n    return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_idx = s.find(char)\n    # Find the index of the last occurrence of the character\n    last_idx = s.rfind(char)\n\n    # If the character is not found, return the original string\n    if first_idx == -1:\n        return s\n\n    # Remove both the first and last occurrence of the character\n    # Return the modified string\n    return s[:first_idx] + s[first_idx + 1:last_idx] + s[last_idx + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if not s or char not in s:\n        return s\n\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n\n    if first_index == -1 or last_index == -1:\n        return s\n\n    # Construct the result by slicing the string and omitting the specified indices\n    result = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    return result", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of elements in each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of rows\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the rows based on the sum of their elements\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Create a list of tuples where each tuple contains the row and its sum\n    rows_with_sums = [(row, sum(row)) for row in matrix]\n\n    # Sort the list of tuples by the sum\n    rows_with_sums.sort(key=lambda x: x[1])\n\n    # Extract the sorted rows from the tuples\n    sorted_matrix = [row for row, _ in rows_with_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of rows\n    return sorted(matrix, key=lambda x: sum(x))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the rows of the matrix based on the sum of their elements\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # First, calculate the sum of each row\n    row_sums = [(row, sum(row)) for row in matrix]\n\n    # Sort the rows based on the sums\n    row_sums.sort(key=lambda x: x[1])\n\n    # Extract the sorted rows from the tuples\n    sorted_matrix = [row for row, _ in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of their elements\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort matrix by the sum of its rows\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the rows based on the sum of their elements\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/19": {"dps": 82.32323232323233, "dps_norm": 90.0, "pass@1": 47.0, "profiled": [{"solution": "def test_duplicate(arr):\n    # Using a set to track the elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if there are any duplicate elements in the given array.\n\n    Parameters:\n    arr (list of int): List of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if there are any duplicate elements in the given array.\n    :param arr: List of integers\n    :return: Boolean value indicating if there are duplicates\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determine whether the given array contains any duplicate elements.\n    :param arr: List of integers\n    :return: Boolean indicating presence of duplicates\n    \"\"\"\n    # Use a set to track elements we have seen\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    # Convert the list to a set and compare its length with the original list length\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): List of integers to check for duplicates.\n\n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n\n    Parameters:\n    arr (list): List of integers\n\n    Returns:\n    bool: True if there are duplicates, False otherwise\n    \"\"\"\n    # Using a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Use a set to track the elements we have seen\n    seen = set()\n\n    for num in arr:\n        if num in seen:\n            # If the number is already in the set, we have a duplicate\n            return True\n        seen.add(num)\n\n    # If we've gone through the whole list without finding a duplicate\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to keep track of the elements we have seen\n    seen = set()\n    # Iterate through each element in the array\n    for number in arr:\n        # If the element is already in the set, we have a duplicate\n        if number in seen:\n            return True\n        # Otherwise, add the element to the set\n        seen.add(number)\n    # If we complete the loop without finding a duplicate, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): List of integers.\n\n    Returns:\n    bool: True if there is any duplicate element, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Use a set to keep track of the elements we have seen\n    seen = set()\n    # Iterate over each element in the array\n    for num in arr:\n        # If the element is already in the set, it means it is a duplicate\n        if num in seen:\n            return True\n        # Otherwise, add the element to the set\n        seen.add(num)\n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    # Using a set to check for duplicates, as a set does not allow duplicate elements\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Use a set to track seen elements\n    seen = set()\n\n    # Iterate through the array\n    for number in arr:\n        # If the number is already in the set, it's a duplicate\n        if number in seen:\n            return True\n        # Otherwise, add the number to the set\n        seen.add(number)\n\n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to check for duplicates\n    seen = set()\n    for number in arr:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n\n    :param arr: List of integers\n    :return: Boolean indicating whether the list contains any duplicate elements\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to check if the given list contains any duplicate elements.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    bool: True if there is any duplicate, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Check if any element in the array appears more than once\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if there is any duplicate element in the given array.\n\n    Args:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if there is a duplicate, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 88.0, "dps_norm": 92.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    # Check if the list is empty\n    if not nums:\n        raise ValueError(\"List is empty, cannot find the smallest number\")\n\n    # Initialize the smallest number as the first element of the list\n    smallest = nums[0]\n\n    # Iterate through the list to find the smallest number\n    for num in nums:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    if not lst:  # Check if the list is empty\n        raise ValueError(\"The list is empty\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Ensure the list is not empty\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    # Initialize the smallest number as the first element of the list\n    smallest = lst[0]\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    # Ensure the list is not empty\n    if not nums:\n        raise ValueError(\"The list is empty\")\n    # Find the smallest number in the list\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    if not nums:\n        raise ValueError(\"The list is empty.\")\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a given list of numbers.\n\n    Parameters:\n    numbers (list): List of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    if not nums:  # check if the list is empty\n        return None  # return None if the list is empty\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    if not nums:\n        raise ValueError(\"The list is empty.\")\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function returns the smallest number in a list.\n    :param numbers: List of numbers.\n    :return: The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    :param lst: List of numbers\n    :return: The smallest number in the list\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:  # Check if the list is empty\n        return None  # Return None for empty list\n    return min(numbers)  # Return the smallest number", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Function to find the smallest number in a list.\n\n    Parameters:\n    numbers (list): A list of integers or floats.\n\n    Returns:\n    int or float: The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n\n    smallest = numbers[0]\n    for number in numbers:\n        if number < smallest:\n            smallest = number\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(nums):\n    # Initialize the smallest number as the first element of the list\n    smallest = nums[0]\n\n    # Iterate through the list starting from the second element\n    for num in nums[1:]:\n        # Update the smallest number if a smaller one is found\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    numbers (list of int): A list of integers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    # This function returns a list of tuples where all elements are divisible by k\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): A list of tuples.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    :param tuples_list: List of tuples to check.\n    :param k: Integer to check divisibility.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result\ntuples_list = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Function to check if all elements in a tuple are divisible by k\n    def all_divisible_by_k(t):\n        return all(x % k == 0 for x in t)\n\n    # Filter the tuples that meet the condition\n    result = [t for t in tuples_list if all_divisible_by_k(t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    def all_elements_divisible_by_k(t, k):\n        return all(element % k == 0 for element in t)\n\n    return [t for t in tuples_list if all_elements_divisible_by_k(t, k)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    def all_divisible_by_k(t):\n        return all(x % k == 0 for x in t)\n\n    return [t for t in tuples_list if all_divisible_by_k(t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples that have all elements divisible by k\n    \"\"\"\n    return [t for t in tuples if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for t in tuples:\n        if all(elem % k == 0 for elem in t):\n            result.append(t)\n    return result\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function returns tuples which have all elements divisible by k.\n\n    Args:\n    - tuples_list (list of tuples): A list of tuples.\n    - k (int): A number to check divisibility.\n\n    Returns:\n    - list of tuples: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    \"\"\"\n    This function returns a list of tuples where all elements in the tuple are divisible by k.\n\n    :param tuples: List of tuples\n    :param k: Divisor\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in tuples if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(num % k == 0 for num in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    def all_divisible(t, k):\n        return all(x % k == 0 for x in t)\n\n    return [t for t in tuples_list if all_divisible(t, k)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Function to find tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for tpl in tuples_list:\n        if all(elem % k == 0 for elem in tpl):\n            result.append(tpl)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result\ntuples_list = [(6, 24, 12), (7, 9, 6), (12, 18, 21)]\nk = 6", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    def all_elements_divisible_by_k(t, k):\n        return all(x % k == 0 for x in t)\n\n    return [t for t in tuples_list if all_elements_divisible_by_k(t, k)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Parameters:\n    - tuples_list: List of tuples.\n    - k: Integer, the divisor.\n\n    Returns:\n    - List of tuples where all elements in each tuple are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(element % k == 0 for element in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"\n    This function returns a dictionary with the frequency of all elements in the given list.\n\n    Parameters:\n    lst (list): List of integers.\n\n    Returns:\n    dict: Dictionary where keys are the list elements and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Get the frequency of all the elements in a list, returned as a dictionary.\n\n    Args:\n    lst (list): The list of elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list as input and returns a dictionary with the frequency of each element.\n\n    Parameters:\n    lst (list): The input list containing elements.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their respective frequencies.\n    \"\"\"\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Return the frequency of each element in the list as a dictionary.\n\n    Args:\n    lst (list): A list of integers\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Get the frequency of all elements in the list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        dict: A dictionary where the keys are the elements in the list and the values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function calculates the frequency of all elements in the list.\n\n    Parameters:\n    lst (list): A list of elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \"\"\"\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all the elements in a list, returned as a dictionary.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary with elements as keys and their counts as values.\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all the elements in a list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for num in lst:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    :param lst: List of elements\n    :return: Dictionary with element frequencies\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 76.73170731707317, "dps_norm": 85.0, "pass@1": 40.0, "profiled": [{"solution": "def len_log(words):\n    # Initialize a variable to keep track of the longest word length\n    longest_length = 0\n\n    # Iterate through each word in the list\n    for word in words:\n        # Update the longest length if the current word is longer\n        if len(word) > longest_length:\n            longest_length = len(word)\n\n    # Return the length of the longest word\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Function to find the length of the longest word in a list of words\n    longest_word_length = 0\n    for word in words:\n        if len(word) > longest_word_length:\n            longest_word_length = len(word)\n    return longest_word_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Parameters:\n    words (list): A list of words (strings)\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    # Initialize a variable to store the length of the longest word\n    max_length = 0\n\n    # Iterate over each word in the list\n    for word in words:\n        # Update max_length if the current word is longer than the current max_length\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize the max_length with the length of the first word in the list\n    max_length = len(words[0])\n\n    # Iterate over each word in the list\n    for word in words:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list of words.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize the maximum length variable\n    max_length = 0\n\n    # Iterate through each word in the list\n    for word in words:\n        # Update the max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n\n    # Return the length of the longest word\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    This function takes a list of words and returns the length of the longest word.\n\n    :param words: List of words (strings)\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n\n    # Initialize the maximum length to 0\n    max_length = 0\n\n    # Iterate over each word in the list\n    for word in words:\n        # Update the maximum length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize variable to keep track of the longest length\n    max_length = 0\n    # Iterate over each word in the list\n    for word in words:\n        # Update max_length if the current word length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize the variable to store the length of the longest word\n    max_length = 0\n\n    # Iterate through each word in the list\n    for word in words:\n        # Update the max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n\n    # Return the length of the longest word\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize the longest length to 0\n    max_len = 0\n\n    # Loop through each word in the list\n    for word in words:\n        # Check if the length of the current word is greater than the max length\n        if len(word) > max_len:\n            max_len = len(word)\n\n    return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize a variable to store the length of the longest word\n    max_length = 0\n\n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n\n    Args:\n    words (list of str): List of words\n\n    Returns:\n    int: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    longest_word = \"\"\n    for word in words:\n        if len(word) > len(longest_word):\n            longest_word = word\n    return len(longest_word)", "matching_cluster_idx": 4}, {"solution": "def len_log(words):\n    \"\"\"\n    This function returns the length of the longest word in a given list of words.\n\n    :param words: List of words to check\n    :return: Length of the longest word\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the input list is empty\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.46036585365853, "dps_norm": 61.0, "pass@1": 63.0, "profiled": [{"solution": "def index_minimum(tuples):\n    if not tuples:\n        return None\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Handle case where the list is empty\n\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    # Ensure the list of tuples is not empty\n    if not tuples:\n        return None\n\n    # Initialize variables to track the tuple with the smallest second value\n    min_tuple = tuples[0]\n\n    # Iterate through the list of tuples\n    for current_tuple in tuples[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        raise ValueError(\"The list is empty\")\n\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        return None\n\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None  # Return None if the list is empty to avoid errors\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None if the list is empty\n\n    # Initialize variables to track the tuple with the smallest second value\n    min_tuple = lst[0]\n\n    for item in lst:\n        if item[1] < min_tuple[1]:\n            min_tuple = item\n\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None\n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n\n    # Initialize the variable to keep track of the tuple with the smallest second value\n    min_tuple = tuples_list[0]\n\n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuples_list[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    # Find the tuple with the smallest second value\n    minimum_tuple = min(lst, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return minimum_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    min_val = min(lst, key=lambda x: x[1])\n    return min_val[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None\n\n    min_value = min((item[1] for item in lst))\n    result = [item[0] for item in lst if item[1] == min_value][0]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    :param tuples_list: List of tuples\n    :return: First value of the tuple with the smallest second value\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list of tuples should not be empty\")\n\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        raise ValueError(\"Input list is empty\")\n\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None  # or raise an exception if you prefer\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 11.805555555555555, "dps_norm": 29.28571428571429, "pass@1": 90.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    Args:\n    n (int): The integer to find the number of divisors for.\n\n    Returns:\n    int: The number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    # Initialize a counter for the number of divisors\n    count = 0\n\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "from collections import defaultdict\ndef frequency_lists(lists):\n    frequency_dict = defaultdict(int)\n    for sublist in lists:\n        for element in sublist:\n            frequency_dict[element] += 1\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Given a list of lists, return a dictionary with the frequency of each element in the flattened list.\n\n    Args:\n    lists (list of lists): The list of lists to flatten and count frequencies.\n\n    Returns:\n    dict: A dictionary with the frequency of each element in the flattened list.\n    \"\"\"\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n\n    # Use a dictionary to count the frequency of each element\n    frequency_dict = {}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(lists_of_lists):\n    frequency_dict = defaultdict(int)\n\n    # Flatten the list of lists\n    for sublist in lists_of_lists:\n        for element in sublist:\n            frequency_dict[element] += 1\n\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Flattens the list of lists and counts the frequency of each element.\n\n    Parameters:\n    lists (list of lists): The input list of lists.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Function to find the frequency of each element in a flattened list of lists,\n    returned in a dictionary.\n\n    :param lists: List of lists containing integers\n    :return: Dictionary with integers as keys and their frequencies as values\n    \"\"\"\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n\n    # Create a dictionary to store frequencies\n    frequency_dict = {}\n\n    # Count the frequency of each element\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n\n    # Flatten the list of lists\n    for sublist in nested_list:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Flatten the list of lists\n    flattened = [item for sublist in lists for item in sublist]\n    # Create a dictionary to count the frequencies\n    frequency = {}\n    for item in flattened:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    This function takes a list of lists and returns a dictionary with the frequency of each element in the flattened list.\n    \"\"\"\n    # Initialize an empty dictionary to store frequencies\n    frequency_dict = {}\n\n    # Flatten the list of lists\n    for sublist in nested_list:\n        for item in sublist:\n            # Update the dictionary with the frequency of each item\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    frequency_dict = {}\n    for sublist in lists_of_lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    \"\"\"\n    Flattens a list of lists and returns a dictionary with the frequency of each element.\n\n    Args:\n    nested_list (list of list of int): The list of lists to be flattened.\n\n    Returns:\n    dict: A dictionary where the keys are the elements from the flattened list and the values are their frequencies.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n\n    # Calculate frequencies\n    frequency_dict = {}\n    for item in flattened:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists_of_lists for item in sublist]\n\n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency\nnested_list = [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n\n    # Loop through each sublist in the main list\n    for sublist in lists:\n        # Loop through each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                frequency_dict[element] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store frequencies\n    frequency_dict = {}\n\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n\n    # Calculate frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n\n    # Flatten the list of lists and compute the frequency of each element\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequencies\n    frequency_dict = {}\n\n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                frequency_dict[element] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(flattened_lists):\n    frequency_dict = {}\n\n    # Flatten the list of lists\n    for sublist in flattened_lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 78.47402597402598, "dps_norm": 90.83333333333333, "pass@1": 86.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, then convert back to a tuple\n    new_list = list(tup)\n    new_list.extend(lst)\n    return tuple(new_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended.\n    \"\"\"\n    # Convert the list to a tuple and concatenate it with the original tuple\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns the resulting tuple.\n\n    :param lst: List to be appended to the tuple\n    :param tpl: Tuple to which the list is appended\n    :return: A new tuple with the elements of the tuple followed by the elements of the list\n    \"\"\"\n    # Convert the tuple to a list, append the list to it, and convert it back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    # Converts tuple to list, appends list elements, and then converts back to tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    :param lst: List to be appended.\n    :param tup: Tuple to which the list will be appended.\n    :return: A new tuple with the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the elements of the list, and then convert it back to a tuple\n    new_tuple = tpl + tuple(lst)\n    return new_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and then convert back to a tuple\n    return tuple(list(tup) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    This function appends the given list to the given tuple and returns a new tuple.\n    \"\"\"\n    # Converting tuple to list, appending list elements, and then converting back to tuple\n    new_tuple = tpl + tuple(lst)\n    return new_tuple", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list elements appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to append the list to.\n\n    Returns:\n    tuple: A new tuple with the original tuple elements followed by the list elements.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    :param lst: list of elements to append\n    :param tup: tuple to which the list elements are appended\n    :return: a new tuple with elements from the original tuple followed by elements from the list\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    :param lst: List of elements to be appended.\n    :param tpl: Original tuple.\n    :return: A new tuple that includes elements from both the list and the original tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    :param lst: List of elements to be appended to the tuple.\n    :param tup: Tuple to which the list elements are to be appended.\n    :return: A new tuple with the elements of the tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 2}]}, "Mbpp/108": {"dps": 84.09638554216868, "dps_norm": 98.18181818181819, "pass@1": 53.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three sorted lists into a single sorted list.\n\n    :param list1: First sorted list\n    :param list2: Second sorted list\n    :param list3: Third sorted list\n    :return: A single sorted list that is a merge of the three input lists\n    \"\"\"\n    # Merging three lists into one\n    merged_list = list1 + list2 + list3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined = list1 + list2 + list3\n\n    # Sort the combined list\n    combined.sort()\n\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the lists into a single list\n    merged_list = list1 + list2 + list3\n\n    # Sort the combined list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging three lists into one\n    merged_list = list1 + list2 + list3\n\n    # Sorting the merged list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list\n    merged_list.sort()\n\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n\n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(l1, l2, l3):\n    merged_list = l1 + l2 + l3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    combined_list = list1 + list2 + list3\n\n    # Sort the combined list\n    combined_list.sort()\n\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    merged_list = sorted(list(sum(lists, [])))\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten all lists into one\n    flattened_list = [item for sublist in lists for item in sublist]\n\n    # Sort the flattened list\n    flattened_list.sort()\n\n    return flattened_list", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the lists\n    combined_list = list1 + list2 + list3\n\n    # Sort the combined list\n    combined_list.sort()\n\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists for item in sublist]\n\n    # Sort the flattened list\n    sorted_list = sorted(flat_list)\n\n    return sorted_list", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the lists into a single list\n    flat_list = [item for sublist in lists for item in sublist]\n\n    # Sort the flattened list\n    flat_list.sort()\n\n    return flat_list", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists for item in sublist]\n\n    # Sort the flattened list\n    flat_list.sort()\n\n    return flat_list", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists into one\n    combined_list = list1 + list2 + list3\n\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n\n    # Sort the combined list\n    combined_list.sort()\n\n    return combined_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 76.1076923076923, "dps_norm": 80.0, "pass@1": 64.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in the given nested lists.\n\n    Args:\n    nested_lists (list of list of int): List of lists containing integers.\n\n    Returns:\n    set: A set of common elements in the nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Get the first list to initialize the common elements set\n    common_elements = set(nested_lists[0])\n\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Create a set from the first list in the nested lists\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining lists and find the intersection with the common_set\n    for sublist in nested_lists[1:]:\n        common_set &= set(sublist)\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Flatten the nested lists into a single list\n    flat_list = [item for sublist in nested_lists for item in sublist]\n\n    # Convert the list to a set to find unique elements\n    flat_set = set(flat_list)\n\n    # Find common elements by intersecting the set with the sublist sets\n    common_elements = set.intersection(*[set(sublist) for sublist in nested_lists])\n\n    return common_elements", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> set:\n    if not nested_lists:\n        return set()\n\n    # Find the common elements by reducing the nested lists\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common &= set(lst)\n\n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Create an empty set to store the common elements\n    common_elements = set()\n\n    # Get the first list to initialize the set of common elements\n    if nested_lists:\n        common_elements = set(nested_lists[0])\n\n    # Iterate over each list in the nested lists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> set:\n    if not nested_lists or not all(nested_lists):\n        return set()\n\n    common_elements = set(nested_lists[0])\n\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> set:\n    if not nested_lists:\n        return set()\n\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Find the intersection of all sets of elements in the nested lists\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize an empty set for common elements\n    common_set = set(nested_lists[0])\n\n    # Iterate through each list in the nested lists\n    for lst in nested_lists[1:]:\n        # Update the common set with intersection of current list and common set\n        common_set = common_set.intersection(set(lst))\n\n    # Convert the set back to a list\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find common elements in given nested lists.\n\n    Args:\n    nested_lists (list of list of int): List containing multiple lists of integers.\n\n    Returns:\n    set of int: Set of common integers present in all the lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Find the intersection of sets created from each list\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n        nested_lists (list of list of int): List of lists containing integers.\n\n    Returns:\n        set: A set of common integers across all lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Flatten the nested lists and find common elements\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize a set with the elements of the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the rest of the nested lists\n    for lst in nested_lists[1:]:\n        # Find the intersection with the current set of common elements\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from collections.abc import Iterable\ndef common_in_nested_lists(nested_lists):\n    if not all(isinstance(lst, Iterable) for lst in nested_lists):\n        raise TypeError(\"All elements of nested_lists must be iterable\")\n\n    if not nested_lists:\n        return set()\n\n    common_elements = nested_lists[0]\n    for lst in nested_lists[1:]:\n        common_elements = set(common_elements) & set(lst)\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert all lists to sets\n    sets_of_lists = [set(nested_list) for nested_list in nested_lists]\n\n    # Find the intersection of all sets\n    common_elements = set.intersection(*sets_of_lists)\n\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "from typing import List, Set\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> Set[int]:\n    \"\"\"\n    Find the common elements in a list of nested lists.\n\n    Parameters:\n    nested_lists (List[List[int]]): List of lists containing integers.\n\n    Returns:\n    Set[int]: A set of common integers present in all lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Find the common elements by intersecting all the sets of lists\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Flatten the nested lists into a single set\n    flat_list = set()\n    for lst in nested_lists:\n        flat_list.update(lst)\n\n    # If there is only one list, return it as a set\n    if len(nested_lists) == 1:\n        return set(nested_lists[0])\n\n    # Find the common elements\n    common_elements = set()\n    for item in flat_list:\n        if all(item in lst for lst in nested_lists):\n            common_elements.add(item)\n\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Function to find common elements in given nested lists.\n\n    Args:\n    nested_lists (list of lists): A list of lists containing integers.\n\n    Returns:\n    set: A set containing the common elements.\n    \"\"\"\n    # Reduce the nested lists to a single set of elements\n    flat_list = [item for sublist in nested_lists for item in sublist]\n\n    # Find the intersection of all sets formed by the elements of the nested lists\n    common_elements = set(flat_list)\n\n    # Check each sublist to ensure the common elements appear in all\n    for sublist in nested_lists:\n        common_elements &= set(sublist)\n\n    return common_elements", "matching_cluster_idx": 3}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return set()\n\n    # Find the intersection of all sets in the nested lists\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> set:\n    if not nested_lists:\n        return set()\n\n    # Convert the first list to a set for easier intersection\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the rest of the lists\n    for sublist in nested_lists[1:]:\n        common_elements &= set(sublist)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Create a set for the first list to initialize the comparison\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Find the intersection of the current set of common elements and the current list\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 27.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n (excluding n itself).\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    sum_of_amicable = 0\n    for i in range(2, limit):\n        divisors_sum = sum_of_divisors(i)\n        if divisors_sum != i and divisors_sum < limit and sum_of_divisors(divisors_sum) == i:\n            sum_of_amicable += i\n    return sum_of_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers between 1 and limit (inclusive).\"\"\"\n    sum_amicable = 0\n    for i in range(2, limit + 1):\n        sum_div_i = sum_of_divisors(i)\n        sum_div_j = sum_of_divisors(sum_div_i)\n        if i != sum_div_i and i == sum_div_j:\n            sum_amicable += i\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(n):\n    \"\"\"Function to return the sum of divisors of a number.\"\"\"\n    divisors_sum = 1  # Every number is divisible by 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Function to sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        sum_div = sum_divisors(i)\n        if sum_div != i and sum_div <= limit and sum_divisors(sum_div) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculates the sum of divisors of n, excluding n itself.\"\"\"\n    sum_div = 1  # 1 is a divisor of any number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_i = sum_of_divisors(i)\n        sum_sum_i = sum_of_divisors(sum_i)\n        if i != sum_i and i == sum_sum_i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i:\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    sum_of_amicable_numbers = 0\n    for i in range(2, limit + 1):\n        div_sum = sum_of_divisors(i)\n        if div_sum > i and div_sum < limit and sum_of_divisors(div_sum) == i:\n            sum_of_amicable_numbers += i + div_sum\n    return sum_of_amicable_numbers", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Return the sum of all proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        divisors_sum = sum_of_proper_divisors(i)\n        if i != divisors_sum and divisors_sum <= limit and sum_of_proper_divisors(divisors_sum) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    total_sum = 0\n    for num in range(2, limit + 1):\n        divisor_sum = sum_of_divisors(num)\n        if divisor_sum != num and divisor_sum <= limit and sum_of_divisors(divisor_sum) == num:\n            total_sum += num\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    total = 0\n    for i in range(2, limit):\n        sum_div_i = sum_of_divisors(i)\n        if sum_div_i != i and sum_div_i < limit and sum_of_divisors(sum_div_i) == i:\n            total += i\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Returns the sum of all proper divisors of n (excluding n itself).\"\"\"\n    total = 1  # 1 is a proper divisor of any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to the specified limit.\"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_divisors_i = sum_of_proper_divisors(i)\n        sum_divisors_sum_divisors_i = sum_of_proper_divisors(sum_divisors_i)\n        if i != sum_divisors_i and i == sum_divisors_sum_divisors_i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\" Helper function to calculate the sum of divisors of n (excluding n itself) \"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\" Function to sum all amicable numbers from 1 to a specified number \"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_div_i = sum_of_divisors(i)\n        sum_div_sum_div_i = sum_of_divisors(sum_div_i)\n        if sum_div_i != i and sum_div_i < limit and sum_div_sum_div_i == i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n    sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i:\n                sum += n // i\n    return sum\ndef is_amicable(n):\n    \"\"\"Check if a number is amicable.\"\"\"\n    if n < 2:\n        return False\n    m = sum_of_proper_divisors(n)\n    return m != n and sum_of_proper_divisors(m) == n\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to a specified number.\"\"\"\n    return sum(x for x in range(1, limit + 1) if is_amicable(x))", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum_div = 1  # 1 is always a divisor of any number\n    sqrtn = int(n**0.5)\n    for i in range(2, sqrtn + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    total = 0\n    for i in range(2, limit + 1):\n        sum_div_i = sum_of_divisors(i)\n        sum_div_sum_div_i = sum_of_divisors(sum_div_i)\n        if sum_div_sum_div_i == i and sum_div_i != i:\n            total += i\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit):\n        divisor_sum = sum_of_proper_divisors(i)\n        if i != divisor_sum and divisor_sum <= limit and sum_of_proper_divisors(divisor_sum) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"\n    Returns the sum of all proper divisors of n.\n    \"\"\"\n    sum_divisors = 1  # 1 is a divisor of every number\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_divisors_i = sum_of_divisors(i)\n        sum_divisors_sum_divisors_i = sum_of_divisors(sum_divisors_i)\n        if i != sum_divisors_i and i == sum_divisors_sum_divisors_i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Returns the sum of proper divisors of n (excluding n itself).\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers up to the specified limit.\"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_i = sum_of_proper_divisors(i)\n        sum_sum_i = sum_of_proper_divisors(sum_i)\n        if sum_i > limit or sum_sum_i > limit:\n            continue\n        if i != sum_i and i == sum_sum_i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Returns the sum of divisors of n.\"\"\"\n    sum_divisors = 1  # 1 is a divisor of any number\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Returns the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for i in range(2, limit + 1):\n        sum_divisors_i = sum_of_divisors(i)\n        sum_divisors_j = sum_of_divisors(sum_divisors_i)\n        if i != sum_divisors_i and i == sum_divisors_j:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"\n    Calculates the sum of proper divisors of n.\n    \"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to the specified number.\n    \"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_div_i = sum_of_divisors(i)\n        sum_div_sum_div_i = sum_of_divisors(sum_div_i)\n        if i != sum_div_i and i == sum_div_sum_div_i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n (excluding n itself).\"\"\"\n    total = 1  # 1 is a proper divisor of every integer > 1\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    total_sum = 0\n    for i in range(2, limit + 1):\n        sum_divisors_i = sum_of_divisors(i)\n        sum_divisors_j = sum_of_divisors(sum_divisors_i)\n        if i != sum_divisors_i and i == sum_divisors_j and sum_divisors_i < limit:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_of_divisors(n):\n        # Calculate the sum of proper divisors of n\n        sum_divisors = 1  # 1 is a proper divisor of any n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                sum_divisors += i\n                if i != n // i:\n                    sum_divisors += n // i\n        return sum_divisors\n\n    def is_amicable(n):\n        # Check if n is amicable\n        return sum_of_divisors(n) != n and sum_of_divisors(sum_of_divisors(n)) == n\n\n    # Sum all amicable numbers from 1 to limit\n    return sum(i for i in range(2, limit + 1) if is_amicable(i))", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"\n    Return the sum of proper divisors of n (excluding n itself).\n    \"\"\"\n    sum = 1\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i:\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Return the sum of all amicable numbers from 1 to the specified limit.\n    \"\"\"\n    total_sum = 0\n    for i in range(2, limit):\n        divisor_sum = sum_of_divisors(i)\n        if i != divisor_sum and divisor_sum <= limit and divisor_sum != 0 and sum_of_divisors(divisor_sum) == i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, s):\n    words = s.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Function to find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of the words to include.\n    sentence (str): The sentence from which to extract words.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter out words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into a list of words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the input text into words\n    words = text.split()\n\n    # Filter out words that are not longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Function to find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The length of the words to filter.\n    sentence (str): The sentence to check for long words.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words that are longer than n characters from a given sentence.\n\n    Parameters:\n    n (int): The minimum length of words to be returned.\n    sentence (str): The input sentence to search words from.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter words based on the length\n    result = [word for word in words if len(word) > n]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Use a list comprehension to filter out words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into a list of words\n    words = sentence.split()\n\n    # Filter out the words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n    # Use a list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    longer_than_n = [word for word in words if len(word) > n]\n    return longer_than_n", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Given a list of words in a sentence, return words that are longer than n characters.\n\n    :param n: Minimum length of words to be included in the result\n    :param sentence: String containing the list of words\n    :return: List of words that are longer than n characters\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n\n    # Filter the words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 53.34183673469388, "dps_norm": 88.66666666666666, "pass@1": 61.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    def is_magic_square(matrix):\n        n = len(matrix)\n        target_sum = sum(sum(row) for row in matrix) // n\n\n        for i in range(n):\n            if sum(matrix[i][j] for j in range(n)) != target_sum:\n                return False\n            if sum(matrix[j][i] for j in range(n)) != target_sum:\n                return False\n\n        # Check diagonals\n        if sum(matrix[i][i] for i in range(n)) != target_sum:\n            return False\n        if sum(matrix[i][n - i - 1] for i in range(n)) != target_sum:\n            return False\n\n        return True\n\n    # Validate the input matrix\n    n = len(matrix)\n    if n != len(matrix[0]):\n        return False\n    if any(len(row) != n for row in matrix):\n        return False\n\n    return is_magic_square(matrix)", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0:\n        return False\n\n    # Sum of the first row\n    row_sum = sum(matrix[0])\n\n    # Check all rows\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n\n    # Check all columns\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != row_sum:\n            return False\n\n    # Check diagonals\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != row_sum:\n        return False\n\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n - i - 1]\n    if diagonal_sum != row_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    if not matrix or not matrix[0]:\n        return False\n\n    n = len(matrix)\n    target_sum = sum(matrix[0])\n\n    def is_row_magic(matrix):\n        return all(sum(row) == target_sum for row in matrix)\n\n    def is_col_magic(matrix):\n        return all(sum(matrix[i][j] for i in range(n)) == target_sum for j in range(n))\n\n    def is_diag_magic(matrix):\n        return sum(matrix[i][i] for i in range(n)) == target_sum and sum(matrix[i][n - i - 1] for i in range(n)) == target_sum\n\n    return is_row_magic(matrix) and is_col_magic(matrix) and is_diag_magic(matrix)", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square (same number of rows and columns)\n    if len(matrix) == 0 or len(matrix) != len(matrix[0]):\n        return False\n\n    n = len(matrix)\n\n    # Calculate the expected sum of each row, column, and diagonal\n    expected_sum = sum(sum(row) for row in matrix) // n\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    # Get the order of the magic square\n    n = len(matrix)\n\n    # Calculate the expected sum of any row, column or diagonal\n    expected_sum = sum(sum(row) for row in matrix) // n\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n-i-1] for i in range(n)) != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    if not matrix or any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    magic_sum = sum(sum(row) for row in matrix) // n\n\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    if n % 2 == 0:\n        if sum(matrix[i][i] for i in range(n)) != magic_sum:\n            return False\n        if sum(matrix[i][n - i - 1] for i in range(n)) != magic_sum:\n            return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    # Ensure it's a square matrix\n    if len(matrix) == 0 or any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    total_sum = sum(sum(row) for row in matrix) // n\n\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if row_sum != total_sum or col_sum != total_sum:\n            return False\n\n    # Diagonal sums\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n-1-i] for i in range(n))\n    if diag1_sum != total_sum or diag2_sum != total_sum:\n        return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to check if the given matrix is a magic square.\n\n    :param matrix: List of lists containing the matrix.\n    :return: Boolean indicating whether the matrix is a magic square.\n    \"\"\"\n\n    # Get the order of the matrix (assuming it is a square matrix)\n    n = len(matrix)\n\n    # Calculate the sum of the first row (which should be constant for a magic square)\n    total_sum = sum(matrix[0])\n\n    # Check if all rows have the same sum\n    for row in matrix:\n        if sum(row) != total_sum:\n            return False\n\n    # Check if all columns have the same sum\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != total_sum:\n            return False\n\n    # Check if the diagonals have the same sum\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    diagonal2_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diagonal1_sum != total_sum or diagonal2_sum != total_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # A magic square is a square matrix where the sum of each row, column, and diagonal is the same.\n    n = len(matrix)\n\n    # Calculate the magic constant (sum of the first row)\n    magic_constant = sum(matrix[0])\n\n    # Check each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check the secondary diagonal\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    # If all conditions are met, return True\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the input is a square matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    if not matrix or any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    sum_of_elements = sum(row[0] for row in matrix)\n\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if row_sum != sum_of_elements or col_sum != sum_of_elements:\n            return False\n\n    # Checking diagonals\n    diag1 = sum(matrix[i][i] for i in range(n))\n    diag2 = sum(matrix[i][n-1-i] for i in range(n))\n    if diag1 != sum_of_elements or diag2 != sum_of_elements:\n        return False\n\n    return True\nmatrix = [\n    [7, 12, 1, 14],\n    [2, 13, 8, 11],\n    [16, 3, 10, 5],\n    [9, 6, 15, 4]\n]", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    def is_magic(matrix):\n        n = len(matrix)\n        if n == 0:\n            return False\n\n        # Check for row sum\n        row_sum = sum(matrix[0])\n\n        for row in matrix:\n            if sum(row) != row_sum:\n                return False\n\n        # Check for column sum\n        for col in range(n):\n            col_sum = 0\n            for row in range(n):\n                col_sum += matrix[row][col]\n            if col_sum != row_sum:\n                return False\n\n        # Check for diagonal sum\n        diagonal1_sum = 0\n        diagonal2_sum = 0\n        for i in range(n):\n            diagonal1_sum += matrix[i][i]\n            diagonal2_sum += matrix[i][n-i-1]\n\n        return diagonal1_sum == row_sum and diagonal2_sum == row_sum\n\n    return is_magic(matrix)", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Checks if the given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of each row,\n    each column, and both main diagonals are the same.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return True  # An empty matrix is considered a magic square by convention.\n\n    # Calculate the sum of the first row as the magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check main diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant or sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is n x n\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the magic constant\n    magic_constant = sum(matrix[0])\n\n    # Check rows, columns, and diagonals\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    target_sum = sum([sum(row) for row in matrix]) // n\n\n    for i in range(n):\n        # Check rows and columns\n        if sum(matrix[i]) != target_sum or sum([matrix[j][i] for j in range(n)]) != target_sum:\n            return False\n\n    # Check diagonals\n    if sum([matrix[i][i] for i in range(n)]) != target_sum or sum([matrix[i][n - 1 - i] for i in range(n)]) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if the given matrix is a magic square.\n\n    A magic square is a square matrix in which the sums of the elements of each row, each column, and both main diagonals are the same.\n\n    Parameters:\n    - matrix (list of list of int): The matrix to be tested\n\n    Returns:\n    - bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n\n    # Calculate the expected sum for each row, column, and diagonal\n    first_sum = sum(matrix[0])\n\n    # Check each row\n    for row in matrix:\n        if sum(row) != first_sum:\n            return False\n\n    # Check each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != first_sum:\n            return False\n\n    # Check main diagonals\n    if sum(matrix[i][i] for i in range(n)) != first_sum or sum(matrix[i][n-i-1] for i in range(n)) != first_sum:\n        return False\n\n    # If all checks passed, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculate the sum of the first row.\n    magic_sum = sum(matrix[0])\n\n    # Check for every row and column.\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(matrix[j][i] for j in range(n))\n        if row_sum != magic_sum or col_sum != magic_sum:\n            return False\n\n    # Check both diagonals.\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    diag2_sum = sum(matrix[i][n-i-1] for i in range(n))\n    if diag1_sum != magic_sum or diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check if the sum of all rows, columns, and diagonals are equal to magic_sum\n    for i in range(n):\n        if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(n)) != magic_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum or sum(matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the expected sum of any row/column/diagonal\n    expected_sum = sum(sum(row) for row in matrix) // n\n\n    # Check all rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 10}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row (should be the same for all rows and columns)\n    total_sum = sum(matrix[0])\n\n    # Check if the sums of rows are all the same\n    for row in matrix:\n        if sum(row) != total_sum:\n            return False\n\n    # Check if the sums of columns are all the same\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != total_sum:\n            return False\n\n    # Check if the sums of diagonals are all the same\n    if sum(matrix[i][i] for i in range(n)) != total_sum:\n        return False\n    if sum(matrix[i][n - i - 1] for i in range(n)) != total_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 97.88116591928251, "dps_norm": 82.5, "pass@1": 95.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Using Counter to count the frequency of each item in the list\n    freq_dict = Counter(lst)\n\n    # Finding the item with maximum frequency\n    max_freq_item = max(freq_dict, key=freq_dict.get)\n\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    count = Counter(items)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    max_frequency_item = frequency.most_common(1)[0][0]\n    return max_frequency_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Using collections.Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n\n    # Finding the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to get the frequency of each item\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(items):\n    from collections import Counter\n    # Use Counter to get the frequency of each item in the list\n    frequency = Counter(items)\n    # Find the item with the maximum frequency\n    max_freq_item = frequency.most_common(1)[0]\n    return max_freq_item[0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    return Counter(lst).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    max_freq_item = frequency.most_common(1)[0][0]\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the frequency of each element in the list\n    count = Counter(lst)\n    # Find the item with the maximum frequency\n    most_common_item = count.most_common(1)[0][0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in a given list.\n\n    :param lst: List of integers\n    :return: Integer with the maximum frequency in the list\n    \"\"\"\n    from collections import Counter\n    return Counter(lst).most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each item in the list using Counter\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    max_freq_item = frequency.most_common(1)[0][0]\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to get the frequency of each item in the list\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n\n    # Use Counter to get the frequency of each item\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the frequency of each item\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Using Counter to get the frequency of each item\n    frequency = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_freq_item = max(frequency, key=frequency.get)\n\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n\n    Args:\n    lst: List of integers.\n\n    Returns:\n    int: The item with the maximum frequency.\n    \"\"\"\n    # Using Counter from collections to count occurrences\n    counts = Counter(lst)\n    # Getting the item with the maximum count\n    return counts.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Dictionary to count the frequency of each item\n    frequency = {}\n\n    # Count the frequency of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n\n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(items):\n    count = Counter(items)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    return Counter(lst).most_common(1)[0][0]", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": 71.77419354838709, "dps_norm": 83.125, "pass@1": 20.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # To handle division by zero case\n    return zeroes / non_zeroes", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = sum(1 for x in arr if x == 0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')  # Prevent division by zero", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    if len(arr) == 0:\n        return 0\n\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n\n    if non_zeroes == 0:\n        return float('inf')\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    if not arr:\n        return 0\n\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # To avoid division by zero\n\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle the case where all elements are zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    if not arr:\n        return 0\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = sum(1 for x in arr if x == 0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to find the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n        arr (list of int): The input array.\n\n    Returns:\n        float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function returns the ratio of zeroes to non-zeroes in the given array of integers.\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # handle the case when there are no non-zeroes\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes\n    zero_count = arr.count(0)\n    # Count the number of non-zeroes\n    non_zero_count = len(arr) - zero_count\n    # Return the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # To avoid division by zero\n    return zero_count / non_zero_count", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    total_elements = len(arr)\n    if total_elements == 0:\n        return 0\n\n    zero_count = arr.count(0)\n    non_zero_count = total_elements - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    total_elements = len(arr)\n    zero_count = arr.count(0)\n    non_zero_count = total_elements - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # To handle division by zero\n\n    return zero_count / non_zero_count if non_zero_count != 0 else 0", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = sum(1 for x in arr if x == 0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    # Count the number of non-zeroes in the array\n    non_zero_count = len(arr) - zero_count\n    # Calculate the ratio of zeroes to non-zeroes\n    ratio = zero_count / non_zero_count if non_zero_count != 0 else float('inf')\n    return ratio", "matching_cluster_idx": 7}]}, "Mbpp/140": {"dps": 79.53416149068323, "dps_norm": 81.875, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    :param lists: List of lists containing numbers\n    :return: Set of all numbers from the provided lists\n    \"\"\"\n    flat_set = set()\n    for sublist in lists:\n        for num in sublist:\n            flat_set.add(num)\n    return flat_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    This function flattens a list of lists into a single set of numbers.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lst_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    lst_of_lists (list of lists): A list containing sublists of numbers.\n\n    Returns:\n    set: A set containing all the numbers from the input list of lists.\n    \"\"\"\n    # Use a set comprehension to flatten the list of lists\n    return {num for sublist in lst_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    This function flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of tuples): A list containing tuples of numbers.\n\n    Returns:\n    set: A set containing all numbers from the tuples.\n    \"\"\"\n    flat_list = []\n    for sublist in list_of_lists:\n        flat_list.extend(sublist)\n    return set(flat_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns a set of all the unique numbers in it.\n    \"\"\"\n    return set([item for sublist in list_of_lists for item in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    :param list_of_lists: List of lists of numbers\n    :return: Set of numbers\n    \"\"\"\n    # Using a set comprehension to flatten the list of lists\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and flattens it into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of lists): A list where each element is another list of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the flattened list.\n    \"\"\"\n    # Flatten the list using list comprehension and convert to set to remove duplicates\n    return set([item for sublist in list_of_lists for item in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and flattens it into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of list of int): The input list of lists.\n\n    Returns:\n    set of int: The flattened set of numbers.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Function to flatten a list of lists into a single set of numbers.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of tuples): A list containing tuples of numbers.\n\n    Returns:\n    set: A set containing unique numbers from the input list of tuples.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n\n    # Iterate through each tuple in the list of lists\n    for sublist in list_of_lists:\n        # Add each element of the tuple to the set\n        for number in sublist:\n            unique_numbers.add(number)\n\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lists_of_lists):\n    # Use a set comprehension to flatten the list of lists into a single set of numbers\n    return {num for sublist in lists_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Initialize an empty set to store unique numbers\n    result_set = set()\n\n    # Iterate through each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Add each element of the sublist to the result set\n        result_set.update(sublist)\n\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    return set(flattened_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of tuples): The input list containing sublists.\n\n    Returns:\n    set: A set containing all the numbers from the sublists.\n    \"\"\"\n    flat_list = []\n    for sublist in list_of_lists:\n        flat_list.extend(sublist)\n    return set(flat_list)", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    :param nested_list: List of lists, each containing integers.\n    :return: Set containing all integers from the nested lists.\n    \"\"\"\n    flat_list = [item for sublist in nested_list for item in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return set(flat_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of list of int): A list containing lists of integers.\n\n    Returns:\n    set: A set of integers.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns a set of numbers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n\n    # Iterate over each sublist in the input list\n    for sublist in lists_of_lists:\n        # Add each element from the sublist to the set\n        for element in sublist:\n            unique_numbers.add(element)\n\n    # Return the set of unique numbers\n    return unique_numbers", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lists):\n    flattened_set = set()\n    for sublist in lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}]}, "Mbpp/141": {"dps": 66.34920634920636, "dps_norm": 41.25, "pass@1": 28.0, "profiled": [{"solution": "def pancake_sort(pancakes):\n    n = len(pancakes)\n\n    def flip(pancakes, k):\n        left, right = 0, k\n        while left < right:\n            pancakes[left], pancakes[right] = pancakes[right], pancakes[left]\n            left += 1\n            right -= 1\n\n    for i in range(n, 1, -1):\n        max_idx = pancakes.index(max(pancakes[:i]))\n        if max_idx != i - 1:\n            flip(pancakes, max_idx)\n            flip(pancakes, i - 1)\n\n    return pancakes", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(pancakes):\n    n = len(pancakes)\n    for size in range(n, 1, -1):\n        # Find the maximum element in the first `size` elements\n        max_index = pancakes.index(max(pancakes[:size]))\n\n        # Move the maximum element to the beginning if it's not already there\n        if max_index != 0:\n            pancakes[0], pancakes[max_index] = pancakes[max_index], pancakes[0]\n\n        # Flip the element to its correct position\n        pancakes = pancakes[:size][::-1] + pancakes[size:]\n\n    return pancakes", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(pancakes):\n    n = len(pancakes)\n\n    for size in range(n, 1, -1):\n        # Find the largest element in the unsorted part and swap it with the first element.\n        max_index = pancakes.index(max(pancakes[:size]))\n        if max_index != 0:\n            pancakes[0], pancakes[max_index] = pancakes[max_index], pancakes[0]\n\n        # Move the largest element to its correct position\n        pancakes[:size] = reversed(pancakes[:size])\n\n    return pancakes", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n\n    def flip(arr, k):\n        left, right = 0, k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    for size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != size - 1:\n            flip(arr, max_idx)\n            flip(arr, size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using a pancake sort algorithm.\n    :param arr: List of integers to be sorted.\n    :return: Sorted list of integers.\n    \"\"\"\n    def flip(arr, k):\n        left, right = 0, k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            flip(arr, max_idx)\n            flip(arr, i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    # Function to flip the first k elements\n    def flip(k):\n        arr[:k] = arr[:k][::-1]\n\n    # Iterate over each element to find the maximum element in the first i elements\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element\n        max_index = arr.index(max(arr[:i]))\n        # Flip the maximum element to the front\n        if max_index != 0:\n            flip(max_index + 1)\n        # Move the maximum element to the end\n        flip(i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(start, end):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    def max_index(start, end):\n        max_val = arr[start]\n        max_idx = start\n        for i in range(start, end + 1):\n            if arr[i] > max_val:\n                max_val = arr[i]\n                max_idx = i\n        return max_idx\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_idx = max_index(0, size - 1)\n        if max_idx != 0:\n            flip(0, max_idx)\n        flip(0, size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(pancakes):\n    # Function to flip a portion of the list\n    def flip(start, end):\n        while start < end:\n            pancakes[start], pancakes[end] = pancakes[end], pancakes[start]\n            start += 1\n            end -= 1\n\n    # Perform Pancake Sort\n    n = len(pancakes)\n    for size in range(n, 1, -1):\n        # Find the maximum element in the first `size` elements\n        max_idx = pancakes.index(max(pancakes[:size]))\n\n        # If the maximum element is not already in place, move it to the start\n        if max_idx != 0:\n            flip(0, max_idx)\n\n        # Move the maximum element to the end of the list\n        flip(0, size - 1)\n\n    return pancakes", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(pancakes):\n    n = len(pancakes)\n    for size in range(n, 1, -1):\n        # Find the maximum in the first size elements\n        max_idx = pancakes.index(max(pancakes[:size]))\n\n        # Flip the maximum to the start\n        pancakes[:max_idx+1] = reversed(pancakes[:max_idx+1])\n\n        # Flip the first size elements to the end\n        pancakes[:size] = reversed(pancakes[:size])\n\n    return pancakes", "matching_cluster_idx": 3}, {"solution": "def flip_pancake(arr, k):\n    # Flip the pancake at index k in the array\n    arr[:k+1] = reversed(arr[:k+1])\n    return arr\ndef pancake_sort(arr):\n    n = len(arr)\n\n    for size in range(n, 1, -1):\n        # Find the maximum element in the first size elements\n        max_index = arr.index(max(arr[:size]))\n\n        if max_index != 0:\n            # Flip the pancake to bring the max element to the beginning\n            arr = flip_pancake(arr, max_index)\n\n        # Move the max element to the end\n        arr = flip_pancake(arr, size-1)\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        left, right = 0, k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != size - 1:\n            flip(arr, max_idx)\n            flip(arr, size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Pancake sort algorithm implementation\n    def flip(arr, k):\n        left = 0\n        right = k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Move the maximum element to the beginning\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != 0:\n            flip(arr, max_idx)\n        # Move the maximum element to the end\n        flip(arr, size - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    # This will sort the list in ascending order using bubble sort algorithm\n    n = len(lst)\n    for i in range(n):\n        # Last i elements are already in place\n        for j in range(0, n-i-1):\n            if lst[j] > lst[j+1]:\n                # Swap if the element found is greater than the next element\n                lst[j], lst[j+1] = lst[j+1], lst[j]\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        left = 0\n        right = k - 1\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            flip(arr, size)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(pancakes):\n    def flip(arr, k):\n        left = 0\n        right = k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(pancakes)\n    for i in range(n, 1, -1):\n        # Find the maximum element in the first i elements\n        max_idx = pancakes.index(max(pancakes[:i]))\n        if max_idx != i - 1:\n            # Flip the first i elements to bring the maximum to the end\n            flip(pancakes, max_idx)\n            # Flip the first i elements to bring the maximum to the front\n            flip(pancakes, i - 1)\n    return pancakes", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the maximum element in the first `size` elements\n        max_index = arr.index(max(arr[:size]))\n\n        # Move the maximum element to the beginning, if it is not already there\n        if max_index != 0:\n            arr[:max_index + 1] = reversed(arr[:max_index + 1])\n\n        # Move the maximum element to the end of the sorted portion\n        arr[:size] = reversed(arr[:size])\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        left = 0\n        right = k - 1\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != size - 1:\n            flip(arr, max_idx + 1)\n            flip(arr, size)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, start):\n        left, right = 0, start\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    def move_max(arr, n):\n        max_idx = arr.index(max(arr[:n]))\n        if max_idx != n - 1:\n            flip(arr, max_idx)\n            flip(arr, n - 1)\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        move_max(arr, size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Function to flip the array up to index 'k'\n    def flip(arr, k):\n        left = 0\n        right = k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n\n    # Iterate through the array in reverse order\n    for size in range(n, 1, -1):\n        # Find the maximum element in the first 'size' elements\n        max_index = arr.index(max(arr[:size]))\n\n        # Move the maximum element to the first position if it's not already there\n        if max_index != 0:\n            flip(arr, max_index)\n\n        # Move the maximum element to its final position\n        flip(arr, size - 1)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        left, right = 0, k\n        while left < right:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_index = arr.index(max(arr[:size]))\n        if max_index != size - 1:\n            flip(arr, max_index)\n            flip(arr, size - 1)\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 96.0, "profiled": [{"solution": "def find_even_pair(lst):\n    # Initialize count of pairs that XOR to an even number\n    count = 0\n\n    # Iterate through each element in the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # Check if XOR of pair (lst[i], lst[j]) is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Number of pairs that XOR to an even number\n    even_pair_count = 0\n\n    # Iterate over the list and check for every pair\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_pair_count += 1\n\n    return even_pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_pair_count = 0\n\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_pair_count += 1\n\n    return even_pair_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    even_count = 0\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                even_count += 1\n\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    even_count = 0\n\n    # Count pairs where XOR result is even\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_count += 1\n\n    return even_count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 96.81159420289855, "dps_norm": 99.375, "pass@1": 39.0, "profiled": [{"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Finds the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n    numbers (list of int): The list of numbers.\n    start_index (int): The start index of the range (inclusive).\n    end_index (int): The end index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n\n    Parameters:\n    lst (list): The list of numbers.\n    start (int): The starting index.\n    end (int): The ending index.\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of elements in the list within the specified range of indices.\n\n    Parameters:\n    - numbers: list of numbers\n    - start_index: start index of the range (inclusive)\n    - end_index: end index of the range (inclusive)\n\n    Returns:\n    - sum of elements within the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): List of numbers.\n    start (int): Start index of the range.\n    end (int): End index of the range.\n\n    Returns:\n    int: Sum of numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n    numbers (list): List of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    # Calculate the sum of elements within the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    This function returns the sum of numbers in a list within a specified range.\n\n    Parameters:\n    nums (list): The list of numbers.\n    start_index (int): The start index (inclusive) of the range.\n    end_index (int): The end index (inclusive) of the range.\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(nums[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive) of the range\n    :param end_index: Ending index (inclusive) of the range\n    :return: Sum of elements in the specified range\n    \"\"\"\n    # Ensure indices are within the bounds of the list\n    start_index = max(0, start_index)\n    end_index = min(len(lst), end_index)\n\n    # Calculate the sum of elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    This function returns the sum of numbers in a list within a specified range.\n\n    Parameters:\n    numbers (list of int): List of numbers to sum.\n    start (int): Starting index of the range.\n    end (int): Ending index of the range (inclusive).\n\n    Returns:\n    int: Sum of the numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    This function returns the sum of elements in the list within the specified range.\n\n    :param lst: List of integers\n    :param start: Start index (inclusive)\n    :param end: End index (inclusive)\n    :return: Sum of the elements in the range\n    \"\"\"\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    lst (list): A list of numbers.\n    start_index (int): The start index (inclusive) for the range.\n    end_index (int): The end index (inclusive) for the range.\n\n    Returns:\n    int: The sum of the numbers in the specified range.\n    \"\"\"\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    This function returns the sum of the numbers in the list within the specified range.\n\n    Parameters:\n    numbers (list of int): List of numbers.\n    start (int): Start index of the range (inclusive).\n    end (int): End index of the range (inclusive).\n\n    Returns:\n    int: Sum of the numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    # Ensure the indices are within the valid range\n    if start_index < 0 or end_index >= len(numbers) or start_index > end_index:\n        return 0\n\n    # Calculate the sum of the sublist\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list from start_index to end_index (inclusive).\n\n    :param lst: List of numbers\n    :param start_index: Start of the range (inclusive)\n    :param end_index: End of the range (inclusive)\n    :return: Sum of the numbers in the specified range\n    \"\"\"\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculates the sum of numbers in the list between the indices start and end (inclusive).\n\n    Args:\n    nums (list): List of integers.\n    start (int): Start index (inclusive).\n    end (int): End index (inclusive).\n\n    Returns:\n    int: Sum of numbers within the specified range.\n    \"\"\"\n    return sum(nums[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    # Calculate the sum of numbers within the specified range\n    return sum(nums[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    # Validate the indices\n    if start < 0 or end >= len(numbers) or start > end:\n        return 0\n\n    # Sum the numbers within the specified range\n    return sum(numbers[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Finds the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n    nums (list of int): The list of numbers.\n    start (int): The starting index (inclusive).\n    end (int): The ending index (inclusive).\n\n    Returns:\n    int: The sum of the elements in the specified range.\n    \"\"\"\n    return sum(nums[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_idx, end_idx):\n    \"\"\"\n    Calculate the sum of numbers in the list within the specified range of indices.\n\n    Parameters:\n    nums (list): The list of numbers.\n    start_idx (int): The start index of the range.\n    end_idx (int): The end index of the range.\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(nums[start_idx:end_idx + 1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 77.1705426356589, "dps_norm": 39.285714285714285, "pass@1": 49.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes the characters with odd index values from the given string.\n\n    Args:\n    s (str): The input string from which characters will be removed.\n\n    Returns:\n    str: A new string with characters having even index values.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Create a new string with only the characters at even indices\n    return ''.join(input_string[i] for i in range(0, len(input_string), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"\n    Remove characters from the given string that are at odd index values (0-based indexing).\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The new string with characters at odd indices removed.\n    \"\"\"\n    # Using a list comprehension to filter out characters at odd indices\n    return ''.join([char for index, char in enumerate(s) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    This function removes characters which have odd index values from the given string.\n    Indices are 0-based.\n\n    Args:\n    input_string (str): The input string from which odd index characters will be removed.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n\n    Args:\n    s (str): Input string.\n\n    Returns:\n    str: String with characters at even indices retained.\n    \"\"\"\n    return ''.join(s[i] for i in range(0, len(s), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to hold the result\n    result = ''\n\n    # Iterate over the input string and collect characters at even indices\n    for index in range(0, len(input_string), 2):\n        result += input_string[index]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def odd_values_string(s):\n    # Create a new string by concatenating characters at even indices\n    return ''.join(s[i] for i in range(0, len(s), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result = ''\n\n    # Iterate through the string and append characters at even indices to the result\n    for i in range(0, len(input_string), 2):\n        result += input_string[i]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values from the given string.\n\n    Args:\n    s (str): Input string.\n\n    Returns:\n    str: String with characters at even indices.\n    \"\"\"\n    return ''.join(s[i] for i in range(0, len(s), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd indices from the input string.\n\n    :param s: str - Input string\n    :return: str - String with characters at odd indices removed\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indexes.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Using list comprehension to collect characters at even indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Use a list comprehension to filter out characters at even indices and join them into a string\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    This function removes characters from the input string that are at odd indices.\n    \"\"\"\n    # Use step parameter in slicing to only include characters with even indices\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"\n    This function removes characters at odd index values from the input string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with characters at odd indexes removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string: str) -> str:\n    # Use a list comprehension to keep only characters at odd indices\n    result = ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s: str) -> str:\n    # Using a list comprehension to select characters at even indexes (0, 2, 4, ...)\n    return ''.join([s[i] for i in range(0, len(s), 2)])", "matching_cluster_idx": 4}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from a given string that are at odd index values.\n\n    :param s: Input string\n    :return: String with characters at even index values\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values from a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with characters at odd indexes removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    :param string: The input string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces blank spaces in the string `s` with the character `char`.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces blank spaces in the string `s` with the character `char` and returns the modified string.\n\n    Parameters:\n    s (str): The input string to process.\n    char (str): The character to replace the blank spaces with.\n\n    Returns:\n    str: The string with blank spaces replaced by the character `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replaces blank spaces in the string with the given character.\n\n    Parameters:\n    string (str): The string to modify.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    # Replace all blank spaces in the string with the specified character\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces blank spaces in the input_string with the given character and returns the modified string.\n\n    Args:\n    input_string (str): The original string.\n    char (str): The character to replace the blank spaces.\n\n    Returns:\n    str: The string with blank spaces replaced by the given character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces blank spaces in the string s with the character char.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to replace the blank spaces with.\n\n    Returns:\n    str: The string with blank spaces replaced by char.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replaces blank spaces in the given string with the provided character.\n\n    Args:\n    string (str): The original string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    This function replaces all blank spaces in the string `s` with the character `char` and returns the modified string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The original string with blank spaces.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Using the replace method to substitute spaces with the provided character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    # Use the replace() method to replace all spaces with the given character\n    return input_string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the string `s` with the character `char`.\n\n    :param s: Input string\n    :param char: Character to replace blank spaces\n    :return: String with blank spaces replaced by `char`\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the string s with the character char.\n\n    Args:\n    s (str): The original string.\n    char (str): The character to replace the blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace blank spaces in the string s with the character char.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace blank spaces in the string with the given character.\n\n    Parameters:\n    s (str): Input string with spaces.\n    char (str): Character to replace the spaces with.\n\n    Returns:\n    str: String with spaces replaced by the given character.\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replace blank spaces in the string with the given character.\n\n    :param string: The input string with spaces to be replaced.\n    :param char: The character to replace the spaces with.\n    :return: The modified string with spaces replaced.\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    # Use the built-in replace method to replace all spaces with the given character\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace all blank spaces in the string with the specified character.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/240": {"dps": 70.85365853658537, "dps_norm": 81.11111111111111, "pass@1": 32.0, "profiled": [{"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    lst1 (list): The first list where the last element will be replaced.\n    lst2 (list): The second list whose elements will replace the last element of the first list.\n\n    Returns:\n    list: A new list with the modifications made.\n    \"\"\"\n    # Remove the last element from the first list\n    lst1 = lst1[:-1]\n\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    # Ensure the first list is not empty\n    if not lst1:\n        return lst2\n    # Slice the first list to exclude the last element, and extend it with elements from the second list\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with list2\n    if len(list1) > 0:\n        list1[-1:] = list2\n    else:\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(first_list, second_list):\n    # Replace the last element of the first list with the entire second list\n    index = len(first_list) - 1\n    first_list[index:] = second_list\n    return first_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    if len(lst1) > 0:\n        lst1[-1:] = lst2\n    else:\n        lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Find the last index of the first list\n    last_index = len(lst1) - 1\n\n    # Extend the first list with the elements of the second list starting from the last index\n    lst1[last_index:] = lst2\n\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n    lst1 (list): The first list where the last element will be replaced.\n    lst2 (list): The second list whose elements will replace the last element of the first list.\n\n    Returns:\n    list: The modified first list.\n    \"\"\"\n    if len(lst1) == 0:\n        return lst2\n    # Replace the last element with the second list\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 has at least one element\n    if not list1:\n        return list2\n\n    # Remove the last element of list1\n    list1.pop()\n\n    # Extend list1 with elements of list2\n    list1.extend(list2)\n\n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Get the index of the last element in list1\n    last_index = len(list1) - 1\n    # Replace the last element with the elements of list2\n    list1[last_index:] = list2\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(first_list, second_list):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Get the index of the last element in the first list\n    last_index = len(first_list) - 1\n\n    # Replace the last element with the second list\n    first_list[last_index:] = second_list\n\n    return first_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Extend list1 by replacing its last element with elements of list2\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with all elements of list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n\n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The second list.\n\n    Returns:\n    list: The modified first list.\n    \"\"\"\n    # Find the index of the last element of lst1\n    last_index = len(lst1) - 1\n\n    # Replace the last element with lst2\n    lst1[last_index:] = lst2\n\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with elements of lst2\n    last_index = len(lst1) - 1\n    lst1[last_index:] = lst2\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    # Check if lst1 is not empty and replace the last element with lst2\n    if lst1:\n        index = len(lst1) - 1\n        lst1[index:] = lst2\n    # If lst1 is empty, return lst2\n    else:\n        lst1 = lst2\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 has at least one element\n    if len(list1) == 0:\n        raise ValueError(\"list1 must contain at least one element\")\n\n    # Replace the last element of list1 with list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    if len(lst1) > 0:\n        lst1[-1:] = lst2  # Replace the last element of lst1 with lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Check if the first list has at least one element\n    if len(lst1) > 0:\n        # Replace the last element of lst1 with the entire lst2\n        lst1[:-1] = lst1[:-1]\n        lst1[-1:] = lst2\n    else:\n        # If lst1 is empty, return lst2\n        lst1 = lst2\n    return lst1", "matching_cluster_idx": 5}, {"solution": "def replace_list(first_list, second_list):\n    # Calculate the index of the last element in the first list\n    last_index = len(first_list) - 1\n\n    # Remove the last element of the first list\n    first_list = first_list[:last_index]\n\n    # Extend the first list with the elements of the second list\n    first_list.extend(second_list)\n\n    return first_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n\n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The second list whose elements will replace the last element of lst1.\n\n    Returns:\n    list: A new list where the last element of lst1 is replaced by the elements of lst2.\n    \"\"\"\n    # Calculate the last element index of the first list\n    last_index = len(lst1) - 1\n\n    # Create a new list by concatenating lst1 (excluding the last element) and lst2\n    new_list = lst1[:last_index] + lst2\n\n    return new_list", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    # Ensure lst1 has at least one element\n    if len(lst1) == 0:\n        return lst2\n\n    # Replace the last element with the elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 41.66666666666667, "dps_norm": 65.0, "pass@1": 42.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    # Initialize an empty result list\n    result = []\n\n    # Iterate over the input list\n    for index, value in enumerate(lst):\n        # Insert the element before the current value\n        result.append(elem)\n        result.append(value)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for idx in range(len(lst)):\n        result.append(element)\n        result.append(lst[idx])\n    return result", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, elem):\n    # Start with an empty result list\n    result = []\n\n    # Iterate over the input list\n    for i in range(len(lst)):\n        # Insert the element before the current element of the list\n        result.append(elem)\n        result.append(lst[i])\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in range(len(lst)):\n        result.append(element)\n        if i < len(lst):\n            result.append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in range(len(lst)):\n        result.append(elem)\n        result.append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to hold the resulting elements\n    result = []\n\n    # Loop through the input list\n    for index in range(len(lst)):\n        # Append the element before the current element in the list\n        result.append(element)\n        result.append(lst[index])\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, elem):\n    # Create a new list to store the result\n    result = []\n\n    # Iterate through the input list\n    for i in range(len(lst)):\n        # Insert the element before the current element\n        result.append(elem)\n        # Append the current element to the result\n        result.append(lst[i])\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n\n    Args:\n    lst (list): The input list.\n    element: The element to be inserted before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each element of the input list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n\n    # Loop through the input list\n    for i in range(len(lst)):\n        # Append the element and the current list element to the result\n        result.append(element)\n        result.append(lst[i])\n\n    # Return the resulting list\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, elem):\n    # Initialize an empty result list\n    result = []\n\n    # Iterate over the input list\n    for item in lst:\n        # Append the element to insert and the current item to the result list\n        result.append(elem)\n        result.append(item)\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    if not lst:\n        return []\n\n    result = []\n    for i in range(len(lst)):\n        result.append(elem)\n        result.append(lst[i])\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate through the input list\n    for i in range(len(lst)):\n        # Insert the element before the current element in the list\n        result.append(element)\n        # Append the current element to the result list\n        result.append(lst[i])\n\n    # Return the resulting list\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in the list.\n\n    Args:\n    lst (list): The list of elements.\n    element: The element to be inserted before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each element.\n    \"\"\"\n    if not lst:\n        return []\n\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for i in range(len(lst)):\n        result.append(elem)\n        result.append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    result = []\n    for i in range(len(lst)):\n        result.append(element)\n        result.append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the resulting elements\n    result = []\n\n    # Iterate over the input list\n    for i in range(len(lst)):\n        # Append the element before the current element of the list\n        result.append(element)\n        # Append the current element of the list\n        result.append(lst[i])\n\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/256": {"dps": 72.55707762557077, "dps_norm": 67.6470588235294, "pass@1": 76.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\ndef count_Primes_nums(limit):\n    \"\"\"Function to count prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for num in range(2, limit):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    prime_count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            prime_count += 1\n    return prime_count", "matching_cluster_idx": 10}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    # Initialize a list to keep track of prime numbers\n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not prime numbers\n\n    # Sieve of Eratosthenes to find all primes <= n\n    p = 2\n    while p * p < n:\n        if primes[p]:\n            for i in range(p * p, n, p):\n                primes[i] = False\n        p += 1\n\n    # Count the number of primes\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(limit):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for num in range(2, limit):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(limit):\n    \"\"\"Function that counts the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for num in range(2, limit):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    # Initializing the list to keep track of prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    # Use Sieve of Eratosthenes algorithm to find all prime numbers up to n\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a given non-negative number.\n\n    Args:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The number of prime numbers less than n.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            prime_count += 1\n    return prime_count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "import math\ndef is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    sqrt_num = int(math.sqrt(num)) + 1\n    for i in range(3, sqrt_num, 2):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 9}, {"solution": "def count_Primes_nums(n):\n    if n <= 1:\n        return 0\n\n    # Initialize the sieve with all numbers marked as prime\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    # Implement the Sieve of Eratosthenes\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n\n    # Count the number of primes less than n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of primes less than n.\"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of prime numbers less than a given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of prime numbers less than a given non-negative number.\"\"\"\n    count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "import math\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 9}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes a non-negative integer n and returns the count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    def is_prime(num):\n        \"\"\"\n        Helper function to check if a number is prime.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            prime_count += 1\n\n    return prime_count", "matching_cluster_idx": 8}]}, "Mbpp/265": {"dps": 57.7906976744186, "dps_norm": 75.83333333333333, "pass@1": 45.0, "profiled": [{"solution": "def list_split(lst, n):\n    # Number of sublists needed\n    num_sublists = len(lst) // n\n    remainder = len(lst) % n\n\n    sublists = [[] for _ in range(n)]\n\n    for i, elem in enumerate(lst):\n        sublists[i % n].append(elem)\n\n    # Adjust for remainders if there are any\n    if remainder != 0:\n        sublists = [sublist[:num_sublists + 1] for sublist in sublists]\n\n    return sublists", "matching_cluster_idx": 2}, {"solution": "def list_split(lst, n):\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n\n    result = [[] for _ in range(n)]\n\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the list into multiple lists, each containing every nth element.\n\n    :param lst: List of elements to be split.\n    :param n: The interval at which to split the list.\n    :return: List of lists, each containing elements at nth intervals.\n    \"\"\"\n    result = []\n    for i in range(n):\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        result.append(sublist)\n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    # Create a new list of lists with n elements each\n    split_lists = [input_list[i::n] for i in range(n)]\n    return split_lists", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list into sublists every nth element.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists, with each sublist containing every nth element from the original list.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n\n    length = len(input_list)\n    result = [[] for _ in range(n)]\n\n    for i in range(length):\n        result[i % n].append(input_list[i])\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i in range(len(lst)):\n        result[i % n].append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list into n lists with elements equally distributed.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The number of lists to split into.\n\n    Returns:\n    list: A list containing n lists with equally distributed elements.\n    \"\"\"\n    result = [[] for _ in range(n)]\n\n    for i, item in enumerate(input_list):\n        result[i % n].append(item)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into a list of lists, with each sublist containing every nth element.\n\n    :param lst: List to be split\n    :param n: Interval for splitting the list\n    :return: List of sublists\n    \"\"\"\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list into n sublists starting from the first element.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(input_list):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, starting from the first element.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The number of sublists to be created.\n\n    Returns:\n    list: A list of sublists.\n    \"\"\"\n    # Initialize the resulting list of sublists\n    result = [[] for _ in range(n)]\n\n    # Iterate over the input list and distribute elements into the n sublists\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        part = []\n        for j in range(i, len(lst), n):\n            part.append(lst[j])\n        result.append(part)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list for every nth element, returning a list of the resulting lists.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists, each containing elements from the original list.\n    \"\"\"\n    result = []\n    for i in range(n):\n        result.append([])\n    for index, item in enumerate(input_list):\n        result[index % n].append(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list into n lists containing every nth element.\n\n    Args:\n    input_list (list): The list to be split.\n    n (int): The number of splits.\n\n    Returns:\n    list: A list of lists, each containing every nth element from the input list.\n    \"\"\"\n    result = []\n    length = len(input_list)\n    for i in range(n):\n        subset = []\n        for j in range(i, length, n):\n            subset.append(input_list[j])\n        result.append(subset)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append([])\n    for i, value in enumerate(lst):\n        result[i % n].append(value)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        result.append(sublist)\n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Create the lists to be filled\n    result = [[] for _ in range(n)]\n\n    # Distribute the elements\n    for i, elem in enumerate(lst):\n        result[i % n].append(elem)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input list into n lists, each containing every nth element.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The number of splits to create.\n\n    Returns:\n    list: A list of lists, where each sublist contains elements from the input_list.\n    \"\"\"\n    # Creating n empty lists\n    result = [[] for _ in range(n)]\n\n    # Iterating over the input list\n    for index, item in enumerate(input_list):\n        # Adding the current item to the corresponding sublist\n        result[index % n].append(item)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(lst):\n        result[i % n].append(item)\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.1, "dps_norm": 82.72727272727272, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): A list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in the list are unique.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if all elements of the given list are unique.\n\n    Parameters:\n    lst (list): The list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if the elements of a given list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements of the list are unique.\n\n    Args:\n    lst (list): The list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): A list of elements to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if all elements of the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Using a set to track seen elements\n    seen = set()\n    for element in lst:\n        if element in seen:\n            return False\n        seen.add(element)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    # Convert the list to a set and compare its length with the length of the list\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function checks if the elements of the given list are unique.\n\n    Args:\n        lst (list): A list of elements to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    # Using a set to track seen elements\n    seen = set()\n\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    # Use set to check if elements are unique\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if the elements of the given list are unique.\n\n    Parameters:\n    lst (list): A list of elements\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): List of elements to be checked.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    This function checks if all elements in the given list are unique.\n\n    Args:\n    lst (list): A list of elements to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): List of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 77.17948717948718, "dps_norm": 89.16666666666667, "pass@1": 66.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    # Counting inversions in the given array\n    count = 0\n    n = len(arr)\n\n    # Loop through each element of the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # If element found is smaller than the next element, increment count\n            if arr[i] > arr[j]:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            j += 1\n            inv_count += (mid - i + 1)\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp, left, mid)\n        inv_count += merge_sort_and_count(arr, temp, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp = [0] * len(arr)\n    return merge_sort_and_count(arr, temp, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort_and_count_inversions(arr, tmp_arr, left, right):\n        inv_count = 0\n        if right > left:\n            mid = (right + left) // 2\n            inv_count += merge_sort_and_count_inversions(arr, tmp_arr, left, mid)\n            inv_count += merge_sort_and_count_inversions(arr, tmp_arr, mid+1, right)\n            inv_count += merge_and_count(arr, tmp_arr, left, mid, right)\n        return inv_count\n\n    def merge_and_count(arr, tmp_arr, left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv_count = 0\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                tmp_arr[k] = arr[i]\n                i += 1\n            else:\n                tmp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        while i <= mid:\n            tmp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            tmp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        for i in range(left, right + 1):\n            arr[i] = tmp_arr[i]\n\n        return inv_count\n\n    tmp = [0]*len(arr)\n    return merge_sort_and_count_inversions(arr, tmp, 0, len(arr)-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inversions = 0\n\n    # Traverse through all pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If element found is smaller than the next element then increment count of inversions\n            if arr[i] > arr[j]:\n                inversions += 1\n\n    return inversions", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_sort_and_count(arr):\n    \"\"\"\n    Helper function that sorts the array and counts the inversions using merge sort.\n    \"\"\"\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        # Recursively sort and count inversions in both halves\n        left_inversions = merge_sort_and_count(left_half)\n        right_inversions = merge_sort_and_count(right_half)\n\n        # Merge the two halves and count inversions\n        i = j = k = 0\n        inversions = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] <= right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n                inversions += (len(left_half) - i)  # Count inversions\n            k += 1\n\n        # Copy the remaining elements\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n        # Total inversions\n        return left_inversions + right_inversions + inversions\n\n    return 0\ndef get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in the array.\n    \"\"\"\n    return merge_sort_and_count(arr)", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count_inversions(arr):\n    \"\"\"\n    This function sorts the array and counts the number of inversions.\n    \"\"\"\n    # Helper function to perform merge and count inversions\n    def merge_and_count(left, right):\n        sorted_arr = []\n        i = j = 0\n        inv_count = 0\n\n        # Merge the arrays and count the inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                sorted_arr.append(left[i])\n                i += 1\n            else:\n                sorted_arr.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n\n        # Add remaining elements\n        while i < len(left):\n            sorted_arr.append(left[i])\n            i += 1\n\n        while j < len(right):\n            sorted_arr.append(right[j])\n            j += 1\n\n        return sorted_arr, inv_count\n\n    # Base case: a list of zero or one elements has zero inversions\n    if len(arr) <= 1:\n        return arr, 0\n\n    # Recursively split the array into halves and merge the sorted halves\n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    left_sorted, left_inv_count = merge_sort_and_count_inversions(left_half)\n    right_sorted, right_inv_count = merge_sort_and_count_inversions(right_half)\n\n    sorted_arr, split_inv_count = merge_and_count(left_sorted, right_sorted)\n\n    # Total inversions = inversions within left + inversions within right + inversions across split\n    return sorted_arr, left_inv_count + right_inv_count + split_inv_count\ndef get_Inv_Count(arr):\n    _, inversion_count = merge_sort_and_count_inversions(arr)\n    return inversion_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp, left, mid, right):\n    i = left      # Initial index of the left subarray\n    j = mid + 1   # Initial index of the right subarray\n    k = left      # Initial index of the merged subarray\n    inv_count = 0 # Number of inversions\n\n    # Merging the two subarrays into temp array\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp[k] = arr[i]\n            i += 1\n        else:\n            temp[k] = arr[j]\n            j += 1\n            inv_count += mid - i + 1\n        k += 1\n\n    # Copying the remaining elements of left subarray, if any\n    while i <= mid:\n        temp[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copying the remaining elements of right subarray, if any\n    while j <= right:\n        temp[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copying back the merged elements to the original array\n    for i in range(left, right + 1):\n        arr[i] = temp[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp, left, right):\n    inv_count = 0\n\n    # Base case: An array or subarray of size 1 doesn't have inversions\n    if left < right:\n        mid = (left + right) // 2\n\n        # Recursive call on the left subarray\n        inv_count += merge_sort_and_count(arr, temp, left, mid)\n\n        # Recursive call on the right subarray\n        inv_count += merge_sort_and_count(arr, temp, mid + 1, right)\n\n        # Merging the two subarrays and counting inversions\n        inv_count += merge_and_count(arr, temp, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp = [0] * len(arr)\n    return merge_sort_and_count(arr, temp, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left_arr, left_inv_count = merge_sort_and_count(arr[:mid])\n    right_arr, right_inv_count = merge_sort_and_count(arr[mid:])\n\n    sorted_arr, inv_count = merge_and_count(left_arr, right_arr)\n    return sorted_arr, left_inv_count + right_inv_count + inv_count\ndef merge_and_count(left, right):\n    sorted_arr = []\n    left_idx, right_idx = 0, 0\n    inv_count = 0\n\n    while left_idx < len(left) and right_idx < len(right):\n        if left[left_idx] <= right[right_idx]:\n            sorted_arr.append(left[left_idx])\n            left_idx += 1\n        else:\n            sorted_arr.append(right[right_idx])\n            inv_count += len(left) - left_idx\n            right_idx += 1\n\n    sorted_arr.extend(left[left_idx:])\n    sorted_arr.extend(right[right_idx:])\n    return sorted_arr, inv_count\ndef get_Inv_Count(arr):\n    sorted_arr, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv_count = merge_sort_and_count(arr[:mid])\n    right, right_inv_count = merge_sort_and_count(arr[mid:])\n\n    merged, inv_count = merge_and_count(left, right)\n\n    return merged, left_inv_count + right_inv_count + inv_count\ndef merge_and_count(left, right):\n    merged = []\n    left_index = 0\n    right_index = 0\n    inv_count = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            merged.append(left[left_index])\n            left_index += 1\n        else:\n            merged.append(right[right_index])\n            inv_count += len(left) - left_index  # inversions caused by the current element in right\n            right_index += 1\n\n    merged.extend(left[left_index:])\n    merged.extend(right[right_index:])\n\n    return merged, inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv_count = merge_sort_and_count(arr[:mid])\n    right, right_inv_count = merge_sort_and_count(arr[mid:])\n\n    sorted_arr = []\n    i, j, inv_count = 0, 0, 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            sorted_arr.append(left[i])\n            i += 1\n        else:\n            sorted_arr.append(right[j])\n            j += 1\n            inv_count += (len(left) - i)\n\n    sorted_arr += left[i:]\n    sorted_arr += right[j:]\n\n    return sorted_arr, inv_count + left_inv_count + right_inv_count\ndef get_Inv_Count(arr):\n    sorted_arr, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Function to count inversions using merge sort\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, left_inv_count = merge_sort(arr[:mid])\n        right, right_inv_count = merge_sort(arr[mid:])\n        merged, split_inv_count = merge(left, right)\n        return merged, left_inv_count + right_inv_count + split_inv_count\n\n    def merge(left, right):\n        merged = []\n        i = j = 0\n        inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i  # elements left in left that are greater than right[j]\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    sorted_arr, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def merge_sort_and_count_inversions(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left_arr, left_inversions = merge_sort_and_count_inversions(arr[:mid])\n    right_arr, right_inversions = merge_sort_and_count_inversions(arr[mid:])\n\n    sorted_arr, split_inversions = merge_and_count(left_arr, right_arr)\n\n    total_inversions = left_inversions + right_inversions + split_inversions\n    return sorted_arr, total_inversions\ndef merge_and_count(left, right):\n    sorted_arr = []\n    left_index = 0\n    right_index = 0\n    split_inversions = 0\n\n    while left_index < len(left) and right_index < len(right):\n        if left[left_index] <= right[right_index]:\n            sorted_arr.append(left[left_index])\n            left_index += 1\n        else:\n            sorted_arr.append(right[right_index])\n            right_index += 1\n            split_inversions += len(left) - left_index\n\n    sorted_arr.extend(left[left_index:])\n    sorted_arr.extend(right[right_index:])\n    return sorted_arr, split_inversions\ndef get_Inv_Count(arr):\n    _, inversions = merge_sort_and_count_inversions(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def merge_and_count_inversions(arr, temp_arr, left, mid, right):\n    i = left  # Starting index for left subarray\n    j = mid + 1  # Starting index for right subarray\n    k = left  # Starting index of temp_arr\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            j += 1\n            inv_count += (mid - i + 1)\n        k += 1\n\n    # Copy remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy back the merged elements to original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count_inversions(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count_inversions(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count_inversions(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count_inversions(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count_inversions(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left, left_inv_count = merge_sort_and_count(arr[:mid])\n        right, right_inv_count = merge_sort_and_count(arr[mid:])\n\n        merged, split_inv_count = merge(left, right)\n        return merged, left_inv_count + right_inv_count + split_inv_count\n\n    def merge(left, right):\n        sorted_array = []\n        i = j = 0\n        inv_count = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                sorted_array.append(left[i])\n                i += 1\n            else:\n                sorted_array.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n\n        sorted_array.extend(left[i:])\n        sorted_array.extend(right[j:])\n\n        return sorted_array, inv_count\n\n    sorted_array, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    n = len(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 76.1896551724138, "dps_norm": 60.833333333333336, "pass@1": 70.0, "profiled": [{"solution": "def large_product(list1, list2, num):\n    # Combine the lists into pairs\n    pairs = [(a, b) for a in list1 for b in list2]\n\n    # Calculate the product of each pair\n    products = [a * b for a, b in pairs]\n\n    # Sort products in descending order\n    products.sort(reverse=True)\n\n    # Return the top `num` largest products\n    return products[:num]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, num_products):\n    # Combine the lists into pairs of products\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the specified number of largest products\n    return products[:num_products]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of tuples where each tuple contains an element from list1 and list2\n    combined = [(a, b) for a in list1 for b in list2]\n\n    # Calculate the product of each pair and sort the list of tuples by product in descending order\n    combined.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n    # Extract the first n largest products\n    largest_products = [combined[i][0] * combined[i][1] for i in range(n)]\n\n    return largest_products", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Find all possible products\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort products in descending order\n    products.sort(reverse=True)\n\n    # Return the first n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Combine the lists into tuples for each pair (x, y) from list1 and list2\n    pairs = [(x, y) for x in list1 for y in list2]\n\n    # Calculate the product for each pair and sort the list of products in descending order\n    products = [x * y for x, y in pairs]\n    products.sort(reverse=True)\n\n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, count):\n    # Create pairs by multiplying one factor from each list\n    pairs = [a * b for a in list1 for b in list2]\n\n    # Sort pairs in descending order\n    pairs.sort(reverse=True)\n\n    # Return the top 'count' largest products\n    return pairs[:count]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Combine the elements from both lists as tuples of pairs\n    product_pairs = [(a, b) for a in list1 for b in list2]\n\n    # Calculate the product of each pair and sort in descending order\n    products = [a * b for a, b in product_pairs]\n    products.sort(reverse=True)\n\n    # Return the specified number of largest products\n    return products[:num]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, num_products):\n    # Combine elements from both lists by creating pairs (a, b) where a is from list1 and b is from list2\n    combined_products = [(a, b) for a in list1 for b in list2]\n\n    # Compute the product of each pair and store it as a tuple (product, index)\n    product_list = [(a * b, i) for i, (a, b) in enumerate(combined_products)]\n\n    # Sort the list of products in descending order\n    product_list.sort(reverse=True)\n\n    # Extract the top num_products products from the sorted list\n    largest_products = [product for product, _ in product_list[:num_products]]\n\n    return largest_products", "matching_cluster_idx": 1}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products from elements in list1 and list2\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the top num largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Merging two lists into a list of tuples\n    product_list = [(a * b) for a in list1 for b in list2]\n\n    # Sorting the product list in descending order\n    product_list.sort(reverse=True)\n\n    # Returning the first 'num' largest products\n    return product_list[:num]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, k):\n    # Combine the two lists element-wise\n    product_list = [a * b for a in list1 for b in list2]\n\n    # Get the k largest elements from the product_list\n    large_products = heapq.nlargest(k, product_list)\n\n    return large_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Combine the lists into pairs and calculate the product of each pair\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the specified number of largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Combine the elements of the two lists into pairs and their products\n    products = [(a, b, a * b) for a in list1 for b in list2]\n\n    # Sort the products in descending order based on the product value\n    products.sort(key=lambda x: x[2], reverse=True)\n\n    # Extract the top n products and return their values\n    return [product[2] for product in products[:n]]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, k):\n    # Calculate the product of each pair from the two lists and create a list of these products\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the top 'k' largest products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Combine the lists into pairs and compute the product of each pair\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Step 1: Compute all possible products of elements from both lists\n    products = [a * b for a in list1 for b in list2]\n\n    # Step 2: Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Step 3: Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(list1, list2, num):\n    # Combine the lists element-wise to form product pairs\n    products = [a * b for a in list1 for b in list2]\n\n    # Use nlargest to get the largest 'num' products\n    return nlargest(num, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Generate all possible products by taking one element from each list\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the first 'k' elements from the sorted list\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Combine the two lists into pairs of products\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Combine both lists into pairs and compute the product of each pair\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Select the top k largest products\n    return products[:k]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 92.41784037558685, "dps_norm": 92.6923076923077, "pass@1": 39.0, "profiled": [{"solution": "def get_max_sum(n):\n    memo = {}\n\n    def f(x):\n        if x <= 0:\n            return 0\n        if x in memo:\n            return memo[x]\n\n        memo[x] = max(\n            f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5),\n            x\n        )\n        return memo[x]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization to store results of subproblems\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 0:\n            return 0\n        result = max(\n            f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5),\n            x\n        )\n        memo[x] = result\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    def f(x):\n        if x <= 1:\n            return x\n        return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n\n    return f(n)", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    def f(n):\n        if n == 0:\n            return 0\n        return max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n\n    return f(n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 0:\n            return 0\n        memo[x] = max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n        return memo[x]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 1:\n        return n\n\n    # Dictionary to store the maximum sum for each value up to n\n    dp = {0: 0}\n\n    # Function to compute the max sum for a given value\n    def f(x):\n        if x in dp:\n            return dp[x]\n\n        dp[x] = max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n        return dp[x]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    memo = {}\n\n    def f(k):\n        if k in memo:\n            return memo[k]\n        if k == 0:\n            return 0\n        memo[k] = max(f(k // 2) + f(k // 3) + f(k // 4) + f(k // 5), k)\n        return memo[k]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "memo = {}\ndef get_max_sum(n):\n    # check if the result is already computed\n    if n in memo:\n        return memo[n]\n\n    # base case: if n is 0, return 0\n    if n == 0:\n        return 0\n\n    # calculate max sum using the given formula\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n\n    # store the result in memoization dictionary\n    memo[n] = max_sum\n\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "from math import floor\ndef get_max_sum(n):\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 0:\n            return 0\n        memo[x] = max(f(floor(x / 2)) + f(floor(x / 3)) + f(floor(x / 4)) + f(floor(x / 5)), x)\n        return memo[x]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n\n    # Calculate f(n/2), f(n/3), f(n/4), f(n/5)\n    f_n2 = get_max_sum(n // 2, memo)\n    f_n3 = get_max_sum(n // 3, memo)\n    f_n4 = get_max_sum(n // 4, memo)\n    f_n5 = get_max_sum(n // 5, memo)\n\n    # Max sum by using the given equation\n    max_sum = max(f_n2 + f_n3 + f_n4 + f_n5, n)\n\n    # Store result in memo dictionary\n    memo[n] = max_sum\n\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case for recursion\n    if n == 0:\n        return 0\n    if n < 0:\n        return float('-inf')\n\n    # Memoization to store already computed values\n    memo = {}\n\n    def f(num):\n        if num in memo:\n            return memo[num]\n        if num == 0:\n            return 0\n        # Calculate the maximum of f(n/2), f(n/3), f(n/4), f(n/5), and n\n        memo[num] = max(f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5), num)\n        return memo[num]\n\n    # Call the recursive function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n\n    if n == 0:\n        return 0\n    memo[n] = max(\n        get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo),\n        n\n    )\n\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n\n    # Compute the maximum sum using the given formula\n    result = max(get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) +\n                 get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo), n)\n\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    # Helper function to compute f(n) using memoization\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x == 0:\n            return 0\n        # Compute the maximum sum\n        max_sum = max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case when n is less than 1\n    if n < 1:\n        return 0\n\n    # Initialize a dictionary to store computed values to avoid redundant calculations\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x < 1:\n            return 0\n        memo[x] = max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n        return memo[x]\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(num):\n        if num == 0:\n            return 0\n        return max(f(num // 2) + f(num // 3) + f(num // 4) + f(num // 5), num)\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Dictionary to store results of subproblems\n    memo = {}\n\n    def f(x):\n        # Base case: if x is 0 or negative, the maximum sum is 0\n        if x <= 0:\n            return 0\n        # If the value is already computed, return the cached value\n        if x in memo:\n            return memo[x]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n        # Cache the computed value\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is 1 or 0, return n (since f(1) = 1 and f(0) = 0)\n    if n == 1 or n == 0:\n        return n\n\n    # If the result for n is already computed, return it directly\n    if n in memo:\n        return memo[n]\n\n    # Compute the maximum of the given equation\n    max_val = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n\n    # Store the computed result in the memo dictionary\n    memo[n] = max_val\n\n    return max_val\nmemo = {}", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Using memoization to store the results of previously computed values\n    memo = {}\n\n    def f(n):\n        if n in memo:\n            return memo[n]\n\n        # Base case: if n is 0 or negative, the sum is 0\n        if n <= 0:\n            return 0\n\n        # Compute the sum by considering different fractions of n\n        value = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n\n        # Store the result in memo\n        memo[n] = value\n        return value\n\n    # Start the recursion with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization to store the maximum sum for subproblems\n    memo = {}\n\n    def f(x):\n        if x in memo:\n            return memo[x]\n        if x <= 0:\n            return 0\n        memo[x] = max(f(int(x/2)) + f(int(x/3)) + f(int(x/4)) + f(int(x/5)), x)\n        return memo[x]\n\n    return f(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 93.85057471264368, "dps_norm": 74.375, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(string):\n    # Create a dictionary to store character counts\n    char_count = {}\n\n    # Count the occurrences of each character\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n\n    # First pass to count the frequency of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Dictionary to count occurrences of each character\n    char_count = {}\n\n    # Populate the dictionary with character counts\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the frequency of each character\n    char_count = {}\n\n    # Populate the dictionary with character counts\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Iterate through the string to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Dictionary to store the frequency of each character\n    frequency = {}\n\n    # First pass: Count the frequency of each character\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # Second pass: Find the first non-repeated character\n    for char in s:\n        if frequency[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Initialize dictionaries to track character counts and their first occurrence index\n    char_count = {}\n    first_occurrence = {}\n\n    # First pass: count the frequency of each character and record their first occurrence\n    for index, char in enumerate(s):\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n            first_occurrence[char] = index\n\n    # Second pass: find the first character with count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 4}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n\n    # First pass to count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    from collections import defaultdict\n\n    char_count = defaultdict(int)\n\n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] += 1\n\n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the frequency of characters\n    frequency = {}\n    # List to store the characters in the order they appear\n    order = []\n\n    # Populate the frequency dictionary and order list\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n            order.append(char)\n\n    # Find the first non-repeating character\n    for char in order:\n        if frequency[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Dictionary to store character counts\n    char_counts = {}\n\n    # Populate the dictionary with character counts\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    # Find the first non-repeating character\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Dictionary to keep track of the count of each character\n    char_count = {}\n\n    # First pass: Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass: Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of characters\n    frequency = {}\n\n    # Traverse the string and populate the frequency dictionary\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if frequency[char] == 1:\n            return char\n\n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Dictionary to store the frequency of characters\n    char_count = {}\n\n    # First pass: count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass: find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> None:\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    char_count = {}\n\n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Iterate over the string to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Dictionary to count occurrences of each character\n    char_count = {}\n\n    # First pass to populate the dictionary with character counts\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Second pass to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeated character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n\n    # Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n\n    # Populate the dictionary with character counts\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Iterate through the string to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    :param tuplex: The tuple in which to check for the element.\n    :param elem: The element to check for within the tuple.\n    :return: True if the element is found, False otherwise.\n    \"\"\"\n    return elem in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    elem: The element to look for.\n\n    Returns:\n    bool: True if element is in the tuple, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if the element exists in the tuple.\n\n    :param tuplex: The tuple to search through.\n    :param element: The element to find in the tuple.\n    :return: True if element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_obj, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n    tuple_obj (tuple): The tuple to check.\n    elem (any): The element to look for.\n\n    Returns:\n    bool: True if the element exists, False otherwise.\n    \"\"\"\n    return elem in tuple_obj", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Checks whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n    tup: A tuple of elements to search within.\n    elem: The element to search for.\n\n    Returns:\n    True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_, element):\n    \"\"\"\n    This function checks whether a given element exists within a tuple.\n\n    Parameters:\n    tuple_ (tuple): The tuple in which to search for the element.\n    element: The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuple_", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex\ntuplex = (\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\")\nelement = 'r'", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to check for existence.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple in which to search for the element.\n        element (any): The element to search for.\n\n    Returns:\n        bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    :param tuplex: The tuple to check.\n    :param element: The element to look for.\n    :return: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to search for the element.\n    elem: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    elem (any): The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuple_in, element):\n    \"\"\"\n    This function checks if an element exists within a tuple.\n\n    Parameters:\n    tuple_in (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tuple_in", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to check.\n    element: The element to look for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return elem in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 90.21739130434783, "dps_norm": 92.22222222222221, "pass@1": 94.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq2 exists in seq1.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq2 exists in seq1, False otherwise.\n    \"\"\"\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if there is any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any common value between two sequences.\n\n    Parameters:\n    seq1 (list): The first sequence of values.\n    seq2 (list): The second sequence of values.\n\n    Returns:\n    bool: True if there is any common value, False otherwise.\n    \"\"\"\n    return any(value in seq2 for value in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq2 exists in seq1.\n\n    Args:\n    seq1 (list): First sequence of elements.\n    seq2 (list): Second sequence of elements.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    return any(elem in seq1 for elem in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check if any value in seq1 exists in seq2.\n    Returns True if there is any overlap, else False.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): First sequence of values.\n    seq2 (list): Second sequence of values.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any common element between two sequences.\n\n    Parameters:\n    seq1 (list): First sequence\n    seq2 (list): Second sequence\n\n    Returns:\n    bool: True if there is any common element, otherwise False\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks whether any value in seq2 exists in seq1.\n    :param seq1: The first sequence\n    :param seq2: The second sequence\n    :return: True if there is any overlap, False otherwise\n    \"\"\"\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq2 exists in seq1.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq2 exists in seq1, False otherwise.\n    \"\"\"\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (list): The first sequence.\n        seq2 (list): The second sequence.\n\n    Returns:\n        bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function checks if there are any common elements between two sequences.\n\n    Args:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if there is any overlap between the two sequences, False otherwise.\n    \"\"\"\n    # Using a set to check for common elements\n    set1 = set(seq1)\n    set2 = set(seq2)\n\n    # Check if there is any intersection between the two sets\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any value in seq2 that exists in seq1.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    for item in seq2:\n        if item in seq1:\n            return True\n    return False", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list): First sequence.\n    seq2 (list): Second sequence.\n\n    Returns:\n    bool: True if there is any overlap, False otherwise.\n    \"\"\"\n    # Use set intersection to determine if there are common elements\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq2 exists in seq1.\n\n    Args:\n    seq1 (list): First sequence.\n    seq2 (list): Second sequence.\n\n    Returns:\n    bool: True if any value in seq2 exists in seq1, False otherwise.\n    \"\"\"\n    for item in seq2:\n        if item in seq1:\n            return True\n    return False", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq2 exists in seq1.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    for item in seq2:\n        if item in seq1:\n            return True\n    return False", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): First sequence.\n    seq2 (list): Second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq2 exists in seq1.\n\n    :param seq1: List of integers\n    :param seq2: List of integers\n    :return: Boolean indicating if there is any overlap\n    \"\"\"\n    return any(elem in seq1 for elem in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    # Use the set intersection method to check for overlapping values\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if there is any common value between two sequences.\n\n    Parameters:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if there is any common value, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq2 exists in seq1.\n\n    Parameters:\n    seq1 (list): The first sequence to check.\n    seq2 (list): The second sequence to check against.\n\n    Returns:\n    bool: True if there is any common value, False otherwise.\n    \"\"\"\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}]}, "Mbpp/421": {"dps": 76.95473251028807, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by the specified delimiter.\n\n    Parameters:\n    elements (tuple): Tuple of elements to concatenate.\n    delimiter (str): Delimiter to use for concatenation.\n\n    Returns:\n    str: Concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter=\"-\"):\n    \"\"\"Concatenates elements of a tuple with the specified delimiter.\"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter=\"-\"):\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tpl):\n    # Convert each element to string and join them with a delimiter\n    return '-'.join(map(str, tpl))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Use the str.join() method to concatenate elements of the tuple with a delimiter\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Convert each element to string and join them with the specified delimiter\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string, with elements separated by the given delimiter.\n\n    Parameters:\n        elements (tuple): A tuple of elements to concatenate.\n        delimiter (str): The delimiter string to separate the elements.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    # Ensure elements are strings by converting non-string elements using str()\n    elements = [str(elem) for elem in elements]\n    # Join the elements with the delimiter\n    return delimiter.join(elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Convert each element in the tuple to a string and join them with the delimiter '-'\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tpl):\n    return '-'.join(map(str, tpl))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter=\"-\"):\n    \"\"\"\n    Concatenates elements of a tuple with a given delimiter.\n\n    Args:\n    elements (tuple): The tuple of elements to concatenate.\n    delimiter (str): The delimiter to use between elements.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    # Use the join method to concatenate the tuple elements with the delimiter\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Convert tuple elements to string and join them with the delimiter '-'\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of the tuple using the specified delimiter.\n\n    Args:\n    elements (tuple): A tuple containing the elements to concatenate.\n    delimiter (str): The delimiter to use between elements.\n\n    Returns:\n    str: A string with the elements concatenated.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Concatenate each element in the tuple with the delimiter '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple by the provided delimiter.\n\n    Args:\n    input_tuple (tuple): The tuple to be concatenated.\n    delimiter (str): The delimiter to be used in concatenation.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(elements, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by a given delimiter.\n\n    Parameters:\n    elements (tuple): The tuple of elements to concatenate.\n    delimiter (str): The delimiter to use for concatenation.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, elements))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tpl):\n    return '-'.join(map(str, tpl))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Use str.join to concatenate elements with '-'\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple):\n    \"\"\"\n    Concatenates elements of the tuple with the delimiter '-'.\n\n    Args:\n        input_tuple (tuple): A tuple containing elements to be concatenated.\n\n    Returns:\n        str: A string where elements of the tuple are concatenated with '-'.\n    \"\"\"\n    return '-'.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Convert each element to string and join them with the '-' delimiter\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 51.624548736462096, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(strings_tuple):\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_of_strings):\n    return [string[-1] for string in tuple_of_strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuples):\n    return [string[-1] for string in tuples]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n    strings_tuple (tuple): A tuple containing strings.\n\n    Returns:\n    List[str]: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Initialize an empty list to store the rear elements\n    rear_elements = []\n\n    # Iterate over each string in the tuple\n    for string in input_tuple:\n        # Append the last character of each string to the list\n        rear_elements.append(string[-1])\n\n    # Return the list of rear elements\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuples):\n    # Using list comprehension to extract the last character of each string in the tuple\n    return [s[-1] for s in tuples]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in a given tuple.\n\n    :param strings: Tuple of strings\n    :return: List of last characters of each string\n    \"\"\"\n    return [string[-1] for string in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupled_strings):\n    # Initialize an empty list to store the rear characters\n    rear_chars = []\n\n    # Iterate through each string in the tuple\n    for s in tupled_strings:\n        # Append the last character of the string to the list\n        rear_chars.append(s[-1])\n\n    return rear_chars", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuples):\n    \"\"\"Extract the last character of each string in a tuple.\"\"\"\n    return [s[-1] for s in tuples]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    # Using list comprehension to extract the last character from each string in the tuple\n    return [string[-1] for string in tupl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character of each string in the given tuple.\n\n    :param strings: A tuple of strings\n    :return: A list of the last characters of each string in the tuple\n    \"\"\"\n    # Create a list to store the last characters\n    last_characters = []\n\n    # Iterate over each string in the tuple\n    for string in strings:\n        # Append the last character of the string to the list\n        last_characters.append(string[-1])\n\n    return last_characters", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    # List comprehension to extract the last character from each string in the tuple\n    return [string[-1] for string in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    return [s[-1] for s in tupl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuples):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n    tuples (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [string[-1] for string in tuples]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tupl):\n    # Use list comprehension to iterate through each element in the tuple and extract the last character of each string\n    return [str[-1] for str in tupl]", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 81.0, "profiled": [{"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    sublists (list of lists): The list of sublists to search within.\n    element (int/str): The element to count within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, target):\n    count = 0\n    for sublist in list_of_lists:\n        if target in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists containing a particular element.\n\n    Args:\n    lst (list): A list of lists.\n    element: The element to count in the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n    nested_list (list of lists): The nested list to search through.\n    element (int/str/etc.): The element to count in the sublists.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists in the nested list that contain the specified element.\n\n    Args:\n    nested_list (list): A list of lists where each sublist may contain the element to be counted.\n    element (any): The element to search for in each sublist.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists that contain a particular element.\n\n    Parameters:\n    sublists (list of lists): The list of sublists to check.\n    element (any): The element to look for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of list): The list of lists to search through.\n    element: The element to count occurrences of in sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing the specified element.\n\n    Parameters:\n    lst (list of list): The list of sublists.\n    element: The element to search for in the sublists.\n\n    Returns:\n    int: The count of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Counts the number of sublists that contain a particular element.\n\n    Parameters:\n    lists (list of list): The list of sublists.\n    element (any): The element to be counted.\n\n    Returns:\n    int: The number of sublists containing the given element.\n    \"\"\"\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    # Initialize a counter\n    count = 0\n\n    # Iterate through each sublist\n    for sublist in lists:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    :param sublists: List of lists\n    :param element: The element to count\n    :return: Number of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 96.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sorts an array using shell sort.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap until it becomes 0\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap until it becomes 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the shell sort algorithm.\n\n    Parameters:\n    arr (list): The list to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, reduce the gap until it becomes 0\n    while gap > 0:\n        # Perform a gapped insertion sort for the current gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap until it becomes 0\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap until it becomes 0\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap until it becomes 0\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"Sort an array using Shell sort.\"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 73.08510638297872, "dps_norm": 74.0, "pass@1": 96.0, "profiled": [{"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if the given number is greater than all the elements in the array.\n\n    Parameters:\n    array (list of int): The list of integers to check against.\n    number (int): The number to compare.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in array:\n        if element >= number:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if element >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list): List of integers.\n    number (int): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    # Iterate through the array and check if the number is greater than all elements\n    for element in arr:\n        if element >= number:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list): A list of integers\n    num (int): The number to check against\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise\n    \"\"\"\n    return all(n < num for n in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list): The given array of integers.\n    num (int): The number to compare with the elements of the array.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    This function checks if the entered number is greater than all elements in the given array.\n\n    Args:\n    array (list of int): The array of numbers to compare against.\n    number (int): The number to check against the elements in the array.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for elem in array:\n        if number <= elem:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the given number is greater than all elements of the array.\n\n    :param arr: List of integers\n    :param num: Integer to be compared\n    :return: Boolean indicating if num is greater than all elements of the array\n    \"\"\"\n    return all(n < num for n in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check if the number is greater than all the elements in the array.\n\n    Parameters:\n    arr (list): The array of integers.\n    number (int): The number to compare with the elements in the array.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num < number for num in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the given number is greater than all elements in the array.\n\n    Parameters:\n    arr (list): The list of numbers.\n    num (int): The number to compare with the elements in the list.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list of int): The list of elements to check against.\n    num (int): The number to compare against the elements in the list.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list of int): The given array.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, otherwise False.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    :param arr: List of integers\n    :param num: Integer\n    :return: Boolean\n    \"\"\"\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, number):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers.\n    number (int): The number to compare against the array elements.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for elem in arr:\n        if number <= elem:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    :param array: List of integers\n    :param number: Integer to compare with the elements in the array\n    :return: True if the number is greater than all elements in the array, False otherwise\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks whether the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers.\n    num (int): The number to be checked.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if element >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, number):\n    # Check if the number is greater than all elements in the array\n    return all(elem < number for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Function to check whether the entered number is greater than all elements of the given array.\n\n    Args:\n    arr (list): List of integers.\n    num (int): Number to compare with the elements of the list.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if element >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n\n    Args:\n        arr (list): A list of integers.\n        num (int): A number to compare with elements in the array.\n\n    Returns:\n        bool: True if num is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(n < num for n in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers.\n    num (int): The number to compare with the elements of the array.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n    \"\"\"\n    return all(n < num for n in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The array of integers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(elem < num for elem in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.45320197044335, "dps_norm": 64.0, "pass@1": 39.0, "profiled": [{"solution": "def count_Occurrence(lst, elements):\n    \"\"\"\n    Counts the occurrences of elements from the elements list in the lst tuple.\n\n    Parameters:\n    lst (tuple): The tuple to search within.\n    elements (list): The list of elements to count.\n\n    Returns:\n    int: The total occurrences of elements in the lst.\n    \"\"\"\n    count = 0\n    for element in elements:\n        count += lst.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, element_list):\n    \"\"\"\n    Counts the occurrence of elements in the input tuple that are also in the element list.\n\n    Args:\n    input_tuple (tuple): The tuple to count elements from.\n    element_list (list): The list of elements to count.\n\n    Returns:\n    int: The total count of elements from element_list that appear in input_tuple.\n    \"\"\"\n    count = 0\n    for elem in element_list:\n        count += input_tuple.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    # Initialize a dictionary to store the counts of each element\n    counts = {}\n\n    # Count the occurrences of each element in the tuple\n    for element in t:\n        if element in counts:\n            counts[element] += 1\n        else:\n            counts[element] = 1\n\n    # Sum the counts of the elements specified in the list\n    total_count = sum(counts[element] for element in lst if element in counts)\n\n    return total_count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(t, lst):\n    count = 0\n    for elem in lst:\n        count += t.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(data, elements):\n    \"\"\"\n    Counts the occurrence of all elements of the given list in a tuple.\n\n    Args:\n    data (tuple): The tuple in which to count the elements.\n    elements (list): The list of elements to count.\n\n    Returns:\n    int: The total count of the specified elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in elements:\n        count += data.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_list, element_list):\n    count = 0\n    for elem in element_list:\n        count += tuple_list.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_list, search_list):\n    \"\"\"\n    Counts the occurrence of elements in the search_list within tuple_list.\n\n    Args:\n    tuple_list (tuple): A tuple containing elements to search through.\n    search_list (list): A list of elements to count their occurrences in the tuple_list.\n\n    Returns:\n    int: The total count of occurrences of elements in search_list within tuple_list.\n    \"\"\"\n    # Flatten the tuple_list into a list to make counting easier\n    flattened_list = list(tuple_list)\n\n    # Initialize the count\n    count = 0\n\n    # Count occurrences of each element in search_list\n    for element in search_list:\n        count += flattened_list.count(element)\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    count = 0\n    for element in lst:\n        count += t.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in a tuple.\n\n    Parameters:\n    t (tuple): The input tuple.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of elements from the list found in the tuple.\n    \"\"\"\n    return sum(t.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    count = 0\n    for element in lst:\n        count += t.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, target_list):\n    count = 0\n    for element in target_list:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a dictionary to store the count of occurrences\n    count_dict = {}\n\n    # Count the occurrences of each element in the tuple\n    for elem in tup:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n\n    # Calculate the total count of elements from the list in the tuple\n    total_count = 0\n    for elem in lst:\n        if elem in count_dict:\n            total_count += count_dict[elem]\n\n    return total_count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(t, l):\n    count = 0\n    for elem in l:\n        count += t.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, l):\n    \"\"\"\n    This function takes a tuple and a list as inputs and returns the count\n    of elements in the list that occur in the tuple.\n\n    Parameters:\n    t (tuple): A tuple of elements.\n    l (list): A list of elements whose occurrences in the tuple need to be counted.\n\n    Returns:\n    int: The count of elements from the list that occur in the tuple.\n    \"\"\"\n    count = 0\n    for element in l:\n        if element in t:\n            count += t.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Args:\n    tup (tuple): The tuple in which to count the elements.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total number of occurrences of the elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    \"\"\"Count the occurrences of list elements in a tuple.\"\"\"\n    count = 0\n    for elem in lst:\n        count += t.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 29.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespace characters from the given string.\n\n    Args:\n        input_string (str): The string from which to remove whitespace.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all whitespaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    # Use the replace() method to remove all whitespaces\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    # Using the replace method to remove all spaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n    :param s: str\n    :return: str\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n        s (str): Input string with possible whitespaces.\n\n    Returns:\n        str: String with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Remove all whitespace characters from the string using str.replace method\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    # Return the string with all whitespaces replaced with empty strings\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using the replace() method to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from the given string.\n\n    :param input_string: string from which whitespaces need to be removed\n    :return: string with all whitespaces removed\n    \"\"\"\n    # Return the input string with all whitespaces replaced by an empty string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    :param s: Input string\n    :return: String with all whitespaces removed\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using the replace method to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n    input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Parameters:\n    input_string (str): The string from which to remove whitespaces.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Using str.replace method to remove all whitespaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string without any whitespaces.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace() method to remove all whitespaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Args:\n    strings (list of str): List of strings to reverse.\n\n    Returns:\n    list of str: List with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in a given list of strings.\n\n    Parameters:\n    strings (list): List of strings to be reversed.\n\n    Returns:\n    list: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Parameters:\n    string_list (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Using list comprehension to reverse each string\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Args:\n    strings (list of str): List of strings to reverse.\n\n    Returns:\n    list of str: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in the given list of string values.\n\n    :param strings: List of strings to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a list of strings.\n\n    :param strings: List of strings to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Function to reverse a single string\n    def reverse_string(s):\n        return s[::-1]\n\n    # Reverse each string in the list\n    return [reverse_string(s) for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Args:\n    string_list (list of str): List of strings to be reversed.\n\n    Returns:\n    list of str: List with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # This function takes a list of strings and returns a new list\n    # with each string reversed.\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Parameters:\n    strings (list of str): List of strings to be reversed.\n\n    Returns:\n    list of str: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in a given list of strings.\n\n    Parameters:\n    strings (list of str): List of string values to be reversed.\n\n    Returns:\n    list of str: List with each string reversed.\n    \"\"\"\n    # Using list comprehension to reverse each string\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Parameters:\n    strings (list of str): List of string values to reverse.\n\n    Returns:\n    list of str: List with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    Args:\n        strings (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Use list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Function to reverse each string in a given list of string values.\n\n    Parameters:\n    strings (list): List of strings to be reversed.\n\n    Returns:\n    list: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Parameters:\n    strings (list): A list of string values to be reversed.\n\n    Returns:\n    list: A list of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    :param strings: List of strings to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    :param strings: List of strings to reverse\n    :return: List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 41.730769230769226, "dps_norm": 77.0, "pass@1": 86.0, "profiled": [{"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Parameters:\n    lst (list of list of int): List of sublists.\n\n    Returns:\n    list of int: List containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    \"\"\"\n    This function takes a list of lists and returns a new list containing the first element of each sublist.\n\n    Parameters:\n    lists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    # Using a list comprehension to get the first element of each sublist\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    # Initialize an empty list to store the first elements\n    first_elements = []\n\n    # Iterate through each sublist in the input list\n    for sublist in sublists:\n        # Append the first element of the current sublist to the result list\n        first_elements.append(sublist[0])\n\n    # Return the list of first elements\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Initialize an empty list to store the first elements of each sublist\n    result = []\n\n    # Iterate over each sublist in the main list\n    for sublist in lst:\n        # Append the first element of the sublist to the result list\n        if sublist:  # Check if the sublist is not empty\n            result.append(sublist[0])\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Initialize an empty list to store the first elements\n    first_elements = []\n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Append the first element of the sublist to the result list\n        first_elements.append(sublist[0])\n    # Return the list containing the first elements\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    # Initialize an empty list to store the first elements\n    result = []\n\n    # Loop through each sublist in the input list\n    for sublist in lists:\n        # Check if the sublist is not empty and append the first element to the result\n        if sublist:\n            result.append(sublist[0])\n\n    # Return the result list\n    return result", "matching_cluster_idx": 2}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(sublists):\n    \"\"\"\n    Extracts the first element of each sublist.\n\n    Args:\n    sublists (list of lists): List containing multiple sublists.\n\n    Returns:\n    list: A new list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    # Initialize an empty list to store the first elements\n    result = []\n    # Iterate through each sublist\n    for sublist in lists:\n        # Add the first element of the sublist to the result list\n        result.append(sublist[0])\n    return result", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    # Initialize an empty list to store the first elements of each sublist\n    first_elements = []\n\n    # Iterate through each sublist\n    for sublist in lists:\n        # Append the first element of the sublist to the result list\n        if sublist:  # Check if the sublist is not empty\n            first_elements.append(sublist[0])\n\n    # Return the list of first elements\n    return first_elements", "matching_cluster_idx": 2}, {"solution": "def Extract(sublists):\n    return [sublist[0] for sublist in sublists]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 93.97560975609755, "dps_norm": 96.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of `old` character with `new` character in the string `s`.\n\n    :param s: input string\n    :param old: character to be replaced\n    :param new: character to replace with\n    :return: modified string with replacements\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old, new):\n    return string.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of a character in a string.\n\n    :param input_string: The original string.\n    :param char_to_replace: The character to be replaced.\n    :param replacement_char: The character to replace with.\n    :return: A new string with all occurrences of char_to_replace replaced by replacement_char.\n    \"\"\"\n    # Using list comprehension to create a new list with replaced characters, then join it back into a string\n    return ''.join([replacement_char if char == char_to_replace else char for char in input_string])", "matching_cluster_idx": 4}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' with 'new' in the string 's'.\n\n    Args:\n    s (str): The input string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The new string with replacements.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char in the string s with new_char.\n\n    Parameters:\n    s (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # Return a new string with all occurrences of 'old' replaced with 'new'\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old, new):\n    \"\"\"\n    Replace all occurrences of old character with new character in the string.\n\n    Parameters:\n    string (str): The original string.\n    old (str): The character to replace.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The new string with the characters replaced.\n    \"\"\"\n    return string.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char in input_string with new_char.\n\n    Parameters:\n    input_string (str): The string in which characters need to be replaced.\n    old_char (str): The character that needs to be replaced.\n    new_char (str): The character that will replace old_char.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    # Replace occurrences of old_char with new_char\n    result = input_string.replace(old_char, new_char)\n    return result", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Use the join and replace methods to create the new string\n    return ''.join(new_char if char == old_char else char for char in s)", "matching_cluster_idx": 3}, {"solution": "def replace_char(input_string, char_to_replace, replacement_char):\n    \"\"\"\n    This function replaces all occurrences of char_to_replace in input_string with replacement_char.\n\n    Args:\n        input_string (str): The string in which to replace characters.\n        char_to_replace (str): The character to be replaced.\n        replacement_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with all occurrences of char_to_replace replaced.\n    \"\"\"\n    return input_string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, replace_with):\n    # Create a new string where all occurrences of char_to_replace are replaced by replace_with\n    return input_string.replace(char_to_replace, replace_with)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # Return a new string with all occurrences of old replaced with new\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    This function replaces all occurrences of `old` character in string `s`\n    with `new` character.\n\n    Args:\n    s (str): The string in which to replace characters.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Use the `replace` method of the string class to replace occurrences of old_char with new_char\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # This function replaces all occurrences of 'old' character with 'new' in the string 's'.\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    This function replaces all occurrences of old_char in input_string with new_char.\n\n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The string after replacement.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 96.84563758389261, "dps_norm": 98.33333333333333, "pass@1": 98.0, "profiled": [{"solution": "def big_sum(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Ensure the array is not empty\n    if len(arr) == 0:\n        raise ValueError(\"Array must not be empty\")\n\n    # Find the maximum and minimum values in the array\n    max_val = max(arr)\n    min_val = min(arr)\n\n    # Calculate the sum of the maximum and minimum values\n    sum_max_min = max_val + min_val\n\n    return sum_max_min", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not arr:\n        return 0\n\n    min_val = min(arr)\n    max_val = max(arr)\n\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function finds the sum of the largest and smallest value in a given array.\n\n    :param arr: List of numbers\n    :return: Sum of the largest and smallest value\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n\n    min_val = min(arr)\n    max_val = max(arr)\n\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        raise ValueError(\"Array is empty\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return None\n\n    smallest = min(arr)\n    largest = max(arr)\n\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n\n    min_val = min(arr)\n    max_val = max(arr)\n\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array is not empty\n    if not arr:\n        raise ValueError(\"The array should not be empty\")\n\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n\n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # Handle empty array case\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Ensure the array is not empty\n    if len(arr) == 0:\n        raise ValueError(\"Array must not be empty\")\n\n    # Find the largest and smallest values in the array\n    largest = max(arr)\n    smallest = min(arr)\n\n    # Return the sum of the largest and smallest values\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array is not empty\n    if len(arr) == 0:\n        return 0\n    # Find the smallest and largest values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    # Return the sum of the smallest and largest values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    smallest = float('inf')\n    largest = float('-inf')\n    for num in arr:\n        if num < smallest:\n            smallest = num\n        if num > largest:\n            largest = num\n    return smallest + largest", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list): List of integers\n\n    Returns:\n    int: Sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must contain at least one element\")\n\n    min_value = min(arr)\n    max_value = max(arr)\n    return min_value + max_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return None\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Ensure the array is not empty\n    if not arr:\n        raise ValueError(\"Array must contain at least one element\")\n\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n\n    # Return their sum\n    return smallest + largest", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 65.0, "profiled": [{"solution": "def to_lower(input_string: str) -> str:\n    return input_string.lower()\ndef is_lower(input_string: str) -> str:\n    return to_lower(input_string)", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    # Convert the given string to lower case\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to convert.\n\n    Returns:\n    str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    This function converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The converted string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: The input string.\n    :return: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Converts the given string to lowercase.\n\n    Parameters:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The converted lowercase string.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    s (str): Input string.\n\n    Returns:\n    str: Lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    # Convert the input string to lower case\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    # Converting the input string to lower case\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 81.85792349726776, "dps_norm": 79.54545454545455, "pass@1": 88.0, "profiled": [{"solution": "import re\ndef extract_values(string):\n    # Use regular expressions to find all substrings between quotation marks\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings within quotation marks\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expressions to find all substrings enclosed in quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Using regular expressions to find all substrings within double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # This regular expression will find all substrings within double quotes\n    pattern = re.compile(r'\"([^\"]*)\"')\n    matches = pattern.findall(input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # This regex pattern matches any substring enclosed in double quotes\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings within quotes\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    import re\n    # Using regular expression to find all substrings enclosed in quotation marks\n    values = re.findall(r'\"(.*?)\"', string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extract values between quotation marks from a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    list: List of extracted values between quotation marks.\n    \"\"\"\n    # Use regular expressions to find all substrings enclosed in quotes\n    values = re.findall(r'\"(.*?)\"', s)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"(.*?)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find all substrings between quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find all sequences of characters enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expressions to find all substrings between quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    values = []\n    start = 0\n    while start < len(input_string):\n        if input_string[start] == '\"':\n            end = input_string.find('\"', start + 1)\n            if end == -1:\n                break\n            values.append(input_string[start + 1:end])\n            start = end + 1\n        else:\n            start += 1\n    return values", "matching_cluster_idx": 1}, {"solution": "def extract_values(s):\n    result = []\n    start = 0\n    while True:\n        start = s.find('\"', start)\n        if start == -1:\n            break\n        start += 1\n        end = s.find('\"', start)\n        if end == -1:\n            break\n        result.append(s[start:end])\n        start = end + 1\n    return result", "matching_cluster_idx": 10}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings between quotation marks\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use a regular expression to find all substrings between quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Regular expression to find all substrings between double quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expressions to find all substrings between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 92.03703703703704, "dps_norm": 82.85714285714285, "pass@1": 41.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    # Use a dictionary to count the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Collect numbers that appear only once\n    unique_nums = [num for num in freq if freq[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Dictionary to keep track of the occurrence of each number\n    num_counts = {}\n\n    # Iterate through the list and populate the dictionary\n    for num in lst:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    # List to store the unique numbers\n    unique_nums = []\n\n    # Iterate through the dictionary and add numbers that occur exactly once\n    for num, count in num_counts.items():\n        if count == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Use a set to keep track of seen numbers and their counts\n    num_counts = {}\n    for num in nums:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in nums if num_counts[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    unique_counts = {}\n\n    for num in nums:\n        if num in unique_counts:\n            unique_counts[num] += 1\n        else:\n            unique_counts[num] = 1\n\n    unique_nums = [num for num, count in unique_counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Collect numbers that appear only once\n    result = [num for num, count in frequency.items() if count == 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Create a dictionary to count the occurrences of each number\n    num_count = {}\n\n    # Traverse the list and populate the count dictionary\n    for num in numbers:\n        if num in num_count:\n            num_count[num] += 1\n        else:\n            num_count[num] = 1\n\n    # List to store numbers that appear exactly once\n    result = [num for num, count in num_count.items() if count == 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Count the occurrences of each number using a dictionary\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Collect numbers that appear exactly once\n    unique_nums = [num for num in nums if count[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Dictionary to keep track of occurrences of each number\n    count = {}\n\n    # Count each number in the list\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Filter out the numbers that have more than one occurrence\n    unique_nums = [num for num in nums if count[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    nums_set = set(nums)\n    return [num for num in nums if nums.count(num) == 1]", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count the frequency of each number\n    frequency = {}\n\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Collect numbers that appear exactly once\n    unique_nums = [num for num in frequency if frequency[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    unique_nums = []\n    num_counts = {}\n\n    for num in nums:\n        if num in num_counts:\n            num_counts[num] += 1\n        else:\n            num_counts[num] = 1\n\n    for num in nums:\n        if num_counts[num] == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers and returns a new list with the two unique numbers.\n    \"\"\"\n    # Use a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Find the numbers that appear exactly once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to track the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Collect numbers that appear exactly once\n    result = [num for num, count in freq.items() if count == 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Create an empty dictionary to store the frequency of each number\n    frequency = {}\n\n    # Iterate over the list of numbers and populate the frequency dictionary\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Initialize a list to store unique numbers\n    unique_numbers = []\n\n    # Iterate over the frequency dictionary and collect numbers that appear exactly once\n    for num, count in frequency.items():\n        if count == 1:\n            unique_numbers.append(num)\n\n    return unique_numbers", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Use a dictionary to count the occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Extract numbers that occur exactly once\n    unique_nums = [num for num in nums if count_dict[num] == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Use a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n\n    # Collect numbers that occur exactly once\n    result = [num for num in count if count[num] == 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Initialize an empty dictionary to keep track of the count of each number\n    count_dict = {}\n\n    # Traverse through the list and count the occurrences of each number\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    # Create a list to store the unique numbers\n    unique_nums = []\n\n    # Traverse through the list again and add numbers to the unique list only if their count is 1\n    for num in numbers:\n        if count_dict[num] == 1:\n            unique_nums.append(num)\n\n    # Return the list of unique numbers\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    nums_dict = {}\n    for num in nums:\n        if num in nums_dict:\n            nums_dict[num] += 1\n        else:\n            nums_dict[num] = 1\n\n    unique_nums = [num for num in nums if nums_dict[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to track the frequency of each number\n    frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in frequency.items() if count == 1]\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to track the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Filter out numbers that appear more than once and create the result list\n    result = [num for num in nums if freq[num] == 1]\n\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 62.25396825396825, "dps_norm": 64.54545454545455, "pass@1": 94.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): First list of integers.\n    list2 (list): Second list of integers.\n    list3 (list): Third list of integers.\n\n    Returns:\n    list: Interleaved list.\n    \"\"\"\n    interleaved_list = []\n    length = len(list1)\n\n    for i in range(length):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all input lists have the same length\n    if not all(len(lst) == len(list1) for lst in [list2, list3]):\n        raise ValueError(\"All input lists must have the same length\")\n\n    # Interleave elements from each list\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \"\"\"\n    assert len(list1) == len(list2) == len(list3), \"All lists must have the same length\"\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n\n    Returns:\n    list: A single list that interleaves the elements from the input lists.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must have the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    assert len(list1) == len(list2) == len(list3), \"All input lists must be of the same length\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All input lists must be of the same length\")\n\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): First list of elements.\n    list2 (list): Second list of elements.\n    list3 (list): Third list of elements.\n\n    Returns:\n    list: Interleaved list of elements.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All input lists must have the same length\")\n\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Interleave three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list of elements.\n        list2 (list): Second list of elements.\n        list3 (list): Third list of elements.\n\n    Returns:\n        list: A single flat list with elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    assert len(list1) == len(list2) == len(list3), \"All lists must be of the same length\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    assert len(list1) == len(list2) == len(list3), \"All lists must be of the same length.\"\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure that the lists have the same length\n    assert len(list1) == len(list2) == len(list3), \"All lists must have the same length\"\n\n    # Initialize the resulting interleaved list\n    interleaved_list = []\n\n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list to the interleaved list\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must be of the same length.\")\n\n    return [item for triplet in zip(list1, list2, list3) for item in triplet]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): First list.\n    list2 (list): Second list.\n    list3 (list): Third list.\n\n    Returns:\n    list: Interleaved list.\n    \"\"\"\n    interleaved_list = []\n\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): First list.\n    list2 (list): Second list.\n    list3 (list): Third list.\n\n    Returns:\n    list: Interleaved list.\n    \"\"\"\n    # Check if all lists are of the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n\n    Returns:\n    list: A single interleaved list.\n    \"\"\"\n    result = []\n    length = len(list1)\n\n    for i in range(length):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    assert len(list1) == len(list2) == len(list3), \"All lists must have the same length\"\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Args:\n    list1 (list): First list of elements.\n    list2 (list): Second list of elements.\n    list3 (list): Third list of elements.\n\n    Returns:\n    list: Interleaved list of elements from the three lists.\n    \"\"\"\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists have the same length\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n\n    # Initialize the interleaved list\n    interleaved = []\n\n    # Interleave elements from each list\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n\n    Parameters:\n    list1 (list): First list to interleave.\n    list2 (list): Second list to interleave.\n    list3 (list): Third list to interleave.\n\n    Returns:\n    list: A flat list with elements interleaved from list1, list2, and list3.\n    \"\"\"\n    # Ensure all lists have the same length\n    assert len(list1) == len(list2) == len(list3), \"All lists must be of the same length\"\n\n    # Initialize the result list\n    result = []\n\n    # Loop over the range of the length of the lists\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 33.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    if n <= 0 or n >= len(arr):\n        return arr\n    part1 = arr[:n]\n    part2 = arr[n:]\n    return part2 + part1", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    :param lst: List of elements to be split.\n    :param n: Position at which to split the list.\n    :return: New list with the first part appended to the end.\n    \"\"\"\n    if n >= 0:\n        return lst[n:] + lst[:n]\n    else:\n        return lst  # Return the original list if n is negative", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): The input list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list as per the specified split and operation.\n    \"\"\"\n    if not arr or n <= 0 or n >= len(arr):\n        return arr\n\n    # Split the list into two parts\n    part1 = arr[:n]\n    part2 = arr[n:]\n\n    # Combine part2 followed by part1\n    return part2 + part1", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Check if n is within the bounds of the list\n    if n < 0 or n >= len(arr):\n        return arr  # If n is out of bounds, return the original list\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n <= 0 or n > len(arr):\n        return arr  # return the array as it is if n is out of bounds\n\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Concatenate the second part and the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    if n < 0 or n >= len(lst):\n        return lst\n    first_part = lst[:n]\n    second_part = lst[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n <= 0 or n >= len(arr):\n        return arr\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Check if the input list and n are valid\n    if not arr or n <= 0 or n >= len(arr):\n        return arr\n    # Split the list at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array at the nth element\n    if n < 0 or n >= len(arr):\n        return arr  # Return the array as is if n is out of bounds\n    split_point = arr[:n]\n    rest_of_array = arr[n:]\n    # Add the first part to the end of the rest of the array\n    return rest_of_array + split_point", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list at the nth element\n    if n < 0 or n >= len(arr):\n        return arr  # If n is out of bounds, return the original list\n\n    # Extract the first part of the list up to the nth element\n    first_part = arr[:n]\n    # Extract the second part of the list from the nth element to the end\n    second_part = arr[n:]\n\n    # Combine the parts such that the first part is added to the end of the second part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Check if the array has enough elements\n    if n >= len(arr):\n        return arr\n\n    # Split the array at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Combine the two parts\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n <= 0 or n > len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    :param arr: List of elements to be split.\n    :param n: The element at which the list should be split.\n    :return: New list with the first part moved to the end.\n    \"\"\"\n    if n >= len(arr):\n        return arr  # If n is out of bounds, return the original list.\n\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    :param arr: List of elements\n    :param n: Index at which to split the list\n    :return: Modified list\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr  # If n is out of bounds, return the list as is\n\n    # Split the list at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Concatenate the second part and the first part\n    result = second_part + first_part\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the list at the nth element\n    mid = arr[:n]\n    end = arr[n:]\n\n    # Concatenating the first part to the end\n    return end + mid", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    part1 = arr[:n]\n    part2 = arr[n:]\n    return part2 + part1", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: A new list with the first part moved to the end.\n    \"\"\"\n    if n < 0 or n >= len(arr):\n        return arr  # If n is out of bounds, return the original list\n\n    # Split the list at index n\n    first_part = arr[:n]\n    second_part = arr[n:]\n\n    # Combine the parts with the first part moved to the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if not arr or n <= 0 or n >= len(arr):\n        return arr  # If the array is empty, or n is out of bounds, return the original array\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 1 or n > len(arr):\n        return arr\n    # Split the array into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Combine the second part with the first part\n    return second_part + first_part", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 12.162162162162161, "dps_norm": 75.0, "pass@1": 88.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The input list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): A list of elements to convert.\n\n    Returns:\n    tuple: A tuple containing the elements from the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The list to be converted to a tuple.\n\n    Returns:\n    tuple: The tuple representation of the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list to a tuple.\n\n    Args:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The input list to be converted.\n\n    Returns:\n        tuple: The tuple converted from the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list to a tuple.\n\n    :param lst: List to be converted\n    :return: Tuple\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    lst (list): A list of elements to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    This function converts a list into a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    lst (list): List to be converted.\n\n    Returns:\n    tuple: Converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The input list to be converted.\n\n    Returns:\n    tuple: The tuple converted from the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The input list to be converted to a tuple.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): A list of elements.\n\n    Returns:\n    tuple: A tuple with the elements of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    if not nums:\n        raise ValueError(\"The list is empty\")\n\n    max_value = max(nums)\n    min_value = min(nums)\n\n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    largest = max(numbers)\n    smallest = min(numbers)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(arr):\n    \"\"\"\n    This function finds the difference between the largest and smallest value in a given list.\n\n    Parameters:\n    arr (list): A list of integers\n\n    Returns:\n    int: The difference between the largest and smallest value in the list\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The list is empty\")\n    return max(arr) - min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        raise ValueError(\"List is empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Check if the list is empty\n    if not nums:\n        raise ValueError(\"The list is empty\")\n\n    # Find the largest and smallest numbers in the list\n    min_num = min(nums)\n    max_num = max(nums)\n\n    # Return the difference between the largest and smallest numbers\n    return max_num - min_num", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n    nums (list of int): List of integers\n\n    Returns:\n    int: Difference between the largest and smallest value in the list\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The input list is empty\")\n\n    max_val = max(nums)\n    min_val = min(nums)\n\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest values in a given list.\n\n    :param numbers: List[int] - A list of integers\n    :return: int - The difference between the largest and smallest values\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list cannot be empty\")\n\n    largest = max(numbers)\n    smallest = min(numbers)\n\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:  # Handle empty list case\n        return 0\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between the largest and smallest values in a given list.\n\n    Parameters:\n    nums (list of int): The list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list must not be empty\")\n\n    largest = max(nums)\n    smallest = min(nums)\n\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"Input list should not be empty\")\n\n    max_val = max(lst)\n    min_val = min(lst)\n\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0\n    largest = max(lst)\n    smallest = min(lst)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:  # Check for empty list\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        raise ValueError(\"List should not be empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(arr):\n    if not arr:\n        return 0\n    return max(arr) - min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        raise ValueError(\"The list is empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 60.66666666666667, "dps_norm": 51.0, "pass@1": 10.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    # Initialize the sum of products\n    sum_prod = 0\n\n    for i in range(n):\n        # Product of binomial coefficients\n        prod = math.comb(n, i) * math.comb(n, i+1)\n        sum_prod += prod\n\n    return sum_prod", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    total_sum = 0\n    for i in range(n):\n        total_sum += math.comb(n, i) * math.comb(n, i+1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    product_sum = 0\n    for k in range(n):\n        product_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return product_sum", "matching_cluster_idx": 4}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for the given value of n.\n\n    Parameters:\n    n (int): The number of terms (binomial coefficients).\n\n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    # Calculate binomial coefficients using the combination formula\n    # C(n, k) = n! / (k! * (n - k)!)\n    from math import comb\n\n    sum_product = 0\n    for k in range(n):\n        sum_product += comb(n, k) * comb(n, k + 1)\n\n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += comb(n, i) * comb(n, i+1)\n    return total", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    product_sum = 0\n    for i in range(n):\n        product_sum += comb(n, i) * comb(n, i+1)\n    return product_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += binomial_coefficient(n, k - 1) * binomial_coefficient(n, k)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "import math\ndef binomial_coeff(n, k):\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        prod = binomial_coeff(n, k) * binomial_coeff(n, k + 1)\n        total_sum += prod\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"\n    Calculate the binomial coefficient C(n, k)\n    \"\"\"\n    if k > n:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (n - i)\n        denominator *= (i + 1)\n    return numerator // denominator\ndef sum_Of_product(n):\n    \"\"\"\n    Find the sum of the product of consecutive binomial coefficients\n    \"\"\"\n    sum_products = 0\n    for k in range(n+1):\n        sum_products += binomial_coefficient(n, k) * binomial_coefficient(n, k+1)\n    return sum_products", "matching_cluster_idx": 0}, {"solution": "import math\ndef binomial_coeff(n, k):\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    total = 0\n    for i in range(n):\n        total += binomial_coeff(n, i) * binomial_coeff(n, i + 1)\n    return total", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/604": {"dps": 28.40909090909091, "dps_norm": 85.0, "pass@1": 87.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words into a single string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the input string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the input string by spaces to get a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a single string with spaces in between\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string by spaces to get individual words\n    words = s.split()\n\n    # Reverse the list of words\n    reversed_words = words[::-1]\n\n    # Join the reversed list back into a string with spaces\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(input_string):\n    # Split the string into words\n    words = input_string.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words back into a string\n    reversed_string = ' '.join(reversed_words)\n\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the input string by spaces\n    words = s.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the reversed list of words back into a string\n    return ' '.join(words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s: str) -> str:\n    # Split the string by spaces to get individual words\n    words = s.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the reversed words back into a string\n    reversed_string = ' '.join(words)\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    \"\"\"\n    This function takes a string with words separated by spaces and returns\n    the string with words in reverse order.\n    \"\"\"\n    # Split the input string into a list of words\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s: str) -> str:\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse the words in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with words reversed.\n    \"\"\"\n    # Split the string by spaces to get the words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string with spaces in between\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the input string into a list of words\n    words = s.split()\n    # Reverse the order of words in the list\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(input_string):\n    # Split the string into words\n    words = input_string.split()\n    # Reverse the order of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a string with spaces in between\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s: str) -> str:\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s: str) -> str:\n    # Split the string by spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string\n    return ' '.join(reversed_words)", "matching_cluster_idx": 3}]}, "Mbpp/610": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/611": {"dps": 90.3680981595092, "dps_norm": 96.66666666666667, "pass@1": 33.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum value in the n'th column.\n\n    Args:\n    matrix (list of lists): The input matrix.\n    n (int): The column index to find the maximum value in.\n\n    Returns:\n    int: The maximum value in the n'th column.\n    \"\"\"\n    # Ensure that the column index is valid\n    if not all(len(row) > n for row in matrix):\n        raise ValueError(\"The column index n is out of range.\")\n\n    # Initialize the maximum value\n    max_value = float('-inf')\n\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Update the maximum value if the current element is greater\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is empty or column index is out of bounds\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid matrix or column index\")\n\n    # Initialize max_value to negative infinity\n    max_value = float('-inf')\n\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Update max_value if current row element at column n is greater\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Initialize the maximum value\n    max_value = float('-inf')\n\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Update the maximum value if the current element is larger\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to return the maximum value in the n'th column of the given matrix.\n\n    :param matrix: List of lists representing the matrix\n    :param n: Column index (0-based)\n    :return: Maximum value in the n'th column\n    \"\"\"\n    # Check if the matrix is not empty and has at least n columns\n    if not matrix or any(len(row) <= n for row in matrix):\n        raise ValueError(\"Invalid matrix or column index\")\n\n    # Extract the n'th column and find the maximum value\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value in the n-th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the max value of the n'th column.\n\n    :param matrix: List of lists representing the matrix.\n    :param n: Column index to find the maximum value in.\n    :return: Maximum value in the n'th column.\n    \"\"\"\n    # Edge case: if n is out of bounds\n    if n >= len(matrix[0]):\n        return None  # Assuming return None if n is out of range\n\n    max_value = float('-inf')\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function returns the maximum value in the n'th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The input matrix.\n    n (int): The column index (0-based).\n\n    Returns:\n    int: The maximum value in the n'th column.\n    \"\"\"\n    # Edge case check: if the matrix is empty or has fewer than n rows, or n is out of range.\n    if not matrix or len(matrix[0]) <= n:\n        return None\n\n    max_value = float('-inf')\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure that the matrix has at least n+1 rows and n columns\n    if not matrix or not all(isinstance(row, list) for row in matrix) or any(len(row) < n for row in matrix):\n        raise ValueError(\"Invalid matrix or n out of bounds\")\n\n    # Extract the n'th column from the matrix\n    nth_column = [row[n] for row in matrix]\n\n    # Return the maximum value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 3}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function returns the maximum value in the n'th column of the matrix.\n\n    :param matrix: List of lists representing the matrix\n    :param n: The column index (0-based)\n    :return: Maximum value in the n'th column\n    \"\"\"\n    if not matrix or n >= len(matrix[0]):\n        return None\n\n    max_value = float('-inf')\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        return None\n\n    # Use the `key` argument in the `max` function to get the max of the nth column\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum value in the n'th column.\n\n    :param matrix: List of lists, representing the matrix.\n    :param n: Column index (0-based).\n    :return: Maximum value in the n'th column.\n    \"\"\"\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid matrix or column index.\")\n\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        raise ValueError(\"Matrix must not be empty\")\n    if n >= len(matrix[0]):\n        raise IndexError(\"n is out of bounds of columns in the matrix\")\n\n    column_n = [row[n] for row in matrix]\n    return max(column_n)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the max of the n'th column.\n\n    :param matrix: List of lists (2D matrix)\n    :param n: The column index (0-based)\n    :return: The maximum value in the n'th column\n    \"\"\"\n    if not matrix or n >= len(matrix[0]):\n        raise ValueError(\"Invalid matrix or column index\")\n\n    max_value = float('-inf')\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure the column exists\n    if n >= len(matrix[0]):\n        raise ValueError(\"The column index is out of bounds\")\n\n    # Initialize the maximum value\n    max_value = float('-inf')\n\n    # Iterate over each row in the matrix\n    for row in matrix:\n        # Check the nth element of each row\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Initialize max value with the smallest possible integer\n    max_value = float('-inf')\n\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Check if the current row has enough columns\n        if len(row) > n:\n            # Update max_value if the current element is greater\n            max_value = max(max_value, row[n])\n\n    return max_value", "matching_cluster_idx": 3}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        raise ValueError(\"Input matrix is empty or has no columns\")\n\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n'th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to search within.\n    n (int): The column index to find the maximum value in (0-indexed).\n\n    Returns:\n    int: The maximum value in the specified column.\n    \"\"\"\n    # Check if the matrix is not empty and n is within the range of columns\n    if not matrix or n >= len(matrix[0]):\n        return None\n\n    # Initialize max value with the first element of the n'th column\n    max_value = matrix[0][n]\n\n    # Iterate over each row starting from the second row\n    for row in matrix[1:]:\n        # Update max_value if the current element is greater\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Initialize max value with the first element of the n-th column\n    max_value = matrix[0][n]\n\n    # Iterate through each row of the matrix\n    for row in matrix:\n        # Check if the current element in the n-th column is greater than the current max value\n        if row[n] > max_value:\n            # Update the max value\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        raise ValueError(\"Matrix or its first row is empty\")\n\n    nth_column = [row[n] for row in matrix]\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum value in the n'th column.\n\n    :param matrix: List of lists representing the matrix.\n    :param n: Column index (0-based).\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"Matrix is empty or has no rows\")\n\n    # Check if n is within the range of columns in the matrix\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range\")\n\n    # Initialize max_value to a very small number\n    max_value = float('-inf')\n\n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Update max_value if current element in n'th column is greater\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 51.7361111111111, "dps_norm": 55.625, "pass@1": 20.0, "profiled": [{"solution": "def replace_spaces(input_string):\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Create a translation table to replace whitespaces with underscores and vice versa\n    translation_table = str.maketrans(\" _\", \"_ \")\n    # Use the translate method to apply the translation table\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    # Create a new string with underscores replacing spaces and vice versa\n    result = \"\"\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Replace whitespace with underscore and vice versa\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n    \"\"\"\n    # Create a translation table to swap spaces and underscores\n    translation_table = str.maketrans(' _', '_ ')\n    # Use the translate method to perform the replacement\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s: str) -> str:\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and vice versa in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with spaces and underscores swapped.\n    \"\"\"\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s: str) -> str:\n    # Replace spaces with underscores and vice versa\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string: str) -> str:\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"Replaces whitespaces with underscores and underscores with whitespaces in a given string.\"\"\"\n    # Create a translation table that maps spaces to underscores and vice versa\n    translation_table = str.maketrans(' _', '_ ')\n    # Use the translate method to apply the translation table to the input string\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(input_string):\n    # Create an empty result string\n    result = ''\n    # Iterate through each character in the input string\n    for char in input_string:\n        # Replace spaces with underscores and underscores with spaces\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n    \"\"\"\n    result = []\n    for char in input_string:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is a space\n        if char == ' ':\n            # Replace space with underscore\n            result += '_'\n        elif char == '_':\n            # Replace underscore with space\n            result += ' '\n        else:\n            # Keep the character as it is\n            result += char\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    # Use translate with a translation table to replace spaces with underscores and vice versa\n    translation_table = str.maketrans(' _', '_ ')\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s: str) -> str:\n    # Define a translation table to replace whitespaces with underscores and vice versa\n    table = str.maketrans(' _', '_ ')\n    # Use the translate method to apply the table to the input string\n    return s.translate(table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Iterate over each character in the string\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    # Join the list into a string\n    return ''.join(result)", "matching_cluster_idx": 3}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 76.0, "profiled": [{"solution": "def move_zero(lst):\n    # Separate the non-zero and zero elements\n    non_zeros = [num for num in lst if num != 0]\n    zeros = [num for num in lst if num == 0]\n    # Combine them to form the final list\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    non_zero_elements = [num for num in lst if num != 0]\n    return non_zero_elements + [0] * (len(lst) - len(non_zero_elements))", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n\n    :param lst: List of integers.\n    :return: List with all zeroes moved to the end.\n    \"\"\"\n    # List comprehension to filter out zeroes first\n    non_zero_elements = [num for num in lst if num != 0]\n    # Extend the list with the remaining zeroes\n    non_zero_elements.extend([num for num in lst if num == 0])\n    return non_zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list while preserving the order of non-zero elements.\n\n    Parameters:\n    nums (list): List of integers\n\n    Returns:\n    list: List with zeroes moved to the end\n    \"\"\"\n    # Filter out zeroes from the list\n    non_zeroes = [num for num in nums if num != 0]\n    # Calculate the number of zeroes\n    num_zeros = len(nums) - len(non_zeroes)\n    # Append the remaining zeroes to the end of the list\n    non_zeroes.extend([0] * num_zeros)\n    return non_zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Separate the non-zero and zero elements\n    non_zero_elements = [num for num in nums if num != 0]\n    zero_elements = [0] * (len(nums) - len(non_zero_elements))\n\n    # Combine the non-zero elements followed by the zero elements\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Initialize a pointer to keep track of non-zero elements\n    non_zero_index = 0\n\n    # Iterate through the array\n    for i in range(len(arr)):\n        # If the current element is not zero, place it at the non_zero_index position\n        if arr[i] != 0:\n            arr[non_zero_index] = arr[i]\n            # Increment the non-zero index\n            non_zero_index += 1\n\n    # Fill the remaining positions with zeroes\n    for j in range(non_zero_index, len(arr)):\n        arr[j] = 0\n\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    list: The list with zeroes moved to the end.\n    \"\"\"\n    # Filter out non-zero elements and append remaining zeroes\n    result = [num for num in lst if num != 0] + [0] * lst.count(0)\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n    arr (list): The list of integers.\n\n    Returns:\n    list: A new list with zeroes moved to the end.\n    \"\"\"\n    # Filter non-zero elements and extend the list with remaining zeroes\n    return [num for num in arr if num != 0] + [0] * arr.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate non-zero elements and zero elements\n    non_zero = [num for num in lst if num != 0]\n    zero = [num for num in lst if num == 0]\n\n    # Concatenate non-zero and zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Separate the non-zero elements and zeroes\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [num for num in nums if num == 0]\n\n    # Concatenate the lists\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Separate the non-zero and zero elements\n    non_zero_elements = [num for num in nums if num != 0]\n    zero_elements = [num for num in nums if num == 0]\n\n    # Combine them to form the final list\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate the non-zero elements and zero elements\n    non_zeros = [num for num in lst if num != 0]\n    zeros = [num for num in lst if num == 0]\n\n    # Combine the non-zero elements and zero elements\n    result = non_zeros + zeros\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Filter out non-zero elements and then extend with zeroes\n    return [num for num in nums if num != 0] + [0] * nums.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # This function moves all zeroes to the end of the list while maintaining the relative order of the other elements.\n    # It uses two pointers technique.\n\n    # Initial pointer for the position where the next non-zero element should be placed\n    non_zero_pos = 0\n\n    # Traverse the array, for each non-zero element, place it at the non_zero_pos and increment the pointer\n    for element in arr:\n        if element != 0:\n            arr[non_zero_pos] = element\n            non_zero_pos += 1\n\n    # All the elements from non_zero_pos to the end of the array are set to zero\n    for i in range(non_zero_pos, len(arr)):\n        arr[i] = 0\n\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Filter out zeros and count them\n    non_zero_elements = [num for num in lst if num != 0]\n    zero_count = lst.count(0)\n\n    # Create a new list with non-zero elements followed by zeros\n    result = non_zero_elements + [0] * zero_count\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # This will keep track of the position where the next non-zero element should be placed\n    position = 0\n\n    for num in nums:\n        if num != 0:\n            nums[position] = num\n            position += 1\n\n    # Fill the remaining elements with zero\n    for i in range(position, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to store non-zero elements\n    non_zero_elements = [num for num in nums if num != 0]\n    # Fill the rest with zeroes\n    nums[:] = non_zero_elements + [0] * (len(nums) - len(non_zero_elements))\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Separate the non-zero elements and zero elements\n    non_zero_elements = [num for num in nums if num != 0]\n    zero_count = nums.count(0)\n\n    # Extend the list of non-zero elements with zeros\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Separate list into non-zero and zero elements\n    non_zero_elements = [x for x in lst if x != 0]\n    zero_elements = [x for x in lst if x == 0]\n    # Combine the lists\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    # Initialize a pointer for the position to place non-zero elements\n    non_zero_position = 0\n\n    # Iterate over the array\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            # Swap the current element with the element at non_zero_position\n            arr[non_zero_position], arr[i] = arr[i], arr[non_zero_position]\n            # Increment the non_zero_position pointer\n            non_zero_position += 1\n\n    return arr", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/644": {"dps": 88.11170212765956, "dps_norm": 89.33333333333333, "pass@1": 59.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    # Validate k\n    if k <= 0 or k > len(arr):\n        raise ValueError(\"k should be in the range (0, len(arr)]\")\n\n    # Reverse the portion of the array up to k\n    arr[:k] = arr[:k][::-1]\n\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    if k < 0:\n        return arr\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first 'k' elements\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed.\n    :param k: Position up to which the array should be reversed.\n    :return: List with elements reversed up to position k.\n    \"\"\"\n    # Reverse the first k elements\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the elements of the array up to the given position k.\n\n    :param arr: List of elements to be reversed\n    :param k: Position up to which elements should be reversed\n    :return: Reversed array up to the given position\n    \"\"\"\n    # Reverse the elements up to the position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    This function reverses the given array up to the given position k.\n\n    Parameters:\n    arr (list): The list to be reversed.\n    k (int): The position up to which the list should be reversed.\n\n    Returns:\n    list: The modified list with elements up to position k reversed.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to position k.\n\n    Parameters:\n    arr (list): The list to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k <= 0 or k > len(arr):\n        return arr\n\n    # Reverse the elements up to the k-th position\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 11}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first 'k' elements\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements\n    arr[:k] = reversed(arr[:k])\n    return arr", "matching_cluster_idx": 12}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from the start up to the k-th element\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Parameters:\n    t (tuple): The input tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, dictionary):\n    return input_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(existing_tuple, dictionary):\n    # Convert dictionary to tuple and append to existing tuple\n    new_tuple = existing_tuple + (dictionary,)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Add a dictionary to the tuple and return the new tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    This function takes a tuple and a dictionary as input, and returns a new tuple with the dictionary appended to the end.\n\n    Parameters:\n    original_tuple (tuple): The original tuple.\n    new_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n\n    Args:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: The new tuple containing the original tuple elements and the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, dictionary):\n    # Convert the dictionary to a tuple\n    dict_as_tuple = (dictionary,)\n    # Add the dictionary as a tuple to the original tuple\n    new_tuple = input_tuple + dict_as_tuple\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    # Add the dictionary to the end of the tuple\n    new_tup = tup + (dct,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the dictionary to a tuple and add it to the original tuple\n    new_tuple = input_tuple + (input_dict,)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    # Convert the dictionary to a tuple and add it to the end of the original tuple\n    new_tuple = original_tuple + (dictionary,)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the result as a new tuple.\n\n    Args:\n        input_tuple (tuple): The original tuple.\n        input_dict (dict): The dictionary to add to the tuple.\n\n    Returns:\n        tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    # Convert the dictionary to a tuple and add it to the original tuple\n    new_tuple = input_tuple + (input_dict,)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(existing_tuple, new_dict):\n    # Add the dictionary to the tuple\n    return existing_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    # Convert dictionary to tuple element\n    tup += (dic,)\n    return tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Add a dictionary to the tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 58.79781420765027, "dps_norm": 68.125, "pass@1": 92.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    # Use regular expressions to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    # Use regular expression to find all matches between quotation marks\n    matches = re.findall(r'\"(.*?)\"', string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regex to find all substrings between quotes\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings between quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expressions to find all substrings between quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extract values between quotation marks \" \" of the given string.\n\n    Parameters:\n    s (str): The input string to extract quotes from.\n\n    Returns:\n    list: A list of strings that are between quotation marks.\n    \"\"\"\n    # Use regex to find all substrings that are enclosed within double quotes\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings between quotes\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Using regex to find all substrings enclosed within quotes\n    quoted_strings = re.findall(r'\\\"(.*?)\\\"', input_string)\n    return quoted_strings", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    # Use regular expression to find all substrings enclosed in quotation marks\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regex to find all words within quotation marks\n    pattern = re.compile(r'\"(.*?)\"')\n    return [match.group(1) for match in pattern.finditer(s)]", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    # Use regex to find all substrings between quotation marks\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regex to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(text):\n    import re\n\n    # Use regular expression to find all substrings between quotes\n    matches = re.findall(r'\".*?\"', text)\n\n    # Remove quotes from the matched substrings\n    values = [match.strip('\"') for match in matches]\n\n    return values", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings between double quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expressions to find all substrings enclosed in double quotation marks\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Define a regular expression pattern to find text between quotes\n    pattern = r'\"(.*?)\"'\n    # Use re.findall to find all matches of the pattern in the input string\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 4}]}, "Mbpp/732": {"dps": 75.71705426356588, "dps_norm": 94.5, "pass@1": 95.0, "profiled": [{"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s: str) -> str:\n    # Create a translation table to replace spaces, commas, and dots with colons\n    translator = str.maketrans(' .,', ':::')\n    # Use the translate method to apply the translation table to the string\n    return s.translate(translator)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, or dots with a colon\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Define the characters to replace\n    replace_chars = ' ,.'\n    # Define the character to replace with\n    replace_with = ':'\n\n    # Use str.translate() and str.maketrans() for efficient replacement\n    translation_table = str.maketrans(replace_chars, replace_with * len(replace_chars))\n    return s.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with colons\n    result = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s: str) -> str:\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    replaced = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return replaced", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    return input_str.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s: str) -> str:\n    special_chars = {' ': ':', ',': ':', '.': ':'}\n    return ''.join(special_chars.get(char, char) for char in s)", "matching_cluster_idx": 4}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Define the characters to be replaced\n    characters_to_replace = ' ,.'\n\n    # Define the replacement character\n    replacement_character = ':'\n\n    # Use the translate method to replace characters\n    return input_string.translate(str.maketrans(characters_to_replace, replacement_character * len(characters_to_replace)))", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with colons\n    result = s.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return result", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_str):\n    \"\"\"\n    This function replaces all occurrences of spaces, commas, or dots with a colon.\n\n    :param input_str: String to replace characters in.\n    :return: String with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    # Define the characters to replace\n    special_chars = \" ,.\"\n    # Define the replacement character\n    replacement = \":\"\n\n    # Create a translation table\n    translation_table = str.maketrans(special_chars, replacement * len(special_chars))\n\n    # Use translate to apply the table\n    return input_str.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(input_string):\n    # Create a translation table that maps spaces, commas, and dots to colons\n    translation_table = str.maketrans(' ,.', ':::')\n    # Use the translate method to replace characters\n    return input_string.translate(translation_table)", "matching_cluster_idx": 8}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = {' ': ':', ',': ':', '.': ':'}\n\n    # Replace each character in the text using str.translate\n    replaced_text = text.translate(str.maketrans(special_chars))\n\n    return replaced_text", "matching_cluster_idx": 8}]}, "Mbpp/740": {"dps": 59.96363636363637, "dps_norm": 60.55555555555556, "pass@1": 85.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    result = {}\n    i = 0\n    while i < len(t) - 1:\n        result[t[i]] = t[i + 1]\n        i += 2\n    return result", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(t):\n    # Create an empty dictionary to store the key-value pairs\n    result = {}\n\n    # Iterate through the tuple in steps of 2 to get the pairs\n    for i in range(0, len(t), 2):\n        # The current element is the key, and the next element is the value\n        result[t[i]] = t[i + 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    # Initialize an empty dictionary\n    result = {}\n\n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(t), 2):\n        # Pair the current element with the next one\n        result[t[i]] = t[i + 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs\")\n\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n    tup (tuple): The input tuple of elements.\n\n    Returns:\n    dict: A dictionary with keys and values formed from adjacent elements of the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The length of the tuple must be even.\")\n\n    result = {}\n    for i in range(0, len(tup), 2):\n        key, value = tup[i], tup[i + 1]\n        result[key] = value\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a key-value dictionary using adjacent elements.\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n    >>> tuple_to_dict((2, 3, 4, 5))\n    {2: 3, 4: 5}\n    >>> tuple_to_dict((5))\n    {}\n    >>> tuple_to_dict((1,))\n    {}\n    \"\"\"\n    if len(t) < 2:\n        return {}\n\n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i + 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Initialize an empty dictionary\n    result_dict = {}\n\n    # Loop over the tuple in steps of 2\n    for i in range(0, len(tup), 2):\n        # Assign key-value pairs to the dictionary\n        if i + 1 < len(tup):\n            result_dict[tup[i]] = tup[i + 1]\n\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(t):\n    # Initialize an empty dictionary\n    result = {}\n\n    # Iterate through the tuple, using the `i` element as the key and `i+1` as the value\n    for i in range(0, len(t) - 1, 2):\n        result[t[i]] = t[i + 1]\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    # Create an empty dictionary to store the key-value pairs\n    result = {}\n\n    # Iterate over the tuple in steps of two\n    for i in range(0, len(t), 2):\n        key = t[i]\n        value = t[i + 1]\n        # Add the key-value pair to the dictionary\n        result[key] = value\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple has an odd number of elements.\")\n\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create an empty dictionary\n    result_dict = {}\n\n    # Iterate over the tuple with a step of 2\n    for i in range(0, len(input_tuple), 2):\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n\n    Args:\n    t (tuple): Input tuple with elements.\n\n    Returns:\n    dict: Dictionary with keys and values from the tuple.\n    \"\"\"\n    # Initialize an empty dictionary\n    result_dict = {}\n\n    # Iterate through the tuple in steps of 2\n    for i in range(0, len(t), 2):\n        # Assign the value to the key in the dictionary\n        result_dict[t[i]] = t[i + 1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts the given tuple to a dictionary with keys and values from adjacent elements.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        dict: A dictionary created from the tuple where each key-value pair is formed from adjacent elements.\n    \"\"\"\n    # Initialize an empty dictionary\n    result_dict = {}\n\n    # Iterate through the tuple in steps of two\n    for i in range(0, len(tup), 2):\n        # Create the key-value pair from the adjacent elements\n        key = tup[i]\n        value = tup[i+1]\n        # Add the pair to the dictionary\n        result_dict[key] = value\n\n    return result_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    # Initialize an empty dictionary\n    result = {}\n    # Loop through the tuple with a step of 2\n    for i in range(0, len(t), 2):\n        # Add the element at the current index as the key and the next element as the value\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"The tuple length must be even.\")\n\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The length of the tuple must be even to form key-value pairs\")\n\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    # Create an empty dictionary\n    result_dict = {}\n\n    # Iterate over the tuple with step 2 to get key-value pairs\n    for i in range(0, len(t), 2):\n        if i + 1 < len(t):\n            result_dict[t[i]] = t[i + 1]\n\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple has an odd number of elements.\")\n\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 69.07534246575342, "dps_norm": 78.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any None value is found in the tuple, otherwise False.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n\n    Parameters:\n    tpl (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is any None value in the tuple, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None values.\n\n    Args:\n    tup (tuple): A tuple of elements.\n\n    Returns:\n    bool: True if any None value is present, otherwise False.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains a None value, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    # Check if any element in the tuple is None\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if there is any None value in the tuple, otherwise False.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any element in the tuple is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(t):\n    # Iterate through each element in the tuple\n    for item in t:\n        # If any item is None, return True\n        if item is None:\n            return True\n    # If no None items found, return False\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tpl):\n    \"\"\"\n    This function checks if the given tuple contains any None values.\n\n    Parameters:\n    tpl (tuple): The input tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None values, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if any element in the given tuple is None.\n\n    Parameters:\n    tuple_input (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    t (tuple): The input tuple to check for None values.\n\n    Returns:\n    bool: True if any element in the tuple is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Parameters:\n    t (tuple): A tuple of elements to check\n\n    Returns:\n    bool: True if any None value is found, False otherwise\n    \"\"\"\n    return any(element is None for element in t)", "matching_cluster_idx": 2}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Function to check if the given tuple contains any None values.\n\n    Args:\n    tpl (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(data):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Args:\n    data (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if any None value is present, False otherwise.\n    \"\"\"\n    return any(x is None for x in data)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    # Check if any element in the tuple is None\n    return any(element is None for element in t)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    t (tuple): The tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Parameters:\n    tpl (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if any None value is found, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n    t (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if the tuple contains None, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 69.25170068027211, "dps_norm": 68.33333333333333, "pass@1": 96.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple elements to the end of the given list.\n\n    Args:\n    lst (list): The list to which tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list with elements of the original list followed by elements of the tuple.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    This function adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list with the tuple elements added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Args:\n    lst (list): The original list.\n    tup (tuple): The tuple to be added.\n\n    Returns:\n    list: A new list with the tuple elements added to the end of the original list.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds elements of the given tuple to the given list.\n\n    Args:\n    lst (list): The original list to add elements to.\n    tup (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list with the elements of the tuple appended.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Args:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list with elements of the tuple added to the original list.\n    \"\"\"\n    # Extend the list with the elements of the tuple\n    new_list = lst + list(tpl)\n    return new_list", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list with the elements of the tuple added to the end.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The list with the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to be added.\n\n    Returns:\n    list: A new list with the elements of the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to add the tuple to.\n    tup (tuple): The tuple to add to the list.\n\n    Returns:\n    list: A new list with the tuple added to it.\n    \"\"\"\n    # Combine the list and the tuple into a single iterable\n    combined = lst + list(tup)\n    return combined", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the end of the given list.\n\n    :param lst: List of elements\n    :param tup: Tuple of elements\n    :return: Updated list with tuple elements added\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The updated list with the elements of the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds a tuple to a list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: A new list with the tuple elements added to the end.\n    \"\"\"\n    # Unpack the tuple and extend the list with its elements\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    # Convert tuple to list and extend the original list\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list with the tuple elements added to the end.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: A new list with the tuple elements added to the original list.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: A new list with the tuple elements appended to the original list.\n    \"\"\"\n    # Extend the list with the tuple elements\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the elements of the given tuple to the given list.\n\n    Args:\n    lst (list): The list to which elements of the tuple are to be added.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list with the elements of the tuple added.\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(tuples, k):\n    # Sort the list of tuples based on the second element (score) in ascending order\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records list by the second element (value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second element (the value)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n\n    Args:\n        records (list of tuples): List of tuples where each tuple contains a name and a number.\n        k (int): Number of records to return.\n\n    Returns:\n        list of tuples: Sorted list of k records with the smallest numbers.\n    \"\"\"\n    # Sort the records by the second element of the tuple (the number) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the list of tuples based on the second element (the value)\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples by the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples by the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the list of tuples by the second element (the number) in ascending order\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records by the second element (score) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the tuple list based on the second element of each tuple (the score)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records by the second element (the number) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element of the tuple (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the integer value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second element (value)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (score) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 84.31034482758622, "dps_norm": 86.25, "pass@1": 61.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize the result list\n    common_elements = []\n\n    # Iterate through the lists and check for common elements at each index\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the lists to avoid index out of range error\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate over the range of the minimum length\n    for i in range(min_length):\n        # Check if the element is common at index i\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate over the range of the shortest list's length\n    for i in range(min_length):\n        # Check if elements at the same index are equal in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to ensure we don't go out of bounds\n    min_len = min(len(l1), len(l2), len(l3))\n\n    common_elements = []\n\n    # Iterate through the indices up to the minimum length\n    for i in range(min_len):\n        # Check if the element is common at the current index\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate through the indices of the lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the element at index i is common in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements in l1, l2, and l3 that appear at the same index\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts elements that are common in the same index positions across three lists.\n\n    :param l1: First list\n    :param l2: Second list\n    :param l3: Third list\n    :return: List of common elements at the same index positions\n    \"\"\"\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate through the indices up to the minimum length\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function returns a list of elements that are common for all three lists at the same index.\n\n    Parameters:\n    l1 (list): List 1\n    l2 (list): List 2\n    l3 (list): List 3\n\n    Returns:\n    list: List of common elements\n    \"\"\"\n    common_elements = []\n    # Iterate through the lists by index\n    for index in range(min(len(l1), len(l2), len(l3))):\n        if l1[index] == l2[index] == l3[index]:\n            common_elements.append(l1[index])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length among the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate over the indices up to the minimum length\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Create a new list to store the common elements\n    common_elements = []\n\n    # Iterate over the range of the smallest list length to ensure no index out of range error\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate over the range of the minimum length\n    for i in range(min_length):\n        # Check if all three lists have the same element at index i\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    min_len = min(len(l1), len(l2), len(l3))\n    common_elements = []\n\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the length of the smallest list to avoid index out of range error\n    min_length = min(len(l1), len(l2), len(l3))\n\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists at the same index.\n\n    Parameters:\n    l1 (list): First list.\n    l2 (list): Second list.\n    l3 (list): Third list.\n\n    Returns:\n    list: List of common elements found at the same index in all three lists.\n    \"\"\"\n    # Ensure all lists are of the same length\n    min_length = min(len(l1), len(l2), len(l3))\n    l1 = l1[:min_length]\n    l2 = l2[:min_length]\n    l3 = l3[:min_length]\n\n    # Find common elements\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate through the indices of the shortest list\n    for i in range(min_length):\n        # Check if the element at index i is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Function to find common elements from three lists at the same index.\n\n    :param l1: First list\n    :param l2: Second list\n    :param l3: Third list\n    :return: List of common elements\n    \"\"\"\n    # Iterate through the indices of the lists\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Ensure all lists have the same length to safely compare indices\n    min_len = min(len(l1), len(l2), len(l3))\n    l1, l2, l3 = l1[:min_len], l2[:min_len], l3[:min_len]\n\n    # Find common elements\n    common_elements = []\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # We will use the zip function to iterate over lists together\n    # and collect common elements based on index\n    common_elements = []\n\n    # Use the min length list to avoid index out of range errors\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to hold the common elements\n    common_elements = []\n\n    # Find the minimum length among the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Iterate over the range of the minimum length\n    for i in range(min_length):\n        # Check if the elements at the same index are equal in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 50.0, "dps_norm": 75.0, "pass@1": 14.0, "profiled": [{"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None  # Return None if there are less than 2 elements\n\n    # Initialize first and second smallest to infinity\n    first = float('inf')\n    second = float('inf')\n\n    for num in nums:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    if second == float('inf'):\n        return None  # Return None if there isn't a second smallest distinct number\n\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None  # Less than 2 elements, no second smallest number\n\n    first, second = float('inf'), float('inf')\n\n    for num in nums:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None  # Not enough elements to find the second smallest\n    # Remove duplicates and sort the list\n    unique_nums = list(set(nums))\n    unique_nums.sort()\n    if len(unique_nums) < 2:\n        return None  # Not enough unique elements to find the second smallest\n    return unique_nums[1]  # Return the second smallest unique number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Handle the case where the list has less than two unique elements\n    if len(set(numbers)) < 2:\n        return None\n\n    # Remove duplicates and sort the list\n    unique_numbers = sorted(set(numbers))\n\n    # Return the second smallest number\n    return unique_numbers[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Check if the list has at least two unique elements\n    if len(set(numbers)) < 2:\n        return None  # Or raise an exception\n\n    # Initialize first and second smallest with infinity\n    first, second = float('inf'), float('inf')\n\n    for number in numbers:\n        if number < first:\n            second = first\n            first = number\n        elif number < second and number != first:\n            second = number\n\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(lst):\n    if len(lst) < 2:\n        return None  # Not enough elements to find the second smallest\n\n    # Initialize the first and second smallest as positive infinity\n    first_smallest = second_smallest = float('inf')\n\n    for number in lst:\n        if number < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = number\n        elif first_smallest < number < second_smallest:\n            second_smallest = number\n\n    if second_smallest == float('inf'):\n        return None  # No unique second smallest element\n    return second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Function to find the second smallest number in a list.\n\n    :param nums: List of numbers\n    :return: The second smallest number in the list or None if the list has less than 2 elements\n    \"\"\"\n    if len(nums) < 2:\n        return None\n\n    # Initialize the first and second smallest\n    first, second = float('inf'), float('inf')\n\n    for num in nums:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    # Remove duplicates to handle negative scenarios\n    unique_nums = list(set(nums))\n\n    # Ensure there are at least two unique numbers\n    if len(unique_nums) < 2:\n        return None  # or raise an exception if preferred\n\n    # Sort the list and return the second smallest element\n    unique_nums.sort()\n    return unique_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None  # Not enough elements to find the second smallest\n\n    first, second = float('inf'), float('inf')\n\n    for num in nums:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    # Check if there are less than 2 elements\n    if len(nums) < 2:\n        return None  # Return None if less than 2 elements\n\n    # Initialize the first and second smallest variables\n    first_min = float('inf')\n    second_min = float('inf')\n\n    # Iterate through the list to find the smallest and second smallest\n    for num in nums:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif first_min < num < second_min:\n            second_min = num\n\n    # Return the second smallest number or None if it doesn't exist\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(lst):\n    if len(lst) < 2:\n        return None  # Not enough elements to find second smallest\n    unique_sorted = sorted(set(lst))  # Remove duplicates and sort the list\n    return unique_sorted[1] if len(unique_sorted) >= 2 else None  # Return second smallest or None if not enough unique elements", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None\n\n    # Initialize the smallest and second smallest with infinity\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Find the second smallest number in a list.\n\n    :param nums: List of numbers\n    :return: Second smallest number or None if the list has less than two unique elements\n    \"\"\"\n    if len(set(nums)) < 2:\n        return None\n\n    unique_nums = sorted(set(nums))\n    return unique_nums[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(nums):\n    # Ensure there are at least two unique numbers\n    if len(set(nums)) < 2:\n        return None\n\n    # Initialize the first and second smallest variables\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n\n    # Iterate through the list\n    for num in nums:\n        if num < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = num\n        elif first_smallest < num < second_smallest:\n            second_smallest = num\n\n    return second_smallest", "matching_cluster_idx": 2}]}, "Mbpp/757": {"dps": 86.6822429906542, "dps_norm": 54.61538461538461, "pass@1": 52.0, "profiled": [{"solution": "def count_reverse_pairs(strings):\n    count = 0\n    length = len(strings)\n    for i in range(length):\n        for j in range(i + 1, length):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    reverse_map = {}\n    count = 0\n\n    for s in strings:\n        reverse_s = s[::-1]\n        if reverse_s in reverse_map:\n            count += reverse_map[reverse_s]\n        if s in reverse_map:\n            reverse_map[s] += 1\n        else:\n            reverse_map[s] = 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    reverse_map = {}\n    count = 0\n\n    for s in strings:\n        reversed_s = s[::-1]\n        if reversed_s in reverse_map:\n            count += reverse_map[reversed_s]\n        reverse_map[s] = reverse_map.get(s, 0) + 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    # Initialize a dictionary to store the count of each string\n    string_count = {}\n    # Initialize a variable to store the count of reverse pairs\n    reverse_pairs_count = 0\n\n    # Traverse each string in the input list\n    for string in strings:\n        # Reverse the current string\n        reversed_string = string[::-1]\n        # If the reversed string is in the dictionary, increment the reverse pair count\n        if reversed_string in string_count:\n            reverse_pairs_count += string_count[reversed_string]\n        # Increment the count of the current string in the dictionary\n        if string in string_count:\n            string_count[string] += 1\n        else:\n            string_count[string] = 1\n\n    return reverse_pairs_count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n\n    Args:\n    strings (list): List of strings.\n\n    Returns:\n    int: Number of reverse pairs.\n    \"\"\"\n    count = 0\n    reversed_strings = [s[::-1] for s in strings]\n\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == reversed_strings[j]:\n                count += 1\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def count_reverse_pairs(strings):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if is_reverse(strings[i], strings[j]):\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            if words[i] == words[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    reverse_map = {}\n    count = 0\n    for string in str_list:\n        reversed_string = string[::-1]\n        if reversed_string in reverse_map:\n            count += reverse_map[reversed_string]\n        reverse_map[string] = reverse_map.get(string, 0) + 1\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n    \"\"\"\n    reverse_map = {}\n    count = 0\n\n    for s in strings:\n        reverse_s = s[::-1]\n        if reverse_s in reverse_map:\n            count += reverse_map[reverse_s]\n        if s in reverse_map:\n            reverse_map[s] += 1\n        else:\n            reverse_map[s] = 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1] or strings[j] == strings[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"Count pairs of reverse strings in the given list.\"\"\"\n    reverse_dict = {}\n    count = 0\n\n    for s in strings:\n        reverse_s = s[::-1]\n        if reverse_s in reverse_dict:\n            count += reverse_dict[reverse_s]\n        reverse_dict[s] = reverse_dict.get(s, 0) + 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    reverse_map = {}\n\n    for string in strings:\n        reversed_string = string[::-1]\n        if reversed_string in reverse_map:\n            count += reverse_map[reversed_string]\n        if string in reverse_map:\n            reverse_map[string] += 1\n        else:\n            reverse_map[string] = 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Count pairs of reverse strings in the given string list.\n\n    Parameters:\n    strings (list): List of strings to be checked for reverse pairs.\n\n    Returns:\n    int: Count of pairs of reverse strings.\n    \"\"\"\n    reverse_map = {}\n    count = 0\n\n    for string in strings:\n        reversed_string = string[::-1]\n        if reversed_string in reverse_map:\n            count += reverse_map[reversed_string]\n        reverse_map[string] = reverse_map.get(string, 0) + 1\n\n    return count", "matching_cluster_idx": 12}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[j] == strings[i][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1] and strings[i][::-1] == strings[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 62.98262548262548, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    count_dict = defaultdict(int)\n\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        count_dict[tuple_sublist] += 1\n\n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        if t in count_dict:\n            count_dict[t] += 1\n        else:\n            count_dict[t] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    sublist_count = defaultdict(int)\n\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        sublist_count[tuple_sublist] += 1\n\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    sublist_count = defaultdict(int)\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        sublist_count[tuple_sublist] += 1\n    return dict(sublist_count)", "matching_cluster_idx": 4}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    # Use defaultdict to count occurrences\n    count_dict = defaultdict(int)\n\n    # Convert each sublist to a tuple and update the count\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        count_dict[sublist_tuple] += 1\n\n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # Convert each sublist to a tuple\n    tuples_list = [tuple(sublist) for sublist in lst]\n\n    # Count the occurrences of each tuple\n    count_dict = dict(Counter(tuples_list))\n\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    from collections import defaultdict\n\n    # Convert each list to a tuple and count occurrences\n    tuple_counts = defaultdict(int)\n    for sublist in lst:\n        tuple_counts[tuple(sublist)] += 1\n\n    # Convert the defaultdict to a regular dict\n    return dict(tuple_counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(main_list):\n    sublist_count = defaultdict(int)\n\n    for sublist in main_list:\n        tuple_sublist = tuple(sublist)\n        sublist_count[tuple_sublist] += 1\n\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Create a dictionary to store the count of each sublist as a tuple\n    sublist_count = {}\n\n    # Iterate over each sublist in the given list\n    for sublist in lst:\n        # Convert the sublist to a tuple and update the count in the dictionary\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        else:\n            sublist_count[tuple_sublist] = 1\n\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    This function takes a list of lists and returns a dictionary where each list is converted to a tuple.\n    The value of each tuple is the number of occurrences of that tuple in the original list.\n    \"\"\"\n    sublist_count = defaultdict(int)\n    for sublist in lst:\n        sublist_count[tuple(sublist)] += 1\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n\n    for sublist in lst:\n        tuple_rep = tuple(sublist)\n        if tuple_rep in sublist_count:\n            sublist_count[tuple_rep] += 1\n        else:\n            sublist_count[tuple_rep] = 1\n\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    # Create a dictionary to store tuple as key and count as value\n    sublist_counts = defaultdict(int)\n\n    for sublist in lst:\n        # Convert sublist to tuple and increment the count in the dictionary\n        sublist_counts[tuple(sublist)] += 1\n\n    return dict(sublist_counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(main_list):\n    # Initialize an empty dictionary to store the results\n    result = {}\n\n    # Iterate through each sublist in the main list\n    for sublist in main_list:\n        # Convert sublist to a tuple and store it in the dictionary, incrementing its count\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Create a dictionary to store the count of each unique sublist (converted to tuple)\n    sublist_count = {}\n\n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple and use it as the key\n        sublist_tuple = tuple(sublist)\n        # Increment the count of this tuple in the dictionary\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n\n    # Return the dictionary with the counts\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        else:\n            sublist_count[tuple_sublist] = 1\n\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    sublist_count = {}\n\n    # Convert each list to a tuple and count its occurrences\n    for sublist in input_list:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n\n    return sublist_count", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    # Use a list comprehension to iterate over the string and check for digit characters\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Parameters:\n    string (str): The input string to count digits in.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"Count the number of digits in a given string.\"\"\"\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    count = 0\n    for char in string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \"\"\"\n    return sum(char.isdigit() for char in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize a counter for digits\n    digit_count = 0\n    # Iterate through each character in the string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter\n            digit_count += 1\n    # Return the final count of digits\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize counter for digits\n    count = 0\n\n    # Loop through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    # Use a list comprehension to count numbers in the string\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"Count the number of digits in a given string.\"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Use a generator expression to count digits in the string\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 72.80373831775701, "dps_norm": 61.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Given a list, return a list of all pairs of consecutive items in the given list.\n\n    :param lst: List of elements\n    :return: List of tuples with consecutive elements from the input list\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Args:\n    lst (list): A list of elements.\n\n    Returns:\n    list: A list of tuples, where each tuple is a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # This function returns a list of pairs of consecutive items from the given list\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \"\"\"\n    if not lst:\n        return []\n\n    pairs = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return pairs", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Initialize an empty list to store pairs\n    pairs = []\n\n    # Iterate through the list up to the second last element\n    for i in range(len(lst) - 1):\n        # Append the pair of consecutive items to the pairs list\n        pairs.append((lst[i], lst[i + 1]))\n\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items in the list\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return pairs", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Initialize an empty list to hold the result\n    result = []\n\n    # Iterate through the list up to the second-to-last element\n    for i in range(len(lst) - 1):\n        # Append the tuple of consecutive elements to the result list\n        result.append((lst[i], lst[i + 1]))\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): List of elements.\n\n    Returns:\n    list: List of pairs of consecutive elements.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i + 1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n\n    Parameters:\n    lst (list): The input list of elements.\n\n    Returns:\n    list: A list of tuples containing pairs of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Initialize an empty list to hold the pairs\n    pairs = []\n\n    # Iterate through the list up to the second last element\n    for i in range(len(lst) - 1):\n        # Append the pair to the list of pairs\n        pairs.append((lst[i], lst[i + 1]))\n\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    input_list (list): The list to create pairs from.\n\n    Returns:\n    list: A list of tuples, each containing a pair of consecutive items.\n    \"\"\"\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Initialize an empty list to hold the pairs\n    pairs = []\n    # Iterate over the list up to the second-last element\n    for i in range(len(lst) - 1):\n        # Append the pair (current element, next element) to the pairs list\n        pairs.append((lst[i], lst[i + 1]))\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of pairs of consecutive items in the given list.\n\n    Args:\n    lst (list): A list of items.\n\n    Returns:\n    list: A list of tuples containing consecutive pairs from the input list.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list: A list of tuples where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    This function takes a list as input and returns a list of pairs of consecutive items from the input list.\n\n    :param lst: List of elements\n    :return: List of tuples representing consecutive pairs\n    \"\"\"\n    if not lst:  # Check if the input list is empty\n        return []\n\n    pairs = []\n    for i in range(len(lst) - 1):\n        pairs.append((lst[i], lst[i + 1]))\n\n    return pairs", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 88.63999999999999, "dps_norm": 65.71428571428572, "pass@1": 98.0, "profiled": [{"solution": "def odd_position(lst):\n    # Loop through the list, checking every other index (0, 2, 4, ...)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate through the list and check each element at odd indices (1, 3, 5, ...)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks if every element at odd indices (1, 3, 5, etc.) in the given list is odd.\n\n    :param lst: List of integers\n    :return: True if every element at odd indices is odd, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list with step 2 to access odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Function to check whether every odd index contains an odd number in a given list.\n\n    Args:\n    lst (list): List of integers to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index contains an odd number in the given list.\n\n    Args:\n    lst (list): The input list of numbers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, otherwise False.\n    \"\"\"\n    return all(num % 2 != 0 for idx, num in enumerate(lst) if idx % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"Check whether every odd index contains odd numbers of a given list.\"\"\"\n    # Iterate over the list using the range and step size of 2 to check the odd indices (1, 3, 5, ...)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            # If any value at an odd index is even, return False\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Loop through the list and check if every element at an odd index is odd\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # iterate over odd indices\n        if lst[i] % 2 == 0:  # check if number at odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in a given list.\n\n    Args:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):  # start at index 1 and step by 2\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index contains an odd number in a given list.\n\n    Parameters:\n    lst (list): List of integers.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n\n    Args:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    This function checks whether every odd index contains an odd number in a given list.\n\n    Parameters:\n    numbers (list of int): The list of numbers to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate through the list\n    for index, number in enumerate(numbers):\n        # Check if index is odd and number is not odd\n        if index % 2 == 1 and number % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is odd.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every element at an odd index in the given list is odd.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    bool: True if every element at an odd index is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Loop through the list and check if elements at odd indices are odd\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/781": {"dps": 87.8740157480315, "dps_norm": 48.0, "pass@1": 95.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns True if the count of divisors of n is even, otherwise it returns False.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function checks if the number of divisors of a given number `n` is even.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check if the count of divisors of n is even.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function returns True if the number of divisors of n is even, else it returns False.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function checks whether the count of divisors of a given number `n` is even.\n    \"\"\"\n    # Find all divisors of `n`\n    divisors = [i for i in range(1, n + 1) if n % i == 0]\n    # Check if the count of divisors is even\n    return len(divisors) % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, otherwise returns False.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function checks whether the count of divisors of a given number `n` is even.\n\n    Args:\n    n (int): A positive integer.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of n is even.\n\n    Args:\n    n (int): The number to count divisors for.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n\n    # Iterate through possible divisors from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    # Check if the count is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to count the number of divisors of a given number and return whether the count is even.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function takes an integer n and returns True if the number of divisors of n is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False  # Divisors are not defined for non-positive integers\n\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 97.83582089552239, "dps_norm": 99.0, "pass@1": 50.0, "profiled": [{"solution": "def remove_all_spaces(s: str) -> str:\n    # Using str.replace() to remove all whitespace characters\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string: str) -> str:\n    \"\"\"\n    This function removes all whitespaces from a given string.\n    \"\"\"\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from a string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    # Use the replace method to remove all spaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Using the replace method to remove all spaces from the string\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a string.\n\n    :param s: Input string\n    :return: String with all whitespaces removed\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(s: str) -> str:\n    # Use the replace method to remove all spaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    This function removes all whitespaces from a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Using the replace method to remove all whitespace characters\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Function to remove all whitespaces from a string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespace characters from a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with all whitespace characters removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a string.\n\n    Parameters:\n    s (str): The input string containing whitespaces.\n\n    Returns:\n    str: The string without any whitespaces.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace() method to remove all spaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    This function removes all whitespaces from the given string.\n\n    :param s: Input string\n    :return: String with all whitespaces removed\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from a given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Return the input string with all whitespaces removed\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 95.36082474226804, "dps_norm": 98.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    # Check if the input list is empty\n    if not lists:\n        return []\n\n    # Find the list with the maximum sum\n    max_list = max(lists, key=sum)\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the highest sum of elements\n    max_sum = -float('inf')\n    result = None\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result = lst\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lists):\n    # Initialize variables to keep track of the list with the maximum sum and its sum\n    max_sum = float('-inf')\n    max_list = None\n\n    # Iterate over each list in the list of lists\n    for lst in lst_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n\n        # Check if the current sum is greater than the maximum sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Check if the input list is empty\n    if not list_of_lists:\n        return []\n\n    # Initialize variables to keep track of the list with the highest sum\n    max_sum = float('-inf')\n    max_sum_list = []\n\n    # Iterate through each list in the list of lists\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n\n        # Update the max_sum and max_sum_list if the current list has a higher sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = sublist\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Function to calculate the sum of a list\n    def sum_of_list(sublist):\n        return sum(sublist)\n\n    # Initialize variables to track the sublist with the maximum sum\n    max_sum = float('-inf')\n    max_sum_sublist = None\n\n    # Iterate through the list of lists\n    for sublist in lst:\n        current_sum = sum_of_list(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_sublist = sublist\n\n    return max_sum_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the list with the maximum sum and the maximum sum found\n    max_sum_list = None\n    max_sum = float('-inf')\n\n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n\n        # If the current sum is greater than the maximum sum found so far, update the max_sum and max_sum_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = lst\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the list with the maximum sum and its sum\n    max_sum = float('-inf')\n    max_list = None\n\n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n\n        # Check if the current sum is greater than the maximum sum found so far\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the highest sum of elements\n    max_sum = float('-inf')\n    result = None\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result = lst\n    return result", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the list with the highest sum and its sum\n    max_sum = float('-inf')\n    max_sum_list = None\n\n    # Iterate over each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n\n        # Check if the current sum is greater than the previous max sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = lst\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Function to return the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    if not lists:\n        return []\n\n    max_sum = float('-inf')\n    max_list = []\n\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lists):\n    # Initialize variables\n    max_sum = float('-inf')\n    max_list = None\n\n    # Iterate over each sublist in the list of lists\n    for sublist in lst_of_lists:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n\n        # Update max_sum and max_list if current_sum is higher\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    if not lists_of_lists:\n        return []\n\n    # Find the list with the maximum sum of elements\n    max_sum = float('-inf')\n    max_list = None\n\n    for lst in lists_of_lists:\n        if sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Find the list with the maximum sum of its elements\n    max_list = max(list_of_lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize variables to keep track of the max sum and the corresponding list\n    max_sum = float('-inf')\n    max_sum_list = None\n\n    # Iterate over each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n\n        # If the current sum is greater than the max sum, update the max sum and the corresponding list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = lst\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = float('-inf')\n    result_list = None\n\n    for sub_list in list_of_lists:\n        current_sum = sum(sub_list)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result_list = sub_list\n\n    return result_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Parameters:\n    list_of_lists (list of lists): A list of lists containing integers.\n\n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    max_sum = float('-inf')\n    max_sum_list = None\n\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = lst\n\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists_of_lists):\n    max_sum = float('-inf')\n    max_list = None\n    for lst in lists_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    \"\"\"\n    Function to return the list in a list of lists whose sum of elements is the highest.\n\n    :param lists: List of lists\n    :return: List with the highest sum of elements\n    \"\"\"\n    if not lists:\n        return []\n\n    max_list = lists[0]\n    for lst in lists:\n        if sum(lst) > sum(max_list):\n            max_list = lst\n\n    return max_list", "matching_cluster_idx": 2}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=lambda x: sum(x))\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 96.53508771929825, "dps_norm": 99.16666666666667, "pass@1": 82.0, "profiled": [{"solution": "def check_K(tuples, k):\n    \"\"\"\n    Function to check if the given tuples contain the element 'k'.\n\n    Args:\n    tuples: A tuple of elements.\n    k: The element to check for.\n\n    Returns:\n    bool: True if 'k' is in the tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Checks if the tuple `t` contains the value `k`.\n\n    Parameters:\n    t (tuple): The tuple to search within.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if `k` is in `t`, False otherwise.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n        tuples (tuple): The input tuple to check.\n        k (int or any hashable type): The value to check for in the tuple.\n\n    Returns:\n        bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 4}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Function to check if the given tuple contains the value 'k'.\n\n    Args:\n    tuples (tuple): The tuple in which to search for the value.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if 'k' is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tuples (tuple): The tuple to check.\n    k: The value to find in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the given list of tuples contains the value k.\n\n    Args:\n        tuples (tuple): A tuple containing numbers.\n        k (int): The value to check for in the tuple.\n\n    Returns:\n        bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    # Check if the given element k is in the tuple\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    # Check if k is present in the tuple\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the given tuple contains the element k.\n\n    Args:\n    tuples: A tuple of elements to search through.\n    k: The element to check for.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    This function checks if the given tuple contains the number k or not.\n\n    Parameters:\n    - tuples: a tuple of integers\n    - k: an integer to check for\n\n    Returns:\n    - True if k is in the tuple, False otherwise\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the given tuples contain the value k.\n\n    Parameters:\n    tuples (tuple): A tuple of integers.\n    k (int): The value to check for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    :param tuples: The tuple to check.\n    :param k: The value to find.\n    :return: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tupl, k):\n    return k in tupl", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the given tuple contains the element k.\n\n    :param tuples: A tuple of integers.\n    :param k: The integer to check for in the tuple.\n    :return: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the element `k`.\n\n    Args:\n    tuples (tuple): The tuple to search within.\n    k: The element to search for.\n\n    Returns:\n    bool: True if `k` is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}]}}}
