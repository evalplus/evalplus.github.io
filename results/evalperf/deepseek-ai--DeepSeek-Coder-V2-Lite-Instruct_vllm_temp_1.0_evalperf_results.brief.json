{"date": "2024-10-19 16:31", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 82.81873138697289, "dps_norm": 78.09379634032757, "pass@1": 79.04237288135593}, "eval": {"HumanEval/9": {"dps": 72.3186119873817, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n\n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    rolling_max_list = [numbers[0]]\n    for num in numbers[1:]:\n        current_max = max(rolling_max_list[-1], num)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    rolling_max_list = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        rolling_max_list.append(current_max)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    rolling_max_list = [max_so_far]\n    \n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        rolling_max_list.append(max_so_far)\n    \n    return rolling_max_list", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 59.853121175030594, "dps_norm": 63.90977443609023, "pass@1": 19.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list first to make it easier to find close elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to make it easier to find close elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 74.01898734177215, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    mean = sum(numbers) / len(numbers)  # Calculate the mean\n    deviations = [abs(x - mean) for x in numbers]  # Calculate absolute deviations\n    mad = sum(deviations) / len(numbers)  # Calculate the mean of the deviations\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must contain at least one number.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # If the list is empty, return 0 to avoid division by zero\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean) for num in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(num - mean) for num in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    \n    mean = sum(numbers) / len(numbers)  # Calculate the mean\n    deviations = [abs(x - mean) for x in numbers]  # Calculate absolute deviations\n    mad = sum(deviations) / len(numbers)  # Calculate the mean of absolute deviations\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(num - mean) for num in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    \n    mean = sum(numbers) / len(numbers)  # Calculate the mean of the numbers\n    absolute_differences = [abs(x - mean) for x in numbers]  # Calculate absolute differences\n    mad = sum(absolute_differences) / len(numbers)  # Calculate the mean of the absolute differences\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:  # Check if the list is empty\n        return 0\n    \n    mean = sum(numbers) / len(numbers)  # Calculate the mean of the numbers\n    absolute_deviations = [abs(x - mean) for x in numbers]  # Calculate absolute deviations from the mean\n    mad = sum(absolute_deviations) / len(numbers)  # Calculate the mean of the absolute deviations\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean_value = sum(numbers) / len(numbers)\n    deviations = [abs(number - mean_value) for number in numbers]\n    mad = sum(deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 4}]}, "HumanEval/16": {"dps": 32.55813953488372, "dps_norm": 43.888888888888886, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate through each character in the string\n    for char in string:\n        # Add the character to the set of distinct characters\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate through each character in the string\n    for char in string:\n        # Add the character to the set of distinct characters\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_characters = set()\n    for char in string:\n        distinct_characters.add(char.lower())\n    return len(distinct_characters)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate over each character in the string\n    for char in string:\n        # Add the character to the set of distinct characters\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate over each character in the string and add it to the set\n    for char in string:\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    lower_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in lower_string:\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate over each character in the string\n    for char in string:\n        # Add the character to the set\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitive comparison\n    lower_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in lower_string:\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string_lower = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    for char in string_lower:\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate through each character in the string and add it to the set\n    for char in string:\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set()\n    # Iterate through each character in the string\n    for char in string:\n        # Add the character to the set of distinct characters\n        distinct_chars.add(char)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 3}]}, "HumanEval/20": {"dps": 84.21307506053269, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list to make it easier to find the closest elements\n    numbers.sort()\n    \n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n    \n    # Iterate through the list to find the closest pair\n    for i in range(len(numbers) - 1):\n        current_diff = abs(numbers[i + 1] - numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    numbers.sort()\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure that the closest elements are adjacent\n    numbers.sort()\n    \n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = numbers[1] - numbers[0]\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the numbers first\n    numbers.sort()\n    \n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list and find the pair with the smallest difference\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list\n    numbers.sort()\n    \n    # Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list and find the pair with the minimum difference\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list to find the closest elements easily\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list to easily find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the minimum difference and the pair of numbers\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two numbers.\")\n    \n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n    \n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list to find the closest elements efficiently\n    numbers.sort()\n    \n    # Initialize the smallest difference to a large value\n    smallest_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        current_diff = numbers[i + 1] - numbers[i]\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The input list must contain at least two elements.\")\n    \n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    for i in range(len(numbers) - 1):\n        current_diff = numbers[i + 1] - numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list to ensure the closest elements are adjacent\n    numbers.sort()\n    \n    # Initialize variables to store the minimum difference and the pair of numbers\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    # Sort the list to make it easier to find the closest pair\n    numbers.sort()\n    \n    # Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list and find the pair with the smallest difference\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    \n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the list to find the closest elements\n    numbers.sort()\n    \n    # Initialize variables to store the minimum difference and the pair of numbers\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the numbers\n    numbers.sort()\n    \n    # Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    # Sort the numbers to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the minimum difference and the pair of numbers\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n\n    # Initialize variables to store the smallest difference and the pair of numbers\n    smallest_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 91.56462585034015, "dps_norm": 58.75, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is 1, as 1 has no divisors smaller than itself", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"n must be greater than 1\")\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case the number is 1 or if the loop never finds a divisor (though 1 is not smaller than n)", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case the number is 1 or there's an error, though the problem assumes n > 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is 1, which doesn't have any smaller divisors than itself", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line is technically unreachable because every number has 1 as a divisor", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Return 1 for the case where n is 1 or if no divisors are found", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, should not reach here for n > 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If n is 1, the largest divisor is 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"n must be greater than 1\")\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case the number is 1, which has no divisors less than itself", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is 1, as 1 has no divisors other than 1 itself", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Return 1 for the smallest divisor if no other divisor is found", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case the number is 1 or if the loop never returns, return 1 as a fallback", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # n is a prime number", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case the number is 1, as it has no divisors smaller than itself", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is 1, there are no divisors smaller than n", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though not necessary if n > 1", "matching_cluster_idx": 3}]}, "HumanEval/26": {"dps": 96.4, "dps_norm": 98.75, "pass@1": 52.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    \n    for number in numbers:\n        if number in seen:\n            if number not in duplicates:\n                duplicates.add(number)\n                result.remove(number)  # Remove the last occurrence\n        else:\n            seen.add(number)\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    result = []\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    \n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    \n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    result = []\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    \n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    \n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    result = []\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    result = []\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        counts[number] = counts.get(number, 0) + 1\n    \n    return [number for number in numbers if counts[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 88.10126582278481, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 92.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these values\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace the values at indices divisible by 3 with the sorted values\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    third_elements.sort()\n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), third_elements):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    values_at_thirds = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort these values\n    values_at_thirds.sort()\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace values at indices divisible by 3 with sorted values\n    for i, value in zip(range(0, len(l), 3), values_at_thirds):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    third_elements.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), third_elements):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted values\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace values at indices divisible by 3 with sorted values\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    divisible_by_three.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, val in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = val\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    third_elements.sort()\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), third_elements):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort these elements\n    divisible_by_three.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace the elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_3.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_3):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted elements\n    divisible_by_three.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract the elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace the elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    evens = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    evens.sort()\n    # Create a new list with sorted even-indexed elements\n    sorted_list = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        sorted_list[i] = evens[even_index]\n        even_index += 1\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even-indexed elements\n    even_elements_sorted = sorted(even_elements)\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace even-indexed elements in the result with sorted elements\n    for i, value in zip(range(0, len(l), 2), even_elements_sorted):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements.sort()\n    \n    # Create a new list to hold the result\n    sorted_list = l[:]\n    # Replace the even-indexed elements with sorted ones\n    for i, value in enumerate(even_elements):\n        sorted_list[i * 2] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements.sort()\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace the elements at even indices with the sorted elements\n    for i, value in zip(range(0, len(l), 2), even_elements):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indexed elements\n    evens = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    evens.sort()\n    # Create a new list with sorted even indexed elements\n    sorted_list = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        sorted_list[i] = evens[even_index]\n        even_index += 1\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort even-indexed elements\n    even_elements.sort()\n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    sorted_list = l[:]\n    for i, value in zip(range(0, len(l), 2), even_elements):\n        sorted_list[i] = value\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = evens[even_index]\n        even_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    \n    # Sort the even-indexed elements\n    even_elements.sort()\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    sorted_list = l[:]\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            sorted_list[i] = even_elements[even_index]\n            even_index += 1\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed values\n    even_values = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the even-indexed values\n    even_values.sort()\n    # Create a new list to store the result\n    result = l[:]\n    # Replace even-indexed values in the result with sorted values\n    for i, value in zip(range(0, len(l), 2), even_values):\n        result[i] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace even-indexed elements in the result with sorted elements\n    for i, value in zip(range(0, len(l), 2), even_elements):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed values and sort them\n    even_values = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace even-indexed values in the result with the sorted values\n    for i, value in zip(range(0, len(l), 2), even_values):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_indices_values = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted values\n    even_indices_values.sort()\n    # Create a new list to store the result\n    sorted_list = l[:]\n    # Replace the elements at even indices with the sorted values\n    for i, value in enumerate(even_indices_values):\n        sorted_list[i * 2] = value\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even indexed values and sort them\n    even_values = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace the even indexed values in the result with the sorted values\n    for i, value in zip(range(0, len(l), 2), even_values):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even-indexed elements\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace the even-indexed elements in the result with the sorted ones\n    for i, value in zip(range(0, len(l), 2), even_elements_sorted):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements_sorted = sorted(even_elements)\n    # Create a new list to hold the result\n    result = l[:]\n    # Replace even-indexed elements in the result with sorted ones\n    for i, value in enumerate(even_elements_sorted):\n        result[i * 2] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list to hold the result\n    result = l[:]\n    \n    # Replace even-indexed elements in the result with the sorted ones\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = even_elements[even_index]\n        even_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(len(l)) if i % 2 == 0]\n    # Sort the extracted elements\n    even_elements_sorted = sorted(even_elements)\n    # Create a new list to store the result\n    result = l[:]\n    # Replace even-indexed elements with sorted ones\n    for i, value in enumerate(even_elements_sorted):\n        result[i * 2] = value\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed values and sort them\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed values\n    result = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = evens[even_index]\n        even_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    result = l[:]\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = evens[even_index]\n        even_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed values and sort them\n    evens = sorted([l[i] for i in range(len(l)) if i % 2 == 0])\n    \n    # Create a new list to store the result\n    result = l[:]\n    \n    # Replace even-indexed values with sorted ones\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result[i] = evens[even_index]\n            even_index += 1\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 78.3529411764706, "dps_norm": 92.0, "pass@1": 100.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n\n    power_of_two = 2 ** n\n    # Return the result modulo p\n    return power_of_two % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Calculate 2^n\n    power_of_two = 2**n\n    # Return the result modulo p\n    return power_of_two % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2^n modulo p\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Calculate 2^n\n    power_of_two = 2**n\n    # Return the modulo of the result\n    return power_of_two % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Calculate 2^n\n    power_of_two = 2 ** n\n    # Return the result modulo p\n    return power_of_two % p", "matching_cluster_idx": 2}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Calculate 2^n\n    power_of_two = 2**n\n    # Return the result modulo p\n    return power_of_two % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Calculate 2^n\n    power_of_two = 2 ** n\n    # Return the result modulo p\n    return power_of_two % p", "matching_cluster_idx": 2}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    # Find the intersection of both sets\n    intersection = set1.intersection(set2)\n    # Convert the intersection back to a sorted list\n    result = sorted(list(intersection))\n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection and convert back to list\n    common_elements = list(set1 & set2)\n    \n    # Sort the list and return\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection back to a sorted list\n    sorted_common = sorted(list(intersection))\n    return sorted_common", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    sorted_common_elements = sorted(common_elements)\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection and sort it\n    common_elements = sorted(list(set1 & set2))\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection and convert back to list to remove duplicates\n    common_elements = list(set1.intersection(set2))\n    \n    # Sort the list of common elements\n    common_elements.sort()\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    # Find the intersection and convert it back to a list\n    common_elements = list(set1.intersection(set2))\n    # Sort the list and return it\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for O(1) lookups\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and enable set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list to ensure sorted output\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    sorted_common_elements = sorted(common_elements)\n    \n    return sorted_common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection and convert it to a sorted list\n    common_elements = sorted(list(set1.intersection(set2)))\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection and convert it back to a sorted list\n    common_elements = sorted(list(set1 & set2))\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and enable set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection back to a sorted list\n    result = sorted(list(intersection))\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find common elements and remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements and remove duplicates\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find the intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection back to a sorted list to ensure sorted output\n    return sorted(list(intersection))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        return n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        return n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    return n if n > 1 else largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = None\n    \n    # Divide n by 2 until it's odd\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    return n if n > largest_factor else largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = i\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = i\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = i\n    while i * i <= n:\n        while n % i == 0:\n            largest_prime = i\n            n //= i\n        i += 1\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_prime = i\n    if n > 1:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        return n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_prime = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_prime = i\n    if n > largest_prime:\n        largest_prime = n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest prime factor\n    largest_factor = None\n    \n    # Divide n by 2 to remove all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 2, then it must be prime\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    largest_factor = i\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            largest_factor = i\n    if n > largest_factor:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 37.14285714285714, "dps_norm": 45.0, "pass@1": 96.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert to lowercase to make the function case-insensitive\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert to lowercase to make the function case-insensitive\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert to lowercase to make the function case-insensitive\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to make the function case-insensitive\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to make the function case-insensitive\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to make the function case-insensitive\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to make the function case-insensitive\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to make the function case-insensitive\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end of the word\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Normalize the string to lowercase\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:  # Check if 'y' is at the end\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 70.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    chars_lst1 = total_chars(lst1)\n    chars_lst2 = total_chars(lst2)\n    \n    if chars_lst1 < chars_lst2:\n        return lst1\n    elif chars_lst2 < chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Helper function to calculate the total number of characters in a list of strings\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    # Calculate the total number of characters for both lists\n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n    \n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def char_count(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = char_count(lst1)\n    count2 = char_count(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 91.68316831683168, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 == 1 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\"\"\"\n    return sum(value for index, value in enumerate(lst) if index % 2 != 0 and value % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to hit odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 (odd index) and step by 2\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to hit odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 (odd indices)\n        if lst[i] % 2 == 0:  # Check if the element is even\n            result += lst[i]\n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 1 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. Add the even elements that are at odd indices.\"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')  # Split the string into words\n    ordered_words = []\n\n    for word in words:\n        # Sort the characters in the word and join them back into a string\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    # Join the ordered words back into a single string with spaces\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    \n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Sort each word and join them back into a string\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string, maintaining spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Sort each word and join them back together\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string, maintaining spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    \n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort each word based on ASCII values\n    sorted_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    \n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort by rows first, then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort coordinates by rows in ascending order and columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort by rows in ascending order, then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for column_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort by row index first, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort by rows first, then by columns in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for column_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort by rows first in ascending order, then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row index ascending, then by column index descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by rows first, then by columns in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row index, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row index, then by column index in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by rows in ascending order, then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for column_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, column_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row index ascending, then by column index descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by rows in ascending order, then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for column_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, column_index))\n    \n    # Sort by rows first (ascending) and then by columns (descending)\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row index ascending, then by column index descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c, rotation):\n        if 'a' <= c <= 'z':\n            return chr(((ord(c) - ord('a') + rotation) % 26) + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr(((ord(c) - ord('A') + rotation) % 26) + ord('A'))\n        else:\n            return c\n\n    result = \"\"\n    for char in s:\n        result += rotate_char(char, 4)  # 2 * 2 = 4\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    encrypted_string = ''.join(rotate_char(c) for c in s)\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2  # Shift each letter by 4 places\n            if char.islower():\n                # Rotate the lowercase alphabet\n                encrypted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Rotate the uppercase alphabet\n                encrypted_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            result.append(encrypted_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                offset = ord('a')\n                shifted = (ord(char) - offset + 2 * 2) % 26\n                result.append(chr(offset + shifted))\n            else:\n                offset = ord('A')\n                shifted = (ord(char) - offset + 2 * 2) % 26\n                result.append(chr(offset + shifted))\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c, n):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + n) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + n) % 26 + ord('A'))\n        else:\n            return c\n    \n    encrypted_text = \"\"\n    for char in s:\n        encrypted_text += rotate_char(char, 4)  # 2 * 2 = 4\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c):\n        if c.isalpha():\n            offset = 65 if c.isupper() else 97\n            return chr((ord(c) - offset + 2 * 2) % 26 + offset)\n        return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr(((ord(c) - ord('a') + 2 * 2) % 26) + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr(((ord(c) - ord('A') + 2 * 2) % 26) + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def shift_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    encrypted_string = ''.join(rotate_char(c) for c in s)\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n    \n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n    \n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            return c\n\n    return ''.join(rotate_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_char(c, n):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + n) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + n) % 26 + ord('A'))\n        else:\n            return c\n\n    encrypted_text = ''\n    for char in s:\n        encrypted_text += rotate_char(char, 2 * 2)  # Rotate by 4 positions\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c, n):\n        if 'a' <= c <= 'z':\n            return chr((ord(c) - ord('a') + n) % 26 + ord('a'))\n        elif 'A' <= c <= 'Z':\n            return chr((ord(c) - ord('A') + n) % 26 + ord('A'))\n        else:\n            return c\n\n    encrypted_string = \"\"\n    for char in s:\n        encrypted_string += rotate_char(char, 2 * 2)  # Rotate by 4 positions\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    def rotate_char(c, n):\n        if c.isalpha():\n            ascii_offset = ord('a') if c.islower() else ord('A')\n            return chr((ord(c) - ascii_offset + n) % 26 + ascii_offset)\n        return c\n\n    rotation = 2 * 2  # Rotate by 2*2 = 4 places\n    encrypted_string = ''.join(rotate_char(c, rotation) for c in s)\n    return encrypted_string", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 85.75875486381324, "dps_norm": 57.91666666666667, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_unique_list = sorted(set(lst))\n    if len(sorted_unique_list) < 2:\n        return None\n    return sorted_unique_list[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted_lst = sorted(set(lst))\n    if len(unique_sorted_lst) < 2:\n        return None\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted_lst = sorted(set(lst))\n    if len(unique_sorted_lst) < 2:\n        return None\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted_list = sorted(set(lst))\n    if len(unique_sorted_list) < 2:\n        return None\n    return unique_sorted_list[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted_lst = sorted(set(lst))\n    if len(unique_sorted_lst) < 2:\n        return None\n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_lst = sorted(set(lst))\n    if len(sorted_lst) < 2:\n        return None\n    return sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    # Return the 2nd smallest element if it exists\n    return unique_sorted_lst[1] if len(unique_sorted_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    first_min = float('inf')\n    second_min = float('inf')\n    \n    for num in lst:\n        if num < first_min:\n            second_min = first_min\n            first_min = num\n        elif first_min < num < second_min:\n            second_min = num\n    \n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    sorted_unique_lst = sorted(set(lst))\n    return sorted_unique_lst[1] if len(sorted_unique_lst) > 1 else None", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 96.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits, odd_digits, odd_digits, odd_digits)\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds(s)\n        # Replace all occurrences of 'i' with the count of odd digits in the string\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    results = []\n    for s in lst:\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result_str = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        results.append(result_str)\n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds(s)\n        # Create the output string with the count of odd digits\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds_in_string(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, string in enumerate(lst):\n        odd_count_in_string = count_odds_in_string(string)\n        result.append(f\"the number of odd elements {odd_count_in_string}n the str{odd_count_in_string}ng {odd_count_in_string} of the {odd_count_in_string}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds_in_string(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds_in_string(s)\n        # Replace the number in the template string with the count of odd digits\n        result_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(result_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds(s)\n        # Replace all occurrences of 'i' with the count of odd digits in the string\n        replaced = s.replace('i', str(odd_count))\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds(s)\n        # Replace 'n' with 'odd' and 'd' with 'digits' to match the expected output format\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace all occurrences of 'i' with the number of odd digits\n        output_str = \"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\".format(odd_digits)\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for char in s if int(char) % 2 != 0)\n        output_str = f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds_in_string(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds_in_string(s)\n        replaced_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(replaced_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for idx, s in enumerate(lst):\n        odd_count = count_odds(s)\n        # Replace the number with the count of odd digits in the string\n        new_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(new_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds_in_string(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds_in_string(s)\n        # Create the replacement string with the count of odd digits\n        replacement = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(replacement)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds_in_string(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odds_in_string(s)\n        # Replace all occurrences of 'i' with the count of odd digits in the string\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 62.7906976744186, "dps_norm": 92.0, "pass@1": 96.0, "profiled": [{"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n\n    # Check all possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'\ndef is_balanced(s):\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Concatenate the two strings in both possible orders\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    # Check if either combined string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    return 'Yes' if is_balanced(combined1) or is_balanced(combined2) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check all possible concatenations\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n\n    # Check if concatenating both strings in any order can result in a balanced string\n    for order in [s1 + s2, s2 + s1]:\n        balance = 0\n        is_good = True\n        for char in order:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                is_good = False\n                break\n        if is_good and balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check all possible concatenations\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    s1, s2 = lst\n\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check all combinations\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check all possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Helper function to check if a single string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False  # More closing than opening\n        return balance == 0\n\n    # Concatenate the two strings in both possible orders and check if either is balanced\n    s1, s2 = lst\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try concatenating in both orders\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_good(s1 + s2) or is_good(s2 + s1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Helper function to check if a single string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try concatenating the strings in both possible orders\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 3}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 22.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Return the first k elements from the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the first k elements from the sorted array\n    max_k_elements = sorted_arr[:k]\n    # Sort the result in ascending order before returning\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the top k elements\n    top_k = sorted_arr[:k]\n    # Return the sorted list\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr_sorted = sorted(arr, reverse=True)\n    return sorted(arr_sorted[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr_sorted = sorted(arr, reverse=True)\n    return sorted(arr_sorted[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr_sorted = sorted(arr, reverse=True)\n    return sorted(arr_sorted[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Return the first k elements from the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the first k elements from the sorted array\n    max_k_elements = sorted_arr[:k]\n    # Sort the result to ensure the output is in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)  # Sort the array in descending order\n    return sorted(arr[:k])  # Return the first k elements sorted in ascending order", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    arr_sorted = sorted(arr, reverse=True)\n    return sorted(arr_sorted[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    arr_sorted = sorted(arr, reverse=True)\n    # Get the first k elements from the sorted array\n    max_k_elements = arr_sorted[:k]\n    # Return the sorted list of maximum k elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    arr.sort(reverse=True)\n    return sorted(arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the first k elements from the sorted array\n    max_k_elements = sorted_arr[:k]\n    # Return the sorted list of maximum k numbers\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the first k elements from the sorted array\n    max_k_elements = sorted_arr[:k]\n    # Sort the result in ascending order before returning\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Return the first k elements of the sorted array\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    # Get the top k elements\n    top_k = sorted_arr[:k]\n    # Return the sorted list of maximum k numbers\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    arr.sort(reverse=True)  # Sort the array in descending order\n    return sorted(arr[:k])  # Return the first k elements sorted in ascending order", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 92.51121076233184, "dps_norm": 70.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the number is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total += lst[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    sum_odd = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            sum_odd += lst[i]\n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    sum_odd_in_even_positions = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            sum_odd_in_even_positions += lst[i]\n    return sum_odd_in_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_of_odds = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            sum_of_odds += lst[i]\n    return sum_of_odds", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    sum_odd_in_even_positions = 0\n    for i in range(0, len(lst), 2):  # Iterate over even indices\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            sum_odd_in_even_positions += lst[i]\n    return sum_odd_in_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total_sum = 0\n    for i in range(0, len(lst), 2):  # Iterate over even positions\n        if lst[i] % 2 != 0:  # Check if the element is odd\n            total_sum += lst[i]\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length first, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 97.79661016949153, "dps_norm": 98.75, "pass@1": 71.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    A non-prime number has more than two distinct positive divisors: 1 and itself.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Multiples of 2 and 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function returns True if the number is not prime, otherwise False.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    if n % 2 == 0 or n % 3 == 0:\n        return True  # Numbers divisible by 2 or 3 are not prime\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True  # Numbers divisible by i or i+2 are not prime\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    # This is checked so that we can skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n\n    # This is checked so that we can skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if the number is not prime, otherwise False.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    A non-prime number has more than two distinct positive divisors: 1 and itself.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n\n    # This is to skip middle five check in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Parameters:\n    n (int): The number to check\n    \n    Returns:\n    bool: True if n is not prime, False otherwise\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    \n    :param n: int - The number to check\n    :return: bool - True if n is not prime, False otherwise\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    # This is to skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n\n    Args:\n    n (int): The number to check for primality.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    # Handle edge cases: numbers less than 2 are not prime\n    if n < 2:\n        return True\n    # Only need to check up to the square root of n for factors\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    A non-prime number is defined as a number that has divisors other than 1 and itself.\n    The function returns True if the number is not prime, and False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    # This is to skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Checks if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not prime.\n    A non-prime number has more than two distinct positive divisors: 1 and itself.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n <= 3:\n        return False  # 2 and 3 are prime numbers\n    \n    # This is to skip middle five numbers in below loop\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 56.0, "profiled": [{"solution": "def heap_queue_largest(numbers, n):\n    if n <= 0:\n        return []\n    from heapq import nlargest\n    largest_numbers = nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    if n <= 0:\n        return []\n    from heapq import nlargest\n    largest_numbers = nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n should be less than or equal to the length of the list\")\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n_elements = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return sorted(largest_n_elements, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    import heapq\n    if n > len(numbers):\n        raise ValueError(\"n should be less than or equal to the length of the list.\")\n    largest_n = heapq.nlargest(n, numbers)\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n should be less than or equal to the length of the list\")\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    largest_numbers.sort(reverse=True)\n    \n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        return []\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n    \n    # Use heapq.nlargest to get the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Since heapq.nlargest returns a list, we don't need to reverse it\n    # to get descending order as it is already in descending order\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    if n == 0:\n        return []\n    from heapq import nlargest\n    largest_numbers = nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n should be less than or equal to the length of the list\")\n    \n    # Use a min-heap to keep track of the n largest numbers\n    import heapq\n    heap = []\n    \n    for number in numbers:\n        if len(heap) < n:\n            heapq.heappush(heap, number)\n        else:\n            if number > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, number)\n    \n    # The heap contains the n largest numbers, but they are in ascending order\n    # We can reverse it to get the numbers in descending order\n    return sorted(heap, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n <= 0:\n        return []\n    if n > len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    # Return the result in descending order\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n <= 0:\n        return []\n    if n > len(numbers):\n        return sorted(numbers, reverse=True)\n    \n    # Use heapq.nlargest to get the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n    largest = heapq.nlargest(n, numbers)\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n <= 0:\n        return []\n    # Use heapq.nlargest to get the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the list.\")\n    \n    from heapq import nlargest\n    \n    largest_numbers = nlargest(n, numbers)\n    return sorted(largest_numbers, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n <= 0:\n        return []\n    # Use heapq.nlargest to get the n largest elements from the list\n    largest_numbers = heapq.nlargest(n, numbers)\n    # Sort the result in descending order\n    largest_numbers.sort(reverse=True)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the list.\")\n    \n    # Use heapq.nlargest to get the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Return the result in descending order\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    if n > len(numbers):\n        raise ValueError(\"n cannot be greater than the length of the list\")\n    \n    # Use heapq.nlargest to get the n largest elements\n    largest_n = heapq.nlargest(n, numbers)\n    \n    # Since heapq.nlargest returns a list, we don't need to sort it again\n    return largest_n", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 66.83673469387755, "dps_norm": 54.5, "pass@1": 75.0, "profiled": [{"solution": "def find_Rotations(s):\n    n = len(s)\n    original_string = s\n    s = s + s  # Concatenate the string with itself to facilitate checking all rotations\n    for i in range(1, n):\n        if s[i:i+n] == original_string:\n            return i\n    return n  # If no rotation matches, the string is already a single rotation", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # The length of the string\n    n = len(s)\n    # Iterate through all possible rotations\n    for i in range(1, n):\n        # Check if the current rotation is the same as the original string\n        if s == s[i:] + s[:i]:\n            return i\n    # If no rotation matches, the string does not rotate to itself\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    original = s\n    s = s + s  # Concatenate string with itself\n    n = len(original)\n    for i in range(1, n):\n        # Check if the substring starting at index i is equal to the original string\n        if s[i:i+n] == original:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    original_string = s\n    s = s + s  # Concatenate the string with itself\n    n = len(original_string)\n    \n    # Check for each rotation\n    for i in range(1, n):\n        # Extract string of length equal to the original string from the doubled string\n        rotated_string = s[i:i+n]\n        # If the rotated string matches the original string, return the rotation count\n        if rotated_string == original_string:\n            return i\n    return n  # If no rotation matches, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # The function checks all rotations from 1 to len(s) - 1 and returns the smallest number of rotations\n    # that results in the original string.\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Function to find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # The string itself is always a rotation of itself\n    n = len(s)\n    # Try every rotation starting from 1 to n-1\n    for i in range(1, n):\n        # Check if the current rotation is the same as the original string\n        if s[:i] == s[n-i:] and s[i:] == s[:n-i]:\n            return i\n    # If no rotation matches, return the length of the string (this case is not expected in the problem statement)\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # The minimum number of rotations to get the same string is the length of the string\n    # divided by the smallest number that divides the length of the string without a remainder\n    # where the rotated string equals the original string.\n    n = len(s)\n    for i in range(1, n):\n        if n % i == 0:\n            rotated = s[i:] + s[:i]\n            if rotated == s:\n                return i\n    return n", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # The length of the string\n    n = len(s)\n    # Iterate over all possible rotations\n    for i in range(1, n):\n        # Check if the current rotation is the same as the original string\n        if s == s[i:] + s[:i]:\n            # Return the number of rotations\n            return i\n    # If no rotation is found, return the length of the string (which means no rotation)\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Check all rotations\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    original_string = s\n    s = s + s\n    for i in range(1, n):\n        rotated_string = s[i:i + n]\n        if rotated_string == original_string:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # The string will have the same substring if it is a rotation of itself\n    # We check for each possible rotation if it's equal to the original string\n    for i in range(1, len(s)):\n        if s == s[i:] + s[:i]:\n            return i\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    original_string = s\n    s = s + s  # Concatenate the string with itself\n    n = len(original_string)\n    for i in range(1, n):\n        substring = s[i:i+n]\n        if substring == original_string:\n            return i\n    return n  # In case no rotation matches, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    original = s\n    s = s + s  # Concatenate the string to itself\n    n = len(original)\n    for i in range(1, n):\n        if s[i:i+n] == original:\n            return i\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # The string itself is always a rotation of itself\n    rotations = 1\n    # Start checking for rotations\n    while rotations < len(s):\n        # Check if the rotated string is the same as the original\n        if s == s[rotations:] + s[:rotations]:\n            return rotations\n        rotations += 1\n    # If no rotation matches, return the length of the string (not greater than 0)\n    return len(s)", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    original_str = s\n    s = s + s  # Concatenate the string with itself\n    n = len(original_str)\n    \n    for i in range(1, n):\n        rotated_str = s[i:i+n]\n        if rotated_str == original_str:\n            return i\n    return n", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 53.0, "profiled": [{"solution": "def remove_Occ(s, c):\n    if len(s) == 0 or c not in s:\n        return s\n    \n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    \n    if first_index == -1 or last_index == -1:\n        return s\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if char not in s:\n        return s\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    else:\n        return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if char not in string:\n        return string\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if char not in s:\n        return s\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    if len(s) == 0 or c not in s:\n        return s\n    \n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    \n    if first_index == -1 or last_index == -1:\n        return s\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if len(string) == 0 or char not in string:\n        return string\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    if first_index == last_index:\n        return string.replace(char, '')\n    else:\n        return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if len(string) == 0 or char not in string:\n        return string\n    \n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    \n    if first_occurrence == -1 or last_occurrence == -1:\n        return string\n    \n    return string[:first_occurrence] + string[first_occurrence + 1:last_occurrence] + string[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if char not in string:\n        return string\n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if char not in s:\n        return s\n    \n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    if not s or c not in s:\n        return s\n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    if ch in s:\n        first_index = s.find(ch)\n        last_index = s.rfind(ch)\n        return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    else:\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if len(s) < 2:\n        return s.replace(char, '')\n    \n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    if first_index == -1:\n        return s\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if char not in string:\n        return string\n    \n    first_index = string.find(char)\n    last_index = string.rfind(char)\n    \n    if first_index == last_index:\n        # If the character is only present once, remove it.\n        return string[:first_index] + string[first_index+1:]\n    else:\n        # Remove the first and last occurrence of the character.\n        return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if char not in s:\n        return s\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if char not in s:\n        return s\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    if char not in s:\n        return s\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    if ch not in s:\n        return s\n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    if c not in s:\n        return s\n    first_index = s.find(c)\n    last_index = s.rfind(c)\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if not string or not char:\n        return string\n    \n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    \n    if first_occurrence == -1:\n        return string\n    \n    if first_occurrence == last_occurrence:\n        return string[:first_occurrence] + string[first_occurrence + 1:]\n    \n    return string[:first_occurrence] + string[first_occurrence + 1:last_occurrence] + string[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    if c in s:\n        first_index = s.find(c)\n        last_index = s.rfind(c)\n        return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n    else:\n        return s", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of the rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=lambda row: sum(row))\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of the rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix rows based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=lambda row: sum(row))\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of the rows\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/19": {"dps": 92.92929292929293, "dps_norm": 96.0, "pass@1": 99.0, "profiled": [{"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to check if an array contains any duplicates.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to check if there are any duplicates in the list.\n    Returns True if there are duplicates, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(numbers):\n    seen = set()\n    for number in numbers:\n        if number in seen:\n            return True\n        seen.add(number)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 98.5, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function finds and returns the smallest number in a list.\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Returns the smallest number in a list.\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:  # Check if the list is empty\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    This function returns the smallest number in a list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, and returns a list of tuples\n    where all elements are divisible by k.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    def is_divisible_by_k(tup):\n        return all(x % k == 0 for x in tup)\n    \n    return [tup for tup in tuples_list if is_divisible_by_k(tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    def divisible_by_k(tup):\n        return all(x % k == 0 for x in tup)\n\n    return [tup for tup in tuples_list if divisible_by_k(tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples containing integers\n    :param k: Integer divisor\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n    \n    :param tuples_list: List of tuples\n    :param k: Integer divisor\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency = {}\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for num in numbers:\n        if num in frequency_dict:\n            frequency_dict[num] += 1\n        else:\n            frequency_dict[num] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency = {}\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 77.75609756097562, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    if not words:  # Check if the list is empty\n        return 0\n    longest_word = max(words, key=len)  # Find the longest word using the `max` function with `key=len`\n    return len(longest_word)  # Return the length of the longest word", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    longest_word_length = 0\n    for word in words:\n        if len(word) > longest_word_length:\n            longest_word_length = len(word)\n    return longest_word_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    longest = \"\"\n    for word in words:\n        if len(word) > len(longest):\n            longest = word\n    return len(longest)", "matching_cluster_idx": 4}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    longest_word_length = len(words[0])\n    for word in words:\n        if len(word) > longest_word_length:\n            longest_word_length = len(word)\n    return longest_word_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    longest_length = max(len(word) for word in words)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    longest = 0\n    for word in words:\n        if len(word) > longest:\n            longest = len(word)\n    return longest", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize the maximum length of a word\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update the maximum length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    max_length = len(words[0])\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 80.2439024390244, "dps_norm": 64.0, "pass@1": 68.0, "profiled": [{"solution": "def index_minimum(tuples_list):\n    # Initialize variables to store the smallest tuple and its index\n    smallest_tuple = None\n    smallest_value = float('inf')\n    \n    # Iterate over the list of tuples\n    for item in tuples_list:\n        # Check if the current tuple's second value is smaller than the smallest found so far\n        if item[1] < smallest_value:\n            smallest_value = item[1]\n            smallest_tuple = item\n    \n    # Return the first value of the tuple with the smallest second value\n    return smallest_tuple[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples_list):\n    # Use the min function with a key to find the tuple with the smallest second value\n    # Then return the first value of that tuple\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Use the min function with a key to find the tuple with the smallest second value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Use the min function with a key to find the tuple with the smallest second value\n    # Then return the first value of that tuple\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Initialize the minimum value to a large number\n    min_value = float('inf')\n    # Initialize the result to an empty string\n    result = \"\"\n    \n    # Iterate through each tuple in the list\n    for item in tuples_list:\n        # Check if the current tuple's second value is less than the current min_value\n        if item[1] < min_value:\n            # Update the min_value and result with the current tuple's second value and first value\n            min_value = item[1]\n            result = item[0]\n    \n    # Return the first value of the tuple with the smallest second value\n    return result", "matching_cluster_idx": 4}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 97.49999999999999, "dps_norm": 97.85714285714286, "pass@1": 94.0, "profiled": [{"solution": "def divisor(n):\n    if n <= 0:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    divisors_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_count += 1\n            if i != n // i:\n                divisors_count += 1\n    \n    return divisors_count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    if n <= 0:\n        return 0  # There are no divisors for non-positive integers\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    divisors_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_count += 1\n            if i != n // i:\n                divisors_count += 1\n    return divisors_count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    This function returns the number of divisors of a given integer.\n    \"\"\"\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    This function returns the number of divisors of a given integer n.\n    \"\"\"\n    if n <= 0:\n        return 0  # No divisors for non-positive numbers\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0  # No divisors for negative numbers or zero\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    This function finds the number of divisors of a given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    divisors_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_count += 1\n            if i != n // i:\n                divisors_count += 1\n    return divisors_count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    This function calculates the number of divisors of a given integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    divisors_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_count += 1\n            if i != n // i:\n                divisors_count += 1\n    return divisors_count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n <= 0:\n        return 0  # There are no divisors for non-positive integers\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    divisors_count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_count += 1\n            if i != n // i:\n                divisors_count += 1\n    return divisors_count", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 99.67521367521368, "dps_norm": 88.125, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency = {}\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(lst_of_lsts):\n    flattened_list = list(chain.from_iterable(lst_of_lsts))\n    frequency_dict = dict(Counter(flattened_list))\n    return frequency_dict", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    # Count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    # Count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    # Count the frequency of each element\n    frequency_dict = Counter(flattened_list)\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    from collections import Counter\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Count the frequency of each element\n    frequency_dict = dict(Counter(flat_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency = {}\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\nfrom itertools import chain\ndef frequency_lists(list_of_lists):\n    frequency_dict = defaultdict(int)\n    for element in chain.from_iterable(list_of_lists):\n        frequency_dict[element] += 1\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    frequency_dict = dict(Counter(flattened_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    from collections import defaultdict\n    \n    frequency_dict = defaultdict(int)\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Count the frequency of each element\n    for item in flattened_list:\n        frequency_dict[item] += 1\n    \n    return dict(frequency_dict)", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 75.84415584415585, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tp):\n    return tp + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tp):\n    return tp + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 96.02409638554217, "dps_norm": 99.54545454545455, "pass@1": 50.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    merged_list = []\n    for lst in lists:\n        merged_list.extend(lst)\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the list of lists and sort the combined list\n    combined_list = []\n    for lst in lists:\n        combined_list.extend(lst)\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the lists into one single list\n    merged_list = []\n    for lst in lists:\n        merged_list.extend(lst)\n    \n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the list of lists and convert to a single list\n    flat_list = [item for sublist in lists for item in sublist]\n    # Sort the flattened list\n    flat_list.sort()\n    return flat_list", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    # Flatten the list of lists and convert it to a single list\n    merged_list = []\n    for lst in lists:\n        merged_list.extend(lst)\n    \n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    merged_list = []\n    for lst in lists:\n        merged_list.extend(lst)\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 77.95384615384616, "dps_norm": 81.875, "pass@1": 62.0, "profiled": [{"solution": "def common_in_nested_lists(lists):\n    if not lists:\n        return []\n    common_elements = set(lists[0])\n    for lst in lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the rest of the lists and update the common_set\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    # Return the common elements as a sorted list (though sets are unordered, this is for consistency with the assertion)\n    return sorted(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the rest of the lists and update the common_set\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    if not lists:\n        return set()\n    \n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the remaining lists and update the common set\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Flatten the nested lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Create a set of the first list for comparison\n    common_elements = set(lists[0])\n    \n    # Iterate over the remaining lists and update the common elements\n    for lst in lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return common_elements", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef common_in_nested_lists(lists: List[List[int]]) -> List[int]:\n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in lists[1:]:\n        # Update the common_set with the intersection of the current set and the next list\n        common_set.intersection_update(lst)\n    \n    # Convert the result back to a list before returning\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return set()\n    \n    # Convert the first list to a set for comparison\n    common_set = set(nested_lists[0])\n    \n    # Iterate over the rest of the lists and update the common_set with intersection\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert all lists to sets to remove duplicates and allow for set operations\n    sets = [set(lst) for lst in lists]\n    \n    # Use intersection to find common elements across all sets\n    common_elements = set.intersection(*sets)\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for initial comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the rest of the lists and update the common_set\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for fast lookup\n    common_set = set(lists[0])\n    \n    # Iterate over the remaining lists and update the common_set with intersection\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for initial comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the rest of the lists\n    for lst in lists[1:]:\n        # Update the common_set to include only elements that are also in the current list\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    if not nested_lists:\n        return []\n    \n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common set with the intersection of the current common set and the current list\n        common_set.intersection_update(lst)\n    \n    # Return the sorted list of common elements\n    return sorted(list(common_set))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    if not lists:\n        return set()\n    \n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the remaining lists and update the common_set\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert all lists to sets to remove duplicates within each list and enable set operations\n    sets = [set(lst) for lst in lists]\n    \n    # Find the intersection of all sets to get the common elements\n    common_elements = set.intersection(*sets)\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return set()\n\n    # Convert the first list into a set for efficient comparison\n    common_set = set(nested_lists[0])\n\n    # Iterate through the rest of the lists and update the common_set\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n\n    return common_set", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(lists: List[List[int]]) -> List[int]:\n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the remaining lists and update the common_set with their elements\n    for lst in lists[1:]:\n        common_set.intersection_update(lst)\n    \n    # Convert the result back to a list and sort it (optional, as per the assert statement)\n    return sorted(list(common_set))", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    if not lists:\n        return set()\n    \n    # Initialize the common set with the first list\n    common = set(lists[0])\n    \n    # Iterate over the rest of the lists and update the common set\n    for lst in lists[1:]:\n        common &= set(lst)\n    \n    return common", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert all lists to sets for efficient comparison\n    sets = [set(lst) for lst in lists]\n    \n    # Find the intersection of all sets\n    common_elements = set.intersection(*sets)\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for efficient comparison\n    common_set = set(lists[0])\n    \n    # Iterate over the rest of the lists\n    for lst in lists[1:]:\n        # Update the common_set with the intersection of current common_set and current list\n        common_set.intersection_update(lst)\n    \n    return common_set", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Flatten the nested lists into a single list\n    flat_list = [item for sublist in nested_lists for item in sublist]\n    \n    # Find the common elements using set intersection\n    common_elements = set(flat_list)\n    for lst in nested_lists:\n        common_elements &= set(lst)\n    \n    return common_elements", "matching_cluster_idx": 3}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            sum_amicable += a + b\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(num):\n    \"\"\"Sum all amicable numbers from 1 to num.\"\"\"\n    sum_amicable = 0\n    for a in range(2, num + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(number):\n    \"\"\"Sum all amicable numbers from 1 to a specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(2, number + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            sum_amicable += a + b\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Helper function to calculate the sum of divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Function to sum all amicable numbers from 1 to a specified number.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of all divisors of n.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    sum_amicable = 0\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of all proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to a specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Compute the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to a specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            sum_amicable += a + b\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            sum_amicable += a + b\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    sum_div = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_div += i\n            if i != n // i:\n                sum_div += n // i\n    return sum_div\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to a specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Helper function to calculate the sum of divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Function to calculate the sum of all amicable numbers from 1 to a specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to a specified number.\"\"\"\n    sum_amicable = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    sum_divisors = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum_divisors += i\n            if i != n // i:\n                sum_divisors += n // i\n    return sum_divisors\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified number.\"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n    \n    Args:\n    n (int): The minimum length of words to be considered.\n    text (str): The input text from which to extract words.\n    \n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 57.0, "profiled": [{"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(my_square[0])\n\n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the primary diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    # Calculate the size of the matrix\n    n = len(my_matrix)\n    \n    # Calculate the sum of the first row\n    magic_sum = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    size = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n\n    # Check sums of rows\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of columns\n    for col in range(size):\n        if sum(my_matrix[row][col] for row in range(size)) != magic_sum:\n            return False\n\n    # Check sum of primary diagonal\n    if sum(my_matrix[i][i] for i in range(size)) != magic_sum:\n        return False\n\n    # Check sum of secondary diagonal\n    if sum(my_matrix[i][size - i - 1] for i in range(size)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_square[0])\n    \n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_list):\n    size = len(my_list)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_list[0])\n\n    # Check the sum of each row\n    for row in my_list:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(size):\n        if sum(my_list[row][col] for row in range(size)) != magic_sum:\n            return False\n\n    # Check the sum of the primary diagonal\n    if sum(my_list[i][i] for i in range(size)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(my_list[i][size - i - 1] for i in range(size)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    # Calculate the sum of the first row to use as a reference\n    magic_constant = sum(my_square[0])\n    \n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n-i-1] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n\n    # Check sums of rows\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of columns\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of main diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of secondary diagonal\n    if sum(my_matrix[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    magic_sum = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n-1-i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    magic_sum = sum(my_square[0])\n    \n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(my_square[0])\n    \n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    \n    # Calculate the sum of the first row\n    sum_base = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for i in range(1, n):\n        if sum(my_matrix[i]) != sum_base:\n            return False\n    \n    # Check the sum of each column\n    for i in range(n):\n        if sum(my_matrix[j][i] for j in range(n)) != sum_base:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != sum_base:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != sum_base:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_matrix[0])\n    \n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][n-i-1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    size = len(my_matrix)\n    # Calculate the sum of the first row to use as a comparison\n    magic_sum = sum(my_matrix[0])\n\n    # Check the sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(size):\n        if sum(my_matrix[row][col] for row in range(size)) != magic_sum:\n            return False\n\n    # Check the sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(size)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(my_matrix[i][size - i - 1] for i in range(size)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_matrix):\n    n = len(my_matrix)\n    magic_constant = sum(my_matrix[0])\n\n    # Check sum of each row\n    for row in my_matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check sum of each column\n    for col in range(n):\n        if sum(my_matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n\n    # Check sum of the primary diagonal\n    if sum(my_matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(my_matrix[i][n - i - 1] for i in range(n)) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    magic_sum = sum(my_square[0])\n    \n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the primary diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    # Calculate the sum of the first row\n    magic_sum = sum(my_square[0])\n\n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the primary diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(my_square):\n    n = len(my_square)\n    \n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(my_square[0])\n    \n    # Check the sum of each row\n    for row in my_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(my_square[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(my_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(my_square[i][n-1-i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 78.41928251121077, "dps_norm": 70.83333333333334, "pass@1": 75.0, "profiled": [{"solution": "def max_occurrences(numbers):\n    frequency = {}\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    max_occur = max(frequency.values())\n    for number, count in frequency.items():\n        if count == max_occur:\n            return number", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    if not lst:\n        return None  # Handle the case of an empty list\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_item = max(frequency_dict, key=frequency_dict.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    frequency_dict = {}\n    for number in numbers:\n        if number in frequency_dict:\n            frequency_dict[number] += 1\n        else:\n            frequency_dict[number] = 1\n    max_frequency = max(frequency_dict.values())\n    for number, freq in frequency_dict.items():\n        if freq == max_frequency:\n            return number", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    if not numbers:\n        return None\n    \n    frequency = {}\n    for number in numbers:\n        frequency[number] = frequency.get(number, 0) + 1\n    \n    max_occurrence = max(frequency.values())\n    for number, count in frequency.items():\n        if count == max_occurrence:\n            return number", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    frequency_counter = Counter(lst)\n    max_freq = max(frequency_counter.values())\n    for item, freq in frequency_counter.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(numbers):\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \"\"\"\n    if not lst:\n        return None\n    freq_count = Counter(lst)\n    max_item = max(freq_count, key=freq_count.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(numbers):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \"\"\"\n    if not numbers:\n        return None  # Return None for an empty list\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(numbers)\n    \n    # Find the element with the maximum frequency\n    max_item, max_freq = max(frequency.items(), key=lambda x: x[1])\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    frequency = {}\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    frequency_counter = Counter(lst)\n    max_freq = max(frequency_counter.values())\n    for item, freq in frequency_counter.items():\n        if freq == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_item = None\n    max_count = 0\n    for item, count in frequency_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    frequency = {}\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    frequency = {}\n    for number in numbers:\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n    max_item = None\n    max_count = 0\n    for number, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = number\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/140": {"dps": 63.69565217391305, "dps_norm": 74.375, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \"\"\"\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a set of unique numbers.\n    \"\"\"\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flattened_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flattened_set.add(item)\n    return flattened_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for lst in list_of_lists:\n        flat_set.update(lst)\n    return flat_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for lst in list_of_lists:\n        for item in lst:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    result = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result.add(item)\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list of tuple): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    result_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    flat_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flat_set.add(item)\n    return flat_set", "matching_cluster_idx": 4}]}, "Mbpp/141": {"dps": 70.9297052154195, "dps_norm": 42.5, "pass@1": 94.0, "profiled": [{"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i = 0\n        while i < k:\n            sub_arr[i], sub_arr[k] = sub_arr[k], sub_arr[i]\n            i += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[:n]))\n        \n        # Flip the sub-array to bring the maximum element to the first position\n        flip(arr, mi)\n        \n        # Flip the sub-array to bring the maximum element to the correct position\n        flip(arr, n - 1)\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sub_array, k):\n        i, j = 0, k\n        while i < j:\n            sub_array[i], sub_array[j] = sub_array[j], sub_array[i]\n            i += 1\n            j -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[0:n]))\n        # Flip the subarray from 0 to mi to bring the maximum element to the front\n        flip(arr, mi)\n        # Flip the subarray from 0 to n-1 to move the maximum element to its correct position\n        flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i, j = 0, k\n        while i < j:\n            sub_arr[i], sub_arr[j] = sub_arr[j], sub_arr[i]\n            i += 1\n            j -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion of the array\n        mi = arr.index(max(arr[0:n]))\n        # Flip the maximum element to the beginning of the array\n        flip(arr, mi)\n        # Flip the maximum element to the end of the unsorted portion of the array\n        flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using pancake sort algorithm.\n    \"\"\"\n    for size in range(len(arr), 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_index = arr.index(max(arr[:size]))\n        \n        # Move the maximum element to the end of the unsorted part of the array\n        arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n        \n        # Move the maximum element to the end of the entire array\n        arr = arr[:size][::-1] + arr[size:]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Helper function to flip the first k elements of the array\n    def flip(sub_array, k):\n        i = 0\n        while i < k / 2:\n            sub_array[i], sub_array[k - i - 1] = sub_array[k - i - 1], sub_array[i]\n            i += 1\n        return sub_array\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the array\n        mi = arr.index(max(arr[0:n]))\n        \n        # Flip the maximum element to the beginning of the array\n        arr = flip(arr, mi + 1)\n        \n        # Flip the maximum element to its correct position\n        arr = flip(arr, n)\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(sub_list, k):\n        i = 0\n        while i < k:\n            sub_list[i], sub_list[k] = sub_list[k], sub_list[i]\n            i += 1\n            k -= 1\n        return sub_list\n\n    n = len(lst)\n    while n > 1:\n        max_idx = lst.index(max(lst[0:n]))\n        if max_idx != n - 1:\n            if max_idx != 0:\n                lst = flip(lst, max_idx)\n            lst = flip(lst, n - 1)\n        n -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i = 0\n        while i < k:\n            sub_arr[i], sub_arr[k] = sub_arr[k], sub_arr[i]\n            i += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[0:n]))\n        if mi != n - 1:\n            # Flip the maximum element to the top (beginning) if it's not already there\n            if mi != 0:\n                flip(arr, mi)\n            # Flip the maximum element to the bottom (end) of the unsorted part\n            flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list using pancake sort algorithm.\n    :param lst: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(sub_list, k):\n        \"\"\"\n        Reverses the order of the first k elements of the list.\n        :param sub_list: List to be flipped.\n        :param k: Number of elements to flip.\n        :return: Flipped list.\n        \"\"\"\n        return sub_list[:k][::-1] + sub_list[k:]\n\n    n = len(lst)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the list\n        max_idx = lst.index(max(lst[:n]))\n\n        # Move the maximum element to the beginning of the list if it's not already\n        if max_idx != n - 1:\n            if max_idx != 0:\n                lst = flip(lst, max_idx + 1)\n            lst = flip(lst, n)\n\n        n -= 1\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i = 0\n        while i < k:\n            sub_arr[i], sub_arr[k] = sub_arr[k], sub_arr[i]\n            i += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[:n]))\n        # Move the maximum element to the end of the unsorted part\n        if mi != n - 1:\n            # Flip the sub-array from the start to the position of the maximum element\n            flip(arr, mi)\n            # Flip the sub-array from the start to the end of the unsorted part\n            flip(arr, n - 1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for size in range(len(lst), 1, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = lst.index(max(lst[:size]))\n        \n        # Move the maximum element to the end of the unsorted part\n        lst = lst[max_index::-1] + lst[max_index+1:]\n        \n        # Move the maximum element to the end of the entire list\n        lst = lst[size-1::-1] + lst[size:]\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i = 0\n        while i < k:\n            sub_arr[i], sub_arr[k] = sub_arr[k], sub_arr[i]\n            i += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[:n]))\n\n        # Flip the maximum element to the front (or the end, depending on its current position)\n        flip(arr, mi)\n\n        # Flip the maximum element to its final position\n        flip(arr, n - 1)\n\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(sub_list, k):\n        i = 0\n        while i < k:\n            sub_list[i], sub_list[k] = sub_list[k], sub_list[i]\n            i += 1\n            k -= 1\n        return sub_list\n\n    n = len(lst)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the list\n        mi = lst.index(max(lst[0:n]))\n        # Flip the list up to the maximum element to bring it to the front\n        lst = flip(lst, mi)\n        # Flip the list up to the end of the unsorted part to bubble it to the end\n        lst = flip(lst, n - 1)\n        n -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for size in range(len(lst), 1, -1):\n        # Find the index of the maximum element in the unsorted part of the list\n        max_index = lst.index(max(lst[:size]))\n        # If the maximum element is already in its correct position, continue\n        if max_index == size - 1:\n            continue\n        # Reverse the list up to the maximum element to bring it to the start\n        lst = lst[max_index::-1] + lst[max_index+1:]\n        # Reverse the entire unsorted part to move the maximum element to its correct position\n        lst = lst[size-1::-1] + lst[size:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    def flip(sub_list, k):\n        i = 0\n        while i < k:\n            sub_list[i], sub_list[k] = sub_list[k], sub_list[i]\n            i += 1\n            k -= 1\n        return sub_list\n\n    n = len(lst)\n    while n > 1:\n        max_index = lst.index(max(lst[0:n]))\n        lst = flip(lst, max_index)\n        lst = flip(lst, n - 1)\n        n -= 1\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(sub_list, k):\n        return sub_list[:k][::-1] + sub_list[k:]\n\n    arr = lst[:]\n    n = len(arr)\n    while n > 1:\n        max_idx = arr.index(max(arr[:n]))\n        if max_idx != n - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, n)\n        n -= 1\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sort a list using pancake sort.\n    \n    :param arr: List[int] - The list to be sorted.\n    :return: List[int] - The sorted list.\n    \"\"\"\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[0:n]))\n        \n        # Flip the list up to and including the maximum element to bring it to the front\n        arr = arr[mi::-1] + arr[mi+1:]\n        \n        # Flip the entire unsorted part of the list to bring the maximum element to its final position\n        arr = arr[n-1::-1] + arr[n:]\n        \n        # Reduce the range of the unsorted part of the list\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i = 0\n        while i < k:\n            sub_arr[i], sub_arr[k] = sub_arr[k], sub_arr[i]\n            i += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[:n]))\n\n        # Flip the maximum element to the beginning of the array\n        flip(arr, mi)\n\n        # Flip the maximum element to the end of the unsorted part of the array\n        flip(arr, n - 1)\n\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def flip(sub_list, k):\n        return sub_list[:k][::-1] + sub_list[k:]\n\n    arr = lst.copy()\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the list\n        mi = arr.index(max(arr[:n]))\n        \n        # Flip the maximum element to the beginning of the list\n        arr = flip(arr, mi + 1)\n        \n        # Flip the maximum element to its final position\n        arr = flip(arr, n)\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        i = 0\n        while i < k:\n            sub_arr[i], sub_arr[k] = sub_arr[k], sub_arr[i]\n            i += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[:n]))\n        \n        # Flip the maximum element to the beginning of the array\n        flip(arr, mi)\n        \n        # Flip the maximum element to the end of the unsorted part of the array\n        flip(arr, n - 1)\n        \n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n    \"\"\"\n    def flip(sub_list, k):\n        \"\"\"\n        Helper function to flip the first k elements of the sublist.\n        \"\"\"\n        return sub_list[:k][::-1] + sub_list[k:]\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        mi = arr.index(max(arr[:n]))\n\n        # Move the maximum element to the beginning of the array\n        arr = flip(arr, mi + 1)\n\n        # Move the maximum element to the end of the unsorted part of the array\n        arr = flip(arr, n)\n\n        # Reduce the size of the unsorted part of the array\n        n -= 1\n\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 93.6231884057971, "dps_norm": 98.75, "pass@1": 66.0, "profiled": [{"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    # Ensure the start and end indices are within the bounds of the list\n    start = max(0, start)\n    end = min(len(numbers) - 1, end)\n    \n    # Sum the numbers in the specified range\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n    numbers (list): A list of integers.\n    start (int): The start index of the range.\n    end (int): The end index of the range.\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n    lst (list): The list of numbers.\n    start (int): The start index of the range.\n    end (int): The end index of the range.\n    \n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Returns the sum of numbers in the list within the specified range [start, end].\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    This function calculates the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n    numbers (list): A list of integers.\n    start (int): The starting index (inclusive).\n    end (int): The ending index (inclusive).\n    \n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Sum the numbers in the list that fall within the specified range.\n\n    Parameters:\n    numbers (list): A list of integers.\n    start (int): The start index (inclusive).\n    end (int): The end index (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Ensure the start and end indices are within the bounds of the list\n    if start < 0 or end >= len(nums) or start > end:\n        return 0\n    # Sum the numbers within the specified range\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    This function calculates the sum of numbers in the list nums between the indices start and end (inclusive).\n    \n    Parameters:\n    nums (list): The list of numbers.\n    start (int): The starting index (inclusive).\n    end (int): The ending index (inclusive).\n    \n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Return the sum of numbers in the list within the specified range [start, end].\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Calculate the sum of numbers in the list `nums` within the specified range [start, end].\n    \n    Args:\n    nums (list): A list of numbers.\n    start (int): The starting index of the range (inclusive).\n    end (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    This function calculates the sum of numbers in a list within a range specified by two indices.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    start (int): The starting index (inclusive).\n    end (int): The ending index (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Ensure the start and end are within the bounds of the list\n    start = max(start, 0)\n    end = min(end, len(lst) - 1)\n    \n    # Sum the numbers in the specified range\n    return sum(lst[start:end+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(nums, start, end):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \"\"\"\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    This function takes a list of numbers and two indices, and returns the sum of numbers within the range [start, end].\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 72.984496124031, "dps_norm": 27.142857142857142, "pass@1": 97.0, "profiled": [{"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = ''\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return s[::2]  # Using slicing to select every second character", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(s, char):\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    return input_string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    return text.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    \"\"\"\n    This function replaces all blank spaces in a given string with a specified character.\n    \n    Parameters:\n    text (str): The input string where spaces need to be replaced.\n    char (str): The character to replace the spaces with.\n    \n    Returns:\n    str: The string with spaces replaced by the specified character.\n    \"\"\"\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replace all blank spaces in the given string with the specified character.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace spaces with.\n    \n    Returns:\n    str: The string with spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replace blank spaces in a string with a specified character.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to replace spaces with.\n    \n    Returns:\n    str: The string with spaces replaced by the specified character.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 75.17241379310344, "dps_norm": 77.0, "pass@1": 36.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table\n    memo = {}\n\n    def count_sequences(current, length):\n        # If the sequence length is n, we have found a valid sequence\n        if length == n:\n            return 1\n        # If we exceed the length, return 0 as it's not a valid sequence\n        if length > n:\n            return 0\n        # Use memoization to store already computed sequences\n        if (current, length) in memo:\n            return memo[(current, length)]\n\n        total = 0\n        # Generate the next possible element\n        for next_element in range(current * 2, m + 1):\n            total += count_sequences(next_element, length + 1)\n        # Store the result in memoization table\n        memo[(current, length)] = total\n        return total\n\n    # Start the sequence with each possible starting element\n    return sum(count_sequences(i, 1) for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Create a memoization table where dp[i][j] represents the number of ways to\n    # form a sequence of length i where the last element is j.\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: There is 1 way to form a sequence of length 1 with any element.\n    for j in range(1, m + 1):\n        dp[1][j] = 1\n    \n    # Fill the dp table\n    for i in range(2, n + 1):  # For each sequence length from 2 to n\n        for j in range(1, m + 1):  # For each possible last element value from 1 to m\n            for k in range(1, j // 2 + 1):  # Sum over all valid previous elements\n                dp[i][j] += dp[i - 1][k]\n    \n    # The answer is the sum of all possible sequences of length n\n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table where dp[i][j] represents the number of sequences of length j ending with the number i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # There is one way to have a sequence of length 1: the number itself (base case)\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            for k in range(1, i // 2 + 1):  # k is the previous number in the sequence\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum up all sequences of length n\n    total = 0\n    for i in range(1, m + 1):\n        total += dp[i][n]\n    \n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array where dp[i][j] represents the number of ways to have a sequence of length j ending with the number i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # There is 1 way to have a sequence of length 1 with any number i (just the number i itself)\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n\n    # Fill the DP table\n    for j in range(2, n + 1):  # Sequence length\n        for i in range(1, m + 1):  # Ending number\n            for k in range(2 * i, m + 1):  # Previous number must be at least twice the current number\n                dp[i][j] += dp[k][j - 1]\n\n    # Sum up all the sequences of length n\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dp[i][n]\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table where dp[i][j] represents the number of sequences of length j ending with the number i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: there's 1 way to have a sequence of length 1 (only the number itself)\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):  # For each sequence length from 2 to n\n        for i in range(1, m + 1):  # For each possible end number\n            for k in range(1, i // 2 + 1):  # For each possible previous number\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum up all the sequences of length n\n    total_sequences = sum(dp[i][n] for i in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(start, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_element in range(start * 2, m + 1):\n            count += count_sequences(next_element, length - 1)\n        return count\n\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n - 1)\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table where dp[i][j] represents the number of ways to form a sequence of length j ending with the number i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # There is one way to form a sequence of length 1, which is the number itself\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            for k in range(2 * i, m + 1):\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum up all possible sequences of length n\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dp[i][n]\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a cache for memoization\n    cache = {}\n\n    def count_sequences(prev, length):\n        # If the sequence length is n, return 1 (a valid sequence is found)\n        if length == n:\n            return 1\n        # If the current state is cached, return the cached result\n        if (prev, length) in cache:\n            return cache[(prev, length)]\n\n        # Initialize the count of sequences\n        count = 0\n        # Iterate over the possible next numbers\n        for next_num in range(prev * 2, m + 1):\n            # Recursively count sequences starting with the next number\n            count += count_sequences(next_num, length + 1)\n        # Cache the result and return it\n        cache[(prev, length)] = count\n        return count\n\n    # Start the sequence with a number between 1 and m\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table with -1 to indicate uncomputed values\n    memo = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    def count_sequences(prev, length):\n        # If we have reached the desired length, return 1 for a valid sequence\n        if length == n:\n            return 1\n        # If the result is already computed, return it\n        if memo[prev][length] != -1:\n            return memo[prev][length]\n        # Initialize the count for the current length and previous value\n        count = 0\n        # Iterate over possible next values based on the problem constraints\n        for next_val in range(prev * 2, m + 1):\n            # Recursively count sequences with the next value\n            count += count_sequences(next_val, length + 1)\n        # Memoize the computed result\n        memo[prev][length] = count\n        return count\n\n    # Start the recursion with each possible starting value\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, 1)\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization dictionary to store the results of subproblems\n    memo = {}\n\n    def count_sequences(start, length):\n        # If we have reached the desired length, return 1 (one valid sequence)\n        if length == 0:\n            return 1\n        # If the result for this state is already computed, return it\n        if (start, length) in memo:\n            return memo[(start, length)]\n\n        # Initialize the count for this state\n        count = 0\n        # Iterate over possible next numbers\n        for next_num in range(start * 2, m + 1):\n            count += count_sequences(next_num, length - 1)\n        # Store the result in memo before returning\n        memo[(start, length)] = count\n        return count\n\n    # Start the recursion with each number from 1 to m as a possible starting point\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n - 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table where dp[i][j] represents the number of ways to form a sequence of length j ending with i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # There is one way to form a sequence of length 1 with any number, which is the number itself\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            for k in range(1, i // 2 + 1):\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum up all the ways to form sequences of length n\n    total_ways = 0\n    for i in range(1, m + 1):\n        total_ways += dp[i][n]\n    \n    return total_ways", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Memoization dictionary to store computed values\n    memo = {}\n\n    def count_sequences(start, length):\n        if length == 0:\n            return 1\n        if (start, length) in memo:\n            return memo[(start, length)]\n\n        total = 0\n        for next_element in range(start * 2, m + 1):\n            total += count_sequences(next_element, length - 1)\n        memo[(start, length)] = total\n        return total\n\n    total_sequences = 0\n    for first_element in range(1, m + 1):\n        total_sequences += count_sequences(first_element, n - 1)\n\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function calculates the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    Args:\n    m (int): The upper bound for the elements in the sequence.\n    n (int): The length of the sequence.\n    \n    Returns:\n    int: The total number of sequences that satisfy the given conditions.\n    \"\"\"\n    \n    # Initialize a cache to store the results of subproblems\n    cache = {}\n    \n    def dp(prev, length):\n        \"\"\"\n        A helper function that uses dynamic programming to find the number of sequences.\n        \n        Args:\n        prev (int): The previous element in the sequence.\n        length (int): The current length of the sequence.\n        \n        Returns:\n        int: The number of sequences that can be formed.\n        \"\"\"\n        if (prev, length) in cache:\n            return cache[(prev, length)]\n        \n        if length == n:\n            return 1\n        \n        count = 0\n        for next_val in range(prev * 2, m + 1):\n            count += dp(next_val, length + 1)\n        \n        cache[(prev, length)] = count\n        return count\n    \n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += dp(start, 1)\n    \n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 1:\n            return 1\n        count = 0\n        for next_value in range(current * 2, m + 1):\n            count += count_sequences(next_value, length - 1)\n        return count\n    \n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n)\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a cache for memoization\n    cache = {}\n\n    def count_sequences(prev, length):\n        # Base case: if the sequence length is n, we found a valid sequence\n        if length == n:\n            return 1\n        # If the result is already in the cache, return it\n        if (prev, length) in cache:\n            return cache[(prev, length)]\n        \n        # Initialize the count of sequences\n        count = 0\n        # Iterate over possible next elements\n        for next_element in range(prev * 2, m + 1):\n            # Recursively count sequences from the next element\n            count += count_sequences(next_element, length + 1)\n        \n        # Cache the result and return\n        cache[(prev, length)] = count\n        return count\n\n    # Start the sequence with the smallest possible element\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, 1)\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(prev, length):\n        if length == n:\n            return 1\n        count = 0\n        for next_val in range(prev * 2, m + 1):\n            count += count_sequences(next_val, length + 1)\n        return count\n\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, 1)\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table where dp[i][j] represents the number of ways\n    # to have a sequence of length j ending with the number i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: There is 1 way to have a sequence of length 1 with any number i\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the dp table\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            for k in range(2 * i, m + 1):\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum all possible sequences of length n\n    total = 0\n    for i in range(1, m + 1):\n        total += dp[i][n]\n    \n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a memoization table\n    memo = {}\n\n    def count_sequences(prev, length):\n        # If we have reached the desired length, return 1 as a valid sequence\n        if length == n:\n            return 1\n        # Use memoization to store results of subproblems\n        if (prev, length) in memo:\n            return memo[(prev, length)]\n        \n        count = 0\n        # Generate the next element in the sequence\n        for next_el in range(prev * 2, m + 1):\n            count += count_sequences(next_el, length + 1)\n        \n        # Store the result in memoization table\n        memo[(prev, length)] = count\n        return count\n\n    # Start the sequence with each number from 1 to m\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, 1)\n\n    return total_count", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a list to store the number of ways to reach each length of sequence\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # There is one way to reach a sequence of length 0, which is to have no elements\n    for j in range(m + 1):\n        dp[0][j] = 1\n    \n    # Fill the dp table\n    for i in range(1, n + 1):  # For each length of sequence\n        for j in range(1, m + 1):  # For each possible last element\n            # Sum the ways to reach this length with each valid previous element\n            for k in range(2 * j, m + 1):\n                dp[i][j] += dp[i - 1][k]\n    \n    # The result is the sum of the ways to reach the desired length with each valid last element\n    return sum(dp[n - 1])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table where dp[i][j] represents the number of ways to have a sequence of length j ending with the number i\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base case: There is 1 way to have a sequence of length 1 with any number i, which is the number itself\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the DP table\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            for k in range(1, i // 2 + 1):\n                dp[i][j] += dp[k][j - 1]\n    \n    # Sum all possible sequences of length n\n    total_sequences = 0\n    for i in range(1, m + 1):\n        total_sequences += dp[i][n]\n    \n    return total_sequences", "matching_cluster_idx": 7}]}, "Mbpp/240": {"dps": 80.48780487804879, "dps_norm": 88.88888888888889, "pass@1": 39.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 has at least one element to ensure we can replace the last element\n    if list1:\n        # Replace the last element of list1 with all elements of list2\n        list1[-1:] = list2\n    else:\n        # If list1 is empty, just append list2 to it\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is empty to avoid index out of range error\n    if not list1:\n        return list2\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is empty, if so, replace its first element with list2\n    if not list1:\n        list1.extend(list2)\n    else:\n        # Replace the last element of list1 with the first element of list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    This function replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if list1:\n        list1[-1:] = list2\n    else:\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:\n        list1[-1:] = list2\n    else:\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with the elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with all elements of list2\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty\n    if list1:\n        # Replace the last element of the first list with the elements of the second list\n        list1[-1:] = list2\n    else:\n        # If the first list is empty, extend it with the second list\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if list1:\n        list1[-1:] = list2\n    else:\n        return list2  # If list1 is empty, return list2 as the new list\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:\n        list1[-1:] = list2\n    else:\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with the elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 has at least one element to ensure we can replace the last element\n    if list1:\n        # Replace the last element of list1 with the elements of list2\n        list1[-1:] = list2\n    else:\n        # If list1 is empty, just extend list2 to list1\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \"\"\"\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with all elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with all elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replace the last element of list1 with elements of list2\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2\n    else:  # If list1 is empty, extend it with list2\n        list1.extend(list2)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    if list1:  # Check if list1 is not empty\n        list1[-1:] = list2  # Replace the last element of list1 with elements of list2\n    else:\n        list1.extend(list2)  # If list1 is empty, extend it with list2\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 72.23744292237443, "dps_norm": 67.05882352941177, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Count the number of prime numbers less than n.\"\"\"\n    if n <= 2:\n        return 0\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is a prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n: int) -> int:\n    if n <= 2:\n        return 0\n    \n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for j in range(i*i, n, i):\n                sieve[j] = False\n    \n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(num):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Function to count prime numbers less than a given non-negative number n.\"\"\"\n    if n <= 2:\n        return 0\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Count the number of prime numbers less than a non-negative number.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Count the number of prime numbers less than a given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(num):\n    \"\"\"Check if a number is a prime number.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Return the number of prime numbers less than n.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(n):\n    \"\"\"Count the number of prime numbers less than n.\"\"\"\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}]}, "Mbpp/265": {"dps": 52.73255813953489, "dps_norm": 69.16666666666667, "pass@1": 94.0, "profiled": [{"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting sublists\n    result = []\n    \n    # Iterate over the range of indices, stepping by n each time\n    for i in range(n):\n        # For each starting index, create a sublist of every nth element\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists with every nth element.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists for every nth element.\n    \n    Parameters:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list of lists: A list containing sublists of every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = []\n    \n    # Iterate over the list, stepping by n each time\n    for i in range(n):\n        # For each starting point, create a sublist by stepping by n\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Create a list to hold the resulting sublists\n    result = []\n    \n    # Iterate over the indices of the list, stepping by n\n    for i in range(n):\n        # Create a sublist starting from index i and stepping by n each time\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting sublists\n    result = []\n    \n    # Iterate over the list in steps of n\n    for i in range(n):\n        # Create a sublist starting from index i and incrementing by n each time\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists, taking every nth element.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    List[List[Any]]: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create a list to hold the result\n    result = []\n    # Iterate over the list in steps of n\n    for i in range(n):\n        # Create a sublist starting from index i and step by n\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        result.append(sublist)\n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists, taking every nth element from the original list.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to take elements.\n    \n    Returns:\n    List[List]: A list of sublists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element and returns a list of the resulting lists.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, each containing every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    # Initialize an empty list to store the resulting lists\n    result = []\n    \n    # Iterate over the indices of the input list, stepping by n\n    for i in range(n):\n        # For each starting index, create a sublist from the input list\n        sublist = [input_list[j] for j in range(i, len(input_list), n)]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Create an empty list to hold the resulting sublists\n    result = []\n    \n    # Iterate over the list, step by n elements\n    for i in range(n):\n        # Create a sublist for every nth element\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists, grouping every nth element.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of sublists, each containing every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists of length n.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The number of elements per sublist.\n    \n    Returns:\n    List[List]: A list of sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists based on every nth element.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    List[List[Any]]: A list of lists containing the elements split according to the nth interval.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists, each containing every nth element from the original list.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list of lists: A list containing sublists of nth elements from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into sublists, taking every nth element.\n    \n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list of lists: A list of lists containing elements from the original list, taken every nth element.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.4, "dps_norm": 85.45454545454545, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    seen = set()\n    return not any(item in seen or seen.add(item) for item in lst)", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): A list of elements to check.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    return not any(item in seen or seen.add(item) for item in lst)", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n    \n    Args:\n    lst (list): The list of elements to check.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    seen = set()\n    for item in lst:\n        if item in seen:\n            return False\n        seen.add(item)\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 30.51282051282051, "dps_norm": 67.5, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    This function calculates the number of inversions in an array using a brute force method.\n    An inversion in an array a[] is a pair (a[i], a[j]) such that i < j and a[i] > a[j].\n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the element at the later index is smaller than the element at the current index\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    This function counts the number of inversions in an array.\n    An inversion is a pair (i, j) where i < j and arr[i] > arr[j].\n    \"\"\"\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n        return inv_count\n\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left     # Starting index for left subarray\n        j = mid + 1  # Starting index for right subarray\n        k = left     # Starting index to be sorted in temp_arr\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all elements left to i in the left subarray are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for loop_var in range(left, right + 1):\n            arr[loop_var] = temp_arr[loop_var]\n\n        return inv_count\n\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n    \"\"\"\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    This function counts the number of inversions in the array.\n    An inversion is a pair (i, j) where arr[i] > arr[j] and i < j.\n    \"\"\"\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count\n    inv_count = 0\n    \n    # Loop through the array to compare elements\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n                \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 87.65517241379311, "dps_norm": 64.16666666666667, "pass@1": 94.0, "profiled": [{"solution": "def large_product(list1, list2, num):\n    # Create a list of products by multiplying each element of list1 with each element of list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top 'num' largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of products by multiplying elements from both lists\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    # Create a list of products\n    products = [x * y for x in list1 for y in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Combine products of each element in list1 with each element in list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    # Return the top n largest products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of all possible products\n    products = [x * y for x in list1 for y in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    # Calculate the products of each element from list1 with each element from list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of products by multiplying each element of list1 with each element of list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of products by multiplying each element of list1 with each element of list2\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Calculate the products of each element in list1 with each element in list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the specified number of largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Pair elements from both lists and calculate their products\n    products = [(a * b, a, b) for a in list1 for b in list2]\n    # Sort the products in descending order\n    sorted_products = sorted(products, key=lambda x: x[0], reverse=True)\n    # Extract the top n largest products\n    top_n_products = [product[0] for product in sorted_products[:n]]\n    return top_n_products", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of tuples (product, index from list1, index from list2)\n    products = [(a * b, i, j) for i, a in enumerate(list1) for j, b in enumerate(list2)]\n    \n    # Sort the products by their values in descending order\n    products.sort(key=lambda x: -x[0])\n    \n    # Extract the top n products\n    top_products = [product[0] for product in products[:n]]\n    \n    return top_products", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Calculate the products of each element in list1 with each element in list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    # Return the top n largest products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num_products):\n    # Calculate all possible products\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    # Return the specified number of largest products\n    return sorted_products[:num_products]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of products by multiplying elements from both lists\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top 'n' largest products\n    return [products[i] for i in range(n)]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all products of elements from list1 and list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of tuples combining elements from both lists along with their product\n    combined = [(a * b, a, b) for a in list1 for b in list2]\n    \n    # Sort the combined list by the product in descending order\n    combined.sort(key=lambda x: x[0], reverse=True)\n    \n    # Extract the top 'n' products\n    top_n_products = [combined[i][0] for i in range(n)]\n    \n    return top_n_products", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products from multiplying one element from list1 with one from list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of products by multiplying each element of list1 with each element of list2\n    products = [a * b for a in list1 for b in list2]\n    # Sort the products in descending order\n    products.sort(reverse=True)\n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 62.67605633802817, "dps_norm": 66.15384615384616, "pass@1": 66.0, "profiled": [{"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, the maximum sum is n itself\n    if n < 2:\n        return n\n    \n    # Initialize a list to store the maximum sum for each number up to n\n    max_sum = [0] * (n + 1)\n    max_sum[0] = 0\n    max_sum[1] = 1\n    \n    # Compute the maximum sum for each number from 2 to n\n    for i in range(2, n + 1):\n        max_sum[i] = max(max_sum[i // 2] + max_sum[i // 3] + max_sum[i // 4] + max_sum[i // 5], i)\n    \n    return max_sum[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Create a memoization table to store previously computed values\n    memo = {0: 0, 1: 1}\n\n    # Define a recursive function to find the maximum sum\n    def max_sum(x):\n        # Check if the value is already computed\n        if x in memo:\n            return memo[x]\n\n        # Compute the value using the given equation\n        result = max(max_sum(x // 2) + max_sum(x // 3) + max_sum(x // 4) + max_sum(x // 5), x)\n\n        # Store the computed value in the memoization table\n        memo[x] = result\n\n        return result\n\n    # Call the recursive function for the given input\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, the maximum sum is n itself\n    if n < 2:\n        return n\n    \n    # Initialize the maximum sum for the current number\n    max_sum = n\n    \n    # Calculate the maximum sum by recursively evaluating f(n/2), f(n/3), f(n/4), and f(n/5)\n    if n // 2 > 0:\n        max_sum = max(max_sum, get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5))\n    \n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    \n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Create a memoization table to store previously computed values\n    memo = {0: 0, 1: 1}\n    \n    # Define a helper function for memoization\n    def dp(x):\n        if x in memo:\n            return memo[x]\n        memo[x] = max(dp(x // 2) + dp(x // 3) + dp(x // 4) + dp(x // 5), x)\n        return memo[x]\n    \n    # Call the helper function for the given n\n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n    result = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    memo[n] = result\n    return result\nmemo = {}", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, the maximum sum is n itself\n    if n < 2:\n        return n\n    \n    # Initialize a list to store the maximum sum for each number up to n\n    max_sum = [0] * (n + 1)\n    max_sum[1] = 1  # Base case: max_sum(1) = 1\n    \n    # Compute the maximum sum for each number from 2 to n\n    for i in range(2, n + 1):\n        max_sum[i] = max(max_sum[i // 2] + max_sum[i // 3] + max_sum[i // 4] + max_sum[i // 5], i)\n    \n    return max_sum[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, return n\n    if n < 2:\n        return n\n    \n    # Initialize a list to store the computed max sums for each number up to n\n    max_sums = [0] * (n + 1)\n    \n    # Set the base case for max_sums[0] and max_sums[1]\n    max_sums[0] = 0\n    max_sums[1] = 1\n    \n    # Compute the max sum for each number from 2 to n\n    for i in range(2, n + 1):\n        max_sums[i] = max(max_sums[i // 2] + max_sums[i // 3] + max_sums[i // 4] + max_sums[i // 5], i)\n    \n    # Return the max sum for the given n\n    return max_sums[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Create a memoization table to store already computed values\n    memo = {0: 0, 1: 1}\n\n    # Define a recursive function to compute the maximum sum\n    def max_sum(x):\n        if x in memo:\n            return memo[x]\n        result = max(max_sum(x // 2) + max_sum(x // 3) + max_sum(x // 4) + max_sum(x // 5), x)\n        memo[x] = result\n        return result\n\n    # Compute the maximum sum for the given n\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, the maximum sum is n itself\n    if n < 2:\n        return n\n    \n    # Initialize a list to store the maximum sums for each number up to n\n    max_sums = [0] * (n + 1)\n    \n    # Set the base case for the maximum sum of 0 and 1\n    max_sums[0], max_sums[1] = 0, 1\n    \n    # Compute the maximum sum for each number from 2 to n\n    for i in range(2, n + 1):\n        max_sums[i] = max(max_sums[i // 2] + max_sums[i // 3] + max_sums[i // 4] + max_sums[i // 5], i)\n    \n    # Return the maximum sum for the given number n\n    return max_sums[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # Create a memoization table to store previously computed results\n    memo = {0: 0, 1: 1}\n\n    # Define a helper function for recursion with memoization\n    def helper(x):\n        if x in memo:\n            return memo[x]\n        result = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n        memo[x] = result\n        return result\n\n    # Compute the maximum sum for the given n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n\n    # Calculate the maximum sum using the given equation\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Create a memoization table to store already computed values\n    memo = {0: 0, 1: 1}\n    \n    # Define a helper function for recursive computation with memoization\n    def helper(x):\n        if x in memo:\n            return memo[x]\n        # Compute the maximum sum using the given equation\n        memo[x] = max(helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5), x)\n        return memo[x]\n    \n    # Compute the maximum sum for the given n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Calculate the maximum sum for the current value of n\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    \n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, return n (since f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n) for n >= 2)\n    if n < 2:\n        return n\n    \n    # Initialize the maximum sum to n\n    max_sum = n\n    \n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5) and compare with n\n    if n // 2 > 0:\n        max_sum = max(max_sum, get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5))\n    \n    return max_sum", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n):\n    # Base cases\n    if n == 0:\n        return 0\n    if n <= 2:\n        return n\n    \n    # Recursive case\n    return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 4}, {"solution": "def get_max_sum(n):\n    # Create a memoization table to store already computed values\n    memo = {0: 0, 1: 1}\n    \n    # Define a recursive function with memoization\n    def compute_max_sum(x):\n        if x in memo:\n            return memo[x]\n        # Compute the maximum sum for the current value using the given equation\n        max_sum = max(compute_max_sum(x // 2) + compute_max_sum(x // 3) + compute_max_sum(x // 4) + compute_max_sum(x // 5), x)\n        memo[x] = max_sum\n        return max_sum\n    \n    # Compute and return the maximum sum for the given number n\n    return compute_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, the max sum is n itself.\n    if n < 2:\n        return n\n    \n    # Calculate the maximum sum for the given value of n.\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    return max_sum", "matching_cluster_idx": 3}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \"\"\"\n    # Create a dictionary to store the frequency of each character\n    frequency = {}\n    \n    # Populate the frequency dictionary\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if frequency[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    \n    # Count the occurrences of each character\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    \n    # Find the first non-repeated character\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to keep track of character counts\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Populate the dictionary with the count of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n            char_order.append(c)\n    \n    for c in char_order:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    \n    # Count the frequency of each character\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    \n    # Find the first character that has a frequency of 1\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n            char_order.append(c)\n    \n    for c in char_order:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    \n    # Build the count and order dictionaries\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    \n    # Find the first non-repeating character\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    \n    # Counting occurrences of each character\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    \n    # Finding the first character that occurs only once\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n            char_order.append(c)\n    for c in char_order:\n        if counts[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Create a dictionary to count the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has a frequency of 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in a given string.\n    If all characters are repeated or the string is empty, it returns None.\n    \"\"\"\n    char_order = []\n    ctr = {}\n    \n    # Count the occurrences of each character\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    \n    # Find the first character with a count of 1\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the frequency of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to keep track of character counts\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that occurs only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to keep track of character counts\n    char_count = {}\n    \n    # Populate the dictionary with character counts\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_order = []\n    ctr = {}\n    for c in s:\n        if c in ctr:\n            ctr[c] += 1\n        else:\n            ctr[c] = 1\n            char_order.append(c)\n    for c in char_order:\n        if ctr[c] == 1:\n            return c\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to keep track of character counts\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple in which to check for the element.\n    element: The element to check for within the tuple.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element_to_check):\n    \"\"\"\n    Check if the element exists within the tuple.\n    \n    Args:\n    test_tup (tuple): The tuple to search within.\n    element_to_check (any): The element to check for in the tuple.\n    \n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element_to_check in test_tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to check for the element.\n    element: The element to look for within the tuple.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(test_tup, element_to_check):\n    result = element_to_check in test_tup\n    return result", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to check within.\n    element: The element to look for in the tuple.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 88.60248447204968, "dps_norm": 87.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any value in seq1 that also exists in seq2.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any value in the first sequence that also exists in the second sequence.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n    \n    Args:\n    seq1 (list): The first sequence of values.\n    seq2 (list): The second sequence of values.\n    \n    Returns:\n    bool: True if there is at least one overlapping value, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    for item in list1:\n        if item in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    for item in list1:\n        if item in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in the first sequence exists in the second sequence.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 24.48559670781893, "dps_norm": 73.57142857142857, "pass@1": 92.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple):\n    # Convert the tuple to a list to use the join method\n    str_list = [str(item) for item in input_tuple]\n    # Concatenate elements with the delimiter '-'\n    result = '-'.join(str_list)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(test_tuple):\n    return '-'.join(str(x) for x in test_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tuple):\n    # Convert each element to string and join them with the delimiter '-'\n    return '-'.join(str(element) for element in test_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenates each element of the tuple into a single string with a '-' delimiter.\n    \n    Args:\n    tup (tuple): A tuple of elements to be concatenated.\n    \n    Returns:\n    str: A single string with elements concatenated by '-'.\n    \"\"\"\n    return '-'.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    delimiter = \"-\"\n    return delimiter.join(str(item) for item in input_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    # Convert the tuple to a list to make it mutable\n    temp_list = list(input_tuple)\n    # Join the elements of the list with the delimiter\n    result = \"-\".join(str(item) for item in temp_list)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    \"\"\"\n    Concatenate each element of the tuple by the delimiter.\n    \n    Parameters:\n    input_tuple (tuple): A tuple containing elements to be concatenated.\n    \n    Returns:\n    str: A string with elements concatenated by the delimiter '-'.\n    \"\"\"\n    # Convert the tuple to a list for easier manipulation\n    elements = list(input_tuple)\n    \n    # Join the elements with the delimiter\n    result = '-'.join(str(element) for element in elements)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tuple):\n    # Convert the tuple elements to a list to join them with a delimiter\n    list_elements = list(test_tuple)\n    # Join the elements with the specified delimiter\n    result = '-'.join(map(str, list_elements))\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    # Convert the tuple to a string using the delimiter\n    return '-'.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tuple):\n    # Convert each element to string and join them with the delimiter\n    result = '-'.join(str(element) for element in test_tuple)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tuple):\n    # Concatenate each element of the tuple with the delimiter '-'\n    return '-'.join(str(element) for element in test_tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tuple):\n    # Convert the tuple to a list to use join\n    test_list = list(test_tuple)\n    # Join the elements with the delimiter '-'\n    result = '-'.join(map(str, test_list))\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    # Join each element of the tuple with the delimiter '-'\n    result = '-'.join(str(x) for x in test_tup)\n    return result", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tuple):\n    # Join each element of the tuple with the delimiter '-'\n    result = '-'.join(str(item) for item in test_tuple)\n    return result", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 90.32490974729242, "dps_norm": 96.0, "pass@1": 98.0, "profiled": [{"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tuple):\n    result = [item[-1] for item in test_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings_tuple):\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(test_tuple):\n    result = [item[-1] for item in test_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tuple):\n    # Extract the last character of each string in the tuple\n    result = [item[-1] for item in test_tuple]\n    return result\ntest_tuple = ('Mers', 'for', 'Vers')", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    return [string[-1] for string in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [string[-1] for string in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    return [word[-1] for word in input_tuple]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    count = 0\n    for sublist in list1:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    count = 0\n    for sublist in list1:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    count = 0\n    for sublist in list1:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    count = 0\n    for sublist in list1:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    # Start with a big gap, then reduce the gap\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements arr[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 72.87234042553192, "dps_norm": 70.0, "pass@1": 37.0, "profiled": [{"solution": "def check_greater(numbers, target):\n    return all(target > num for num in numbers)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \n    Args:\n    arr (list): The list of numbers.\n    num (int): The number to check against the elements of the list.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Function to check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(numbers, value):\n    return all(value > num for num in numbers)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(numbers, target):\n    return all(target > num for num in numbers)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the number is greater than all elements in the array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    num (int): The integer to compare with the elements of the array.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \n    Args:\n    arr (list): A list of numbers.\n    num (int): The number to check against the elements of the array.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 60.0, "profiled": [{"solution": "def count_Occurrence(test_tup, lst):\n    res = sum(test_tup.count(ele) for ele in lst)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    # Initialize the count to 0\n    count = 0\n    # Iterate over each element in the list1\n    for ele in list1:\n        # Count the occurrences of the element in the test_tup\n        count += test_tup.count(ele)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    res = sum(test_tup.count(ele) for ele in test_list)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, list_elements):\n    count = 0\n    for element in list_elements:\n        count += input_tuple.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    # Initialize a count variable\n    count = 0\n    # Iterate over each element in the list1\n    for ele in list1:\n        # Count the occurrences of the element in the test_tup\n        count += test_tup.count(ele)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tuple, test_list):\n    # Initialize a result counter\n    res = 0\n    # Iterate through each element in the test_list\n    for ele in test_list:\n        # Count the occurrences of the current element in the test_tuple and add to res\n        res += test_tuple.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    result = sum(test_tup.count(ele) for ele in test_list)\n    return result", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_list):\n    # Initialize a count variable to keep track of the total occurrences\n    total_occurrences = 0\n    \n    # Iterate over each element in the elements_list\n    for element in elements_list:\n        # Count the occurrences of the current element in the input_tuple and add it to the total_occurrences\n        total_occurrences += input_tuple.count(element)\n    \n    # Return the total number of occurrences\n    return total_occurrences", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, list1):\n    res = sum(test_tup.count(ele) for ele in list1)\n    return res", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n    return text.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The input string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(strings):\n    # Use a list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_list = []\n    for string in strings:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list of str): The list of strings to be reversed.\n    \n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n    strings (list of str): List of strings to be reversed.\n\n    Returns:\n    list of str: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Use a list comprehension to reverse each string in the list\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    strings (list of str): A list of strings to be reversed.\n    \n    Returns:\n    list of str: A list of reversed strings.\n    \"\"\"\n    reversed_list = []\n    for string in strings:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    strings (list of str): A list containing strings to be reversed.\n    \n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of strings.\n    \n    Returns:\n    list: A list of strings, each string in the original list reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_strings = []\n    for string in strings:\n        reversed_strings.append(string[::-1])\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_strings = []\n    for string in strings:\n        reversed_strings.append(string[::-1])\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_strings = []\n    for string in strings:\n        reversed_strings.append(string[::-1])\n    return reversed_strings", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 45.96153846153846, "dps_norm": 79.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] if len(item) > 0 else None for item in lst]", "matching_cluster_idx": 2}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] if item else None for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list1):\n    return [sublist[0] for sublist in list1]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list1):\n    return [sublist[0] for sublist in list1]", "matching_cluster_idx": 3}, {"solution": "def Extract(lists):\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n    \n    Args:\n    input_string (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The string with the specified character replaced.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Parameters:\n    s (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The new string with replaced characters.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a specified character with another character in a given string.\n    \n    Parameters:\n    string (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: A new string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n    \n    Args:\n    string (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The new string with replaced characters.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Args:\n    s (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: A new string with all occurrences of old_char replaced with new_char.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, char_to_replace, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Args:\n    input_string (str): The original string.\n    char_to_replace (str): The character to be replaced.\n    new_char (str): The new character to replace with.\n\n    Returns:\n    str: The string with all occurrences of char_to_replace replaced with new_char.\n    \"\"\"\n    return input_string.replace(char_to_replace, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Use the str.replace() method to replace all occurrences of old_char with new_char\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Args:\n    s (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: A new string with the specified character replacements.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a specific character with another character in a string.\n    \n    Args:\n    s (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: A new string with all occurrences of old_char replaced with new_char.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Args:\n    string (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The new string with the replacements made.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n    \n    Args:\n    s (str): The input string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The resulting string after replacement.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if not numbers:\n        raise ValueError(\"The input list must contain at least one element.\")\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if not numbers:  # Check if the list is empty\n        return 0\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Array must not be empty\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if not numbers:\n        raise ValueError(\"The input array must not be empty\")\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if not numbers:  # Check if the array is empty\n        return 0\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if not numbers:  # Check if the list is empty\n        return 0\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not arr:  # Check if the array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    if not numbers:\n        raise ValueError(\"The array cannot be empty\")\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 56.0, "profiled": [{"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n    return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 90.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    # Use regex to find all substrings that are enclosed in double quotes\n    return [match.strip('\"') for match in re.findall(r'\"(.*?)\"', s)]", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings within quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings that are enclosed in double quotes\n    values = re.findall(r'\"(.*?)\"', s)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all substrings within quotation marks\n    return [match.strip('\"') for match in re.findall(r'\"(.*?)\"', text)]", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all substrings within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings within double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings between double quotes\n    return [match.group(1) for match in re.finditer(r'\"(.*?)\"', input_string)]", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings within quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings in quotation marks\n    values = re.findall(r'\"(.*?)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all values enclosed in quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s: str) -> list:\n    # Use regular expression to find all substrings within quotation marks\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings within quotation marks\n    return [match.strip('\"') for match in re.findall(r'\"(.*?)\"', input_string)]", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regex to find all substrings that are enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings within quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regex to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s: str) -> list:\n    # Use regex to find all substrings enclosed in quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    # Use regular expression to find all substrings within double quotes\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 34.567901234567906, "dps_norm": 28.571428571428573, "pass@1": 97.0, "profiled": [{"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if nums.count(num) == 1 and num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for num in numbers:\n        if numbers.count(num) == 1 and num not in unique_numbers:\n            unique_numbers.append(num)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            unique_numbers.append(num)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if nums.count(num) == 1 and num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1 and number not in unique_numbers:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            unique_numbers.append(number)\n    return unique_numbers", "matching_cluster_idx": 1}]}, "Mbpp/578": {"dps": 60.33333333333333, "dps_norm": 64.0909090909091, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Get the length of the lists\n    n = len(list1)\n    \n    # Loop through the indices of the lists\n    for i in range(n):\n        # Append the elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Get the length of the lists (since they are of the same length)\n    length = len(list1)\n    \n    # Loop through the lists using their indices\n    for i in range(length):\n        # Append the elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n    \n    Returns:\n    list: A single flat list containing interleaved elements from the input lists.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the range of the length of one of the lists\n    for i in range(len(list1)):\n        # Append the elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to hold the result\n    result = []\n    \n    # Iterate over the range of the length of one of the lists\n    for i in range(len(list1)):\n        # Append the elements from each list at index i\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to hold the result\n    result = []\n    \n    # Use the range of the lists to iterate through them\n    for i in range(len(list1)):\n        # Append elements from each list in order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through the length of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    # Use the zip function to pair elements from each list\n    for (a, b, c) in zip(list1, list2, list3):\n        # Append the elements from each list in order\n        result.extend([a, b, c])\n    return result", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 31.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the array, return the array as is.\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list at the nth element\n    first_part = lst[:n]\n    second_part = lst[n:]\n    # Add the first part to the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n is out of the range of the array\")\n    \n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the array, return the array as is.\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n is out of the range of the array\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n > len(arr):\n        raise ValueError(\"n is greater than the length of the array\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n is out of the range of the array\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the array, return the array as is\n    return arr[n:] + arr[:n]  # Split the array and reassemble", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n is out of the range of the array length\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list at the nth element\n    first_part = lst[:n]\n    second_part = lst[n:]\n    # Add the first part to the end\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n > len(arr):\n        raise ValueError(\"n is greater than the length of the array\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n is out of the range of the array\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the bounds of the array\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n > len(arr):\n        raise ValueError(\"n is greater than the length of the array\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n >= len(arr):\n        return arr  # If n is greater than or equal to the length of the array, return the array as is.\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n    \n    Args:\n    lst (list): A list of elements.\n    \n    Returns:\n    tuple: A tuple with the same elements as the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n    \n    Args:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Given a list of numbers, return the difference between the largest and smallest number.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in a given list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between the largest and smallest value in a given list.\n    assert big_diff([1,2,3,4]) == 3\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 40.53333333333334, "dps_norm": 51.0, "pass@1": 42.0, "profiled": [{"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n + 1):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Sum of the product of consecutive binomial coefficients.\"\"\"\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Find the sum of the product of consecutive binomial coefficients up to n.\"\"\"\n    sum_product = 0\n    for k in range(n + 1):\n        sum_product += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Sum of the product of consecutive binomial coefficients.\"\"\"\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Find the sum of the product of consecutive binomial coefficients.\"\"\"\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients up to n.\"\"\"\n    sum_product = 0\n    for k in range(n + 1):\n        sum_product += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients up to n.\"\"\"\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Sum of the product of consecutive binomial coefficients.\"\"\"\n    result = 0\n    for i in range(n + 1):\n        result += binomial_coefficient(n, i) * binomial_coefficient(n, i + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    sum_product = 0\n    for k in range(n + 1):\n        sum_product += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n + 1):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\ndef sum_Of_product(n):\n    sum_product = 0\n    for k in range(n + 1):\n        sum_product += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_product", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    result = 0\n    for k in range(n + 1):\n        result += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return result", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    sum_ = 0\n    for k in range(n + 1):\n        sum_ += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Sum of the product of consecutive binomial coefficients.\"\"\"\n    sum_ = 0\n    for k in range(n + 1):\n        sum_ += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_", "matching_cluster_idx": 4}, {"solution": "def binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient 'n choose k'.\"\"\"\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\ndef sum_Of_product(n):\n    \"\"\"Find the sum of the product of consecutive binomial coefficients up to n.\"\"\"\n    sum_ = 0\n    for k in range(n + 1):\n        sum_ += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return sum_", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    result = 0\n    for k in range(n + 1):\n        result += comb(n, k) * comb(n, k+1)\n    return result", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n + 1):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()  # Split the string into a list of words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()  # Split the string into words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()  # Split the string into words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()  # Split the string into a list of words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses the order of words in the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with the words reversed.\n    \"\"\"\n    words = s.split()  # Split the string into words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()  # Split the string into a list of words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()  # Split the string into words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()  # Split the string into words\n    reversed_words = words[::-1]  # Reverse the list of words\n    return ' '.join(reversed_words)  # Join the reversed list back into a string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    return ' '.join(words[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    if k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k is out of the range of the list\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k > 0 and k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Ensure k is within the bounds of the list\n    if k <= 0 or k > len(lst):\n        return lst\n    # Use list slicing to return a new list with the k'th element removed\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Check if k is within the bounds of the list\n    if k > 0 and k <= len(lst):\n        # Use slicing to create a new list excluding the k'th element\n        return lst[:k-1] + lst[k:]\n    else:\n        # If k is out of bounds, return the list as is\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k > 0 and k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        raise ValueError(\"Index k is out of range\")", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k > 0 and k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k <= 0 or k > len(lst):\n        raise ValueError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Check if k is within the bounds of the list\n    if k > 0 and k <= len(lst):\n        # Use list slicing to return a new list with the k'th element removed\n        return lst[:k-1] + lst[k:]\n    else:\n        # If k is out of bounds, return the original list\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n    \n    Args:\n    lst (list): The list from which the k'th element is to be removed.\n    k (int): The index of the element to be removed, starting from 1.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"Index out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of range\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of range\n    return lst[:k-1] + lst[k:]  # Slice the list to exclude the k'th element", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst  # Return the original list if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 47.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"The n'th column does not exist in the matrix.\")\n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Check if the matrix is empty or n is out of range\n    if not matrix or n >= len(matrix[0]):\n        return None\n    \n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the n'th column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of bounds\")\n    \n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range\")\n    \n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise IndexError(\"Column index out of range\")\n    \n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Ensure n is within the bounds of the matrix columns\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of bounds\")\n    \n    # Extract the n'th column from the matrix\n    nth_column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the n'th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range.\")\n    \n    max_value = float('-inf')\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range\")\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or n >= len(matrix[0]):\n        return None\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if n >= len(matrix[0]):\n        raise ValueError(\"Column index is out of range.\")\n    \n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if not matrix or not matrix[0]:\n        raise ValueError(\"Matrix must be non-empty and have at least one row with elements\")\n    if n >= len(matrix[0]):\n        raise IndexError(\"Column index is out of range\")\n    \n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 99.99999999999999, "dps_norm": 100.0, "pass@1": 11.0, "profiled": [{"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s: str) -> str:\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(\" \", \"_\") if \" \" in s else s.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Initialize a list to store zero elements\n    zero = [num for num in nums if num == 0]\n    # Concatenate non-zero elements with zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Initialize two lists: one for non-zero elements and one for zeros\n    non_zero = [x for x in num_list if x != 0]\n    zero = [x for x in num_list if x == 0]\n    # Concatenate the non-zero list and the zero list\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to store non-zero elements\n    non_zeros = [num for num in nums if num != 0]\n    # Create a list to store zero elements\n    zeros = [num for num in nums if num == 0]\n    # Combine the non-zero and zero elements\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Create a list to store non-zero elements\n    non_zero = [num for num in num_list if num != 0]\n    # Count the number of zeros in the original list\n    zero_count = num_list.count(0)\n    # Append the zeros to the end of the non-zero list\n    result = non_zero + [0] * zero_count\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Create two lists: one for non-zero elements and one for zeros\n    non_zero = [x for x in num_list if x != 0]\n    zero = [x for x in num_list if x == 0]\n    \n    # Concatenate the non-zero list and the zero list\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Filter out all non-zero elements\n    non_zero_elements = [num for num in nums if num != 0]\n    # Count the number of zeros in the original list\n    zero_count = nums.count(0)\n    # Append the zeros to the end of the non-zero elements list\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Create a list to store zero elements\n    zero = [num for num in nums if num == 0]\n    # Combine non-zero elements with zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to store non-zero elements\n    non_zero = [x for x in nums if x != 0]\n    # Create a list to store the zero elements\n    zero = [x for x in nums if x == 0]\n    # Combine the non-zero and zero lists\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to store non-zero elements\n    non_zeros = [x for x in nums if x != 0]\n    # Create a list to store the count of zeros\n    zeros = [0] * (len(nums) - len(non_zeros))\n    # Combine non-zero elements with zeros\n    return non_zeros + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to hold non-zero elements\n    non_zero_elements = [num for num in nums if num != 0]\n    # Calculate the number of zeros to append\n    zero_count = len(nums) - len(non_zero_elements)\n    # Append the zeros to the end of the non-zero elements list\n    result = non_zero_elements + [0] * zero_count\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Function to move all zeroes to the end of the given list.\n    \"\"\"\n    # Initialize a pointer to track the position where the next non-zero element should be placed\n    insert_position = 0\n    \n    # Iterate through the list\n    for num in nums:\n        if num != 0:\n            nums[insert_position] = num\n            insert_position += 1\n    \n    # Fill the remaining positions with zeroes\n    for i in range(insert_position, len(nums)):\n        nums[i] = 0\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Create a list to store non-zero elements\n    non_zero = [num for num in num_list if num != 0]\n    # Create a list to store zero elements\n    zero = [num for num in num_list if num == 0]\n    # Concatenate non-zero elements with zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Create a list to hold non-zero elements\n    non_zero = [num for num in num_list if num != 0]\n    # Create a list to hold zero elements\n    zero = [num for num in num_list if num == 0]\n    # Combine non-zero elements with zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Filter out all non-zero elements\n    non_zeroes = [x for x in nums if x != 0]\n    # Count the number of zeroes\n    zero_count = nums.count(0)\n    # Combine non-zero elements with the same number of zeroes at the end\n    return non_zeroes + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to hold non-zero elements\n    non_zeroes = [num for num in nums if num != 0]\n    # Create a list to hold zeroes\n    zeroes = [0] * (len(nums) - len(non_zeroes))\n    # Combine non-zeroes and zeroes\n    return non_zeroes + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(num_list):\n    # Create a list to hold non-zero elements\n    non_zero = [num for num in num_list if num != 0]\n    # Count the number of zeros in the original list\n    zero_count = num_list.count(0)\n    # Append the zeros to the end of the non-zero list\n    result = non_zero + [0] * zero_count\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to store non-zero elements\n    non_zero = [x for x in nums if x != 0]\n    # Create a list to store zero elements\n    zero = [x for x in nums if x == 0]\n    # Concatenate non-zero elements with zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to hold non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Create a list to hold zero elements\n    zero = [0] * (len(nums) - len(non_zero))\n    # Concatenate the non-zero elements with the zero elements\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Create a list to hold non-zero elements\n    non_zeros = [x for x in nums if x != 0]\n    # Count the number of zeros in the original list\n    zero_count = nums.count(0)\n    # Append the zeros to the end of the non-zero elements\n    result = non_zeros + [0] * zero_count\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \"\"\"\n    non_zero_elements = [num for num in nums if num != 0]\n    zero_elements = [num for num in nums if num == 0]\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 63.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += numbers[i] ^ numbers[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += arr[i] ^ arr[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += arr[i] ^ arr[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += nums[i] ^ nums[j]\n    return total_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 71.80851063829786, "dps_norm": 73.33333333333333, "pass@1": 99.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array upto a given position k.\n    \n    Args:\n    arr (list): The list to be reversed.\n    k (int): The position upto which the array should be reversed.\n    \n    Returns:\n    list: The array after reversing the first k elements.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array up to the given position k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if k is 0 or negative, return the array as is\n    if k <= 0:\n        return arr\n    # Reverse the array from start to k (exclusive)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Function to reverse an array upto a given position k.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to a given position k.\n    \n    Args:\n    arr (list): The list of elements to reverse.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The modified array after reversing up to position k.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k is out of bounds for the array\")\n    \n    # Reverse the array up to k\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if k is within the bounds of the array\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Position k is out of bounds\")\n    \n    # Reverse the array from the start up to the kth position\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to a given position k.\n    \n    Args:\n    arr (list): The list to be reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array after reversing up to position k.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to a given position k.\n    :param arr: List[int] - The array to be reversed\n    :param k: int - The position up to which the array should be reversed\n    :return: List[int] - The array after reversing up to position k\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Args:\n    arr (list): The input list to reverse.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array reversed up to the position k.\n    \"\"\"\n    # Reverse the array from the start up to the k-th position\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    This function reverses an array up to a given position k.\n    Args:\n    arr (list): The input list to be reversed.\n    k (int): The position upto which the array should be reversed.\n    Returns:\n    list: The array after reversing the elements up to position k.\n    \"\"\"\n    # Reverse the array up to the k-th element (0-indexed)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array from the start up to the k-th position\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Args:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array reversed up to the k-th position.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to a given position k.\n    \n    Parameters:\n    arr (list): The list of elements.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the elements up to position k reversed.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to a given position k.\n    \n    Args:\n    arr (list): The list of elements.\n    k (int): The position upto which the array should be reversed.\n    \n    Returns:\n    list: The array reversed up to position k.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to a given position k.\n    \n    Args:\n    arr (list): The list of elements to reverse.\n    k (int): The position upto which the array should be reversed.\n    \n    Returns:\n    list: The array after reversing elements up to position k.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Ensure k is within the bounds of the array\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Position k is out of bounds\")\n    \n    # Reverse the array from the start to k (exclusive)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Args:\n    arr (list): The list of elements to reverse.\n    k (int): The position upto which the array needs to be reversed.\n    \n    Returns:\n    list: The array after reversing up to position k.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Position k is out of bounds for the array.\")\n    \n    # Reverse the array up to k (inclusive)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Check if k is within the bounds of the array\n    if k < 0 or k > len(arr):\n        return arr  # Return the original array if k is out of bounds\n    \n    # Reverse the array from start to k (inclusive)\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array from the start up to the k-th position\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the array up to a given position k.\n    Args:\n    arr (list): The list to be reversed.\n    k (int): The position upto which the array should be reversed.\n    Returns:\n    list: The array reversed up to position k.\n    \"\"\"\n    # Reverse the array up to position k using slicing\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 40.21978021978022, "dps_norm": 75.0, "pass@1": 26.0, "profiled": [{"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the tuple to a list so it can be modified\n    temp_list = list(input_tuple)\n    # Append the dictionary to the end of the list\n    temp_list.append(input_dict)\n    # Convert the list back to a tuple\n    output_tuple = tuple(temp_list)\n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Combine the tuple and dictionary into a new list\n    combined_list = list(input_tuple) + [input_dict]\n    # Convert the list back to a tuple\n    combined_tuple = tuple(combined_list)\n    return combined_tuple", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(tup)\n    # Add the dictionary to the end of the list\n    temp_list.append(dictionary)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to the end of a tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple to which the dictionary will be added.\n    input_dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple that includes the original tuple elements followed by the dictionary.\n    \"\"\"\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Add a dictionary to the end of a tuple and return the new tuple.\n    \n    Args:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the dictionary added at the end.\n    \"\"\"\n    # Combine the tuple and the dictionary into a list\n    combined_list = list(input_tuple) + [input_dict]\n    # Convert the list back to a tuple\n    result_tuple = tuple(combined_list)\n    return result_tuple", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Combine the tuple and the dictionary into a new list\n    combined_list = list(tup) + [dictionary]\n    # Convert the list back to a tuple\n    combined_tuple = tuple(combined_list)\n    return combined_tuple", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(input_tuple)\n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    # Convert the list back to a tuple\n    output_tuple = tuple(temp_list)\n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Combine the tuple and the dictionary into a new tuple that includes the dictionary as the last element\n    combined_tuple = input_tuple + (input_dict,)\n    return combined_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tuple, test_dict):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(test_tuple)\n    # Add the dictionary to the end of the list\n    temp_list.append(test_dict)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to allow modification\n    tup_list = list(tup)\n    # Update the list with the dictionary items\n    tup_list.append(dictionary)\n    # Convert the list back to a tuple\n    return tuple(tup_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tuple, test_dict):\n    # Concatenate the tuple and the dictionary into a single iterable\n    combined = (*test_tuple, test_dict)\n    return combined", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the tuple to a list to allow modification (since tuples are immutable)\n    temp_list = list(input_tuple)\n    # Add the dictionary to the end of the list\n    temp_list.append(input_dict)\n    # Convert the list back to a tuple\n    output_tuple = tuple(temp_list)\n    return output_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(tup)\n    # Add the dictionary to the end of the list\n    temp_list.append(dictionary)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the end of a tuple and return the new tuple.\n    \n    Args:\n    tup (tuple): The original tuple to which the dictionary will be appended.\n    dictionary (dict): The dictionary to be appended to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the original tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(tup)\n    # Add the dictionary to the end of the list\n    temp_list.append(dictionary)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Combine the tuple and the dictionary into a new list\n    combined_list = list(input_tuple) + [input_dict]\n    # Convert the list back to a tuple\n    result_tuple = tuple(combined_list)\n    return result_tuple", "matching_cluster_idx": 1}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    # Convert the tuple to a list to allow modification\n    tuple_list = list(input_tuple)\n    # Add the dictionary to the end of the list\n    tuple_list.append(input_dict)\n    # Convert the list back to a tuple\n    result_tuple = tuple(tuple_list)\n    return result_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to allow modification\n    temp = list(tup)\n    # Add the dictionary to the end of the list\n    temp.append(dictionary)\n    # Convert the list back to a tuple\n    return tuple(temp)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tuple_input, dict_input):\n    # Convert the tuple to a list so we can append\n    tuple_list = list(tuple_input)\n    # Append the dictionary to the list\n    tuple_list.append(dict_input)\n    # Convert the list back to a tuple and return\n    return tuple(tuple_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tuple, dict_to_add):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(test_tuple)\n    # Add the dictionary to the end of the list\n    temp_list.append(dict_to_add)\n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    return result_tuple", "matching_cluster_idx": 3}]}, "Mbpp/725": {"dps": 67.97814207650272, "dps_norm": 72.5, "pass@1": 87.0, "profiled": [{"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extract values between quotation marks \" \" of the given string.\n    \"\"\"\n    # Use regex to find all substrings within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings within quotation marks\n    return [match.group(1) for match in re.finditer(r'\"(.*?)\"', text)]", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings within quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings in quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regex to find all substrings enclosed in quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings between double quotes\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regex to find all substrings enclosed in quotation marks\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regex to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regex to find all substrings enclosed in quotation marks\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all substrings within double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    # Use regular expression to find all matches between quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 95.29069767441861, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for char, replacement in replacements.items():\n        text = text.replace(char, replacement)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(\"[ ,.]\", \":\", text)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    # Replace all spaces, commas, and dots with a colon\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for char, replacement in replacements.items():\n        text = text.replace(char, replacement)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {' ': ':', ',': ':', '.': ':'}\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {\n        ' ': ':',\n        ',': ':',\n        '.': ':'\n    }\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    replacements = {\n        ' ': ':',\n        ',': ':',\n        '.': ':'\n    }\n    for old, new in replacements.items():\n        text = text.replace(old, new)\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    replaced_text = text.replace(' ', ':').replace(',', ':').replace('.', ':')\n    return replaced_text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 50.981818181818184, "dps_norm": 61.111111111111114, "pass@1": 99.0, "profiled": [{"solution": "def tuple_to_dict(test_tup):\n    res = {}\n    for i in range(0, len(test_tup) - 1, 2):\n        res[test_tup[i]] = test_tup[i + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result[key] = value\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key, value = input_tuple[i], input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key, value = input_tuple[i], input_tuple[i+1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple length must be even.\")\n    \n    result = {}\n    for i in range(0, len(t), 2):\n        key, value = t[i], t[i+1]\n        result[key] = value\n    return result", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(t), 2):\n        result[t[i]] = t[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tuple):\n    result_dict = {}\n    for i in range(0, len(test_tuple), 2):\n        if i + 1 < len(test_tuple):\n            result_dict[test_tuple[i]] = test_tuple[i + 1]\n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(tup):\n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(tup), 2):\n        # Check if there are at least two more elements to pair\n        if i + 1 < len(tup):\n            result_dict[tup[i]] = tup[i + 1]\n        else:\n            # If only one element is left, it won't have a pair\n            result_dict[tup[i]] = None\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(test_tup):\n    res = dict(zip(test_tup[::2], test_tup[1::2]))\n    return res", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(test_tup):\n    # Check if the tuple has an even number of elements\n    if len(test_tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n\n    # Create a dictionary using adjacent elements\n    res = {}\n    for i in range(0, len(test_tup), 2):\n        res[test_tup[i]] = test_tup[i + 1]\n\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple length must be even.\")\n    \n    result_dict = {}\n    for i in range(0, len(tup), 2):\n        key = tup[i]\n        value = tup[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(t), 2):\n        key, value = t[i], t[i+1]\n        result[key] = value\n    return result", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(t), 2):\n        key = t[i]\n        value = t[i + 1]\n        result[key] = value\n    return result", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple, taking two elements at a time\n    for i in range(0, len(input_tuple), 2):\n        # Check if there are at least two more elements left\n        if i + 1 < len(input_tuple):\n            # Assign the pair of elements to the dictionary\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(tup), 2):\n        result[tup[i]] = tup[i + 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(tup), 2):\n        result[tup[i]] = tup[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements\")\n    \n    result = {}\n    for i in range(0, len(tup), 2):\n        result[tup[i]] = tup[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Check if the tuple has an even number of elements\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n    \n    # Create a dictionary from the tuple elements\n    result_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        result_dict[key] = value\n    return result_dict", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 17.123287671232877, "dps_norm": 41.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def check_none(test_tuple):\n    return any(element is None for element in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(x is None for x in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if None is in the tuple\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(x is None for x in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(x is None for x in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    # Check if any element in the tuple is None\n    return any(element is None for element in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(x is None for x in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    return any(item is None for item in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(element is None for element in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    return any(item is None for item in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tuple):\n    return any(element is None for element in test_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n    return any(item is None for item in test_tuple)", "matching_cluster_idx": 1}]}, "Mbpp/750": {"dps": 88.70748299319727, "dps_norm": 90.0, "pass@1": 96.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds elements of the given tuple to the end of the given list.\n\n    Args:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple containing elements to be added to the list.\n\n    Returns:\n    list: The list after adding the elements of the tuple.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds elements from the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The list to which elements will be added.\n    tup (tuple): The tuple containing elements to be added to the list.\n    \n    Returns:\n    list: The list after adding elements from the tuple.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The list after adding the tuple elements.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list by adding the elements from the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n    # Convert tuple1 to a list and extend list1 with it\n    list1.extend(list(tuple1))\n    return list1", "matching_cluster_idx": 3}, {"solution": "def add_tuple(list_1, tuple_1):\n    # Append the elements of the tuple to the end of the list\n    list_1.extend(tuple_1)\n    return list_1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n    # Combine the list and the tuple\n    combined = list1 + list(tuple1)\n    return combined", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list_arg, tuple_arg):\n    # Extend the list with the elements of the tuple\n    list_arg.extend(tuple_arg)\n    return list_arg", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Convert the tuple to a list and extend the original list\n    lst.extend(list(tup))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    # Extend the list by adding the elements from the tuple\n    list1.extend(tuple1)\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list by the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list with the elements of the tuple\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n    # Extend the list with the elements of the tuple\n    list1.extend(tuple1)\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n    # Extend the list with the elements of the tuple\n    list1.extend(tuple1)\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Convert the tuple to a list and extend the original list\n    test_list.extend(list(test_tup))\n    return test_list", "matching_cluster_idx": 3}, {"solution": "def add_tuple(list_arg, tuple_arg):\n    # Extend the list by appending elements from the tuple\n    list_arg.extend(tuple_arg)\n    return list_arg", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Extend the list by adding the elements of the tuple at the end\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 87.71812080536913, "dps_norm": 72.5, "pass@1": 98.0, "profiled": [{"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Function to find minimum k records from tuple list.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_tuples, K):\n    # Sort the list of tuples based on the second element (the number)\n    sorted_tuples = sorted(test_tuples, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_tuples[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples.\n    \n    Args:\n    records (list of tuples): List of tuples where each tuple contains a name and a score.\n    k (int): Number of minimum records to find.\n    \n    Returns:\n    list of tuples: List of k minimum records sorted by score.\n    \"\"\"\n    # Sort the records based on the score\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list based on the second element of each tuple (the score)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list by the second element of each tuple (the score)\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list by the second element (score) in descending order\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_tuples, K):\n    # Sort the tuples by the second element (the number) in ascending order\n    sorted_tuples = sorted(test_tuples, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_tuples[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list based on the second element of each tuple (the score)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_tuples, K):\n    # Sort the tuples based on the second element (score)\n    sorted_tuples = sorted(test_tuples, key=lambda x: x[1])\n    # Return the first K tuples from the sorted list\n    return sorted_tuples[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second element (score)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuple_list, k):\n    # Sort the tuple list based on the second element of each tuple (the score)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_tup, K):\n    # Sort the tuple list based on the second element of each tuple\n    sorted_tup = sorted(test_tup, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_tup[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list based on the second element of each tuple (the score)\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_tup, K):\n    # Sort the list based on the second element of each tuple (the score)\n    sorted_tup = sorted(test_tup, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_tup[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list based on the second element of each tuple (the score)\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list based on the second element of each tuple (the score)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_tup, K):\n    # Sort the list of tuples by the second element (score)\n    sorted_tuples = sorted(test_tup, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_tuples[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 73.27586206896552, "dps_norm": 81.25, "pass@1": 64.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by checking the index positions\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by checking each element at the same index in all three lists\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find common elements that appear at the same index in all three lists\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements that appear at the same indices in all three lists\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements based on their indices in all three lists\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by checking indices\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for index, (elem1, elem2, elem3) in enumerate(zip(l1, l2, l3)):\n        if elem1 == elem2 == elem3:\n            common_elements.append(elem1)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by checking each index in all three lists\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by comparing the lists element-wise\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length among the three lists to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, append it to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by comparing the indices of elements in all three lists\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists using zip to get elements at the same index\n    for item1, item2, item3 in zip(l1, l2, l3):\n        # Check if the element is the same in all three lists\n        if item1 == item2 == item3:\n            common_elements.append(item1)\n    \n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length among the three lists to avoid index out of range\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, append it to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements by checking each element at the same index in all three lists\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3):  # Ensure the index exists in all lists\n            if l1[i] == l2[i] == l3[i]:\n                common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for index, (item1, item2, item3) in enumerate(zip(l1, l2, l3)):\n        if item1 == item2 == item3:\n            common_elements.append(item1)\n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the common elements that appear at the same indices\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 20.0, "profiled": [{"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 91.38996138996139, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple to use as a dictionary key\n        sublist_tuple = tuple(sublist)\n        # Increment the count for this sublist in the dictionary\n        sublist_count[sublist_tuple] = sublist_count.get(sublist_tuple, 0) + 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        # Count the occurrences of each sublist\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    sublist_count = defaultdict(int)\n    for sublist in lst:\n        # Convert each sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        sublist_count[sublist_tuple] += 1\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple since tuples are hashable and can be keys in a dictionary\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    counts = {}\n    \n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since tuples are hashable and can be dictionary keys)\n        sublist_tuple = tuple(sublist)\n        \n        # Check if the tuple is already in the dictionary\n        if sublist_tuple in counts:\n            # If yes, increment its count\n            counts[sublist_tuple] += 1\n        else:\n            # If not, add it to the dictionary with a count of 1\n            counts[sublist_tuple] = 1\n    \n    # Return the dictionary with tuples as keys and counts as values\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple to make it hashable and usable as a dictionary key\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple as dictionary keys must be hashable\n        sublist_tuple = tuple(sublist)\n        # Count the occurrences of each tuple\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple since tuples are hashable and can be used as dictionary keys\n        sublist_tuple = tuple(sublist)\n        # Increment the count for this sublist tuple in the dictionary\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # Convert each sublist to a tuple\n    tuple_list = [tuple(sublist) for sublist in lst]\n    # Count the occurrences of each tuple\n    counts = Counter(tuple_list)\n    # Return the counts as a dictionary\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    sublist_count = defaultdict(int)\n    for sublist in lst:\n        # Convert the sublist to a tuple since tuples are hashable and can be used as dictionary keys\n        sublist_tuple = tuple(sublist)\n        sublist_count[sublist_tuple] += 1\n    \n    # Convert the defaultdict to a regular dictionary for the final output\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    sublist_count = defaultdict(int)\n    for sublist in lst:\n        # Convert each sublist to a tuple to use it as a dictionary key\n        tuple_sublist = tuple(sublist)\n        sublist_count[tuple_sublist] += 1\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    counts = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since tuples are hashable and can be keys in a dictionary)\n        sublist_tuple = tuple(sublist)\n        \n        # Increment the count for this tuple in the dictionary\n        counts[sublist_tuple] = counts.get(sublist_tuple, 0) + 1\n    \n    # Return the dictionary with counts\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        # Convert sublist to a tuple since tuples are hashable and can be used as dictionary keys\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    count_dict = defaultdict(int)\n    for sublist in lst:\n        # Convert each sublist to a tuple (since tuples are hashable and can be used as dictionary keys)\n        sublist_tuple = tuple(sublist)\n        count_dict[sublist_tuple] += 1\n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        # Convert each sublist to a tuple (immutable and hashable)\n        sublist_tuple = tuple(sublist)\n        # Count the occurrences of each tuple\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert the sublist to a tuple since tuples are hashable and can be used as dictionary keys\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert each sublist to a tuple to use as a dictionary key\n        sublist_tuple = tuple(sublist)\n        # Count the occurrences of each unique sublist\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        # Convert each sublist to a tuple (since tuples are hashable and can be dictionary keys)\n        sublist_tuple = tuple(sublist)\n        # Count the occurrences of each unique sublist\n        if sublist_tuple in sublist_count:\n            sublist_count[sublist_tuple] += 1\n        else:\n            sublist_count[sublist_tuple] = 1\n    return sublist_count", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 43.175182481751825, "dps_norm": 73.75, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(lst):\n    return all(element == lst[0] for element in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # If the list is empty, return False as there's no distinct element\n        return False\n    first_element = numbers[0]  # Take the first element as a reference\n    for number in numbers[1:]:  # Iterate over the rest of the elements\n        if number != first_element:  # If any element is different from the first one\n            return False  # The list does not contain only one distinct element\n    return True  # If the loop completes without returning False, all elements are the same", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False  # An empty list does not contain a single distinct element\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False  # Found a different element, so return False\n    return True  # All elements are the same", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    # Check if the list is empty or has only one element\n    if not numbers or len(set(numbers)) == 1:\n        return True\n    return False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Use a set to find the unique elements in the list\n    unique_set = set(nums)\n    # Check if the length of the set is 1, which means all elements are the same\n    return len(unique_set) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    return all(element == lst[0] for element in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # If the list is empty, we cannot have a unique element\n        return False\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    return all(num == numbers[0] for num in numbers)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False  # An empty list does not contain a single distinct element\n    first_element = numbers[0]\n    for num in numbers:\n        if num != first_element:\n            return False  # Found a different element, so return False\n    return True  # All elements are the same", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False  # An empty list does not contain a single distinct element\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False\n    first_element = numbers[0]\n    for num in numbers:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False\n    first_element = numbers[0]\n    for num in numbers:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False  # An empty list does not contain a single distinct element\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False  # Found a different element, so return False\n    return True  # All elements are the same", "matching_cluster_idx": 5}, {"solution": "def unique_Element(nums):\n    if not nums:  # Check if the list is empty\n        return False\n    first_element = nums[0]\n    for num in nums:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # Check if the list is empty\n        return False  # Assuming empty list does not contain one distinct element\n    first_element = numbers[0]\n    for num in numbers:\n        if num != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    if not numbers:  # If the list is empty, we cannot have a unique element\n        return False\n    first_element = numbers[0]\n    for number in numbers:\n        if number != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return False\n    # Use a set to find unique elements\n    unique_set = set(numbers)\n    # Return True if there's only one unique element\n    return len(unique_set) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digits in the given string.\n    \n    Args:\n    input_string (str): The string to be evaluated.\n    \n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Function to count number of digits in a given string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    This function counts the number of digits in a given string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 63.27102803738318, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list of items.\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items from the input list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 4}]}, "Mbpp/775": {"dps": 94.39999999999999, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(numbers):\n    for i in range(1, len(numbers), 2):  # Start from index 1 and step by 2\n        if numbers[i] % 2 == 0:  # Check if the number at odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to check odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to check odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2\n        if lst[i] % 2 == 0:  # Check if the number at the odd position is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Iterate over odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Iterate over odd indices starting from 1\n        if lst[i] % 2 == 0:  # Check if the number at the odd position is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to check odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Iterate over odd positions\n        if lst[i] % 2 == 0:  # Check if the number at the odd position is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for i in range(1, len(numbers), 2):  # Iterate over odd indices\n        if numbers[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for i in range(1, len(numbers), 2):  # Start from index 1 and step by 2\n        if numbers[i] % 2 == 0:  # Check if the number at odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for i in range(1, len(numbers), 2):\n        if numbers[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Iterate over odd indices starting from 1\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for i in range(1, len(numbers), 2):\n        if numbers[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    for i in range(1, len(numbers), 2):  # Start at index 1 and step by 2\n        if numbers[i] % 2 == 0:  # Check if the number at the odd position is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start at index 1 and step by 2 to check only odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to check odd indices\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):  # Iterate over odd indices starting from 1\n        if lst[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 28.80690737833595, "dps_norm": 45.2991452991453, "pass@1": 13.0, "profiled": [{"solution": "def find_sum(numbers):\n    unique_numbers = set(numbers)\n    sum_unique = sum(unique_numbers)\n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = []\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n    return sum(unique_elements)", "matching_cluster_idx": 1}, {"solution": "def find_sum(numbers):\n    unique_numbers = []\n    for num in numbers:\n        if num not in unique_numbers:\n            unique_numbers.append(num)\n    return sum(unique_numbers)", "matching_cluster_idx": 2}, {"solution": "def find_sum(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    return sum(unique_numbers)", "matching_cluster_idx": 1}, {"solution": "def find_sum(lst):\n    element_sum = 0\n    seen = set()\n    for element in lst:\n        if element not in seen:\n            element_sum += element\n            seen.add(element)\n    return element_sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    unique_elements = []\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n    return sum(unique_elements)", "matching_cluster_idx": 1}, {"solution": "def find_sum(lst):\n    element_sum = 0\n    seen = set()\n    for element in lst:\n        if element not in seen:\n            element_sum += element\n            seen.add(element)\n    return element_sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    return sum(unique_numbers)", "matching_cluster_idx": 1}, {"solution": "def find_sum(lst):\n    sum_of_elements = 0\n    seen = set()\n    for element in lst:\n        if element not in seen:\n            sum_of_elements += element\n            seen.add(element)\n    return sum_of_elements", "matching_cluster_idx": 4}, {"solution": "def find_sum(numbers):\n    unique_numbers = []\n    for number in numbers:\n        if number not in unique_numbers:\n            unique_numbers.append(number)\n    return sum(unique_numbers)", "matching_cluster_idx": 1}, {"solution": "def find_sum(lst):\n    element_sum = 0\n    seen = set()\n    \n    for element in lst:\n        if element not in seen:\n            element_sum += element\n            seen.add(element)\n    \n    return element_sum", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    unique_elements = []\n    for element in lst:\n        if element not in unique_elements:\n            unique_elements.append(element)\n    return sum(unique_elements)", "matching_cluster_idx": 1}, {"solution": "def find_sum(numbers):\n    unique_numbers = set(numbers)  # Remove duplicates by converting to a set\n    return sum(unique_numbers)  # Sum the unique elements", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to replace all spaces with an empty string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the str.replace method to replace all spaces with an empty string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    if not lists:\n        return []\n    \n    max_sum = float('-inf')\n    max_list = []\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    if not lists:\n        return []\n    max_sum = float('-inf')\n    max_list = []\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    # Initialize the result list to an empty list\n    result = []\n    \n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # If the current sum is greater than the max_sum, update max_sum and result\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result = lst\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    # Initialize the result list to an empty list\n    result_list = []\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # If the current sum is greater than the max_sum, update max_sum and result_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result_list = lst\n            \n    return result_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Find the list with the maximum sum of elements\n    max_sum_list = max(list_of_lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    if not lists:\n        return []\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    # Initialize the result list to an empty list\n    result_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # If the current sum is greater than the maximum sum found so far\n        if current_sum > max_sum:\n            # Update the maximum sum and the result list\n            max_sum = current_sum\n            result_list = lst\n    \n    return result_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    max_sum = sum(list_of_lists[0])\n    max_list = list_of_lists[0]\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum = float('-inf')\n    max_list = []\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Find the list with the maximum sum of elements\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize the variable to store the list with the highest sum\n    max_sum_list = []\n    max_sum = float('-inf')\n    \n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # Update the max_sum and max_sum_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = lst\n    \n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize the variable to store the list with the highest sum\n    max_sum_list = []\n    # Initialize the variable to store the maximum sum found so far\n    max_sum = float('-inf')\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # Update the maximum sum and the list associated with this sum if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_list = lst\n    \n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    if not lists:\n        return []\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    if not lists:\n        return []\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    max_sum = float('-inf')\n    max_list = []\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum = float('-inf')\n    max_list = []\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize the maximum sum to a very small number\n    max_sum = float('-inf')\n    # Initialize the result list to an empty list\n    result_list = []\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        # If the current sum is greater than the max_sum, update max_sum and result_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            result_list = sublist\n    \n    return result_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize the maximum sum to negative infinity and the result list to None\n    max_sum = float('-inf')\n    max_list = None\n    \n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # If the current sum is greater than the max_sum, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    # Return the list with the highest sum of elements\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if the given tuple contains the value k or not.\n    \n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (int): The value to check for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n    \n    Args:\n    tup (tuple): The tuple to be checked.\n    k (int): The element to search for.\n    \n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    \"\"\"\n    Function to check if K is present in the given tuple.\n    \n    Args:\n    test_tup (tuple): The tuple to search within.\n    K (int): The integer to look for in the tuple.\n    \n    Returns:\n    bool: True if K is found in the tuple, False otherwise.\n    \"\"\"\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(input_tuple, k):\n    return k in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tuple, K):\n    return K in test_tuple", "matching_cluster_idx": 5}]}}}
