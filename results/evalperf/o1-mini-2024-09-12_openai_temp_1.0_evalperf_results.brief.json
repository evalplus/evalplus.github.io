{"date": "2024-11-04 06:28", "config": {"n_samples": 50, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 85.00738681020263, "dps_norm": 81.11533806360009, "pass@1": 88.83050847457628}, "eval": {"HumanEval/9": {"dps": 98.15457413249212, "dps_norm": 97.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until each given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of rolling maximum elements found up to each point in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 1, 5, 3, 7, 2])\n    [5, 5, 5, 5, 7, 7]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([10])\n    [10]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([5, 4, 3, 2, 1])\n    [5, 5, 5, 5, 5]\n    >>> rolling_max([2, 2, 2, 2])\n    [2, 2, 2, 2]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 1, 5, 3, 7, 7, 2])\n    [5, 5, 5, 5, 7, 7, 7]\n    >>> rolling_max([])\n    []\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found up to each position in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([5, 4, 3, 2, 1])\n    [5, 5, 5, 5, 5]\n    >>> rolling_max([2, 2, 2, 2])\n    [2, 2, 2, 2]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')  # Initialize to negative infinity to handle all integer inputs\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 1, 5, 3, 7, 7, 2])\n    [5, 5, 5, 5, 7, 7, 7]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([-1, -2, -3, -2, -1])\n    [-1, -1, -1, -1, -1]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    result.append(current_max)\n    \n    for num in numbers[1:]:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\nimport doctest\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum elements found until the given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    >>> rolling_max([5, 1, 5, 3, 7, 2])\n    [5, 5, 5, 5, 7, 7]\n    >>> rolling_max([])\n    []\n    >>> rolling_max([-1, -3, -2, -5])\n    [-1, -1, -1, -1]\n    \"\"\"\n    result: List[int] = []\n    current_max: int = float('-inf')\n\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 32.03488372093023, "dps_norm": 52.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    # Sort the numbers to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n\n    # Iterate through the sorted list and check adjacent differences\n    for i in range(1, len(sorted_numbers)):\n        if abs(sorted_numbers[i] - sorted_numbers[i - 1]) < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    # Sort the list to bring close elements together\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    Args:\n        numbers (List[float]): The list of numbers to check.\n        threshold (float): The distance threshold.\n\n    Returns:\n        bool: True if any two numbers are closer than the threshold, False otherwise.\n\n    Examples:\n        >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n        False\n        >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n        True\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([5.0], 0.1)\n    False\n    >>> has_close_elements([1.1, 1.2, 1.3, 1.4], 0.15)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    \n    sorted_numbers = sorted(numbers)\n    \n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        # If there are fewer than 2 numbers, no pair exists.\n        return False\n\n    # Sort the list to bring close elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        difference = abs(sorted_numbers[i+1] - sorted_numbers[i])\n        if difference < threshold:\n            return True\n\n    # If no such pair is found\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([5.0], 0.1)\n    False\n    >>> has_close_elements([1.5, 3.2, 4.8, 6.1], 1.0)\n    False\n    >>> has_close_elements([1.0, 1.2, 1.4, 1.6], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\nimport itertools\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to optimize the comparison\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([], 1.0)\n    False\n    >>> has_close_elements([1.5], 0.5)\n    False\n    >>> has_close_elements([1.0, 1.4, 1.7, 2.2], 0.5)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Sort the list to reduce the number of comparisons\n    sorted_numbers = sorted(numbers)\n    n = len(sorted_numbers)\n    \n    # Iterate through the sorted list and check adjacent elements\n    for i in range(n - 1):\n        if abs(sorted_numbers[i+1] - sorted_numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\nimport doctest\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate the Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and the mean:\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers must not be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_diffs) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    \n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers must not be empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    mad = sum(deviations) / len(deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    >>> mean_absolute_deviation([5.0, 5.0, 5.0, 5.0])\n    0.0\n    >>> mean_absolute_deviation([10.0, 20.0, 30.0])\n    6.666666666666667\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list of numbers is empty.\")\n    \n    mean = sum(numbers) / len(numbers)\n    total_deviation = sum(abs(x - mean) for x in numbers)\n    mad = total_deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 45.73643410852713, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lowercase_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(lowercase_string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaAaAa')\n    1\n    >>> count_distinct_characters('Hello, World!')\n    10\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lowercase_string = string.lower()\n    # Use a set to store distinct characters\n    distinct_characters = set(lowercase_string)\n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to evaluate.\n\n    Returns:\n        int: The number of distinct characters in the string, case-insensitive.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc')\n    3\n    >>> count_distinct_characters('Hello, World!')\n    10\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lower_string)\n    # Optionally, you can remove spaces or other non-relevant characters here\n    # For this example, all characters are considered\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(lower_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to make it case-insensitive\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lower_string)\n    # Return the count of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to evaluate.\n\n    Returns:\n        int: The number of distinct characters in the string, case-insensitive.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n        >>> count_distinct_characters('Hello World!')\n        8\n        >>> count_distinct_characters('')\n        0\n    \"\"\"\n    # Normalize the string to lowercase to ensure case-insensitivity\n    normalized_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    \n    # If you want to exclude non-alphabetic characters, uncomment the following line:\n    # unique_characters = set(filter(str.isalpha, normalized_string))\n    \n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the count case-insensitive\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lowercase_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lowercase_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lowercase_string = string.lower()\n    # Create a set of characters to eliminate duplicates\n    unique_characters = set(lowercase_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc')\n    3\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    >>> count_distinct_characters('AaBbCc')\n    3\n    \"\"\"\n    # Convert the string to lowercase to make the count case-insensitive\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(lower_string)\n    # Optionally, you might want to exclude non-alphabetic characters\n    # unique_characters = set(char for char in lower_string if char.isalpha())\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" \n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    lower_string = string.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(lower_string)\n    \n    # Return the number of unique characters\n    return len(distinct_chars)", "matching_cluster_idx": 7}, {"solution": "import doctest\ndef count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case insensitivity\n    lower_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(lower_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    >>> count_distinct_characters('Hello, World!')\n    10\n    >>> count_distinct_characters('')\n    0\n    \"\"\"\n    # Convert the string to lower case to ensure case-insensitivity\n    lower_string = string.lower()\n    # Create a set of characters to eliminate duplicates\n    unique_characters = set(lower_string)\n    # Remove any whitespace characters if they should not be counted\n    # Uncomment the following line if spaces should be excluded\n    # unique_characters.discard(' ')\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n\n    Args:\n        string (str): The input string to evaluate.\n\n    Returns:\n        int: The number of distinct characters in the string.\n\n    Examples:\n        >>> count_distinct_characters('xyzXYZ')\n        3\n        >>> count_distinct_characters('Jerry')\n        4\n    \"\"\"\n    # Convert the string to lowercase to make the count case-insensitive\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the count case-insensitive\n    normalized_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(normalized_string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(1, len(sorted_numbers)):\n        current_diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n            # If the difference is zero, it's the smallest possible, so we can break early\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -1.4, 0.0, 1.4, 1.5])\n    (-1.5, -1.4)\n    >>> find_closest_elements([10.0, 10.1])\n    (10.0, 10.1)\n    >>> find_closest_elements([5.5, 3.3, 4.4, 2.2, 1.1])\n    (2.2, 3.3)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n            if min_diff == 0:\n                break  # Can't get smaller than zero\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.1, 0.0, 4.5, 2.2])\n    (-2.1, -1.5)\n    >>> find_closest_elements([10.5, 10.4])\n    (10.4, 10.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list and find the smallest difference between consecutive elements\n    for i in range(len(sorted_numbers) - 1):\n        first = sorted_numbers[i]\n        second = sorted_numbers[i + 1]\n        current_diff = second - first\n        \n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (first, second)\n            \n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    min_diff = sys.float_info.max\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(len(sorted_numbers) - 1):\n        first = sorted_numbers[i]\n        second = sorted_numbers[i + 1]\n        diff = second - first\n        \n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (first, second)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the numbers to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the minimal difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current = sorted_numbers[i]\n        next_num = sorted_numbers[i + 1]\n        diff = next_num - current\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (current, next_num)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    \n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list and find the smallest difference\n    for i in range(1, len(sorted_numbers)):\n        diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n    \n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two), select and return two that are the closest\n    to each other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.1, -1.4, 0.0])\n    (-1.5, -1.4)\n    >>> find_closest_elements([10.5, 22.3])\n    (10.5, 22.3)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to ensure closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, 4.0, 0.0])\n    (-1.5, 0.0)\n    >>> find_closest_elements([10.5, 10.4])\n    (10.4, 10.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(len(sorted_numbers) - 1):\n        first, second = sorted_numbers[i], sorted_numbers[i + 1]\n        current_diff = second - first\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (first, second)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        first, second = sorted_numbers[i], sorted_numbers[i + 1]\n        current_diff = second - first\n\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (first, second)\n\n            # If the smallest possible difference is found, exit early\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([10.5, 4.2, 5.1, 4.3])\n    (4.2, 4.3)\n    >>> find_closest_elements([-1.0, -2.5, -3.1, -2.4])\n    (-2.5, -2.4)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list and find the smallest difference\n    for i in range(1, len(sorted_numbers)):\n        first = sorted_numbers[i - 1]\n        second = sorted_numbers[i]\n        current_diff = second - first\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (first, second)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Examples:\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n        (2.0, 2.2)\n        >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n        (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest elements next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i+1] - sorted_numbers[i]\n        \n        # If a smaller difference is found, update min_diff and closest_pair\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n            \n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport doctest\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.8, 0.0, 4.5])\n    (-2.8, -1.5)\n    >>> find_closest_elements([5.5, 5.5, 5.5, 5.5])\n    (5.5, 5.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = sorted_numbers[1] - sorted_numbers[0]\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    # Sort the list to bring closest numbers next to each other\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize minimum difference and the closest pair\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the smallest difference\n    for i in range(len(sorted_numbers) - 1):\n        first, second = sorted_numbers[i], sorted_numbers[i + 1]\n        current_diff = second - first\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (first, second)\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.1, 0.0, 2.5])\n    (-2.1, -1.5)\n    >>> find_closest_elements([10.0, 10.0])\n    (10.0, 10.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(len(sorted_numbers) - 1):\n        current = sorted_numbers[i]\n        next_num = sorted_numbers[i + 1]\n        diff = next_num - current\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (current, next_num)\n            # Early exit if the smallest possible difference is found\n            if min_diff == 0:\n                break\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    for i in range(1, len(sorted_numbers)):\n        current_diff = sorted_numbers[i] - sorted_numbers[i - 1]\n        if current_diff < min_diff:\n            min_diff = current_diff\n            closest_pair = (sorted_numbers[i - 1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two), select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    >>> find_closest_elements([-1.5, -3.2, -2.1, 0.0, 4.5])\n    (-2.1, -1.5)\n    >>> find_closest_elements([10.5, 9.8])\n    (9.8, 10.5)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Iterate through the sorted list and find the minimal difference\n    for i in range(len(sorted_numbers) - 1):\n        current = sorted_numbers[i]\n        next_num = sorted_numbers[i + 1]\n        diff = next_num - current\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (current, next_num)\n\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 46.83673469387755, "dps_norm": 26.25, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1  # The only divisor for 1 or less is 1 itself\n\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 1  # Fallback, though for n > 1, it should always find a divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though for n > 1, 1 is always a divisor", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1  # The only divisor of 1 is itself\n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback in case no divisor is found", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is prime", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(1)\n    0\n    >>> largest_divisor(0)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors less than n for n <= 1\n    for divisor in range(n - 1, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 0  # Fallback, should not be reached for n > 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    # Start checking from n//2 down to 1\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # Fallback, though for n > 1, 1 is always a divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though for n > 1, 1 is always a divisor", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors less than n for n <= 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, should never reach here for n > 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1  # The only divisor of 1 is itself\n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though this line is theoretically unreachable", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # In case n is 1, return 1 as the only divisor", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though 1 will always satisfy for n > 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors smaller than n\n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n\n    return 0  # Fallback, though for n > 1, 1 is always a divisor", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though for n > 1 this line is theoretically unreachable", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(100)\n    50\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1.\")\n    \n    for divisor in range(n - 1, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1  # Fallback, should never reach here for n > 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(13)\n    1\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n    \n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    None\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors smaller than n for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None  # This line is theoretically unreachable", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(7)\n    1\n    >>> largest_divisor(1)\n    0\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors less than n for n <= 1\n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Fallback, though loop should always return before this", "matching_cluster_idx": 3}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport collections\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 6, 7, 4])\n    [6, 7]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = collections.Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30, 40])\n    [10, 20, 30, 40]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1,1,1,1])\n    []\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([5, 5, 5, 5])\n    []\n    >>> remove_duplicates([10, 20, 30, 40, 50])\n    [10, 20, 30, 40, 50]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([7, 8, 9, 7, 10, 8])\n    [9, 10]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 5, 4, 6, 7])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10])\n    [10]\n    >>> remove_duplicates([2, 2, 2, 2])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1, 2, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    count = Counter(numbers)\n    return [num for num in numbers if count[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 2, 3])\n    [2, 3]\n    >>> remove_duplicates([1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([5, 5, 5, 5])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([1, 1, 1, 2, 3])\n    [2, 3]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([5, 6, 7, 5, 6, 8])\n    [7, 8]\n    \"\"\"\n    counts = Counter(numbers)\n    # Keep only elements that appear exactly once, preserving order\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\nimport doctest\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 6, 5, 4, 7])\n    [6, 7]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1,1,1,1])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5, 8])\n    [6, 7, 8]\n    >>> remove_duplicates([10, 20, 30])\n    [10, 20, 30]\n    >>> remove_duplicates([])\n    []\n    >>> remove_duplicates([1,1,1,1])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\nfrom collections import Counter\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    >>> remove_duplicates([4, 5, 4, 6, 7, 5])\n    [6, 7]\n    >>> remove_duplicates([1, 1, 1, 1])\n    []\n    >>> remove_duplicates([])\n    []\n    \"\"\"\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 71.70886075949367, "dps_norm": 80.625, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False  # multiples of 2 and 3 are not prime\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    sqrt_n = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are primes\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are primes\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False  # multiples of 2 and 3 are not prime\n\n    i = 5\n    w = 2\n\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # alternates between adding 2 and 4\n\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 5}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w  # This alternates w between 2 and 4\n    return True", "matching_cluster_idx": 5}, {"solution": "import math\nimport doctest\ndef is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    \n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = int(math.sqrt(n)) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return False\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list `l` and returns a list `l'` such that\n    `l'` is identical to `l` in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of `l`, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 8, 7, 6, 5, 4, 3, 2, 1])\n    [3, 8, 7, 6, 5, 4, 9, 2, 1]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the original values with the sorted values at the specified indices\n    for index, new_value in zip(divisible_by_three, sorted_values):\n        sorted_list[index] = new_value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three (0-based indexing)\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Assign the sorted values back to their respective indices\n    for index, value in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    indices_div3 = [i for i in range(len(l)) if i % 3 == 0]\n    elements_div3 = [l[i] for i in indices_div3]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_div3)\n    \n    # Create a copy of the original list to modify\n    result = l.copy()\n    \n    # Replace elements at indices divisible by three with sorted elements\n    for idx, sorted_val in zip(indices_div3, sorted_elements):\n        result[idx] = sorted_val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by three (0-based)\n    divisible_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values = [l[i] for i in divisible_by_three]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Replace the values at the divisible-by-three indices with the sorted values\n    for idx, sorted_val in zip(divisible_by_three, sorted_values):\n        result[idx] = sorted_val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Assign the sorted values back to their respective indices\n    for index, value in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([])\n    []\n    >>> sort_third([10])\n    [10]\n    >>> sort_third([3, 1, 4, 1, 5, 9, 2, 6, 5])\n    [2, 1, 4, 3, 5, 9, 5, 6, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    values_to_sort = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Replace the values at divisible indices with the sorted values\n    for idx, sorted_val in zip(divisible_indices, sorted_values):\n        result[idx] = sorted_val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a copy to avoid modifying the original list\n    result = l.copy()\n    \n    # Find all indices divisible by three\n    indices = [i for i in range(len(result)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values = [result[i] for i in indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values)\n    \n    # Assign the sorted values back to their respective indices\n    for idx, val in zip(indices, sorted_values):\n        result[idx] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list `l` and returns a list `l'` such that\n    `l'` is identical to `l` in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of `l`, but sorted.\n\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_by_three)\n    \n    # Create a copy of the original list to avoid mutating it\n    result = l.copy()\n    \n    # Replace the values at indices divisible by three with sorted values\n    sorted_iter = iter(sorted_values)\n    for i in range(0, len(l), 3):\n        result[i] = next(sorted_iter)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 3, 7, 2, 8, 5, 6, 0])\n    [3, 1, 4, 5, 7, 2, 8, 5, 6, 0]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    divisible_values = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(divisible_values)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Place the sorted values back into their respective indices\n    for index, value in zip(divisible_indices, sorted_values):\n        result[index] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 2, 7, 3, 8, 5, 6])\n    [2, 1, 4, 5, 7, 3, 8, 5, 6]\n    \"\"\"\n    # Find indices divisible by three\n    divisible_indices = list(range(0, len(l), 3))\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to modify\n    sorted_list = l.copy()\n    \n    # Assign the sorted values back to their respective indices\n    for idx, val in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 3, 7, 2, 5, 6, 8, 0])\n    [3, 1, 4, 5, 7, 2, 9, 6, 8, 0]\n    >>> sort_third([])\n    []\n    >>> sort_third([10])\n    [10]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the elements at these indices\n    elements_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it directly\n    sorted_list = l.copy()\n    \n    # Replace the original elements with the sorted ones at the specified indices\n    for idx, sorted_val in zip(divisible_by_three_indices, sorted_elements):\n        sorted_list[idx] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices\n    that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract values at these indices\n    values_to_sort = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Replace the values at divisible indices with the sorted values\n    for index, value in zip(divisible_indices, sorted_values):\n        result[index] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three,\n    while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([])\n    []\n    >>> sort_third([10])\n    [10]\n    >>> sort_third([9, 7, 5, 3, 1, 0, -1, -3, -5])\n    [-1, 7, 5, 3, 1, 0, -5, -3, -9]\n    \"\"\"\n    # Find all indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the elements at these indices\n    elements = [l[i] for i in indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements)\n    \n    # Create a copy of the original list to avoid modifying it directly\n    sorted_list = l.copy()\n    \n    # Assign the sorted elements back to their respective indices\n    for idx, sorted_val in zip(indices, sorted_elements):\n        sorted_list[idx] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Identify indices divisible by three (0-based indexing)\n    divisible_by_three_indices = list(range(0, len(l), 3))\n    \n    # Extract the elements at these indices\n    elements_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the elements at the divisible indices with the sorted elements\n    for idx, sorted_val in zip(divisible_by_three_indices, sorted_elements):\n        sorted_list[idx] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find all indices divisible by three\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the elements at these indices\n    elements_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the elements at the divisible by three indices with the sorted ones\n    for index, sorted_value in zip(divisible_by_three_indices, sorted_elements):\n        sorted_list[index] = sorted_value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find all indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the elements at these indices\n    elements = [l[i] for i in indices]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements)\n    \n    # Create a copy of the list to avoid modifying the original list\n    sorted_list = l.copy()\n    \n    # Replace the elements at the specified indices with the sorted elements\n    for idx, sorted_val in zip(indices, sorted_elements):\n        sorted_list[idx] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find indices divisible by three\n    divisible_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid mutating it\n    sorted_list = l.copy()\n    \n    # Assign the sorted values back to their respective indices\n    for idx, val in zip(divisible_indices, sorted_values):\n        sorted_list[idx] = val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Find all indices divisible by three (0-based indexing)\n    divisible_by_three_indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the values at these indices\n    values_to_sort = [l[i] for i in divisible_by_three_indices]\n    \n    # Sort the extracted values\n    sorted_values = sorted(values_to_sort)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the values at the divisible indices with the sorted values\n    for index, sorted_val in zip(divisible_by_three_indices, sorted_values):\n        sorted_list[index] = sorted_val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 7, 3, 2, 8, 5, 6])\n    [5, 1, 4, 7, 3, 2, 8, 5, 6]\n    >>> sort_third([])\n    []\n    >>> sort_third([10])\n    [10]\n    \"\"\"\n    # Identify indices divisible by three\n    indices = [i for i in range(len(l)) if i % 3 == 0]\n    \n    # Extract the elements at those indices\n    sorted_values = sorted([l[i] for i in indices])\n    \n    # Create a copy of the list to modify\n    l_prime = l.copy()\n    \n    # Assign sorted values back to the respective indices\n    for idx, val in zip(indices, sorted_values):\n        l_prime[idx] = val\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([9, 1, 4, 3, 7, 2, 5, 8, 6])\n    [5, 1, 4, 3, 7, 2, 6, 8, 9]\n    \"\"\"\n    # Extract indices divisible by three\n    indices = list(range(0, len(l), 3))\n    # Extract the corresponding values\n    values = [l[i] for i in indices]\n    # Sort the extracted values\n    sorted_values = sorted(values)\n    # Create a copy of the original list to avoid mutating it\n    sorted_list = l.copy()\n    # Place the sorted values back into their respective positions\n    for idx, val in zip(indices, sorted_values):\n        sorted_list[idx] = val\n    return sorted_list", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    >>> unique(['apple', 'banana', 'apple', 'cherry'])\n    ['apple', 'banana', 'cherry']\n    >>> unique([])\n    []\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(1, n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 97.20949263502455, "dps_norm": 94.5, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the extracted even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to maintain odd indices\n    result = l.copy()\n    # Replace the even indices with the sorted even elements\n    result[::2] = sorted_evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 2])\n    [6, 1, 8, 3, 10, 2]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices = list(range(0, len(l), 2))\n    even_values = [l[i] for i in even_indices]\n    \n    # Sort the even-indexed values\n    sorted_evens = sorted(even_values)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Replace the even-indexed elements with the sorted values\n    for idx, val in zip(even_indices, sorted_evens):\n        result[idx] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 5])\n    [6, 1, 8, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    # Create a copy of the original list to avoid mutating it\n    result = l.copy()\n    # Replace the even indices with the sorted even elements\n    even_index = 0\n    for i in range(0, len(result), 2):\n        result[i] = sorted_even[even_index]\n        even_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the list to modify\n    result = l.copy()\n    # Assign back the sorted even elements to even indices\n    result[::2] = sorted_evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 3, 2, 5])\n    [3, 1, 4, 2, 5]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices = list(range(0, len(l), 2))\n    even_elements = [l[i] for i in even_indices]\n    \n    # Sort the extracted even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a copy of the original list to maintain odd indices\n    result = l.copy()\n    \n    # Replace the even indices with sorted even elements\n    for idx, val in zip(even_indices, sorted_even):\n        result[idx] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices = list(range(0, len(l), 2))\n    even_values = [l[i] for i in even_indices]\n    \n    # Sort the even-indexed values\n    sorted_even = sorted(even_values)\n    \n    # Create a copy of the original list to avoid mutating it\n    result = l.copy()\n    \n    # Replace the even-indexed elements with the sorted values\n    for idx, val in zip(even_indices, sorted_even):\n        result[idx] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([])\n    []\n    >>> sort_even([10])\n    [10]\n    >>> sort_even([4, 1, 2, 3, 0])\n    [0, 1, 2, 3, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_values = l[::2]\n    # Sort the even index values\n    sorted_even = sorted(even_values)\n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    # Replace the even index values with sorted values\n    sorted_list[::2] = sorted_even\n    return sorted_list", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 4, 3, 2, 5])\n    [2, 1, 4, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    \n    # Replace even indices with sorted even elements\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_even[even_index]\n        even_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to preserve odd indices\n    result = l.copy()\n    # Replace the even indices with the sorted elements\n    result[::2] = sorted_evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 5])\n    [6, 1, 8, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with sorted even elements\n    result[::2] = sorted_even\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted even elements\n    even_index = 0\n    for i in range(0, len(l), 2):\n        result[i] = sorted_evens[even_index]\n        even_index += 1\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the indices for even positions\n    even_indices = list(range(0, len(l), 2))\n    \n    # Extract the elements at even indices\n    even_elements = [l[i] for i in even_indices]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the elements at even indices with the sorted elements\n    for index, value in zip(even_indices, sorted_even):\n        sorted_list[index] = value\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the even indices with the sorted even elements\n    sorted_list[::2] = sorted_evens\n    \n    return sorted_list", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_evens = sorted(even_elements)\n    \n    # Create an iterator for the sorted even elements\n    sorted_evens_iter = iter(sorted_evens)\n    \n    # Reconstruct the list with sorted even elements and original odd elements\n    sorted_list = [\n        next(sorted_evens_iter) if index % 2 == 0 else value\n        for index, value in enumerate(l)\n    ]\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even elements\n    sorted_evens = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted even elements\n    result[::2] = sorted_evens\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted values\n    result[::2] = sorted_even\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices = list(range(0, len(l), 2))\n    even_elements = [l[i] for i in even_indices]\n    \n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a copy of the original list to modify\n    sorted_l = l.copy()\n    \n    # Replace even-indexed elements with sorted values\n    for index, value in zip(even_indices, sorted_even):\n        sorted_l[index] = value\n    \n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    \n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 5])\n    [6, 1, 8, 3, 10, 5]\n    >>> sort_even([])\n    []\n    >>> sort_even([4])\n    [4]\n    \"\"\"\n    # Extract elements at even indices\n    even_indices = list(range(0, len(l), 2))\n    even_elements = [l[i] for i in even_indices]\n    \n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a copy of the original list to avoid modifying it\n    sorted_list = l.copy()\n    \n    # Replace the even-indexed elements with the sorted ones\n    for idx, val in zip(even_indices, sorted_even):\n        sorted_list[idx] = val\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 8, 3, 6, 2])\n    [6, 1, 8, 3, 10, 2]\n    >>> sort_even([])\n    []\n    >>> sort_even([7])\n    [7]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    # Create a copy of the original list to avoid modifying it\n    result = l.copy()\n    # Replace the even indices with the sorted elements\n    result[::2] = sorted_even\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    >>> sort_even([10, 1, 7, 3, 5, 2])\n    [5, 1, 7, 3, 10, 2]\n    >>> sort_even([])\n    []\n    >>> sort_even([4])\n    [4]\n    >>> sort_even([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])\n    [1, 8, 3, 6, 5, 4, 7, 2, 9, 0]\n    \"\"\"\n    # Extract even index elements\n    even_indices = list(range(0, len(l), 2))\n    even_values = [l[i] for i in even_indices]\n    \n    # Sort the even index values\n    sorted_even_values = sorted(even_values)\n    \n    # Create a copy of the original list to modify\n    result = l.copy()\n    \n    # Replace the even index values with the sorted values\n    for idx, val in zip(even_indices, sorted_even_values):\n        result[idx] = val\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 64.0, "profiled": [{"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if p == 1:\n        return 0\n    result = 1\n    base = 2 % p\n    exponent = n\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % p\n        base = (base * base) % p\n        exponent = exponent // 2\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    \n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns the string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    \n    This function compares the unique characters in both strings\n    and returns True if they contain exactly the same set of characters,\n    regardless of the order or frequency of each character.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "import doctest\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 94.38976377952756, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and find the intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find the intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and allow set operations\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of both sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to eliminate duplicates and find common elements\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find the intersection of both sets\n    common_elements = set1.intersection(set2)\n\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "import math\nimport doctest\ndef largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = None\n    # Divide out the factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n\n    # Now n must be odd, start checking from 3\n    factor = 3\n    max_factor = math.isqrt(n) + 1\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n            max_factor = math.isqrt(n) + 1\n        factor += 2\n\n    if n > 1:\n        largest_factor = n\n\n    return int(largest_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Remove the factor of 2\n    while n % 2 == 0:\n        max_factor = 2\n        n = n // 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            max_factor = factor\n            n = n // factor\n        factor += 2\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        max_factor = n\n\n    return max_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        for i in range(3, int(x**0.5) + 1, 2):\n            if x % i == 0:\n                return False\n        return True\n\n    largest_factor = None\n\n    # Divide out the factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n\n    # Now n must be odd. Start checking from 3.\n    factor = 3\n    max_factor = n**0.5\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n            max_factor = n**0.5\n        factor += 2\n\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Remove the factor 2\n    while n % 2 == 0:\n        last_factor = 2\n        n //= 2\n\n    # Check for odd factors\n    factor = 3\n    max_factor = n**0.5\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            last_factor = factor\n            n //= factor\n            max_factor = n**0.5\n        factor += 2\n\n    if n == 1:\n        return last_factor\n    else:\n        return n", "matching_cluster_idx": 8}, {"solution": "import math\nimport doctest\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    >>> largest_prime_factor(600851475143)\n    6857\n    \"\"\"\n    # Initialize the largest factor\n    largest = None\n\n    # Remove the factor 2 to handle even numbers\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n\n    # Now n must be odd. Start checking from 3 onwards\n    factor = 3\n    max_factor = math.isqrt(n) + 1\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n            max_factor = math.isqrt(n) + 1\n        factor += 2  # Only check odd numbers\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        while n % factor == 0:\n            last_factor = factor\n            n = n // factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "import doctest\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n        if factor * factor > n:\n            if n > 1:\n                last_factor = n\n            break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n = n // factor\n            while n % factor == 0:\n                n = n // factor\n        factor += 1\n        if factor * factor > n:\n            if n > 1:\n                last_factor = n\n            break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1 and not a prime number.\")\n    \n    largest = None\n\n    # Remove factors of 2\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n\n    # Now n is odd, start checking odd factors\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n        factor += 2\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n = n // factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k):\n        if k <= 1:\n            return False\n        if k <= 3:\n            return True\n        if k % 2 == 0 or k % 3 == 0:\n            return False\n        i = 5\n        while i * i <= k:\n            if k % i == 0 or k % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = None\n    # Divide out the factor 2 first\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    # Now n must be odd, start checking from 3\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        factor += 2\n    if n > 2:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "import math\nimport doctest\ndef largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the maximum factor\n    max_factor = -1\n\n    # Remove the factor 2\n    while n % 2 == 0:\n        max_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 onwards\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_factor = i\n            n //= i\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        max_factor = n\n\n    return max_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k: int) -> bool:\n        if k < 2:\n            return False\n        if k == 2:\n            return True\n        if k % 2 == 0:\n            return False\n        sqrt_k = int(k**0.5) + 1\n        for i in range(3, sqrt_k, 2):\n            if k % i == 0:\n                return False\n        return True\n\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            if is_prime(factor):\n                last_factor = factor\n            n = n // factor\n        else:\n            factor += 1 if factor == 2 else 2\n    if n > 1 and is_prime(n):\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            n = n // factor\n            while n % factor == 0:\n                n = n // factor\n        factor += 1\n    if n > last_factor:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k):\n        if k <= 1:\n            return False\n        if k <= 3:\n            return True\n        if k % 2 == 0 or k % 3 == 0:\n            return False\n        i = 5\n        while i * i <= k:\n            if k % i == 0 or k % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        while n % factor == 0:\n            last_factor = factor\n            n = n // factor\n        factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(k):\n        if k <= 1:\n            return False\n        if k <= 3:\n            return True\n        if k % 2 == 0 or k % 3 == 0:\n            return False\n        i = 5\n        while i * i <= k:\n            if k % i == 0 or k % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = None\n\n    # Divide out the factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n\n    # Now n is odd, start checking odd factors\n    factor = 3\n    max_factor = int(n**0.5) + 1\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n            max_factor = int(n**0.5) + 1\n        factor += 2\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1.\")\n    \n    # Remove the factor 2\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n    \n    # Check for odd factors from 3 upwards\n    factor = 3\n    max_factor = n ** 0.5\n    while factor <= max_factor and n > 1:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n            max_factor = n ** 0.5\n        factor += 2\n    \n    # If n is a prime number greater than 2\n    if n > 1:\n        largest = n\n    \n    return int(largest)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n = n // factor\n        factor += 1 if factor == 2 else 2  # After 2, consider only odd numbers\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest factor\n    largest = 1\n\n    # Divide n by 2 to handle even numbers\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n\n    # Now n must be odd. Start checking from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n        factor += 2\n\n    # If n is a prime number greater than 2\n    if n > 2:\n        largest = n\n\n    return largest", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 43.11688311688311, "dps_norm": 51.25, "pass@1": 98.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"syzygy\")\n    2\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"BY\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"bypass\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"AEIOU\")\n    5\n    >>> vowels_count(\"Why\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"Yellow\")\n    2\n    \"\"\"\n    s = s.lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if i == len(s) - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n\n    Additional Test Cases:\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"syzygy\")\n    2\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"QUEUE\")\n    4\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"myth\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    \"\"\"\n    vowels = set('aeiou')\n    s = s.lower()\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s_lower = s.lower()\n    length = len(s_lower)\n    \n    for idx, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if idx == length - 1:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    1\n    >>> vowels_count(\"syzygy\")\n    2\n    >>> vowels_count(\"xyz\")\n    0\n    >>> vowels_count(\"y\")\n    1\n    >>> vowels_count(\"bye\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"QUEUE\")\n    4\n    >>> vowels_count(\"crypt\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    \"\"\"\n\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == length - 1:\n            count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"APPLE\")\n    2\n    >>> vowels_count(\"crypt\")\n    0\n    >>> vowels_count(\"my\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"queue\")\n    4\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif (char in 'yY') and (i == length - 1):\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"hello\")\n    2\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"Python\")\n    1\n    \"\"\"\n\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for c in s if c in vowels)\n    if s and s[-1] in ('y', 'Y'):\n        count +=1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"crypt\")\n    0\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"LY\")\n    1\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in 'yY' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"Yellow\")\n    2\n    >>> vowels_count(\"myth\")\n    0\n    >>> vowels_count(\"happy\")\n    1\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"Fly\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"crypt\")\n    0\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"Education\")\n    5\n    >>> vowels_count(\"why\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"queue\")\n    4\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"happy\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AeiouY\")\n    6\n    >>> vowels_count(\"Why\")\n    1\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif (char in 'yY') and (i == length - 1):\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"python\")\n    1\n    >>> vowels_count(\"queue\")\n    3\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"bcdfg\")\n    0\n    >>> vowels_count(\"yEllo\")\n    2\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"queueing\")\n    5\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    \"\"\"\n    vowels = set('aeiou')\n    s_lower = s.lower()\n    count = 0\n\n    for i, char in enumerate(s_lower):\n        if char in vowels:\n            count += 1\n        elif char == 'y':\n            if i == len(s_lower) - 1:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"sy\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"why\")\n    1\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"bY\")\n    1\n    >>> vowels_count(\"crypt\")\n    0\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"Queue\")\n    3\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"syzygy\")\n    2\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"rhythms\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"PYTHON\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AeIoUy\")\n    6\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s[:-1]:\n        if char in vowels:\n            count += 1\n    # Check if the last character is a vowel or 'y'/'Y'\n    if s:\n        last_char = s[-1]\n        if last_char in vowels or last_char.lower() == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    s_len = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == s_len - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"my\")\n    1\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"Fly\")\n    1\n    >>> vowels_count(\"APPLE\")\n    2\n    >>> vowels_count(\"\")\n    0\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"Umbrella\")\n    3\n    >>> vowels_count(\"Python\")\n    1\n    >>> vowels_count(\"crypt\")\n    0\n    >>> vowels_count(\"fly\")\n    1\n    >>> vowels_count(\"BY\")\n    1\n    >>> vowels_count(\"gym\")\n    0\n    >>> vowels_count(\"queue\")\n    4\n    >>> vowels_count(\"why\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"AEIOUY\")\n    6\n    >>> vowels_count(\"bcdfg\")\n    0\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in {'y', 'Y'} and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"sky\")\n    1\n    >>> vowels_count(\"yellow\")\n    2\n    >>> vowels_count(\"beautiful\")\n    5\n    >>> vowels_count(\"Y\")\n    1\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"syzygy\")\n    1\n    >>> vowels_count(\"python\")\n    1\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = 0\n    length = len(s)\n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char in ('y', 'Y') and i == length - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 98.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total1 = total_chars(lst1)\n    total2 = total_chars(lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in lst1\n    total1 = sum(len(s) for s in lst1)\n    # Calculate total number of characters in lst2\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1  # If totals are equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in lst1\n    total1 = sum(len(s) for s in lst1)\n    \n    # Calculate total number of characters in lst2\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters for each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    \n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1  # If equal, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total1 = total_chars(lst1)\n    total2 = total_chars(lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total characters for lst1\n    total1 = sum(len(s) for s in lst1)\n    # Calculate total characters for lst2\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare totals and return the appropriate list\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in all strings of the list less than the other list.\n\n    If the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in lst1\n    total1 = sum(len(s) for s in lst1)\n    \n    # Calculate the total number of characters in lst2\n    total2 = sum(len(s) for s in lst2)\n    \n    # Compare the totals and return the appropriate list\n    if total1 <= total2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare and return the appropriate list\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst2 < total_chars_lst1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total1 = total_chars(lst1)\n    total2 = total_chars(lst2)\n    \n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 87.67326732673267, "dps_norm": 55.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even numbers at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 2, 3, 4, 5, 6]) ==> 12\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 2, 3, 4, 5, 6]) ==> 12\n        add([10, 15, 20, 25, 30]) ==> 15\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 4, 2, 5, 6, 8]) ==> 12\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list should not be empty.\")\n\n    # Initialize sum\n    total = 0\n\n    # Iterate over odd indices\n    for index in range(1, len(lst), 2):\n        element = lst[index]\n        if element % 2 == 0:\n            total += element\n\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([1, 4, 3, 2, 8, 5]) ==> 6  # 4 and 2 are even and at odd indices (1 and 3)\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd\n        if index % 2 == 1:\n            # Check if the value is even\n            if value % 2 == 0:\n                total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 2, 3, 4, 5, 6]) ==> 12\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 1 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        12\n        >>> add([2])\n        0\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n    # Iterate over the list with index\n    for index in range(1, len(lst), 2):  # Start at index 1 and step by 2 for odd indices\n        if lst[index] % 2 == 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 2, 3, 4, 5, 6]) ==> 12\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) == 2\n        add([1, 4, 3, 6, 5, 8]) == 12\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    total = 0\n    # Iterate over the list with their indices\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 4, 3, 6, 5, 8]) ==> 4 + 8 = 12\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n    # Iterate over the list with indices\n    for index in range(1, len(lst), 2):\n        element = lst[index]\n        if element % 2 == 0:\n            total += element\n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    # Iterate over odd indices\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        12\n        >>> add([10, 15, 20, 25, 30])\n        15\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 == 1 and value % 2 == 0:\n            total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n        add([10, 5, 8, 3, 6, 4]) ==> 9 (5 and 4 are at odd indices and even is only 4)\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 1 and element % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        18\n        >>> add([2])\n        0\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must be non-empty.\")\n\n    sum_even = 0\n    # Iterate over odd indices\n    for index in range(1, len(lst), 2):\n        element = lst[index]\n        if element % 2 == 0:\n            sum_even += element\n    return sum_even", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([10, 4, 3, 6, 5, 8]) ==> 18\n        add([1, 3, 5, 7]) ==> 0\n    \"\"\"\n    sum_evens = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 1 and value % 2 == 0:\n            sum_evens += value\n    return sum_evens", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers `lst`, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements located at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 2, 3, 4, 5, 6])\n        12\n        >>> add([1, 3, 5, 7])\n        0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over list with indices\n    for index, value in enumerate(lst):\n        # Check if index is odd\n        if index % 2 != 0:\n            # Check if the element is even\n            if value % 2 == 0:\n                total += value\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n        add([1, 4, 3, 6, 5, 8]) ==> 18\n    \"\"\"\n    # Initialize sum to 0\n    total = 0\n\n    # Iterate over the list with index\n    for index in range(1, len(lst), 2):  # Start at index 1 and step by 2 for odd indices\n        if lst[index] % 2 == 0:\n            total += lst[index]\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 3, 5, 7])\n        0\n        >>> add([2, 4, 6, 8, 10])\n        12\n    \"\"\"\n    sum_even = 0\n    for index in range(1, len(lst), 2):  # Start at index 1 and step by 2 to get odd indices\n        if lst[index] % 2 == 0:\n            sum_even += lst[index]\n    return sum_even", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n        >>> add([1, 4, 3, 6, 5, 8])\n        18\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 6.0, "profiled": []}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates first by rows in ascending order.\n    Also, sort coordinates within the same row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort first by row ascending, then by column descending within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value equals x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort the column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append each coordinate to the result list\n        for col in cols_sorted:\n            coordinates.append((row_idx, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data structure as nested lists,\n    which is similar to a matrix; however, unlike matrices,\n    each row may contain a different number of columns.\n    Given `lst` and an integer `x`, find all occurrences of `x` in the list,\n    and return a list of tuples `[(x1, y1), (x2, y2), ...]` such that\n    each tuple represents a coordinate `(row, column)`, starting with 0.\n    \n    The returned list should be sorted:\n    - Primarily by row in ascending order.\n    - Secondarily, for each row, by column in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_index for col_index, elem in enumerate(row) if elem == x]\n        # Sort column indices in descending order\n        sorted_cols = sorted(cols, reverse=True)\n        # Append tuples of (row, column) to the result\n        for col in sorted_cols:\n            coordinates.append((row_index, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] where\n    each tuple represents the coordinates (row, column), starting from 0.\n    \n    The returned list is sorted:\n    - Primarily by row in ascending order.\n    - Within each row, by column in descending order.\n    \n    Examples:\n    >>> get_row([\n    ...   [1,2,3,4,5,6],\n    ...   [1,2,3,4,1,6],\n    ...   [1,2,3,4,5,1]\n    ... ], 1)\n    [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    >>> get_row([], 1)\n    []\n    \n    >>> get_row([[], [1], [1, 2, 3]], 3)\n    [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the element is x\n        cols = [col_index for col_index, value in enumerate(row) if value == x]\n        # Sort column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append tuples of (row_index, col_index) to the coordinates list\n        for col in cols_sorted:\n            coordinates.append((row_index, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    The coordinates are sorted initially by rows in ascending order.\n    Within each row, they are sorted by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element is x\n        cols = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append the (row, col) tuples to the coordinates list\n        for col in cols_sorted:\n            coordinates.append((row_idx, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and an integer x, find all occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value is x\n        x_cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort column indices in descending order\n        x_cols_sorted = sorted(x_cols, reverse=True)\n        # Append the (row, column) tuples to the result\n        for col in x_cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the value is x\n        cols = [col_idx for col_idx, value in enumerate(row) if value == x]\n        if cols:\n            # Sort column indices in descending order\n            cols_sorted = sorted(cols, reverse=True)\n            # Append tuples (row_index, column_index) to the result\n            for col in cols_sorted:\n                result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the same row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort primarily by row ascending, then by column descending within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Collect all column indices where the element equals x\n        cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        if cols:\n            # Sort column indices in descending order\n            cols_sorted = sorted(cols, reverse=True)\n            for col in cols_sorted:\n                coordinates.append((row_idx, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find all occurrences of x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...],\n    where each tuple is a coordinate - (row, column), starting with 0.\n    \n    The coordinates are sorted primarily by rows in ascending order.\n    Within each row, coordinates are sorted by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element is x\n        cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        # Sort columns in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append tuples of (row_idx, col_idx) to the result\n        for col in cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Collect all column indices where the value equals x\n        cols = [col_idx for col_idx, value in enumerate(row) if value == x]\n        if cols:\n            # Sort columns in descending order\n            cols_sorted = sorted(cols, reverse=True)\n            # Append tuples to the coordinates list\n            for col in cols_sorted:\n                coordinates.append((row_idx, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates within each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1, 2, 3, 4, 5, 6],\n      [1, 2, 3, 4, 1, 6],\n      [1, 2, 3, 4, 5, 1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        if cols:\n            # Sort columns in descending order\n            sorted_cols = sorted(cols, reverse=True)\n            # Append tuples of (row_idx, col_idx)\n            for col in sorted_cols:\n                coordinates.append((row_idx, col))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2-dimensional data structure as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and an integer x, find all occurrences of x in the list\n    and return a list of tuples [(row1, col1), (row2, col2), ...]\n    where each tuple represents the coordinates (row, column) starting from 0.\n    \n    The returned list is sorted first by rows in ascending order.\n    Within each row, the coordinates are sorted by columns in descending order.\n    \n    Args:\n        lst (list of lists): The 2D data structure to search.\n        x (int): The integer to find in the list.\n        \n    Returns:\n        list of tuples: A list of (row, column) tuples where x is found.\n        \n    Examples:\n        >>> get_row([\n              [1,2,3,4,5,6],\n              [1,2,3,4,1,6],\n              [1,2,3,4,5,1]\n            ], 1)\n        [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        \n        >>> get_row([], 1)\n        []\n        \n        >>> get_row([[], [1], [1, 2, 3]], 3)\n        [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    # Sort by row ascending, then by column descending within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        # Sort the column indices in descending order\n        sorted_cols = sorted(cols, reverse=True)\n        # Append tuples of (row_idx, col_idx) to the result\n        for col in sorted_cols:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_idx for col_idx, elem in enumerate(row) if elem == x]\n        # Sort the columns in descending order\n        sorted_cols = sorted(cols, reverse=True)\n        # Append tuples of (row, column) to the result\n        for col in sorted_cols:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    \n    get_row([], 1) == []\n    \n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n\n    # Iterate over each row with its index\n    for row_idx, row in enumerate(lst):\n        # Iterate over each element in the row with its column index\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort first by row ascending, then by column descending within the same row\n    coordinates_sorted = sorted(coordinates, key=lambda t: (t[0], -t[1]))\n    \n    return coordinates_sorted", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    matches = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                matches.append((row_idx, col_idx))\n    # Sort by row ascending, then by column descending within the same row\n    matches.sort(key=lambda coord: (coord[0], -coord[1]))\n    return matches", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element is equal to x\n        cols = [col_idx for col_idx, val in enumerate(row) if val == x]\n        # Sort the column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append the (row, column) tuples to the result\n        for col in cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix. However, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find all integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2), ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of each row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        # Find all column indices where the element equals x\n        cols = [col_idx for col_idx, item in enumerate(row) if item == x]\n        # Sort column indices in descending order\n        cols_sorted = sorted(cols, reverse=True)\n        # Append tuples to the result\n        for col in cols_sorted:\n            result.append((row_idx, col))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as nested lists,\n    which is similar to a matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst and integer x, find integers x in the list,\n    and return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        # Find all column indices where the element is x\n        cols = [col_index for col_index, value in enumerate(row) if value == x]\n        # Sort column indices in descending order\n        cols_sorted_desc = sorted(cols, reverse=True)\n        # Append the coordinates to the result\n        for col in cols_sorted_desc:\n            result.append((row_index, col))\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet is rotated such that each letter shifts down by four places.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('z'):\n                shifted -= 26  # Wrap around if beyond 'z'\n            encrypted.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = ord(char) + 4\n            if shifted > ord('Z'):\n                shifted -= 26\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabet characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated by shifting each letter forward by four places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions for uppercase letters\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated such that each letter shifts down by four places.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) - ord('a') + 4\n            shifted = shifted % 26  # Wrap around if necessary\n            encrypted_char = chr(shifted + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase characters similarly\n            shifted = ord(char) - ord('A') + 4\n            shifted = shifted % 26\n            encrypted_char = chr(shifted + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated by four places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase characters by 4 positions with wrap-around\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabet characters are unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet is rotated such that each letter shifts down by two multiplied by two places (i.e., shift by 4).\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    shift = 2 * 2  # Shift by 4\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            shifted = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            shifted = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            result.append(char)\n    \n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    shift = 2 * 2  # Shift by two multiplied by two places, which is 4\n    result = []\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around using modulo 26\n            shifted_ord = ((ord(char) - ord('a') + shift) % 26) + ord('a')\n            shifted_char = chr(shifted_ord)\n            result.append(shifted_char)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted_ord = ((ord(char) - ord('A') + shift) % 26) + ord('A')\n            shifted_char = chr(shifted_ord)\n            result.append(shifted_char)\n        else:\n            # If it's not a letter, leave it unchanged\n            result.append(char)\n\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet is rotated by shifting each letter down by four places.\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabet characters are left unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            base = ord('A') if char.isupper() else ord('a')\n            # Shift the character by 4 places\n            shifted = chr((ord(char) - base + 4) % 26 + base)\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are added unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by shifting each lowercase letter forward by four places.\n    \n    The alphabet is treated as circular, so 'z' wraps around to 'd'.\n    \n    Parameters:\n    s (str): The input string to encrypt.\n    \n    Returns:\n    str: The encrypted string with each letter shifted by four places.\n    \n    Examples:\n    >>> encrypt('hi')\n    'lm'\n    >>> encrypt('asdfghjkl')\n    'ewhjklnop'\n    >>> encrypt('gf')\n    'kj'\n    >>> encrypt('et')\n    'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) - ord('a')  # 0-25\n            shifted = (shifted + 4) % 26\n            encrypted_char = chr(shifted + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters as well\n            shifted = ord(char) - ord('A')  # 0-25\n            shifted = (shifted + 4) % 26\n            encrypted_char = chr(shifted + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the input string by shifting each alphabet character\n    forward by four places in the alphabet. Non-alphabet characters\n    are left unchanged.\n\n    Args:\n        s (str): The string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    encrypted = []\n    shift = 4  # Shift by two multiplied by two places\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            shifted = ((ord(char) - ord('a') + shift) % 26) + ord('a')\n            encrypted.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            shifted = ((ord(char) - ord('A') + shift) % 26) + ord('A')\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabet characters are unchanged\n            encrypted.append(char)\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each lowercase alphabet character forward by four places.\n    Wraps around the alphabet if necessary. Non-alphabet characters are unchanged.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions with wrap-around\n            shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            # If not a lowercase letter, leave it unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each lowercase letter forward by four positions\n    in the alphabet. Wraps around if the shift goes past 'z'. Non-lowercase characters\n    are left unchanged.\n\n    Args:\n        s (str): The input string to encrypt.\n\n    Returns:\n        str: The encrypted string.\n    \n    Examples:\n        encrypt('hi') returns 'lm'\n        encrypt('asdfghjkl') returns 'ewhjklnop'\n        encrypt('gf') returns 'kj'\n        encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('z'):\n                shifted -= 26  # Wrap around\n            encrypted_char = chr(shifted)\n            encrypted.append(encrypted_char)\n        else:\n            # If not a lowercase letter, leave it unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet is rotated by shifting each letter forward by four places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) - ord('a') + 4\n            shifted %= 26  # Wrap around if beyond 'z'\n            encrypted_char = chr(ord('a') + shifted)\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = ord(char) - ord('A') + 4\n            shifted %= 26\n            encrypted_char = chr(ord('A') + shifted)\n            encrypted.append(encrypted_char)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('z'):\n                shifted -= 26\n            result.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # Shift character by 4 positions for uppercase letters\n            shifted = ord(char) + 4\n            if shifted > ord('Z'):\n                shifted -= 26\n            result.append(chr(shifted))\n        else:\n            # Non-alphabetic characters are appended unchanged\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    shift = 2 * 2  # Shift by two multiplied to two places, which is 4\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate shifted character with wrap-around\n            shifted = ord(char) - ord('a')\n            shifted = (shifted + shift) % 26\n            encrypted_char = chr(shifted + ord('a'))\n            encrypted.append(encrypted_char)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = ord(char) - ord('A')\n            shifted = (shifted + shift) % 26\n            encrypted_char = chr(shifted + ord('A'))\n            encrypted.append(encrypted_char)\n        else:\n            # For non-alphabetic characters, keep them unchanged\n            encrypted.append(char)\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    rotated = []\n    for c in s:\n        if 'a' <= c <= 'z':\n            shifted = ord(c) - ord('a')  # 0-25\n            shifted = (shifted + 4) % 26\n            rotated.append(chr(shifted + ord('a')))\n        elif 'A' <= c <= 'Z':\n            shifted = ord(c) - ord('A')\n            shifted = (shifted + 4) % 26\n            rotated.append(chr(shifted + ord('A')))\n        else:\n            rotated.append(c)  # Non-alphabetic characters are unchanged\n    return ''.join(rotated)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet is rotated such that each letter shifts down by two multiplied to two places (i.e., by 4 places).\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters\n            shifted = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters\n            shifted = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters remain unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet is rotated such that each letter shifts down by two multiplied by two places (i.e., 4 places).\n\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    shift = 2 * 2  # Shift by 4\n\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the shifted character with wrap-around using modulo 26\n            shifted = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            encrypted.append(shifted)\n        elif 'A' <= char <= 'Z':\n            # Handle uppercase letters similarly\n            shifted = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            encrypted.append(shifted)\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted.append(char)\n\n    return ''.join(encrypted)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = ''\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift lowercase letters by 4 positions\n            shifted = (ord(char) - ord('a') + 4) % 26\n            encrypted += chr(shifted + ord('a'))\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase letters by 4 positions\n            shifted = (ord(char) - ord('A') + 4) % 26\n            encrypted += chr(shifted + ord('A'))\n        else:\n            # Non-alphabetic characters are unchanged\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated.\n    The alphabet is rotated such that each letter shifts forward by four places.\n    \n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift character by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('z'):\n                shifted -= 26\n            encrypted.append(chr(shifted))\n        elif 'A' <= char <= 'Z':\n            # Shift uppercase characters by 4 positions\n            shifted = ord(char) + 4\n            if shifted > ord('Z'):\n                shifted -= 26\n            encrypted.append(chr(shifted))\n        else:\n            # Non-alphabetic characters are left unchanged\n            encrypted.append(char)\n    return ''.join(encrypted)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 83.715953307393, "dps_norm": 57.083333333333336, "pass@1": 98.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) >= 2:\n        return unique_elements[1]\n    return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    sorted_elements = sorted(unique_elements)\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) >= 2:\n        return unique_elements[1]\n    return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) >= 2:\n        return unique_elements[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    first_min = second_min = None\n    for num in lst:\n        if first_min is None or num < first_min:\n            second_min, first_min = first_min, num\n        elif num != first_min:\n            if second_min is None or num < second_min:\n                second_min = num\n\n    return second_min", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    unique_elements = sorted(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = set(lst)  # Remove duplicates\n    if len(unique_elements) < 2:\n        return None  # Not enough unique elements for a 2nd smallest\n    sorted_elements = sorted(unique_elements)\n    return sorted_elements[1]  # Return the 2nd smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) >= 2:\n        return unique_elements[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if not lst:\n        return None\n\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) >= 2:\n        return unique_elements[1]\n    return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_elements = set(lst)\n    \n    # If there are fewer than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Sort the unique elements\n    sorted_elements = sorted(unique_elements)\n    \n    # Return the second smallest element\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_elements = sorted(set(lst))\n    if len(unique_elements) < 2:\n        return None\n    return unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    else:\n        return None", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 99.59432048681542, "dps_norm": 79.16666666666666, "pass@1": 94.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {n}n the str{n}ng {n} of the {n}nput.\"\n    where all the n's should be replaced by the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in '13579')\n        # Create the formatted string with replacements\n        sentence = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(sentence)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        formatted_str = (f\"the number of odd elements {count}n the \"\n                         f\"str{count}ng {count} of the {count}nput.\")\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        replaced = template.replace('i', str(count))\n        result.append(replaced)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where all the count's should be replaced by the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in '13579')\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    template = \"the number of odd elements in the string i of the input.\"\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 == 1)\n        transformed_str = template.replace('i', str(count))\n        result.append(transformed_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's are replaced by the number\n    of odd digits in the corresponding string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in '13579')\n        # Replace all occurrences of 'i' with the count\n        phrase = \"the number of odd elements in the string i of the input.\"\n        modified_phrase = phrase.replace('i', str(count))\n        output.append(modified_phrase)\n    return output", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(\n            f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        )\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements Xn the strXng X of the Xnput.\"\n    where X is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char.isdigit() and int(char) % 2 == 1)\n        # Create the formatted string\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        formatted = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted)\n    return result", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        sentence = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        output.append(sentence)\n    return output", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where {count} is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    >>> odd_count([])\n    []\n    >>> odd_count(['2468', '1357'])\n    [\"the number of odd elements 0n the str0ng 0 of the 0nput.\",\n     \"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in '13579')\n        formatted_str = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element in the output should be \"the number of odd elements {n}n the str{n}ng {n} of the {n}nput.\"\n    where {n} is the number of odd digits in the corresponding input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    >>> odd_count(['2468', '1357', '0000'])\n    [\"the number of odd elements 0n the str0ng 0 of the 0nput.\",\n     \"the number of odd elements 4n the str4ng 4 of the 4nput.\",\n     \"the number of odd elements 0n the str0ng 0 of the 0nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in '13579')\n        n = str(count)\n        # Create the formatted string\n        formatted_str = f\"the number of odd elements {n}n the str{n}ng {n} of the {n}nput.\"\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for c in s if c in '13579')\n        # Create the formatted string with count replacing 'i's\n        message = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(message)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where {count} is the number of odd digits in the corresponding string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in {'1', '3', '5', '7', '9'})\n        message = (f\"the number of odd elements {count}n the str{count}ng \"\n                   f\"{count} of the {count}nput.\")\n        result.append(message)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements <count>n the str<count>ng <count> of the <count>nput.\"\n    where all the 'i's are replaced by the number of odd digits in the corresponding input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    template = \"the number of odd elements in the string i of the input.\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in {'1', '3', '5', '7', '9'})\n        # Replace all occurrences of 'i' with the count\n        modified_str = template.replace('i', str(count))\n        result.append(modified_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where {count} is the number of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if char in '13579')\n        formatted_str = (f\"the number of odd elements {count}n the str{count}ng \"\n                         f\"{count} of the {count}nput.\")\n        result.append(formatted_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements {n}n the str{n}ng {n} of the {n}nput.\"\n    where {n} is the number of odd digits in the corresponding input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in '13579')\n        # Template sentence with 'i's to be replaced\n        sentence = \"the number of odd elements in the string i of the input.\"\n        # Replace all 'i's with the count\n        modified_sentence = ''.join(str(count) if char == 'i' else char for char in sentence)\n        result.append(modified_sentence)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n    where {count} is the number of odd digits in the corresponding input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if c in '13579')\n        output_str = (\n            f\"the number of odd elements {count}n the str{count}ng \"\n            f\"{count} of the {count}nput.\"\n        )\n        result.append(output_str)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element of the output should be \"the number of odd elements Xn the strXng X of the Xnput.\"\n    where X is the number of odd digits in the corresponding input string.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        count = sum(1 for char in s if char in '13579')\n        # Construct the desired sentence with the count inserted appropriately\n        sentence = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(sentence)\n    return result", "matching_cluster_idx": 4}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', \"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    base = \"the number of odd elements in the string i of the input.\"\n    result = []\n    \n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        new_string = base.replace('i', str(count))\n        result.append(new_string)\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        return 'No'  # As per problem, we expect exactly two strings\n\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    concatenated1 = s1 + s2\n    concatenated2 = s2 + s1\n\n    if is_balanced(concatenated1) or is_balanced(concatenated2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance +=1\n            elif char == ')':\n                balance -=1\n            else:\n                # Invalid character\n                return False\n            if balance <0:\n                return False\n        return balance ==0\n\n    if len(lst) !=2:\n        return 'No'\n    \n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n    \n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    # Check both possible concatenations\n    concatenations = [lst[0] + lst[1], lst[1] + lst[0]]\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Check both possible concatenations\n    concatenations = [lst[0] + lst[1], lst[1] + lst[0]]\n    for combined in concatenations:\n        if is_balanced(combined):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n    \n    first, second = lst\n    concatenations = [first + second, second + first]\n    \n    for combined in concatenations:\n        if is_balanced(combined):\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance +=1\n            else:\n                balance -=1\n            if balance <0:\n                return False\n        return balance ==0\n\n    s1, s2 = lst\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    concatenations = [s1 + s2, s2 + s1]\n\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance is negative, there's a closing parenthesis without a matching opening\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both concatenation orders\n    concatenations = [lst[0] + lst[1], lst[1] + lst[0]]\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n\n    # Check both concatenation orders\n    concat1 = s1 + s2\n    concat2 = s2 + s1\n\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # Extract the two strings\n    first, second = lst\n\n    # Check both possible concatenations\n    concatenation1 = first + second\n    concatenation2 = second + first\n\n    if is_balanced(concatenation1) or is_balanced(concatenation2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n\n    # Check both possible concatenation orders\n    concatenations = [s1 + s2, s2 + s1]\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    # Concatenate in both possible orders\n    first_order = lst[0] + lst[1]\n    second_order = lst[1] + lst[0]\n\n    # Check if either concatenation results in a balanced string\n    if is_balanced(first_order) or is_balanced(second_order):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        \"\"\"\n        Helper function to check if the parentheses in the string s are balanced.\n        \"\"\"\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance drops below zero, there's a closing parenthesis without a matching opening\n            if balance < 0:\n                return False\n        # All open parentheses should be closed\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    first, second = lst\n    # Check both possible concatenations\n    concatenations = [first + second, second + first]\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    # There are two possible concatenation orders\n    concatenations = [lst[0] + lst[1], lst[1] + lst[0]]\n    \n    for concat_str in concatenations:\n        if is_balanced(concat_str):\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance is negative, there are more ')' than '('\n            if balance < 0:\n                return False\n        # All open parentheses should be closed\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If at any point balance is negative, it's unbalanced\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Concatenate in both possible orders and check\n    first_order = lst[0] + lst[1]\n    second_order = lst[1] + lst[0]\n\n    if is_balanced(first_order) or is_balanced(second_order):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            # If balance is negative, there are more ')' than '(' up to this point\n            if balance < 0:\n                return False\n        # In the end, balance should be zero for a balanced string\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n    concatenations = [s1 + s2, s2 + s1]\n\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            # If count goes negative, there are more ')' than '(' so far\n            if count < 0:\n                return False\n        # All open parentheses should be closed\n        return count == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    first, second = lst\n\n    # Check both possible concatenations\n    if is_balanced(first + second) or is_balanced(second + first):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            else:\n                # Invalid character\n                return False\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n\n    # Check both possible concatenations\n    concatenations = [s1 + s2, s2 + s1]\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    if len(lst) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n\n    s1, s2 = lst\n    concatenations = [s1 + s2, s2 + s1]\n\n    for concat in concatenations:\n        if is_balanced(concat):\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 57.327586206896555, "dps_norm": 82.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order to get the largest k elements\n    sorted_arr = sorted(arr, reverse=True)\n    # Select the first k elements\n    max_k = sorted_arr[:k]\n    # Sort the selected elements in ascending order before returning\n    return sorted(max_k)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use nlargest to get the k largest elements\n    import heapq\n    k_largest = heapq.nlargest(k, arr)\n    # Sort the result in ascending order\n    return sorted(k_largest)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Return the last k elements\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array.\")\n    \n    # Find the k largest elements\n    k_largest = sorted(arr, reverse=True)[:k]\n    \n    # Sort the k largest elements in ascending order\n    return sorted(k_largest)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order to get the largest elements first\n    sorted_desc = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_desc[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array.\")\n\n    # Sort the array in descending order and take the first k elements\n    top_k = sorted(arr, reverse=True)[:k]\n    # Sort the selected elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use heapq.nlargest to get the k largest elements\n    top_k = heapq.nlargest(k, arr)\n    # Sort the result in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Return the last k elements\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order to get the largest k elements\n    sorted_desc = sorted(arr, reverse=True)\n    # Take the first k elements\n    top_k = sorted_desc[:k]\n    # Sort the top k elements in ascending order\n    top_k_sorted = sorted(top_k)\n    return top_k_sorted", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Get the k largest elements\n    largest_k = sorted(arr, reverse=True)[:k]\n    # Sort them in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 5}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Get the k largest elements\n    largest_k = heapq.nlargest(k, arr)\n    # Return them sorted in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order to get the largest k elements\n    sorted_desc = sorted(arr, reverse=True)\n    # Take the first k elements\n    top_k = sorted_desc[:k]\n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array.\")\n\n    # Sort the array in descending order to get the k largest elements\n    sorted_desc = sorted(arr, reverse=True)\n    top_k = sorted_desc[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order to get the largest elements first\n    sorted_desc = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_desc[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    sorted_top_k = sorted(top_k)\n    \n    return sorted_top_k", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order to get the largest k elements\n    sorted_desc = sorted(arr, reverse=True)\n    # Extract the top k elements\n    top_k = sorted_desc[:k]\n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Extract the last k elements (which are the k largest)\n    k_largest = sorted_arr[-k:]\n    \n    return k_largest", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Find the k largest elements\n    import heapq\n    largest_k = heapq.nlargest(k, arr)\n    # Sort them in ascending order\n    return sorted(largest_k)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Use nlargest to get the k largest elements\n    import heapq\n    k_largest = heapq.nlargest(k, arr)\n    # Sort them in ascending order\n    return sorted(k_largest)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order to get the largest elements first\n    sorted_desc = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    top_k = sorted_desc[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements which are the largest\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 83.67713004484305, "dps_norm": 62.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Even positions are indices 0, 2, 4, ...\n    even_position_elements = lst[::2]\n    # Filter odd elements from these positions\n    odd_elements = [num for num in even_position_elements if num % 2 != 0]\n    # Return the sum of the filtered odd elements\n    return sum(odd_elements)", "matching_cluster_idx": 5}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over even indices\n    for index in range(0, len(lst), 2):\n        if lst[index] % 2 != 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n        solution([5, 8, 7, 1]) ==> 12\n        solution([3, 3, 3, 3, 3]) ==> 9\n        solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum\n    total = 0\n\n    # Iterate over even indices (0-based)\n    for index in range(0, len(lst), 2):\n        if lst[index] % 2 != 0:\n            total += lst[index]\n\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Even positions have indices 0, 2, 4, etc.\n    # Sum elements at even indices that are odd\n    return sum(element for index, element in enumerate(lst) if index % 2 == 0 and element % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 0 and element % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Positions are zero-based indices.\n\n    Examples:\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    \n    # Iterate over even indices\n    for index in range(0, len(lst), 2):\n        element = lst[index]\n        if element % 2 != 0:\n            total += element\n            \n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(element for idx, element in enumerate(lst) if idx % 2 == 0 and element % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total = 0\n    for index in range(0, len(lst), 2):  # Iterate over even indices: 0, 2, 4, ...\n        if lst[index] % 2 != 0:           # Check if the element is odd\n            total += lst[index]           # Add to total if odd\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over even indices\n    for index in range(0, len(lst), 2):\n        if lst[index] % 2 != 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize sum\n    total = 0\n    # Iterate over even indices\n    for index in range(0, len(lst), 2):\n        if lst[index] % 2 != 0:\n            total += lst[index]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(element for index, element in enumerate(lst) if index % 2 == 0 and element % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    --------\n    >>> solution([5, 8, 7, 1])\n    12\n    >>> solution([3, 3, 3, 3, 3])\n    9\n    >>> solution([30, 13, 24, 321])\n    0\n    \"\"\"\n    # Sum of odd numbers at even indices (0-based)\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 87.71653543307087, "dps_norm": 62.85714285714286, "pass@1": 30.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    \n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the filtered list by length and then alphabetically\n    sorted_filtered = sorted(filtered, key=lambda x: (len(x), x))\n    \n    return sorted_filtered", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list first alphabetically, then by length\n    # Since all remaining strings have even lengths, primary sort by length,\n    # and secondary sort alphabetically if needed\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted by ascending length.\n    If two strings have the same length, they are sorted alphabetically.\n\n    Args:\n        lst (list of str): The input list of strings.\n\n    Returns:\n        list of str: The sorted list with only even-length strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list: first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes the strings with odd lengths,\n    and returns the resulting list sorted in ascending order by length.\n    If two words have the same length, they are sorted alphabetically.\n\n    Parameters:\n    lst (list of str): The input list of strings.\n\n    Returns:\n    list of str: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically to ensure the secondary sort\n    even_length_strings.sort()\n    \n    # Then sort by length to ensure the primary sort\n    even_length_strings.sort(key=len)\n    \n    return even_length_strings", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list: first by length, then alphabetically\n    # Since all words have the same length, this will sort alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that after removing odd-length strings, all remaining words\n    will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # If no strings remain after filtering, return an empty list\n    if not even_length_strings:\n        return []\n    \n    # Since all remaining strings have the same length, sort alphabetically\n    # If not all strings have the same length, sort by length then alphabetically\n    # This handles both possibilities\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted in ascending order by length.\n    If two words have the same length, they are sorted alphabetically.\n\n    Args:\n        lst (list of str): The input list of strings.\n\n    Returns:\n        list of str: The filtered and sorted list of strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length\n    even_length_strings.sort()  # Sort alphabetically\n    even_length_strings.sort(key=len)  # Then sort by length\n\n    return even_length_strings", "matching_cluster_idx": 6}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first alphabetically, then by length\n    sorted_lst = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word,\n    and you should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list by length and then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    \n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    \n    The function should return a list of strings in sorted order.\n    \n    You may assume that all words will have the same length.\n    \n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the sorted list. The sorting is done first by\n    ascending length and then alphabetically for strings of the same length.\n\n    Parameters:\n    lst (list of str): The list of strings to process.\n\n    Returns:\n    list of str: The sorted list with only even-length strings.\n    \n    Examples:\n        >>> sorted_list_sum([\"aa\", \"a\", \"aaa\"])\n        [\"aa\"]\n        >>> sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"])\n        [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_words = sorted(even_length_words, key=lambda x: (len(x), x))\n    \n    return sorted_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulting list in sorted order.\n\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list:\n    # First by length (ascending), then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n\n    return sorted_list", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 70.97457627118644, "dps_norm": 84.375, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    Args:\n    - n (int): The number to check.\n    \n    Returns:\n    - bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 4}, {"solution": "import math\ndef is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if n is not a prime number, False otherwise.\n    \n    Examples:\n    >>> is_not_prime(2)\n    False\n    >>> is_not_prime(4)\n    True\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # 0 and 1 are not prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Other even numbers are not prime\n    sqrt_n = int(n**0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n\n    # Check for factors from 3 to the square root of n\n    import math\n    sqrt_n = int(math.sqrt(n)) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Identify non-prime numbers.\n    Returns True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False if n is prime.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines whether a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True  # Divisible by a number other than 1 and itself\n    return False  # No divisors found, number is prime", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n    \n    Args:\n        n (int): The number to check.\n        \n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n\n    sqrt_n = int(n**0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine whether a number is not prime.\n    \n    Args:\n        n (int): The number to check.\n    \n    Returns:\n        bool: True if n is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Other even numbers are not prime\n\n    sqrt_n = int(n ** 0.5) + 1\n    for divisor in range(3, sqrt_n, 2):\n        if n % divisor == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine whether a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True  # 0 and 1 are not prime numbers\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n\n    sqrt_n = int(n ** 0.5) + 1\n    for i in range(3, sqrt_n, 2):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determine if a number is not prime.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if n is not prime, False otherwise.\n    \"\"\"\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, not prime\n    return False  # No divisors found, prime", "matching_cluster_idx": 4}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to return.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    if n <= 0:\n        return []\n    # Use heapq.nlargest to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Parameters:\n    numbers (list): The list of integers to search.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from the given list and returns them in descending order.\n\n    Parameters:\n    nums (list): The list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Return the n largest integers from the list in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        numbers (List[int]): The list of numbers to search.\n        n (int): The number of largest elements to return.\n    \n    Returns:\n        List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    # Using heapq.nlargest to get the n largest elements\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    - numbers (list of int): The list of integers to search.\n    - n (int): The number of largest integers to find.\n    \n    Returns:\n    - list of int: The n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Parameters:\n    numbers (list): A list of integers.\n    n (int): The number of largest integers to retrieve.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    Parameters:\n    numbers (list): The list of integers.\n    n (int): The number of largest integers to retrieve.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    Parameters:\n    numbers (list): The list of integers to search.\n    n (int): The number of largest integers to return.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Return the n largest integers from the list in descending order.\n    \n    Parameters:\n    nums (List[int]): The list of numbers to search.\n    n (int): The number of largest integers to return.\n    \n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest = heapq.nlargest(n, nums)\n    # Sort the largest elements in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from a given list and returns them in descending order.\n    \n    Parameters:\n    numbers (list): The list of integers to search.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use heapq.nlargest to get the n largest elements\n    largest = heapq.nlargest(n, numbers)\n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        nums (list): The list of integers to evaluate.\n        n (int): The number of top elements to return.\n\n    Returns:\n        list: A list containing the n largest integers in descending order.\n    \n    Example:\n        >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n        [85, 75, 65]\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param numbers: List of integers\n    :param n: Number of largest integers to return\n    :return: List of n largest integers in descending order\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n        numbers (list): A list of integers.\n        n (int): The number of largest integers to retrieve.\n        \n    Returns:\n        list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Returns the n largest integers from the given list in descending order.\n    \n    Parameters:\n    numbers (list): The list of integers to search.\n    n (int): The number of largest integers to return.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list and return them in descending order.\n\n    Parameters:\n    nums (List[int]): The list of integers to search.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from the given list and return them in descending order.\n\n    :param nums: List of integers.\n    :param n: Number of largest integers to find.\n    :return: List of n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Finds the n largest integers from the given list and returns them in descending order.\n\n    :param numbers: List of integers.\n    :param n: Number of largest elements to return.\n    :return: List of n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): The list of integers.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    list: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, numbers)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from the given list of numbers and returns them in descending order.\n    \n    Parameters:\n    nums (List[int]): The list of integers to search.\n    n (int): The number of largest integers to find.\n    \n    Returns:\n    List[int]: A list containing the n largest integers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 69.45578231292517, "dps_norm": 59.0, "pass@1": 100.0, "profiled": [{"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # If no rotation results in the same string, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # If no smaller rotation found, return the length of the string", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to return the string to its original form.\n    A rotation is defined as moving the first character to the end of the string.\n\n    :param s: The input string.\n    :return: The minimum number of rotations required.\n    \"\"\"\n    if not s:\n        return 0  # No rotations needed for empty string\n\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # In the worst case, n rotations are needed", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first character of the string to the end.\n    The function returns the smallest number of such rotations needed to return to the original string.\n    \n    :param s: The input string.\n    :return: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            if s == s[k:] + s[:k]:\n                return k\n    return n  # In the worst case, return the length of the string", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get back the same string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n         Returns 0 if the string is empty.\n    \"\"\"\n    if not s:\n        return 0  # No rotations needed for empty string\n    \n    n = len(s)\n    rotated = s\n    for rotation in range(1, n + 1):\n        # Perform one rotation: move the first character to the end\n        rotated = rotated[1:] + rotated[0]\n        if rotated == s:\n            return rotation\n    return n  # In the worst case, it takes n rotations to return to the original", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n\n    Parameters:\n    s (str): The input string to rotate.\n\n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # In the worst case, rotating n times returns the original string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to return the string to its original form.\n    \n    A rotation is defined as moving the first character of the string to the end.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations needed.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # In the worst case, n rotations are needed", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first k characters to the end of the string.\n    \n    Parameters:\n    s (str): The input string to rotate.\n    \n    Returns:\n    int: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if s[k:] + s[:k] == s:\n            return k\n    return n  # In the worst case, full rotation returns the same string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    A rotation is defined as moving the first character to the end of the string.\n    \n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    if not s:\n        return 0  # No rotation needed for empty string\n    \n    original = s\n    rotated = s\n    count = 0\n    n = len(s)\n    \n    while True:\n        # Perform one rotation: move first character to the end\n        rotated = rotated[1:] + rotated[0]\n        count += 1\n        \n        if rotated == original:\n            return count\n        if count > n:\n            # This should not happen as the maximum rotations needed is equal to the length of the string\n            return -1  # Indicates an error", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    A rotation is defined as moving the first character to the end of the string.\n\n    :param s: The input string.\n    :return: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    if not s:\n        return 0  # No rotations needed for empty string\n\n    original = s\n    count = 0\n    n = len(s)\n\n    while True:\n        # Perform one rotation: move first character to the end\n        s = s[1:] + s[0]\n        count += 1\n\n        if s == original:\n            return count\n\n        if count > n:\n            # In case something goes wrong, prevent infinite loop\n            return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    A rotation is defined as moving the first `k` characters of the string to the end.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # In the worst case, it takes n rotations to return to the original string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations required to return the string to its original form.\n    \n    Args:\n        s (str): The input string to rotate.\n        \n    Returns:\n        int: The minimum number of rotations needed.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # If no rotation returns the string earlier, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # In the worst case, rotating n times gives the original string", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    if not s:\n        return 0  # Define behavior for empty string\n    original = s\n    rotated = s\n    rotations = 0\n    while True:\n        # Perform a left rotation by one character\n        rotated = rotated[1:] + rotated[0]\n        rotations += 1\n        if rotated == original:\n            return rotations\n        if rotations > len(s):\n            # If no rotation returns to the original string\n            return -1", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to return the string to its original form.\n\n    Parameters:\n    s (str): The input string to be rotated.\n\n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # If no smaller rotation is found, return the length of the string", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for k in range(1, n + 1):\n        if s[k:] + s[:k] == s:\n            return k\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of left rotations (greater than 0) required to return the string to its original form.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations needed. Returns 0 for empty strings.\n    \"\"\"\n    if not s:\n        return 0  # No rotations needed for empty string\n    \n    original = s\n    rotated = s\n    n = len(s)\n    \n    for rotation in range(1, n + 1):\n        # Perform a single left rotation\n        rotated = rotated[1:] + rotated[0]\n        if rotated == original:\n            return rotation\n    \n    return n  # In the worst case, it takes n rotations to return to original", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to return the string to its original form.\n\n    Parameters:\n    s (str): The input string to rotate.\n\n    Returns:\n    int: The minimum number of rotations needed.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        rotated = s[k:] + s[:k]\n        if rotated == s:\n            return k\n    return n  # If no smaller rotation found, return the length of the string", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    A single rotation is defined as moving the first character to the end of the string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The minimum number of rotations needed to return to the original string.\n    \"\"\"\n    n = len(s)\n    for k in range(1, n + 1):\n        if n % k == 0:\n            rotated = s[k:] + s[:k]\n            if rotated == s:\n                return k\n    return n  # In the worst case, the string returns to itself after n rotations", "matching_cluster_idx": 7}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Finds the minimum number of rotations (greater than 0) required to return the string to its original state.\n    \n    A rotation is defined as moving the first character to the end of the string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations needed.\n    \"\"\"\n    if not s:\n        return 0  # No rotations needed for empty string\n    rotated = s\n    count = 0\n    while True:\n        rotated = rotated[1:] + rotated[0]\n        count += 1\n        if rotated == s:\n            return count\n        if count > len(s):\n            # This should not happen as the string will always repeat within its length\n            return len(s)", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 44.03225806451613, "dps_norm": 80.0, "pass@1": 96.0, "profiled": [{"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of character `c` from string `s`.\n    \n    Parameters:\n    s (str): The original string.\n    c (str): The character to remove.\n    \n    Returns:\n    str: The modified string with first and last occurrences of `c` removed.\n    \"\"\"\n    indices = [i for i, char in enumerate(s) if char == c]\n    \n    if not indices:\n        # Character not found, return original string\n        return s\n    elif len(indices) == 1:\n        # Only one occurrence, remove it\n        return s[:indices[0]] + s[indices[0]+1:]\n    else:\n        # Remove first and last occurrence\n        first, last = indices[0], indices[-1]\n        return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrences of the character removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    if first == -1:\n        # Character not found, return the original string\n        return s\n    elif first == last:\n        # Character occurs only once, remove it\n        return s[:first] + s[first + 1:]\n    else:\n        # Remove both first and last occurrences\n        # To avoid index shifting, remove the last occurrence first\n        s = s[:last] + s[last + 1:]\n        s = s[:first] + s[first + 1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    if not char or len(char) != 1:\n        raise ValueError(\"The 'char' parameter must be a single character.\")\n    \n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character does not exist or occurs only once, handle accordingly\n    if first_index == -1:\n        return s  # Character not found\n    if first_index == last_index:\n        # Remove the single occurrence\n        return s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence first to avoid affecting the index of the first\n    s = s[:last_index] + s[last_index+1:]\n    s = s[:first_index] + s[first_index+1:]\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of the character `c` from the string `s`.\n\n    If the character `c` occurs only once, it removes that single occurrence.\n    If the character `c` does not occur in the string, it returns the original string unchanged.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n\n    if first == -1:\n        # Character not found\n        return s\n    if first == last:\n        # Character occurs only once\n        return s[:first] + s[first+1:]\n    else:\n        # Remove the last occurrence first to avoid affecting the first index\n        s = s[:last] + s[last+1:]\n        # Then remove the first occurrence\n        s = s[:first] + s[first+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    if first == -1:\n        # Character not found in the string\n        return s\n    if first == last:\n        # Character occurs only once; remove that single occurrence\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid affecting the index of the first occurrence\n    s = s[:last] + s[last+1:]\n    # Remove the first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Remove the first and last occurrence of character `c` from string `s`.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of `c`.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n\n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n\n    # If the character occurs only once, remove that single occurrence\n    if first == last:\n        return s[:first] + s[first+1:]\n\n    # Remove both the first and last occurrences\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    ch (str): The character to remove.\n\n    Returns:\n    str: The string after removing the first and last occurrence of `ch`.\n    \"\"\"\n    first = s.find(ch)\n    last = s.rfind(ch)\n    \n    if first == -1:\n        # Character not found, return original string\n        return s\n    if first == last:\n        # Only one occurrence found, remove it\n        return s[:first] + s[first+1:]\n    \n    # Remove both first and last occurrences\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    if first_index == -1:\n        # Character not found, return original string\n        return s\n    elif first_index == last_index:\n        # Character occurs only once, remove it\n        return s[:first_index] + s[first_index+1:]\n    else:\n        # Remove last occurrence first to not mess up the first_index\n        s = s[:last_index] + s[last_index+1:]\n        # Then remove the first occurrence\n        s = s[:first_index] + s[first_index+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Remove the first and last occurrence of the character `c` from the string `s`.\n    \n    Parameters:\n    s (str): The input string.\n    c (str): The character to remove.\n    \n    Returns:\n    str: The string after removing the first and last occurrence of `c`.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == -1:\n        # Character not found, return original string\n        return s\n    if first == last:\n        # Only one occurrence, remove it\n        return s[:first] + s[first+1:]\n    \n    # Remove both first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrences of char removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first = s.find(char)\n    \n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n    \n    # Find the index of the last occurrence\n    last = s.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first == last:\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid affecting the first index\n    s = s[:last] + s[last+1:]\n    \n    # Remove the first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Args:\n        s (str): The input string.\n        c (str): The character to remove.\n\n    Returns:\n        str: The string after removing the first and last occurrence of the character.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n\n    if first == -1:\n        # Character not found\n        return s\n    if first == last:\n        # Only one occurrence found\n        return s[:first] + s[first+1:]\n    \n    # Remove first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n    \n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n    \n    Returns:\n    str: The modified string with the first and last occurrence of char removed.\n    \"\"\"\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    if first_index == -1:\n        # Character not found in the string\n        return s\n    if first_index == last_index:\n        # Character occurs only once\n        return s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence first to not affect the first index\n    s = s[:last_index] + s[last_index+1:]\n    # Then remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of the character `c` from the string `s`.\n    \n    If the character `c` appears only once, it is removed once.\n    If the character `c` does not appear in the string, the original string is returned.\n    \n    :param s: The original string.\n    :param c: The character to remove.\n    :return: The modified string with the first and last occurrence of `c` removed.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == -1:\n        # Character not found\n        return s\n    elif first == last:\n        # Character found only once\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first and last occurrence\n        # Convert string to list for easier manipulation\n        chars = list(s)\n        # Mark the characters to remove by replacing them with None\n        chars[first] = None\n        chars[last] = None\n        # Reconstruct the string without the removed characters\n        return ''.join([char for char in chars if char is not None])", "matching_cluster_idx": 0}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    :param s: The original string.\n    :param char: The character to remove.\n    :return: A new string with the first and last occurrences of char removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n\n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n\n    # If the first and last occurrences are the same, remove it once\n    if first == last:\n        return s[:first] + s[first+1:]\n\n    # Remove the last occurrence first to avoid affecting the index of the first occurrence\n    s = s[:last] + s[last+1:]\n    # Then remove the first occurrence\n    s = s[:first] + s[first+1:]\n\n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of character `c` from the string `s`.\n    If the character occurs only once, it removes that single occurrence.\n    If the character does not exist in the string, returns the original string.\n    \"\"\"\n    first = s.find(c)\n    last = s.rfind(c)\n    \n    if first == -1:\n        # Character not found\n        return s\n    elif first == last:\n        # Character occurs only once\n        return s[:first] + s[first+1:]\n    else:\n        # Remove first occurrence\n        s = s[:first] + s[first+1:]\n        # Adjust the last index since the string has been modified\n        last = s.rfind(c)\n        # Remove last occurrence\n        s = s[:last] + s[last+1:]\n        return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    \"\"\"\n    Remove the first and last occurrence of the specified character from the string.\n\n    Args:\n    s (str): The original string.\n    ch (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of `ch` removed.\n    \"\"\"\n    first = s.find(ch)\n    last = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n    \n    # If the character occurs only once, remove that single occurrence\n    if first == last:\n        return s[:first] + s[first+1:]\n    \n    # Remove the first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrences of `char` removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first == -1:\n        return s\n    \n    # If the character occurs only once, remove that single occurrence\n    if first == last:\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid affecting the index of the first occurrence\n    s = s[:last] + s[last+1:]\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s: str, c: str) -> str:\n    \"\"\"\n    Removes the first and last occurrence of character 'c' from string 's'.\n    If the character occurs only once, it removes that single occurrence.\n    If the character does not exist in the string, it returns the original string.\n    \n    Parameters:\n    s (str): The input string.\n    c (str): The character to remove.\n    \n    Returns:\n    str: The modified string with specified characters removed.\n    \"\"\"\n    # Find all indices where character c occurs\n    indices = [i for i, char in enumerate(s) if char == c]\n    \n    # If character c does not exist, return original string\n    if not indices:\n        return s\n    \n    # Determine indices to remove\n    # If only one occurrence, remove it\n    if len(indices) == 1:\n        indices_to_remove = {indices[0]}\n    else:\n        # Remove first and last occurrence\n        indices_to_remove = {indices[0], indices[-1]}\n    \n    # Build the new string excluding the characters at indices_to_remove\n    new_s = ''.join([char for i, char in enumerate(s) if i not in indices_to_remove])\n    \n    return new_s", "matching_cluster_idx": -1}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrences of char removed.\n    \"\"\"\n    first = s.find(char)\n    last = s.rfind(char)\n    \n    if first == -1:\n        # Character not found\n        return s\n    if first == last:\n        # Only one occurrence found\n        return s[:first] + s[first+1:]\n    \n    # Remove the last occurrence first to avoid affecting the first index\n    s = s[:last] + s[last+1:]\n    # Then remove the first occurrence\n    s = s[:first] + s[first+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrence of the specified character from the string.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to remove.\n\n    Returns:\n    str: The modified string with the first and last occurrence of 'char' removed.\n    \"\"\"\n    first = s.find(char)\n    if first == -1:\n        # Character not found, return original string\n        return s\n\n    last = s.rfind(char)\n    if first == last:\n        # Only one occurrence found, remove it\n        return s[:first] + s[first+1:]\n    \n    # Remove first and last occurrences\n    return s[:first] + s[first+1:last] + s[last+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the matrix in ascending order based on the sum of its rows.\n    \n    Parameters:\n    matrix (list of list of int): The input matrix to be sorted.\n    \n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of list of int): The matrix to sort.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    # Use the built-in sorted function with sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of list of int): The matrix to sort.\n\n    Returns:\n        list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Use sorted with key as the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n    \n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :return: A new matrix sorted by the sum of its rows in ascending order.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): A 2D list where each sublist represents a row in the matrix.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to sort.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix (list of lists): The matrix to sort.\n        \n    Returns:\n        list of lists: The sorted matrix.\n        \n    Example:\n        >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n        [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Args:\n        matrix (list of lists): The matrix to sort.\n\n    Returns:\n        list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort the matrix in ascending order based on the sum of its rows.\n    \n    Args:\n        matrix (list of list of int): The matrix to sort.\n        \n    Returns:\n        list of list of int: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts the given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order based on the sum of its rows.\n\n    Parameters:\n    matrix (list of lists): The matrix to be sorted.\n\n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix using the sum of each row as the key\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 93.65853658536585, "dps_norm": 97.5, "pass@1": 88.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by underscores, otherwise returns False.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters \n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by a single underscore. Otherwise, returns False.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, and False otherwise.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \n    Example:\n        assert text_lowercase_underscore(\"aab_cbbbc\") == True\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of lowercase letters separated by single underscores.\n    Otherwise, returns False.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    separated by a single underscore. Otherwise, returns False.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with a single underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Args:\n        s (str): The input string to be evaluated.\n        \n    Returns:\n        bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string consists of sequences of lowercase letters\n    joined by underscores. Returns False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Parameters:\n    s (str): The input string to check.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters \n    joined with an underscore, and False otherwise.\n    \n    Parameters:\n    s (str): The input string to check.\n\n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(?:_[a-z]+)*$')\n    return bool(pattern.fullmatch(s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters \n    joined with an underscore, and False otherwise.\n    \n    Args:\n        s (str): The input string to check.\n        \n    Returns:\n        bool: True if the condition is met, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(?:_[a-z]+)*$'\n    return bool(re.fullmatch(pattern, s))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 77.02020202020202, "dps_norm": 87.0, "pass@1": 84.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given list contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Args:\n        arr (list of int): The array to check.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if there are any duplicate elements in the list.\n\n    Parameters:\n    nums (List[int]): The list of integers to check.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the array contains any duplicate elements.\n\n    :param arr: List of integers\n    :return: True if any duplicates are found, False otherwise\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n\n    Args:\n        arr (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates exist, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the given list.\n\n    Args:\n        arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Using a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Determines if there are any duplicate elements in the given list of integers.\n\n    Args:\n        nums (list of int): The list of integers to check for duplicates.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    # Using a set to store unique elements and comparing its length to the original list\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if any duplicate element is found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n\n    Args:\n        arr (list of int): The array to check for duplicates.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to determine if there are any duplicate elements in the array.\n\n    Parameters:\n    arr (list of int): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The array of integers to check for duplicates.\n\n    Returns:\n    bool: True if any duplicates are found, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Args:\n        arr (list): List of integers.\n\n    Returns:\n        bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Returns True if there are any duplicate elements in the array, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if there are any duplicate elements in the array.\n\n    Parameters:\n    arr (list): The list of integers to check for duplicates.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Checks if the given array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the array contains any duplicate elements.\n\n    Args:\n        arr (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n\n    Args:\n        arr (list of int): The array of integers to check.\n\n    Returns:\n        bool: True if duplicates are found, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 71.5, "dps_norm": 81.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds and returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    min_num = lst[0]\n    for num in lst[1:]:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"Return the smallest number in the list.\"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the provided list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n\n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find and return the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of integers or floats.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty and has no smallest number.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int or float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    min_num = lst[0]\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Finds and returns the smallest number in a list.\n\n    Args:\n        numbers (list): A list of integers or floats.\n\n    Returns:\n        The smallest number in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n\n    smallest = lst[0]\n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list is empty.\")\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds and returns the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty and has no smallest number.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the given list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int/float: The smallest number in the list.\n\n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Returns the smallest number in the provided list.\n\n    Parameters:\n    lst (list): A list of numerical values.\n\n    Returns:\n    int/float: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Finds tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n    assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n    \n    :param tuple_list: List of tuples to be filtered\n    :param k: Integer divisor\n    :return: List of tuples with all elements divisible by k\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Args:\n        tuples_list (list of tuples): The list of tuples to check.\n        k (int): The divisor.\n\n    Returns:\n        list of tuples: Tuples where every element is divisible by k.\n\n    Example:\n        >>> find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6)\n        [(6, 24, 12)]\n    \"\"\"\n    return [t for t in tuples_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to filter.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Finds and returns tuples from the given list where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to be filtered.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    :param tuples_list: List of tuples to be checked\n    :param k: The divisor\n    :return: List of tuples with all elements divisible by k\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Find tuples where all elements are divisible by k.\n\n    Args:\n        list_of_tuples (list of tuples): The list of tuples to evaluate.\n        k (int): The divisor.\n\n    Returns:\n        list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [tup for tup in list_of_tuples if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns a list of tuples where all elements in each tuple are divisible by k.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to be checked.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Finds and returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to filter.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements in each tuple are divisible by k.\n    \n    Parameters:\n    tuples_list (list of tuples): The list of tuples to evaluate.\n    k (int): The divisor.\n    \n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    :param tuple_list: List of tuples to be checked\n    :param k: The divisor\n    :return: List of tuples with all elements divisible by k\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n    \n    Parameters:\n    tuples_list (list of tuples): The input list of tuples to filter.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: A list containing tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds and returns a list of tuples where all elements are divisible by k.\n\n    Args:\n        tuples_list (list of tuples): The list of tuples to check.\n        k (int): The divisor.\n\n    Returns:\n        list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Finds and returns tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(list_of_tuples, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    - list_of_tuples: List of tuples containing integers.\n    - k: An integer divisor.\n\n    Returns:\n    - List of tuples with all elements divisible by k.\n    \"\"\"\n    return [t for t in list_of_tuples if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    tuple_list (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in tuple_list if all(elem % k == 0 for elem in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    \"\"\"\n    Finds and returns a list of tuples where all elements are divisible by k.\n\n    Parameters:\n    lst (list of tuples): The list of tuples to check.\n    k (int): The divisor.\n\n    Returns:\n    list of tuples: Tuples where every element is divisible by k.\n    \"\"\"\n    return [t for t in lst if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 77.45098039215686, "dps_norm": 81.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Args:\n        lst (list): The list of elements to count.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Args:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for elem in lst:\n        if elem in frequency:\n            frequency[elem] += 1\n        else:\n            frequency[elem] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Args:\n        lst (list): The list of elements to count.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list of elements to count frequencies for.\n\n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Parameters:\n    lst (list): The list of elements to count.\n    \n    Returns:\n    dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Args:\n        lst (list): The list of elements to count.\n        \n    Returns:\n        dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Args:\n        lst (list): The list of elements to count.\n        \n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \n    Args:\n        lst (list): The list of elements to count.\n        \n    Returns:\n        dict: A dictionary where keys are elements from the list and values are their frequencies.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 4}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of each element in the list.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the given list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    :param words: List of strings.\n    :return: Integer representing the length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): The list of words to evaluate.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n\n    Args:\n        words (list of str): A list of words.\n\n    Returns:\n        int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list `words`.\n    \n    Args:\n        words (list of str): A list of words.\n        \n    Returns:\n        int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the given list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    :param words: List of words (strings)\n    :return: Integer representing the length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Finds the length of the longest word in a list.\n\n    Parameters:\n    words (list of str): The list of words to evaluate.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n    \n    :param words: List of strings\n    :return: Integer representing the length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    :param words: List of strings\n    :return: Integer length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list.\n    \"\"\"\n    if not words:\n        return 0  # Return 0 if the list is empty\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): List containing words as strings.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n    \n    :param words: List of strings\n    :return: Integer representing the length of the longest word\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): List containing words as strings.\n\n    Returns:\n    int: Length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the provided list of words.\n    \n    Parameters:\n    words (list of str): List of words to evaluate.\n\n    Returns:\n    int: Length of the longest word.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Returns the length of the longest word in the given list.\n\n    Parameters:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word. Returns 0 if the list is empty.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.8719512195122, "dps_norm": 62.0, "pass@1": 100.0, "profiled": [{"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        lst (list of tuples): A list where each tuple contains at least two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    for tup in lst[1:]:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    # Use the min function with a key that specifies to compare based on the second element of each tuple\n    smallest_tuple = min(lst, key=lambda x: x[1])\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples, where each tuple contains at least two elements.\n    :return: The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    for tup in lst:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    \n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): A list where each tuple contains a string and a numeric value.\n    \n    Returns:\n    str: The first element of the tuple with the smallest second value.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    # Use the min function with a key to find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n        lst (list of tuples): List containing tuples of the form (value, number).\n    \n    Returns:\n        The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n\n    Parameters:\n    tuple_list (list of tuples): A list where each tuple contains at least two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        raise ValueError(\"The list is empty.\")\n\n    # Initialize with the first tuple\n    min_tuple = tuple_list[0]\n    min_value = min_tuple[1]\n\n    # Iterate through the list to find the tuple with the smallest second value\n    for item in tuple_list[1:]:\n        if item[1] < min_value:\n            min_tuple = item\n            min_value = item[1]\n\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n\n    Args:\n        lst (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n        The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n\n    min_tuple = lst[0]\n    for item in lst[1:]:\n        if item[1] < min_tuple[1]:\n            min_tuple = item\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    \n    for tup in lst[1:]:\n        if tup[1] < min_tuple[1]:\n            min_tuple = tup\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value in the list.\n    \n    :param lst: List of tuples where each tuple contains a name and a number.\n    :return: The name with the smallest associated number.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): Each tuple contains at least two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        return None  # Handle empty list case\n    \n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    # Find the tuple with the smallest second value\n    min_tuple = min(lst, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second value.\n\n    Parameters:\n    tuples_list (list of tuples): A list where each tuple contains two elements.\n\n    Returns:\n    The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list is empty.\")\n    \n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): A list where each tuple contains two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    tuples (list of tuples): A list where each tuple contains two elements.\n    \n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuples:\n        raise ValueError(\"The list of tuples is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples[0]\n    \n    for current_tuple in tuples[1:]:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    tuple_list (list of tuples): Each tuple contains two elements where the second element is comparable.\n\n    Returns:\n    The first element of the tuple with the smallest second element.\n    \"\"\"\n    if not tuple_list:\n        raise ValueError(\"The list is empty\")\n\n    # Initialize with the first tuple\n    min_tuple = tuple_list[0]\n    \n    for current in tuple_list[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \n    Args:\n        tuples_list (list of tuples): Each tuple contains at least two elements where the second element is comparable.\n    \n    Returns:\n        The first element of the tuple with the smallest second value.\n    \n    Example:\n        >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n        'Varsha'\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"The list is empty.\")\n    \n    # Initialize with the first tuple\n    min_tuple = tuples_list[0]\n    \n    for current in tuples_list[1:]:\n        if current[1] < min_tuple[1]:\n            min_tuple = current\n    \n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Parameters:\n    lst (list of tuples): Each tuple contains a name and a numerical value.\n\n    Returns:\n    str: The first element of the tuple with the smallest second value.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    # Initialize with the first tuple\n    min_tuple = lst[0]\n    for item in lst[1:]:\n        if item[1] < min_tuple[1]:\n            min_tuple = item\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 53.6111111111111, "dps_norm": 59.285714285714285, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    n = abs(n)  # Ensure n is positive\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the number of divisors for.\n    \n    Returns:\n    int: The number of positive divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has infinitely many divisors.\")\n    \n    n = abs(n)\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Finds the number of divisors of a given integer.\n\n    Args:\n        n (int): The integer to find divisors for.\n\n    Returns:\n        int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n_abs = abs(n)\n    count = 0\n    for i in range(1, n_abs + 1):\n        if n_abs % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n = abs(n)  # Consider positive divisors only\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    n = abs(n)  # Ensure n is positive\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the divisors of.\n    \n    Returns:\n    int: The number of divisors.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n = abs(n)  # Consider absolute value for negative numbers\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the divisors of.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n = abs(n)  # Consider positive divisors only\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find the number of divisors for.\n    \n    Returns:\n    int: The count of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for. Must be a positive integer.\n    \n    Returns:\n    int: Number of positive divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the integer n.\n    \n    Parameters:\n    n (int): The integer to find the number of divisors for.\n    \n    Returns:\n    int: The number of positive divisors of n.\n    \"\"\"\n    if n < 1:\n        return 0  # Undefined for non-positive integers\n    \n    count = 0\n    sqrt_n = int(n ** 0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1  # i is a divisor\n            if i != n // i:\n                count += 1  # n//i is also a divisor if different from i\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n_abs = abs(n)\n    count = 0\n    for i in range(1, n_abs + 1):\n        if n_abs % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for. Must be a positive integer.\n    \n    Returns:\n    int: The count of positive divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Calculate the number of divisors of a given integer n.\n\n    Parameters:\n    n (int): The integer to find the number of divisors for.\n\n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n\n    return count", "matching_cluster_idx": 5}, {"solution": "import math\ndef divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The count of positive divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n\n    n = abs(n)\n    count = 0\n    sqrt_n = int(math.sqrt(n))\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    \n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer n.\n    \n    Parameters:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors of n.\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Zero has an infinite number of divisors.\")\n    \n    n = abs(n)\n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    \n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of positive divisors of the integer n.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    # Iterate from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Parameters:\n    list_of_lists (List[List[Any]]): A list containing sublists of elements.\n\n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Calculates the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): A list containing sublists with elements.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        lists (List[List[Any]]): A list of lists containing hashable elements.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    for sublist in lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(list_of_lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Takes a list of lists and returns a dictionary with the frequency of each element.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [element for sublist in list_of_lists for element in sublist]\n    \n    # Count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    :param lists: List of lists containing elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    frequency = {}\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The list containing sublists with elements.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency[item] = frequency.get(item, 0) + 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in list_of_lists for item in sublist]\n    \n    # Count the frequency of each element\n    frequency = dict(Counter(flattened))\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    freq = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            freq[item] = freq.get(item, 0) + 1\n    return freq", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a flattened list of lists.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 93.96103896103897, "dps_norm": 98.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Append the elements of the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list is appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of tpl followed by elements of lst.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n        lst (list): The list to append.\n        tpl (tuple): The tuple to append to.\n\n    Returns:\n        tuple: A new tuple containing the elements of the original tuple followed by the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n        lst (list): The list to append.\n        tpl (tuple): The tuple to append to.\n\n    Returns:\n        tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to append the list to.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list elements.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Args:\n    lst (list): The list of elements to append.\n    tup (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with elements of lst appended to tpl.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns the new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list elements.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with elements from the list appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends elements of a list to a tuple and returns a new tuple.\n\n    Args:\n        lst (list): The list of elements to append.\n        tpl (tuple): The original tuple.\n\n    Returns:\n        tuple: A new tuple with the list elements appended.\n    \"\"\"\n    # Convert the list to a tuple and concatenate with the original tuple\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_a, tuple_b):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    Args:\n        list_a (list): The list to append.\n        tuple_b (tuple): The tuple to which the list is appended.\n\n    Returns:\n        tuple: A new tuple containing elements of tuple_b followed by elements of list_a.\n    \"\"\"\n    return tuple_b + tuple(list_a)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to append to.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by the list elements.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The tuple to which the list elements will be appended.\n\n    Returns:\n    tuple: A new tuple containing the elements of the original tuple followed by the list elements.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the elements of the given list to the given tuple and returns a new tuple.\n    \n    Parameters:\n    lst (list): The list of elements to append.\n    tpl (tuple): The original tuple.\n    \n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple and returns the resulting tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with the list elements appended.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends a list to a tuple and returns a new tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tpl (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements of the original tuple followed by the list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(f\"Expected lst to be a list, got {type(lst).__name__}\")\n    if not isinstance(tpl, tuple):\n        raise TypeError(f\"Expected tpl to be a tuple, got {type(tpl).__name__}\")\n    \n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the elements of a list to a tuple.\n\n    Parameters:\n    lst (list): The list of elements to append.\n    tup (tuple): The original tuple.\n\n    Returns:\n    tuple: A new tuple with elements of lst appended to tup.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine the three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from the three input lists.\n    \"\"\"\n    combined = list1 + list2 + list3\n    combined.sort()\n    return combined", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A single sorted list containing all elements from the three input lists.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    combined = list1 + list2 + list3\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers to be merged.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    merged_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(merged_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all three lists\n    merged = list1 + list2 + list3\n    # Sort the merged list\n    sorted_list = sorted(merged)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    merged = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(merged)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n        \n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    combined = list1 + list2 + list3\n    return sorted(combined)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): The first list of integers.\n        list2 (list): The second list of integers.\n        list3 (list): The third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n        list1 (list): The first list of integers.\n        list2 (list): The second list of integers.\n        list3 (list): The third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    merged = list1 + list2 + list3\n    sorted_list = sorted(merged)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1, list2, list3: Lists of integers.\n\n    Returns:\n    - A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    merged = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(merged)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - list3: Third list of integers.\n\n    Returns:\n    - A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list of int): The first list of integers.\n        list2 (list of int): The second list of integers.\n        list3 (list of int): The third list of integers.\n\n    Returns:\n        list of int: A sorted list containing all elements from the three input lists.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list of int): The first list of integers.\n        list2 (list of int): The second list of integers.\n        list3 (list of int): The third list of integers.\n\n    Returns:\n        list of int: A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n\n    Args:\n        list1 (list): First list of integers.\n        list2 (list): Second list of integers.\n        list3 (list): Third list of integers.\n\n    Returns:\n        list: A sorted list containing all elements from list1, list2, and list3.\n    \"\"\"\n    # Combine all three lists\n    combined = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    combined = list1 + list2 + list3\n    return sorted(combined)", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 91.53846153846155, "dps_norm": 86.25, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (list of lists): A list containing multiple lists of elements.\n\n    Returns:\n    set: A set of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple lists.\n\n    Returns:\n        list: A list of common elements present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert each sublist to a set for efficient intersection\n    sets = map(set, nested_lists)\n    \n    # Find the intersection of all sets\n    common_elements = set.intersection(*sets)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    List[int]: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list as a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform set intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n    \n    Parameters:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set.intersection_update(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n    \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list of lists containing elements.\n\n    Returns:\n        List[Any]: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_elements = set(nested_lists[0])\n\n    # Intersect with the sets of the remaining lists\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n    \n    Parameters:\n    lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not lists:\n        return []\n    \n    # Initialize the common elements as the set of the first list\n    common_elements = set(lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in lists[1:]:\n        common_elements &= set(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in all the nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple lists.\n\n    Returns:\n        list: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in the given nested lists.\n\n    Parameters:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    List[int]: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_set &= set(lst)\n        if not common_set:\n            break  # Early exit if no common elements\n\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in the given nested lists.\n\n    :param nested_lists: List of lists containing elements.\n    :return: List of common elements.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert each list to a set\n    sets = map(set, nested_lists)\n    \n    # Find the intersection of all sets\n    common_elements = set.intersection(*sets)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in all nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple lists of elements.\n\n    Returns:\n        list: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for sublist in nested_lists[1:]:\n        common_elements &= set(sublist)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n    \n    Parameters:\n    nested_lists (list of lists): A list containing multiple lists of elements.\n    \n    Returns:\n    list: A list of elements common to all the nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the intersection with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    # Initialize the common elements with the first list\n    common_elements = set(nested_lists[0])\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    \"\"\"\n    Finds the common elements in given nested lists.\n\n    Parameters:\n    lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    List[int]: A list of integers that are common to all nested lists.\n    \"\"\"\n    if not lists:\n        return []\n    \n    # Initialize the common set with the first list\n    common_set = set(lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in lists[1:]:\n        common_set &= set(lst)\n    \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple lists of elements.\n\n    Returns:\n        list: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    # Return the common elements as a sorted list (optional)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements present in all nested lists.\n\n    Args:\n        nested_lists (List[List[Any]]): A list of lists containing elements.\n\n    Returns:\n        List[Any]: A list of elements common to all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds common elements in the given nested lists.\n\n    Args:\n        nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: A list of common integers present in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first list\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and perform intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n        if not common_elements:\n            break  # Early exit if no common elements\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements in the given nested lists.\n\n    Args:\n        nested_lists (list of lists): A list containing multiple sublists.\n\n    Returns:\n        list: A list of elements common to all sublists.\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Initialize the common set with the first sublist\n    common_set = set(nested_lists[0])\n\n    # Iterate through the remaining sublists and perform intersection\n    for sublist in nested_lists[1:]:\n        common_set &= set(sublist)\n\n    return list(common_set)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.64552238805969, "dps_norm": 86.42857142857142, "pass@1": 100.0, "profiled": [{"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n\n    Amicable numbers are two different numbers so related that the sum of the proper divisors\n    of each is equal to the other number.\n\n    Args:\n        n (int): The upper limit of the range to check for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    def sum_of_proper_divisors(num):\n        \"\"\"Calculate the sum of proper divisors of a number.\"\"\"\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                divisors.add(num // i)\n        return sum(divisors)\n\n    amicable_sum = 0\n    for a in range(2, n + 1):\n        b = sum_of_proper_divisors(a)\n        if b != a and b <= n:\n            if sum_of_proper_divisors(b) == a:\n                amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"\n    Calculate the sum of proper divisors of a number n.\n    Proper divisors are numbers less than n which divide evenly into n.\n    \"\"\"\n    if n < 1:\n        return 0\n    divisors = [1]  # 1 is a proper divisor of every number > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            complement = n // i\n            if complement != i:\n                divisors.append(complement)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n    \n    An amicable pair consists of two different numbers so that\n    the sum of the proper divisors of each is equal to the other number.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(2, limit + 1):\n        b = sum_proper_divisors(a)\n        if b != a:\n            if sum_proper_divisors(b) == a:\n                amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                if i != num // i:\n                    divisors.add(num // i)\n        return sum(divisors)\n\n    sum_divisors = {}\n    for i in range(1, n + 1):\n        sum_divisors[i] = sum_proper_divisors(i)\n\n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = sum_divisors[a]\n        if b != a and b <= n and sum_divisors.get(b, 0) == a:\n            amicable_sum += a\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculates the sum of all amicable numbers from 1 to n.\n\n    Args:\n        n (int): The upper limit to calculate amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    def sum_proper_divisors(num):\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                divisors.add(num // i)\n        return sum(divisors)\n\n    amicables = set()\n    for a in range(2, n + 1):\n        b = sum_proper_divisors(a)\n        if b != a and b <= n:\n            if sum_proper_divisors(b) == a:\n                amicables.add(a)\n                amicables.add(b)\n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n\n    An amicable pair consists of two different numbers so that the sum of the proper\n    divisors of each is equal to the other number.\n\n    :param n: The upper limit to search for amicable numbers.\n    :return: The sum of all amicable numbers within the range.\n    \"\"\"\n    def sum_proper_divisors(num):\n        \"\"\"Return the sum of proper divisors of num.\"\"\"\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                complement = num // i\n                if complement != i:\n                    divisors.add(complement)\n        return sum(divisors)\n\n    # Precompute the sum of proper divisors for each number up to n\n    sum_divisors = {}\n    for i in range(1, n + 1):\n        sum_divisors[i] = sum_proper_divisors(i)\n\n    amicable_set = set()\n    for a in range(1, n + 1):\n        b = sum_divisors.get(a, 0)\n        if b != a and b <= n:\n            if sum_divisors.get(b, 0) == a:\n                amicable_set.add(a)\n                amicable_set.add(b)\n\n    return sum(amicable_set)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to the specified limit.\n\n    An amicable pair consists of two numbers where the sum of the proper divisors\n    of each number is equal to the other number.\n\n    Args:\n        limit (int): The upper bound of the range to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n\n    def sum_proper_divisors(n):\n        \"\"\"Return the sum of proper divisors of n.\"\"\"\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                complement = n // i\n                if complement != i:\n                    divisors.add(complement)\n        return sum(divisors)\n\n    amicable_numbers = set()\n\n    for a in range(2, limit + 1):\n        b = sum_proper_divisors(a)\n        if b != a and b <= limit:\n            if sum_proper_divisors(b) == a:\n                amicable_numbers.add(a)\n                amicable_numbers.add(b)\n\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    if n < 2:\n        return 0\n    divisors = {1}\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            if i != n // i:\n                divisors.add(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    checked = set()\n    for num in range(2, limit + 1):\n        if num in checked:\n            continue\n        sum_div = sum_of_proper_divisors(num)\n        if sum_div != num:\n            sum_div_div = sum_of_proper_divisors(sum_div)\n            if sum_div_div == num:\n                amicable_sum += num + sum_div\n                checked.add(num)\n                checked.add(sum_div)\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(num):\n    \"\"\"\n    Returns the sum of proper divisors of num.\n    \"\"\"\n    if num < 1:\n        return 0\n    sum_div = 1  # 1 is a proper divisor for all num > 1\n    sqrt_num = int(num ** 0.5)\n    for i in range(2, sqrt_num + 1):\n        if num % i == 0:\n            sum_div += i\n            complement = num // i\n            if complement != i:\n                sum_div += complement\n    return sum_div\ndef amicable_numbers_sum(n):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to n.\n    \"\"\"\n    sum_amicable = 0\n    for num in range(2, n + 1):\n        sum1 = sum_proper_divisors(num)\n        if sum1 != num:\n            sum2 = sum_proper_divisors(sum1)\n            if sum2 == num:\n                sum_amicable += num\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers up to a specified limit.\n\n    An amicable pair consists of two numbers where the sum of the proper divisors\n    of each number equals the other number. For example, (220, 284) is the smallest\n    amicable pair because:\n        - Proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110; sum = 284\n        - Proper divisors of 284 are 1, 2, 4, 71, 142; sum = 220\n\n    Parameters:\n        limit (int): The upper bound to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers up to the specified limit.\n    \"\"\"\n    def sum_of_proper_divisors(n):\n        \"\"\"Helper function to calculate the sum of proper divisors of n.\"\"\"\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n\n    amicable_sum = 0\n    for number in range(2, limit + 1):\n        sum_divisors = sum_of_proper_divisors(number)\n        if sum_divisors != number:\n            sum_divisors_pair = sum_of_proper_divisors(sum_divisors)\n            if sum_divisors_pair == number:\n                amicable_sum += number\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_of_proper_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n    \n    amicable_numbers = set()\n    for number in range(2, limit + 1):\n        sum_div = sum_of_proper_divisors(number)\n        if sum_div != number:\n            if sum_div <= limit:\n                if sum_of_proper_divisors(sum_div) == number:\n                    amicable_numbers.add(number)\n                    amicable_numbers.add(sum_div)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                if i != n // i:\n                    divisors.add(n // i)\n        return sum(divisors)\n\n    sum_amicables = 0\n    seen = set()\n    for a in range(2, limit + 1):\n        if a in seen:\n            continue\n        b = sum_proper_divisors(a)\n        if b != a and b <= limit:\n            if sum_proper_divisors(b) == a:\n                sum_amicables += a + b\n                seen.update([a, b])\n    return sum_amicables", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(n):\n    \"\"\"\n    Calculate the sum of proper divisors of n.\n    Proper divisors are numbers less than n which divide evenly into n.\n    \"\"\"\n    if n < 1:\n        return 0\n    div_sum = 1  # 1 is a proper divisor for all n > 1\n    max_divisor = int(n**0.5)\n    for i in range(2, max_divisor + 1):\n        if n % i == 0:\n            div_sum += i\n            complement = n // i\n            if complement != i:\n                div_sum += complement\n    return div_sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 to the specified limit.\n\n    An amicable pair consists of two numbers where each number is the sum of the proper divisors of the other.\n    \"\"\"\n    amicable_sum = 0\n    checked = set()\n    \n    for number in range(2, limit + 1):\n        if number in checked:\n            continue\n        partner = sum_of_proper_divisors(number)\n        if partner != number:\n            if sum_of_proper_divisors(partner) == number:\n                amicable_sum += number\n                amicable_sum += partner\n                checked.add(partner)\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(x):\n        divisors = [1]\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                divisors.append(i)\n                if i != x // i:\n                    divisors.append(x // i)\n        return sum(divisors)\n\n    amicables = set()\n    for num in range(1, n + 1):\n        sum1 = sum_proper_divisors(num)\n        if sum1 != num and sum1 <= n:\n            sum2 = sum_proper_divisors(sum1)\n            if sum2 == num:\n                amicables.add(num)\n                amicables.add(sum1)\n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_proper_divisors(n):\n        \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n        if n < 2:\n            return 0\n        total = 1  # 1 is a proper divisor for all n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                complement = n // i\n                if complement != i:\n                    total += complement\n        return total\n\n    amicable_sum = 0\n    for number in range(2, limit + 1):\n        partner = sum_proper_divisors(number)\n        if (\n            partner != number and\n            sum_proper_divisors(partner) == number and\n            partner <= limit\n        ):\n            amicable_sum += number\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_of_proper_divisors(n):\n        if n < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                if i != n // i:\n                    divisors.add(n // i)\n        return sum(divisors)\n\n    total = 0\n    for num in range(1, limit + 1):\n        sum_div = sum_of_proper_divisors(num)\n        if sum_div != num:\n            sum_div_pair = sum_of_proper_divisors(sum_div)\n            if sum_div_pair == num:\n                total += num\n    return total", "matching_cluster_idx": 11}, {"solution": "def sum_proper_divisors(n):\n    \"\"\"\n    Calculate the sum of proper divisors of a number.\n    Proper divisors are numbers less than n which divide evenly into n.\n    \"\"\"\n    if n < 2:\n        return 0\n    total = 1  # 1 is a proper divisor of every number\n    sqrt_n = int(n**0.5)\n    for i in range(2, sqrt_n + 1):\n        if n % i == 0:\n            total += i\n            complement = n // i\n            if complement != i:\n                total += complement\n    return total\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Sum all amicable numbers from 1 up to the specified limit.\n    \n    Parameters:\n    limit (int): The upper bound of the range to search for amicable numbers.\n    \n    Returns:\n    int: The sum of all amicable numbers within the range.\n    \"\"\"\n    amicable_sum = 0\n    for number in range(2, limit + 1):\n        partner = sum_proper_divisors(number)\n        if partner != number:\n            if sum_proper_divisors(partner) == number:\n                amicable_sum += number\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_proper_divisors(num):\n    \"\"\"\n    Calculate the sum of proper divisors of a number.\n    \"\"\"\n    if num < 2:\n        return 0\n    divisors_sum = 1\n    sqrt_num = int(num**0.5)\n    for i in range(2, sqrt_num + 1):\n        if num % i == 0:\n            divisors_sum += i\n            complement = num // i\n            if complement != i:\n                divisors_sum += complement\n    return divisors_sum\ndef amicable_numbers_sum(n):\n    \"\"\"\n    Sum all amicable numbers from 1 to n.\n\n    Parameters:\n    n (int): The upper limit of the range to search for amicable numbers.\n\n    Returns:\n    int: The sum of all amicable numbers within the range.\n    \"\"\"\n    sum_divisors = {}\n    for i in range(1, n + 1):\n        sum_divisors[i] = sum_of_proper_divisors(i)\n    \n    amicables = set()\n    for a in range(1, n + 1):\n        b = sum_divisors.get(a, 0)\n        if b != a and b <= n:\n            if sum_divisors.get(b, 0) == a:\n                amicables.add(a)\n                amicables.add(b)\n    \n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to n.\n\n    An amicable pair consists of two different numbers where the sum of the proper\n    divisors of each number is equal to the other number.\n\n    Args:\n        n (int): The upper limit of the range to search for amicable numbers.\n\n    Returns:\n        int: The sum of all amicable numbers within the range.\n    \"\"\"\n    # Initialize a list to hold the sum of proper divisors for each number\n    sum_divisors = [0] * (n + 1)\n\n    # Calculate sum of proper divisors for each number using sieve method\n    for i in range(1, n // 2 + 1):\n        for j in range(2 * i, n + 1, i):\n            sum_divisors[j] += i\n\n    amicable_sum = 0\n    for i in range(1, n + 1):\n        j = sum_divisors[i]\n        if j != i and j <= n:\n            if sum_divisors[j] == i:\n                amicable_sum += i\n\n    return amicable_sum", "matching_cluster_idx": 13}, {"solution": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        \"\"\"\n        Calculate the sum of proper divisors of a given number.\n        \"\"\"\n        if num < 2:\n            return 0\n        divisors = {1}\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                divisors.add(i)\n                complement = num // i\n                if complement != i:\n                    divisors.add(complement)\n        return sum(divisors)\n    \n    amicables = set()\n    for num in range(1, n + 1):\n        sum1 = sum_proper_divisors(num)\n        if sum1 != num:\n            sum2 = sum_proper_divisors(sum1)\n            if sum2 == num:\n                amicables.add(num)\n                amicables.add(sum1)\n    \n    return sum(amicables)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_of_proper_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.append(i)\n                if i != n // i:\n                    divisors.append(n // i)\n        return sum(divisors)\n\n    amicable_nums = set()\n    for number in range(2, limit + 1):\n        pair = sum_of_proper_divisors(number)\n        if pair != number:\n            if sum_of_proper_divisors(pair) == number:\n                amicable_nums.add(number)\n                amicable_nums.add(pair)\n    return sum(amicable_nums)", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    text (str): The input string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Finds and returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included in the result.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included in the output list.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Finds and returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included in the result.\n    text (str): The string containing words to be evaluated.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words longer than n characters in the given text.\n\n    Args:\n        n (int): The minimum length of words to find.\n        text (str): The input string containing words separated by spaces.\n\n    Returns:\n        list: A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Returns a list of words longer than n characters from the given string.\n\n    Parameters:\n    n (int): The minimum length of words to be returned.\n    words (str): The string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the sentence that are longer than n characters.\n    \n    Parameters:\n    n (int): The minimum length of words to include.\n    sentence (str): The input sentence containing words separated by spaces.\n    \n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Find words longer than n characters in a given sentence.\n\n    Args:\n        n (int): The minimum number of characters a word must have to be included.\n        sentence (str): A string containing words separated by spaces.\n\n    Returns:\n        list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into individual words\n    words = sentence.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    \n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Args:\n    n (int): The minimum length of words to return.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the text into individual words\n    words = text.split()\n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Find and return a list of words longer than n characters from the given string.\n\n    Parameters:\n    n (int): The minimum length of words to return.\n    words (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    word_list = words.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the given sentence that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Returns a list of words longer than n characters from the input string.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    words (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the given sentence that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to include.\n    sentence (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter and return words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Write a function to find words that are longer than n characters from a given list of words.\n\n    Args:\n        n (int): The minimum number of characters a word must have to be included.\n        sentence (str): A string containing words separated by spaces.\n\n    Returns:\n        list: A list of words longer than n characters.\n\n    Example:\n        >>> long_words(3, \"python is a programming language\")\n        ['python', 'programming', 'language']\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words longer than n characters from a given text.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): The input string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    # Split the text into individual words\n    words = text.split()\n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    \"\"\"\n    Returns a list of words longer than n characters from the given string of words.\n    \n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    words (str): A string containing words separated by spaces.\n    \n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the given text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to return.\n    text (str): The string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Finds and returns a list of words from the sentence that are longer than n characters.\n    \n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    sentence (str): The sentence from which to extract words.\n    \n    Returns:\n    List[str]: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Returns a list of words from the input text that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum number of characters a word must have to be included.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in text.split() if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 56.84948979591837, "dps_norm": 94.33333333333333, "pass@1": 70.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of every row, every column,\n    and both main diagonals are the same.\n    \n    Parameters:\n    matrix (list of list of int): The square matrix to check.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not isinstance(matrix, list):\n        return False\n\n    n = len(matrix)\n    \n    # Check if all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix[1:]:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is empty or not square\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    diag1_sum = sum(matrix[i][i] for i in range(n))\n    if diag1_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    diag2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if diag2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if the given matrix is a magic square.\n    \n    A magic square is a square matrix in which the sums of every row, every column,\n    and both main diagonals are all equal.\n    \n    :param matrix: List of lists representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Check if matrix is empty\n    if n == 0:\n        return False\n    \n    # Ensure all rows have the same length\n    if not all(len(row) == n for row in matrix):\n        return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in zip(*matrix):\n        if sum(col) != magic_sum:\n            return False\n    \n    # Check the main diagonal\n    main_diagonal = sum(matrix[i][i] for i in range(n))\n    if main_diagonal != magic_sum:\n        return False\n    \n    # Check the secondary diagonal\n    secondary_diagonal = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of every row, every column,\n    and both main diagonals are all equal.\n    \n    Args:\n        matrix (list of lists of int): The square matrix to be tested.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        # Matrix is empty or not square\n        return False\n\n    n = len(matrix)\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determine if the provided matrix is a magic square.\n    \n    A magic square is a square matrix in which the sum of every row,\n    the sum of every column, and the sums of both main diagonals are all equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to be tested.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            print(\"Matrix is not square.\")\n            return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    print(f\"Magic Sum: {magic_sum}\")\n\n    # Check sums of all rows\n    for idx, row in enumerate(matrix):\n        row_sum = sum(row)\n        print(f\"Sum of row {idx + 1}: {row_sum}\")\n        if row_sum != magic_sum:\n            print(f\"Row {idx + 1} does not match the magic sum.\")\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        print(f\"Sum of column {col + 1}: {col_sum}\")\n        if col_sum != magic_sum:\n            print(f\"Column {col + 1} does not match the magic sum.\")\n            return False\n\n    # Check sum of the main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    print(f\"Sum of main diagonal: {main_diag_sum}\")\n    if main_diag_sum != magic_sum:\n        print(\"Main diagonal does not match the magic sum.\")\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    print(f\"Sum of secondary diagonal: {secondary_diag_sum}\")\n    if secondary_diag_sum != magic_sum:\n        print(\"Secondary diagonal does not match the magic sum.\")\n        return False\n\n    print(\"The matrix is a magic square.\")\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n    expected_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of every row, every column,\n    and both main diagonals are all equal.\n    \n    Parameters:\n    matrix (list of lists of int): The square matrix to test.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row as the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check if all rows sum to the target sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check if all columns sum to the target sum\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n    \n    # Check the main diagonal sum\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != target_sum:\n        return False\n    \n    # Check the secondary diagonal sum\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if the given matrix is a magic square.\n\n    A magic square is a square matrix where the sum of every row, every column,\n    and both main diagonals are equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to check.\n\n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix:\n        return False\n\n    n = len(matrix)\n\n    # Check if the matrix is square\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if the provided matrix is a magic square.\n    \n    A magic square is a square matrix in which the sum of every row,\n    the sum of every column, and the sums of both main diagonals are equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to test.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        # The matrix must be non-empty and square\n        return False\n    \n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines whether a given square matrix is a magic square.\n    \n    A magic square is a square matrix in which the sums of every row,\n    every column, and both main diagonals are all equal.\n    \n    Parameters:\n    matrix (list of list of int): The square matrix to be tested.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    # Check if the matrix is empty\n    if not matrix or not matrix[0]:\n        return False\n\n    n = len(matrix)\n\n    # Check if all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of each row, each column,\n    and both main diagonals are all equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to test.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Check if the matrix is empty\n    if n == 0:\n        return False\n    \n    # Check if all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the sum of the first row as the target magic sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for idx, row in enumerate(matrix):\n        row_sum = sum(row)\n        if row_sum != magic_sum:\n            print(f\"Row {idx+1} sum {row_sum} does not match magic sum {magic_sum}.\")\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            print(f\"Column {col+1} sum {col_sum} does not match magic sum {magic_sum}.\")\n            return False\n    \n    # Check sum of the main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != magic_sum:\n        print(f\"Main diagonal sum {main_diag_sum} does not match magic sum {magic_sum}.\")\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diag_sum != magic_sum:\n        print(f\"Secondary diagonal sum {secondary_diag_sum} does not match magic sum {magic_sum}.\")\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if matrix is empty or not a square\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False\n    # Calculate the sum of the first row\n    target_sum = sum(matrix[0])\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n    # Check main diagonal\n    main_diag_sum = sum(matrix[i][i] for i in range(n))\n    if main_diag_sum != target_sum:\n        return False\n    # Check secondary diagonal\n    sec_diag_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if sec_diag_sum != target_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Number of rows\n    n = len(matrix)\n    \n    # Check if matrix is empty\n    if n == 0:\n        return False\n    \n    # Check if all rows have the same length\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check sum of main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    A magic square is a square matrix in which the sum of every row, every column,\n    and both main diagonals are all equal.\n\n    Args:\n        matrix (list of lists of int): The square matrix to test.\n\n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False  # Not a square matrix\n\n    n = len(matrix)\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines whether the provided matrix is a magic square.\n    \n    A magic square is a square matrix in which the sum of every row, every column,\n    and both main diagonals are equal.\n    \n    Args:\n        matrix (list of list of int): The square matrix to be tested.\n    \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Check if matrix is empty\n    if n == 0:\n        return False\n    \n    # Check if all rows have the same length\n    if not all(len(row) == n for row in matrix):\n        return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        row_sum = sum(row)\n        if row_sum != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if the provided matrix is a magic square.\n    \n    A magic square is a n x n matrix where the sums of each row,\n    each column, and both main diagonals are all equal.\n    \n    Args:\n        matrix (list of lists): The matrix to be tested.\n        \n    Returns:\n        bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Check if matrix is empty\n    if n == 0:\n        return False\n    \n    # Check if all rows are of equal length\n    for row in matrix:\n        if len(row) != n:\n            return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if main_diagonal_sum != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    if secondary_diagonal_sum != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Determines if a given square matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of every row, every column,\n    and both main diagonals are equal.\n    \n    Args:\n    - matrix (list of lists of int): The square matrix to test.\n    \n    Returns:\n    - bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Check if the matrix is empty or not square\n    if n == 0 or any(len(row) != n for row in matrix):\n        return False\n    \n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the anti-diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Check if a given matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of every row, every column,\n    and both main diagonals are equal.\n    \n    Parameters:\n    matrix (list of lists): The square matrix to check.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    if not matrix or not all(len(row) == len(matrix) for row in matrix):\n        return False  # Not a square matrix\n\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 96.88340807174887, "dps_norm": 85.83333333333333, "pass@1": 80.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the list.\n    If the list is empty, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    counts = Counter(lst)\n    max_item, _ = counts.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Return the item with the highest frequency in the list.\n    If multiple items have the same highest frequency, the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        return None  # Return None for empty lists\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    If multiple items have the same maximum frequency, returns the first one encountered.\n    \n    :param lst: List of elements\n    :return: Element with the highest frequency\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    count = Counter(lst)\n    max_freq = max(count.values())\n    \n    for item in lst:\n        if count[item] == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    if not lst:\n        return None  # Handle empty list\n    counts = Counter(lst)\n    max_freq = max(counts.values())\n    # Return the first item with the maximum frequency\n    for item in lst:\n        if counts[item] == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    max_freq = max(count.values())\n    # Return the first item with the maximum frequency\n    for item in lst:\n        if count[item] == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the list.\n    If multiple items have the same maximum frequency, the first encountered is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    counts = Counter(lst)\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    counter = Counter(lst)\n    # Find the element with the highest frequency\n    max_item = max(counter, key=counter.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the list.\n    If the list is empty, returns None.\n    \"\"\"\n    if not lst:\n        return None\n    counts = Counter(lst)\n    max_item = max(counts, key=counts.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in a given list.\n\n    Args:\n        lst (list): The list of items.\n\n    Returns:\n        The item with the highest frequency. If multiple items have the same\n        maximum frequency, the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    counts = Counter(lst)\n    max_item, _ = counts.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    # Find the item with the highest frequency\n    max_item = max(count, key=count.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the list.\n    If multiple items have the same highest frequency, the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    frequency = Counter(lst)\n    most_common_item, _ = frequency.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    # Count the frequency of each item\n    frequency = Counter(lst)\n    # Get the item with the highest frequency\n    most_common_item, _ = frequency.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n\n    Parameters:\n    lst (list): The list of items to evaluate.\n\n    Returns:\n    The item with the highest frequency. If multiple items have the same maximum\n    frequency, the first one encountered is returned. Returns None if the list is empty.\n    \"\"\"\n    if not lst:\n        return None\n\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    max_freq = max(frequency.values())\n    for item in lst:\n        if frequency[item] == max_freq:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the highest frequency.\n    \"\"\"\n    from collections import Counter\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    count = Counter(lst)\n    max_item, _ = count.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    If multiple items have the same maximum frequency, the first one encountered is returned.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        frequency[item] = frequency.get(item, 0) + 1\n\n    # Find the maximum frequency\n    max_freq = max(frequency.values())\n\n    # Iterate through the dictionary to find the item with the maximum frequency\n    for item in frequency:\n        if frequency[item] == max_freq:\n            return item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to analyze.\n    \n    Returns:\n    The item with the highest frequency. If there are multiple items with the same maximum frequency,\n    the first one encountered in the list is returned.\n    \"\"\"\n    from collections import Counter\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    frequency = Counter(lst)\n    # Get the most common element and its count\n    most_common_item, _ = frequency.most_common(1)[0]\n    return most_common_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of elements to evaluate.\n    \n    Returns:\n    The item with the highest frequency.\n    \"\"\"\n    from collections import Counter\n    if not lst:\n        return None  # Handle empty list case\n    \n    counter = Counter(lst)\n    most_common = counter.most_common(1)[0][0]\n    return most_common", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    if not lst:\n        return None  # Handle empty list case\n    counts = Counter(lst)\n    max_count = max(counts.values())\n    # Return the first item with the maximum count\n    for item in lst:\n        if counts[item] == max_count:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Finds the item with the maximum frequency in the given list.\n    If multiple items have the same maximum frequency, returns the first one encountered.\n    \n    Args:\n        lst (list): The list of items to evaluate.\n        \n    Returns:\n        The item with the highest frequency. Returns None if the list is empty.\n    \"\"\"\n    if not lst:\n        return None\n    \n    counts = Counter(lst)\n    max_freq = max(counts.values())\n    \n    for item in lst:\n        if counts[item] == max_freq:\n            return item", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Returns the item with the highest frequency in the given list.\n    \n    Parameters:\n    lst (list): The list of items to evaluate.\n    \n    Returns:\n    The item with the maximum frequency. If multiple items have the same maximum frequency,\n    the first one encountered is returned.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    \n    counter = Counter(lst)\n    max_item, _ = counter.most_common(1)[0]\n    return max_item", "matching_cluster_idx": 4}]}, "Mbpp/137": {"dps": 98.54838709677418, "dps_norm": 99.375, "pass@1": 54.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Define as infinity if no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle division by zero if there are no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Args:\n        arr (list of int): The input array of integers.\n\n    Returns:\n        float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle division by zero if there are no non-zero elements\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # or handle as needed\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n\n    if non_zeroes == 0:\n        return float('inf')  # or you could return 0, depending on the desired behavior\n\n    ratio = zeroes / non_zeroes\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of the number of zeroes to the number of non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    nonzeros = len(arr) - zeros\n    if nonzeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / nonzeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Alternatively, you could return 0 or raise an exception\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n    \n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    nonzeros = len(arr) - zeros\n    if nonzeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / nonzeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zeroes.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Alternatively, you could raise an exception\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Handle division by zero if no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to evaluate.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Avoid division by zero\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zeroes.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # Define as infinity when there are no non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n\n    Parameters:\n    arr (list of int): The input list of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zeroes. Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    count_zero = arr.count(0)\n    count_non_zero = len(arr) - count_zero\n\n    if count_non_zero == 0:\n        return float('inf')  # Avoid division by zero\n\n    return count_zero / count_non_zero", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculates the ratio of zeroes to non-zeroes in the given array.\n\n    Parameters:\n    arr (list of int): The array of integers.\n\n    Returns:\n    float: The ratio of the number of zeroes to the number of non-zero elements.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeros = arr.count(0)\n    non_zeros = len(arr) - zeros\n    if non_zeros == 0:\n        return float('inf')  # No non-zero elements\n    return zeros / non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zero elements in the array.\n\n    Parameters:\n    arr (list of int): The input array of integers.\n\n    Returns:\n    float: The ratio of zeroes to non-zero elements.\n           Returns float('inf') if there are no non-zero elements.\n    \"\"\"\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Alternatively, you can raise an exception if preferred\n    return zeroes / non_zeroes", "matching_cluster_idx": 7}]}, "Mbpp/140": {"dps": 75.57453416149067, "dps_norm": 76.875, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single list of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples.\n\n    Returns:\n        list: A flat list containing all unique numbers from the input.\n    \"\"\"\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists or tuples into a single list of numbers.\n\n    Args:\n        list_of_lists (list): A list containing lists or tuples of numbers.\n\n    Returns:\n        list: A flattened list containing all the numbers from the input.\n    \"\"\"\n    flattened = []\n    for sublist in list_of_lists:\n        flattened.extend(sublist)\n    return flattened", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of tuples): The input list containing tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the input lists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n\n    Args:\n        list_of_lists (list): A list containing lists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flattened_set.add(item)\n    return flattened_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of unique numbers.\n    \n    Args:\n        list_of_lists (list of iterables): The list containing sub-lists or tuples of numbers.\n        \n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing lists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n        list_of_lists (list of tuples): The input list containing tuples of numbers.\n    \n    Returns:\n        set: A set containing all unique numbers from the input lists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n    \n    Parameters:\n    list_of_lists (list): A list containing sublists or tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flattened_set.add(item)\n    return flattened_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of lists/tuples): The input list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing iterables like lists or tuples.\n\n    Returns:\n        list: A flattened list containing all unique numbers from the input.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            flattened_set.add(item)\n    return list(flattened_set)", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The input list containing sublists or tuples.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of iterables): The input list containing iterables of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the input.\n    \"\"\"\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    flattened_set = set()\n    for sublist in list_of_lists:\n        flattened_set.update(sublist)\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of unique numbers.\n\n    Args:\n        list_of_lists (list of tuples): A list containing tuples of numbers.\n\n    Returns:\n        set: A set containing all unique numbers from the input.\n    \"\"\"\n    return set(number for sublist in list_of_lists for number in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n\n    Parameters:\n    list_of_lists (list of iterables): The list containing sublists or tuples of numbers.\n\n    Returns:\n    set: A set containing all unique numbers from the sublists.\n    \"\"\"\n    return set(item for sublist in list_of_lists for item in sublist)", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 71.95011337868482, "dps_norm": 43.125, "pass@1": 94.0, "profiled": [{"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n        sub_arr[:k] = sub_arr[:k][::-1]\n\n    n = len(arr)\n    # Make a copy of the array to avoid modifying the original\n    arr = arr.copy()\n    \n    # Perform pancake sort\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_index = arr.index(max(arr[:size]))\n        \n        if max_index != size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Now flip it to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to sort\n    :return: Sorted list of elements\n    \"\"\"\n    # Make a copy to avoid modifying the original list\n    arr = list(arr)\n    n = len(arr)\n    \n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_num = max(arr[:current_size])\n        max_index = arr.index(max_num)\n        \n        # If the maximum is not already in its correct position\n        if max_index != current_size - 1:\n            # If the maximum is not at the first position, flip it to the front\n            if max_index != 0:\n                arr[:max_index + 1] = arr[:max_index + 1][::-1]\n                print(f\"Flipped first {max_index + 1} elements: {arr}\")\n            \n            # Flip it to its correct position\n            arr[:current_size] = arr[:current_size][::-1]\n            print(f\"Flipped first {current_size} elements: {arr}\")\n    \n    return arr", "matching_cluster_idx": 1}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n        return sub_arr[:k][::-1] + sub_arr[k:]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum element is not at its correct position, move it\n        if max_index != current_size - 1:\n            # If the maximum element is not at the first position, flip it to the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Now flip it to its correct position\n            arr = flip(arr, current_size)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n        sub_arr[:k] = sub_arr[:k][::-1]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        if max_index != current_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            flip(arr, max_index + 1)\n            # Flip it to its correct position\n            flip(arr, current_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to sort.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(lst, k):\n        \"\"\"Helper function to reverse the first k elements of the list.\"\"\"\n        return lst[:k][::-1] + lst[k:]\n\n    n = len(arr)\n    # Make a copy of the array to avoid modifying the original list\n    arr = arr.copy()\n\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_idx = arr.index(max(arr[:size]))\n        \n        if max_idx != size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n                print(f\"Flipped first {max_idx + 1} elements: {arr}\")\n            \n            # Move the maximum element to its correct position\n            arr = flip(arr, size)\n            print(f\"Flipped first {size} elements: {arr}\")\n    \n    return arr", "matching_cluster_idx": 1}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    # Traverse through all sizes from n down to 1\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..curr_size-1]\n        max_num = max(arr[0:curr_size])\n        max_idx = arr.index(max_num)\n\n        # If the maximum is not at its correct position\n        if max_idx != curr_size - 1:\n            # If the maximum is not at the front, bring it to the front\n            if max_idx != 0:\n                # Flip the array up to the maximum element\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n                print(f\"Flip up to index {max_idx}: {arr}\")\n            \n            # Now flip it to its correct position\n            arr[:curr_size] = arr[:curr_size][::-1]\n            print(f\"Flip up to index {curr_size - 1}: {arr}\")\n    \n    return arr", "matching_cluster_idx": 1}, {"solution": "def pancake_sort(lst):\n    \"\"\"\n    Sorts a list using the Pancake Sort algorithm.\n\n    Args:\n        lst (list): The list of elements to sort.\n\n    Returns:\n        list: A sorted list in ascending order.\n    \"\"\"\n    n = len(lst)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in lst[0..current_size-1]\n        max_index = lst.index(max(lst[:current_size]))\n\n        if max_index != current_size - 1:\n            # Flip the maximum number to the front if it's not already there\n            if max_index != 0:\n                lst[:max_index + 1] = reversed(lst[:max_index + 1])\n                print(f\"Flipped first {max_index + 1} elements: {lst}\")\n\n            # Flip it to its correct position\n            lst[:current_size] = reversed(lst[:current_size])\n            print(f\"Flipped first {current_size} elements: {lst}\")\n\n    return lst", "matching_cluster_idx": 1}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        \"\"\"Helper function to reverse the first k+1 elements of the array.\"\"\"\n        start = 0\n        end = k\n        while start < end:\n            sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start]\n            start += 1\n            end -= 1\n\n    n = len(arr)\n    # Make a copy of the array to avoid modifying the original list\n    sorted_arr = arr.copy()\n\n    # Perform pancake sort\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = sorted_arr.index(max(sorted_arr[:current_size]))\n        \n        # If the maximum is not at its correct position, flip it to the front\n        if max_index != current_size - 1:\n            if max_index != 0:\n                flip(sorted_arr, max_index)\n            # Now flip it to its correct position\n            flip(sorted_arr, current_size - 1)\n    \n    return sorted_arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the first k+1 elements of the list.\"\"\"\n        left = 0\n        right = k\n        while left < right:\n            sub_arr[left], sub_arr[right] = sub_arr[right], sub_arr[left]\n            left += 1\n            right -= 1\n\n    n = len(arr)\n    # Create a copy of the array to avoid modifying the original list\n    arr = arr.copy()\n    \n    # Iterate from the end of the array to the beginning\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:size]))\n        \n        # If the maximum is not at its correct position, move it\n        if max_index != size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index)\n            # Move the maximum element to its correct position\n            flip(arr, size - 1)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    # Iterate from the full array size down to 1\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum is not already in its correct position\n        if max_index != current_size - 1:\n            # If the maximum is not at the first position, flip it to the front\n            if max_index != 0:\n                arr[:max_index + 1] = reversed(arr[:max_index + 1])\n            # Now flip it to its correct position\n            arr[:current_size] = reversed(arr[:current_size])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of integers to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        sub_arr[:k] = sub_arr[:k][::-1]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = arr.index(max(arr[:current_size]))\n        \n        if max_index != current_size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            flip(arr, current_size)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    result = arr.copy()\n    \n    # Function to flip the array up to the index k\n    def flip(sub_arr, k):\n        return sub_arr[:k+1][::-1] + sub_arr[k+1:]\n    \n    # Iterate from the end of the array to the beginning\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element within the current unsorted portion\n        max_idx = result.index(max(result[:size]))\n        \n        if max_idx != size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_idx != 0:\n                result = flip(result, max_idx)\n            # Then flip it to its correct position at the end of the unsorted portion\n            result = flip(result, size - 1)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the array using the pancake sort algorithm.\n    \"\"\"\n    sorted_arr = arr.copy()\n    n = len(sorted_arr)\n    \n    # Start from the complete array and reduce the size one by one\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element within the unsorted portion\n        max_num = max(sorted_arr[:current_size])\n        max_index = sorted_arr.index(max_num)\n        \n        # If the max element is not at its correct position, move it\n        if max_index != current_size - 1:\n            # If the max element is not at the beginning, flip it to the front\n            if max_index != 0:\n                sorted_arr = flip(sorted_arr, max_index + 1)\n            # Now flip it to its correct position\n            sorted_arr = flip(sorted_arr, current_size)\n    \n    return sorted_arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    # Traverse through all elements in the array\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element within the current size\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # If the maximum element is not at its correct position\n        if max_index != current_size - 1:\n            # Flip the maximum element to the front\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Flip it to its correct position\n            arr[:current_size] = arr[:current_size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sort algorithm.\n    \n    Args:\n        arr (list): The list of integers to sort.\n        \n    Returns:\n        list: A new list containing the sorted integers.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"Reverses the first k+1 elements of the list.\"\"\"\n        return sublist[:k+1][::-1] + sublist[k+1:]\n\n    n = len(arr)\n    result = arr.copy()\n    \n    # Traverse through all elements in the array\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the current slice\n        max_idx = result.index(max(result[:current_size]))\n        \n        if max_idx != current_size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_idx != 0:\n                result = flip(result, max_idx)\n                # Uncomment the following line to see the flips\n                # print(f\"Flipped at position {max_idx + 1}: {result}\")\n            \n            # Flip it to its correct position\n            result = flip(result, current_size - 1)\n            # Uncomment the following line to see the flips\n            # print(f\"Flipped at position {current_size}: {result}\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sublist, k):\n        \"\"\"Reverses the first k elements of the list.\"\"\"\n        return sublist[:k][::-1] + sublist[k:]\n\n    n = len(arr)\n    sorted_arr = arr.copy()\n    \n    # Iterate from the end of the array to the beginning\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0..current_size-1]\n        max_index = sorted_arr.index(max(sorted_arr[:current_size]))\n        \n        if max_index != current_size - 1:\n            # Move the maximum element to the front if it's not already there\n            if max_index != 0:\n                sorted_arr = flip(sorted_arr, max_index + 1)\n                # Uncomment the next line to see the steps\n                # print(f\"Flip at {max_index + 1}: {sorted_arr}\")\n            \n            # Move the maximum element to its correct position\n            sorted_arr = flip(sorted_arr, current_size)\n            # Uncomment the next line to see the steps\n            # print(f\"Flip at {current_size}: {sorted_arr}\")\n    \n    return sorted_arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of integers to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:size]\n        max_index = arr.index(max(arr[0:size]))\n        if max_index != size - 1:\n            # Flip the maximum element to the beginning if it's not already there\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Flip it to the correct position\n            arr[:size] = arr[:size][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to sort.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the elements of sub_arr up to index k.\"\"\"\n        start = 0\n        end = k\n        while start < end:\n            sub_arr[start], sub_arr[end] = sub_arr[end], sub_arr[start]\n            start += 1\n            end -= 1\n\n    n = len(arr)\n    # Create a copy of the array to avoid modifying the original list\n    sorted_arr = arr.copy()\n\n    # Iterate from the complete array to the first element\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = sorted_arr.index(max(sorted_arr[:current_size]))\n\n        # If the maximum is not already in its correct position\n        if max_index != current_size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(sorted_arr, max_index)\n            # Flip it to its correct position\n            flip(sorted_arr, current_size - 1)\n\n    return sorted_arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(sub_arr, k):\n        \"\"\"Reverse the first k elements of the array.\"\"\"\n        return sub_arr[:k][::-1] + sub_arr[k:]\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current unsorted portion\n        max_index = arr.index(max(arr[:size]))\n        \n        if max_index != size - 1:\n            # Bring the maximum element to the front if it's not already there\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            arr = flip(arr, size)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of integers using the pancake sorting algorithm.\n    \n    Args:\n    arr (list): The list of integers to sort.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    def flip(sub_arr, k):\n        \"\"\"Reverses the order of the first k elements in the list.\"\"\"\n        return sub_arr[:k][::-1] + sub_arr[k:]\n\n    n = len(arr)\n    for current_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:current_size]\n        max_index = arr.index(max(arr[:current_size]))\n        \n        # Move the maximum element to the end of the current list if it's not already there\n        if max_index != current_size - 1:\n            # Flip the maximum element to the front if it's not already at the front\n            if max_index != 0:\n                arr = flip(arr, max_index + 1)\n            # Flip it to its correct position at the end of the current list\n            arr = flip(arr, current_size)\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 99.99999999999999, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    nums (list of int): The list of integers to evaluate.\n    \n    Returns:\n    int: The number of valid pairs.\n    \"\"\"\n    even_count = sum(1 for num in nums if num % 2 == 0)\n    odd_count = len(nums) - even_count\n    # Number of pairs with both even\n    even_pairs = even_count * (even_count - 1) // 2\n    # Number of pairs with both odd\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    An XOR of two numbers is even if both numbers are even or both are odd.\n    \n    Parameters:\n    nums (list): List of integers.\n    \n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Number of ways to choose 2 even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Number of ways to choose 2 odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Args:\n        lst (list of int): The list of integers.\n    \n    Returns:\n        int: The number of valid pairs.\n    \"\"\"\n    even = 0\n    odd = 0\n\n    # Count the number of even and odd numbers\n    for num in lst:\n        if num % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n\n    # The number of valid pairs is the sum of combinations of even and odd numbers\n    return (even * (even - 1)) // 2 + (odd * (odd - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n\n    Parameters:\n    lst (list of int): The list of integers to evaluate.\n\n    Returns:\n    int: The number of valid pairs.\n    \"\"\"\n    if not lst:\n        return 0\n\n    # Count the number of even and odd numbers in the list\n    even_count = sum(1 for num in lst if num % 2 == 0)\n    odd_count = len(lst) - even_count\n\n    # Calculate the number of pairs with both even or both odd\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Args:\n    lst (list of int): The list of integers to evaluate.\n    \n    Returns:\n    int: The count of valid pairs.\n    \"\"\"\n    # Count the number of even and odd numbers in the list\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n\n    # Number of valid pairs is combinations of evens and combinations of odds\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The count of valid pairs.\n    \"\"\"\n    # Count the number of even and odd integers in the list\n    count_even = sum(1 for num in lst if num % 2 == 0)\n    count_odd = len(lst) - count_even\n\n    # Calculate the number of valid even pairs using combination formula C(n, 2)\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n\n    # Total pairs that XOR to an even number\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Args:\n        lst (list of int): The list of integers.\n        \n    Returns:\n        int: The count of pairs with even XOR.\n    \"\"\"\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    # Number of even pairs: C(even_count, 2)\n    # Number of odd pairs: C(odd_count, 2)\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Args:\n        nums (list): A list of integers.\n        \n    Returns:\n        int: The number of pairs whose XOR is even.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of even pairs and odd pairs\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Total pairs with XOR even\n    total_pairs = even_pairs + odd_pairs\n    return total_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The count of pairs where the XOR of the pair is even.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of valid pairs is the combination of evens taken 2 at a time\n    # plus the combination of odds taken 2 at a time\n    even_pairs = even_count * (even_count - 1) // 2\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    lst (list of int): The list of integers to evaluate.\n    \n    Returns:\n    int: The count of pairs where the XOR of the pair is even.\n    \"\"\"\n    even = sum(1 for num in lst if num % 2 == 0)\n    odd = len(lst) - even\n    # Number of even-even pairs\n    even_pairs = (even * (even - 1)) // 2\n    # Number of odd-odd pairs\n    odd_pairs = (odd * (odd - 1)) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "from math import comb\ndef find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Parameters:\n    lst (list of int): The list of integers to process.\n\n    Returns:\n    int: The number of pairs whose XOR is even.\n    \"\"\"\n    count_even = sum(1 for x in lst if x % 2 == 0)\n    count_odd = len(lst) - count_even\n    return comb(count_even, 2) + comb(count_odd, 2)", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    Two numbers XOR to an even number if both are even or both are odd.\n    \n    Parameters:\n    nums (list): List of integers.\n\n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    even = 0\n    odd = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    \n    # Number of ways to choose 2 even numbers\n    even_pairs = even * (even - 1) // 2\n    # Number of ways to choose 2 odd numbers\n    odd_pairs = odd * (odd - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n\n    Args:\n        lst (list of int): The list of integers.\n\n    Returns:\n        int: The count of valid pairs.\n    \"\"\"\n    evens = sum(1 for x in lst if x % 2 == 0)\n    odds = len(lst) - evens\n    # Number of even pairs: C(evens, 2) + C(odds, 2)\n    return (evens * (evens - 1)) // 2 + (odds * (odds - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The number of pairs whose XOR is even.\n    \"\"\"\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    # Number of pairs where both are even or both are odd\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        lst (list of int): The list of integers.\n\n    Returns:\n        int: The count of valid pairs.\n    \"\"\"\n    even = sum(1 for num in lst if num % 2 == 0)\n    odd = len(lst) - even\n    return (even * (even - 1)) // 2 + (odd * (odd - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    A pair will have an even XOR if both integers are either even or both are odd.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n\n    # Count the number of even and odd integers in the list\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Calculate the number of valid pairs:\n    # C(even_count, 2) + C(odd_count, 2)\n    even_pairs = (even_count * (even_count - 1)) // 2\n    odd_pairs = (odd_count * (odd_count - 1)) // 2\n\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The number of valid pairs.\n    \"\"\"\n    count_even = 0\n    count_odd = 0\n    \n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    # Number of pairs with both even or both odd\n    even_pairs = count_even * (count_even - 1) // 2\n    odd_pairs = count_odd * (count_odd - 1) // 2\n    \n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \"\"\"\n    odds = sum(1 for x in lst if x % 2)\n    evens = len(lst) - odds\n    return (odds * (odds - 1)) // 2 + (evens * (evens - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n    \n    Parameters:\n    lst (list): List of integers.\n    \n    Returns:\n    int: Number of valid pairs.\n    \"\"\"\n    even_count = sum(1 for x in lst if x % 2 == 0)\n    odd_count = len(lst) - even_count\n    # Number of even pairs plus number of odd pairs\n    return (even_count * (even_count - 1)) // 2 + (odd_count * (odd_count - 1)) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in the list that XOR to an even number.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The count of pairs where the XOR of the pair is even.\n    \"\"\"\n    even_count = sum(1 for num in nums if num % 2 == 0)\n    odd_count = len(nums) - even_count\n    # Number of pairs with both even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Number of pairs with both odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    return even_pairs + odd_pairs", "matching_cluster_idx": 3}]}, "Mbpp/170": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/226": {"dps": 97.75193798449612, "dps_norm": 95.0, "pass@1": 96.0, "profiled": [{"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: A new string containing only characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"Remove characters at odd index values from the string.\"\"\"\n    return s[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string containing only characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters at odd index positions from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string containing characters from even index positions.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    # Use slicing to get characters at even indices\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters with odd index values from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters at odd index positions from the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string after removing characters at odd indices.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(s) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the input string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters with odd index values from the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters at even indices.\n    \n    Example:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A string containing only characters from even indices.\n        \n    Example:\n        >>> odd_values_string('abcdef')\n        'ace'\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string with characters at odd indices removed.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters from the string that have odd index values.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A new string with characters at even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes characters from the input string that have odd index values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters from even indices.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from even indices of the input string.\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}]}, "Mbpp/230": {"dps": 96.5079365079365, "dps_norm": 98.75, "pass@1": 98.0, "profiled": [{"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces blank spaces in the string s with the character c.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by c.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the string `s` with the specified `char`.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified `char`.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Takes a string `s` and a character `char`, replaces blank spaces in the string with the character, and returns the new string.\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified `char`.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Args:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return char.join(s.split(' '))", "matching_cluster_idx": 5}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces blank spaces in the string `s` with the specified `char`.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    Parameters:\n    s (str): The input string.\n    c (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces blank spaces in the string `s` with the character `char` and returns the new string.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string: str, replacement_char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input_string with the replacement_char.\n\n    Args:\n        input_string (str): The original string containing spaces.\n        replacement_char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string with spaces replaced by replacement_char.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"\n    Replace blank spaces in the input string `s` with the character `c`.\n    \n    Parameters:\n    s (str): The input string.\n    c (str): The character to replace spaces with.\n    \n    Returns:\n    str: The modified string with spaces replaced by `c`.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    \"\"\"\n    Replace blank spaces in the input_string with replacement_char.\n\n    :param input_string: The string to process.\n    :param replacement_char: The character to replace spaces with.\n    :return: The modified string with spaces replaced.\n    \"\"\"\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified `char`.\n\n    Parameters:\n    s (str): The original string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the input string `s` with the specified character `char`.\n\n    Args:\n        s (str): The original string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, char: str) -> str:\n    \"\"\"\n    Replaces all blank spaces in the string `s` with the specified `char`.\n\n    Args:\n        s (str): The input string.\n        char (str): The character to replace blank spaces with.\n\n    Returns:\n        str: The modified string with blank spaces replaced.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replaces all blank spaces in the string `s` with the specified `char`.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by `char`.\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 96.55172413793103, "dps_norm": 92.0, "pass@1": 98.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def helper(current_length, previous):\n        if current_length == n:\n            return 1\n        total = 0\n        min_next = 2 * previous\n        for next_val in range(min_next, m + 1):\n            total += helper(current_length + 1, next_val)\n        return total\n\n    total_sequences = 0\n    # The first element can be at most m divided by 2^(n-1) to allow a valid sequence\n    max_start = m // (2 ** (n - 1))\n    for start in range(1, max_start + 1):\n        total_sequences += helper(1, start)\n    \n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(remaining, prev):\n        \"\"\"\n        Recursively counts the number of valid sequences.\n        \n        Args:\n            remaining (int): Number of elements left to add to the sequence.\n            prev (int): The last element in the current sequence.\n        \n        Returns:\n            int: Number of valid sequences from this state.\n        \"\"\"\n        if remaining == 0:\n            return 1  # A valid sequence of desired length is formed\n\n        total = 0\n        # Next element should be at least twice the previous and at most m\n        for next_val in range(2 * prev, m + 1):\n            total += count_sequences(remaining - 1, next_val)\n        return total\n\n    total_sequences = 0\n    # Start sequences with any integer from 1 to m\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(n - 1, first)\n    \n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current, length):\n        if length == 1:\n            return 1\n        total = 0\n        # Next element must be at least twice the current and <= m\n        next_min = 2 * current\n        for next_val in range(next_min, m + 1):\n            total += count_sequences(next_val, length - 1)\n        return total\n\n    total_sequences = 0\n    # The first element must allow for a sequence of length n\n    # So a1 <= m / (2^(n-1))\n    max_first = m // (2 ** (n - 1))\n    for first in range(1, max_first + 1):\n        total_sequences += count_sequences(first, n)\n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element is a positive integer,\n    each element is greater than or equal to twice the previous element, and each element is\n    less than or equal to m.\n    \n    Args:\n    - m (int): The maximum allowed value for any element in the sequence.\n    - n (int): The length of the sequence.\n    \n    Returns:\n    - int: The total number of valid sequences.\n    \"\"\"\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count(current_length, prev):\n        if current_length == n:\n            return 1\n        total = 0\n        if prev == 0:\n            # Choose the first element from 1 to m\n            for x in range(1, m + 1):\n                total += count(current_length + 1, x)\n        else:\n            # Choose the next element >= 2 * prev and <= m\n            start = 2 * prev\n            for x in range(start, m + 1):\n                total += count(current_length + 1, x)\n        return total\n\n    return count(0, 0)", "matching_cluster_idx": 8}, {"solution": "from functools import lru_cache\ndef get_total_number_of_sequences(m, n):\n    @lru_cache(maxsize=None)\n    def count_sequences(x, k):\n        if k == 1:\n            return 1 if x <= m else 0\n        total = 0\n        next_x_min = 2 * x\n        for next_x in range(next_x_min, m + 1):\n            total += count_sequences(next_x, k - 1)\n        return total\n\n    total_sequences = 0\n    # Calculate the maximum possible starting number to ensure the sequence length n doesn't exceed m\n    max_start = m // (2 ** (n - 1))\n    for x in range(1, max_start + 1):\n        total_sequences += count_sequences(x, n)\n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    if n < 1 or m < 1:\n        return 0\n\n    @lru_cache(maxsize=None)\n    def count_sequences(length, last):\n        if length == 0:\n            return 1\n        total = 0\n        start = 2 * last\n        for x in range(start, m + 1):\n            total += count_sequences(length - 1, x)\n        return total\n\n    total_sequences = 0\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(n - 1, first)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(length, last):\n        if length == 0:\n            return 1\n        # If it's the first element, it can be any number from 1 to m\n        if last == 0:\n            total = 0\n            for first in range(1, m + 1):\n                total += count_sequences(length - 1, first)\n            return total\n        total = 0\n        # Next element must be at least twice the last element\n        start = 2 * last\n        for next_elem in range(start, m + 1):\n            total += count_sequences(length - 1, next_elem)\n        return total\n\n    return count_sequences(n, 0)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current, length):\n        if length == 1:\n            return 1\n        total = 0\n        next_min = 2 * current\n        if next_min > m:\n            return 0\n        for next_num in range(next_min, m + 1):\n            total += count_sequences(next_num, length - 1)\n        return total\n\n    total_sequences = 0\n    # The first element must satisfy that a sequence of length n can be formed\n    # So a <= m / (2^(n-1))\n    max_first = m // (2 ** (n - 1))\n    for first in range(1, max_first + 1):\n        total_sequences += count_sequences(first, n)\n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n where each element is a positive integer,\n    is greater than or equal to twice the previous element, and is less than or equal to m.\n\n    Args:\n        m (int): The maximum allowed value for each element in the sequence.\n        n (int): The length of the sequence.\n\n    Returns:\n        int: The total number of valid sequences.\n    \"\"\"\n    # Initialize dp_prev where dp_prev[j] represents the number of sequences of length 1 ending with j\n    dp_prev = [0] * (m + 1)\n    for j in range(1, m + 1):\n        dp_prev[j] = 1  # Base case: single-element sequences\n\n    # Iterate over sequence lengths from 2 to n\n    for _ in range(2, n + 1):\n        # Compute prefix sums for the previous dp layer\n        prefix = [0] * (m + 1)\n        for j in range(1, m + 1):\n            prefix[j] = prefix[j - 1] + dp_prev[j]\n\n        # Initialize dp_curr for the current sequence length\n        dp_curr = [0] * (m + 1)\n        for j in range(1, m + 1):\n            k = j // 2  # Floor division to find the maximum allowed previous element\n            dp_curr[j] = prefix[k]\n\n        # Update dp_prev for the next iteration\n        dp_prev = dp_curr\n\n    # The total number of valid sequences is the sum of all sequences of length n ending with any j\n    total_sequences = sum(dp_prev)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    if n == 0:\n        return 0\n    # Initialize DP for sequences of length 1\n    dp_prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        dp_prev[x] = 1\n\n    # Build DP table for lengths from 2 to n\n    for length in range(2, n + 1):\n        dp_current = [0] * (m + 1)\n        for x in range(1, m + 1):\n            # The previous element y must satisfy y <= x / 2\n            max_prev = x // 2\n            dp_current[x] = sum(dp_prev[y] for y in range(1, max_prev + 1))\n        dp_prev = dp_current\n\n    # Total sequences of length n\n    total_sequences = sum(dp_prev[x] for x in range(1, m + 1))\n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(prev, remaining):\n        if remaining == 0:\n            return 1\n        if prev is None:\n            total = 0\n            for next_num in range(1, m+1):\n                total += count_sequences(next_num, remaining-1)\n            return total\n        else:\n            start = 2 * prev\n            if start > m:\n                return 0\n            end = m\n            total = 0\n            for next_num in range(start, end+1):\n                total += count_sequences(next_num, remaining-1)\n            return total\n\n    return count_sequences(None, n)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current, length):\n        if length == 1:\n            return 1\n        total = 0\n        next_min = current * 2\n        for next_num in range(next_min, m + 1):\n            total += count_sequences(next_num, length - 1)\n        return total\n\n    total_sequences = 0\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(first, n)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def dp(current, remaining):\n        if remaining == 1:\n            return 1  # Only the current element\n        total = 0\n        # Next element must be at least twice the current and <= m\n        next_min = 2 * current\n        for next_val in range(next_min, m + 1):\n            total += dp(next_val, remaining - 1)\n        return total\n\n    total_sequences = 0\n    # The first element must allow a sequence of length n\n    # i.e., first_element * (2 ** (n -1)) <= m\n    max_first = m // (2 ** (n -1))\n    for first in range(1, max_first + 1):\n        total_sequences += dp(first, n)\n    return total_sequences", "matching_cluster_idx": 9}, {"solution": "import functools\ndef get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element\n    is a positive integer, greater than or equal to twice the previous element,\n    and less than or equal to m.\n    \"\"\"\n    @functools.lru_cache(maxsize=None)\n    def helper(current_length, last_num):\n        if current_length == n:\n            return 1\n        count = 0\n        # The next number must be at least twice the last number and <= m\n        next_min = 2 * last_num\n        for next_num in range(next_min, m + 1):\n            count += helper(current_length + 1, next_num)\n        return count\n\n    total_sequences = 0\n    # Start the sequence with any number from 1 to m\n    for start_num in range(1, m + 1):\n        total_sequences += helper(1, start_num)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current_length, prev):\n        if current_length == n:\n            return 1\n        total = 0\n        next_lower = 2 * prev\n        for next_num in range(next_lower, m + 1):\n            total += count_sequences(current_length + 1, next_num)\n        return total\n\n    total_sequences = 0\n    for first_num in range(1, m + 1):\n        total_sequences += count_sequences(1, first_num)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def count_sequences(current_length, previous):\n        if current_length == n:\n            # If we've reached the desired length, count this as a valid sequence\n            return 1\n        total = 0\n        # The next number must be at least twice the previous and <= m\n        next_min = 2 * previous\n        for next_num in range(next_min, m + 1):\n            total += count_sequences(current_length + 1, next_num)\n        return total\n\n    total_sequences = 0\n    # Start the sequence with any number from 1 to m\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(1, start)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "from functools import lru_cache\ndef get_total_number_of_sequences(m, n):\n    \"\"\"\n    Returns the number of possible sequences of length n where each element is a positive integer,\n    greater than or equal to twice the previous element, and less than or equal to m.\n    \n    Parameters:\n    - m (int): The maximum allowed value for elements in the sequence.\n    - n (int): The length of the sequences.\n    \n    Returns:\n    - int: The total number of valid sequences.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def count_sequences(current, remaining):\n        if remaining == 1:\n            return 1\n        total = 0\n        next_start = 2 * current\n        if next_start > m:\n            return 0\n        for next_num in range(next_start, m + 1):\n            total += count_sequences(next_num, remaining - 1)\n        return total\n\n    total_sequences = 0\n    for first in range(1, m + 1):\n        total_sequences += count_sequences(first, n)\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "from functools import lru_cache\ndef get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculates the number of possible sequences of length n where each element \n    is a positive integer, greater than or equal to twice the previous element, \n    and less than or equal to m.\n    \n    :param m: The maximum value each element in the sequence can take.\n    :param n: The length of the sequence.\n    :return: The total number of valid sequences.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def helper(prev, length_remaining):\n        if length_remaining == 0:\n            return 1\n        total = 0\n        if prev is None:\n            # Starting the sequence: choose any number from 1 to m\n            for x in range(1, m + 1):\n                total += helper(x, length_remaining - 1)\n        else:\n            # Choose the next number >= 2 * prev and <= m\n            for x in range(2 * prev, m + 1):\n                total += helper(x, length_remaining - 1)\n        return total\n\n    return helper(None, n)", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Computes the number of possible sequences of length n where each element\n    is a positive integer less than or equal to m, and each element is at least\n    twice the previous element.\n\n    Parameters:\n    - m (int): The maximum value of any element in the sequence.\n    - n (int): The length of the sequence.\n\n    Returns:\n    - int: The total number of valid sequences.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    # Initialize dp_prev where dp_prev[y] represents the number of sequences\n    # of length 1 ending with y. Initially, there's one sequence for each y.\n    dp_prev = [0] * (m + 1)\n    for y in range(1, m + 1):\n        dp_prev[y] = 1\n\n    # Iterate over sequence lengths from 2 to n\n    for _ in range(2, n + 1):\n        # Compute prefix sums to optimize the sum of dp_prev[x] where x <= y//2\n        prefix_sum = [0] * (m + 1)\n        for y in range(1, m + 1):\n            prefix_sum[y] = prefix_sum[y - 1] + dp_prev[y]\n        \n        # Calculate dp_current based on dp_prev and the prefix sums\n        dp_current = [0] * (m + 1)\n        for y in range(1, m + 1):\n            dp_current[y] = prefix_sum[y // 2]\n        \n        # Update dp_prev for the next iteration\n        dp_prev = dp_current\n\n    # The total number of sequences is the sum of all possible last elements\n    total_sequences = sum(dp_prev[1:])\n    return total_sequences", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    if n == 0:\n        return 0\n    # Initialize dp_prev for sequences of length 1\n    dp_prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        dp_prev[x] = 1\n\n    for step in range(2, n + 1):\n        # Compute prefix sums of dp_prev\n        prefix_sum = [0] * (m + 1)\n        for x in range(1, m + 1):\n            prefix_sum[x] = prefix_sum[x - 1] + dp_prev[x]\n        # Compute dp_new for the current step\n        dp_new = [0] * (m + 1)\n        for x in range(1, m + 1):\n            dp_new[x] = prefix_sum[x // 2]\n        # Update dp_prev for the next step\n        dp_prev = dp_new\n\n    # Total number of sequences of length n\n    total_sequences = sum(dp_prev)\n    return total_sequences", "matching_cluster_idx": 8}]}, "Mbpp/240": {"dps": 52.3780487804878, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with all elements from lst2.\n\n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The list whose elements will replace the last element of lst1.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    if not lst1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list1 with the last element replaced by elements of list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to insert into list1.\n\n    Returns:\n        list: The modified list with the last element replaced by list2 elements.\n    \"\"\"\n    # Ensure that list1 has at least one element\n    if not list1:\n        raise ValueError(\"The first list must contain at least one element.\")\n    \n    # Replace the last element with list2 elements\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by list2's elements.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    \n    # Replace the last element with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with all elements from lst2.\n\n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The list whose elements will replace the last element of lst1.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    if not lst1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Parameters:\n    list1 (list): The original list whose last element will be replaced.\n    list2 (list): The list of elements to insert into list1.\n\n    Returns:\n    list: The modified list with the last element of list1 replaced by list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list must contain at least one element.\")\n    # Replace the last element with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list is empty and has no elements to replace.\")\n    # Replace the last element of list1 with the elements of list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list is empty.\")\n    # Remove the last element and extend with list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Parameters:\n    list1 (list): The original list whose last element is to be replaced.\n    list2 (list): The list of elements to insert in place of the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        return list2.copy()\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n    list: The modified list with the last element of list1 replaced by list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        return list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements from list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to replace the last element of list1.\n    \n    Returns:\n        list: The modified list with the last element of list1 replaced by list2.\n    \"\"\"\n    if not list1:\n        # If the first list is empty, return the second list\n        return list2\n    # Replace the last element by concatenating all but the last element of list1 with list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"\n    Replaces the last element of lst1 with the elements of lst2.\n\n    Parameters:\n    lst1 (list): The first list.\n    lst2 (list): The list whose elements will replace the last element of lst1.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    # Remove the last element of lst1 and concatenate with lst2\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list.\n    list2 (list): The second list to replace the last element of list1.\n\n    Returns:\n    list: The modified list with the last element replaced by list2's elements.\n    \"\"\"\n    if not list1:\n        # If the first list is empty, return the second list\n        return list2\n    # Replace the last element by slicing up to the last element and concatenating list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The first list whose last element is to be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    if not list1:\n        raise ValueError(\"The first list cannot be empty.\")\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1 (list): The original list.\n        list2 (list): The list to insert in place of the last element of list1.\n\n    Returns:\n        list: The modified list with the last element replaced by list2.\n    \"\"\"\n    # Exclude the last element of list1 and concatenate with list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list after replacement.\n    \"\"\"\n    if not list1:\n        # If the first list is empty, return the second list\n        return list2\n    # Remove the last element of list1 and extend with list2\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with all elements of list2.\n\n    Parameters:\n    list1 (list): The original list.\n    list2 (list): The list to insert.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    if not list1:\n        # If list1 is empty, return list2\n        return list2.copy()\n    # Create a copy of list1 without the last element\n    new_list = list1[:-1]\n    # Extend the new list with elements from list2\n    new_list.extend(list2)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of list1 with the elements of list2.\n\n    Parameters:\n    list1 (list): The original list whose last element will be replaced.\n    list2 (list): The list of elements to insert into list1.\n\n    Returns:\n    list: The modified list with the last element replaced by list2.\n    \"\"\"\n    if not list1:\n        # If list1 is empty, simply return list2\n        return list2\n    # Replace the last element with list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    element: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Args:\n        lst (list): The original list.\n        elem: The element to insert.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    element: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n        lst (list): The original list.\n        element: The element to insert before each element of the list.\n\n    Returns:\n        list: The resulting list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    \"\"\"\n    Inserts the element 'el' before each element in the list 'lst' and returns the resulting list.\n    \n    Args:\n        lst (list): The original list of elements.\n        el (any): The element to insert before each element in the list.\n        \n    Returns:\n        list: A new list with 'el' inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(el)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Args:\n        lst (list): The original list of elements.\n        element: The element to insert before each element of the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Parameters:\n    lst (list): The original list.\n    elem: The element to insert before each item in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Args:\n        lst (list): The original list of elements.\n        elem: The element to insert before each element of the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Args:\n        lst (list): The original list of elements.\n        elem: The element to insert before each element of the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    elem (any): The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem: The element to insert before each element of the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Args:\n        lst (list): The original list of elements.\n        elem: The element to insert before each item in the list.\n\n    Returns:\n        list: A new list with the element inserted before each original item.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Args:\n        lst (list): The original list of elements.\n        elem: The element to insert before each element of the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem: The element to insert before each element of the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the specified element before each element in the input list.\n\n    Args:\n        lst (list): The original list of elements.\n        element: The element to insert before each element of the list.\n\n    Returns:\n        list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the specified element before each element in the input list.\n    \n    Parameters:\n    lst (list): The original list.\n    element: The element to insert before each element of the list.\n    \n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the list.\n\n    Parameters:\n    lst (list): The original list.\n    elem: The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the specified element before each element in the given list.\n\n    Parameters:\n    lst (list): The original list.\n    element: The element to insert before each element of the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Inserts the specified element before each element in the provided list.\n\n    Parameters:\n    lst (list): The original list of elements.\n    elem (Any): The element to insert before each element in the list.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 98.27625570776256, "dps_norm": 90.88235294117646, "pass@1": 100.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    # Initialize a list to track prime status of numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a sieve list where index represents the number.\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False  # 0 and 1 are not primes.\n\n    for current in range(2, int(n ** 0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime.\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n\n    # Count the number of primes by summing the True values in the sieve.\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: Number of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not primes\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for current in range(2, int(n ** 0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean array where index represents the number.\n    # True means the number is assumed to be prime initially.\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    # Count the number of primes by summing the True values in the sieve\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: Number of prime numbers less than n\n    \"\"\"\n    if n < 2:\n        return 0\n    \n    # Initialize a list to track prime numbers\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n    \n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as not prime\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    \n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: Number of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a list to track prime status of numbers from 0 to n-1\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if is_prime[current]:\n            # Mark multiples of current as non-prime\n            for multiple in range(current*current, n, current):\n                is_prime[multiple] = False\n\n    # Count the number of primes less than n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            for multiple in range(i * i, n, i):\n                sieve[multiple] = False\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number n.\n\n    Parameters:\n    n (int): A non-negative integer.\n\n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    # Initialize a boolean array where index represents the number.\n    # True indicates that the number is prime.\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes.\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of the current prime as non-prime.\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False\n\n    for current in range(2, int(n**0.5) + 1):\n        if is_prime[current]:\n            for multiple in range(current*current, n, current):\n                is_prime[multiple] = False\n\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0:2] = [False, False]  # 0 and 1 are not primes\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(range(current*current, n, current))\n    return sum(sieve)", "matching_cluster_idx": 16}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n\n    Parameters:\n    n (int): A non-negative integer\n\n    Returns:\n    int: Number of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0], sieve[1] = False, False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            # Mark multiples of current as non-prime\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Takes a non-negative integer and returns the number of prime numbers less than the given number.\n    \n    Args:\n        n (int): A non-negative integer.\n        \n    Returns:\n        int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Return the number of prime numbers less than a non-negative number n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than a non-negative integer n.\n\n    Parameters:\n    n (int): The upper limit (non-inclusive) to count prime numbers below.\n\n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            sieve[current*current:n:current] = [False] * len(sieve[current*current:n:current])\n\n    return sum(sieve)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number n.\n    \n    Parameters:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False  # 0 and 1 are not primes\n\n    for current in range(2, int(n**0.5) + 1):\n        if sieve[current]:\n            for multiple in range(current*current, n, current):\n                sieve[multiple] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 64.01162790697674, "dps_norm": 80.83333333333333, "pass@1": 98.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n lists, where each resulting list contains every nth element from the original list.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists with every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by taking every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements into the sublists\n    for index, element in enumerate(lst):\n        sublist_index = index % n\n        result[sublist_index].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by selecting every n-th element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list: A list containing n sublists with every n-th element.\n    \"\"\"\n    # Initialize n empty sublists\n    split_lists = [[] for _ in range(n)]\n    \n    # Distribute elements into the sublists based on their index modulo n\n    for index, element in enumerate(lst):\n        split_lists[index % n].append(element)\n    \n    return split_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements into the sublists based on their index modulo n\n    for index, element in enumerate(lst):\n        sublist_index = index % n\n        result[sublist_index].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element from the original list.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of n sublists containing the split elements.\n    \"\"\"\n    # Initialize n empty sublists\n    split_lists = [[] for _ in range(n)]\n    \n    # Iterate over the original list and distribute elements to the appropriate sublist\n    for index, item in enumerate(lst):\n        split_lists[index % n].append(item)\n    \n    return split_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by selecting every nth element.\n\n    Args:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: A list containing n sublists with the split elements.\n    \"\"\"\n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute elements to the sublists\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list: A list of n sublists with every nth element.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    result = [[] for _ in range(n)]\n    for idx, elem in enumerate(lst):\n        result[idx % n].append(elem)\n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list: A list containing n sublists with every nth element.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, where each sublist contains every nth element\n    starting from a different offset.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists.\n    \"\"\"\n    # Initialize a list of empty lists\n    split_lists = [[] for _ in range(n)]\n    \n    # Iterate over the original list and distribute elements to the sublists\n    for index, element in enumerate(lst):\n        split_lists[index % n].append(element)\n    \n    return split_lists", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists by taking every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list of lists: A list containing n sublists with every nth element.\n    \"\"\"\n    split_lists = [[] for _ in range(n)]\n    for index, element in enumerate(lst):\n        split_lists[index % n].append(element)\n    return split_lists", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list of lists: A list containing n sublists with the split elements.\n    \"\"\"\n    # Initialize n empty sublists\n    sublists = [[] for _ in range(n)]\n    \n    # Distribute elements into the sublists\n    for index, element in enumerate(lst):\n        sublists[index % n].append(element)\n    \n    return sublists", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n    \n    Parameters:\n    lst (list): The list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    # Initialize n empty sublists\n    split_lists = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute elements into sublists based on their index\n    for index, element in enumerate(lst):\n        split_lists[index % n].append(element)\n    \n    return split_lists", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The interval at which to split the list.\n\n    Returns:\n        list of lists: A list containing n sublists.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The number of sublists to create.\n\n    Returns:\n        list: A list containing n sublists with every nth element.\n    \"\"\"\n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute elements to the sublists\n    for index, element in enumerate(lst):\n        sublist_index = index % n\n        result[sublist_index].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list: A list containing n sublists.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Distribute elements into the sublists based on their index modulo n\n    for index, item in enumerate(lst):\n        sublist_index = index % n\n        result[sublist_index].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits the input_list into n sublists by distributing elements based on their index modulo n.\n\n    Parameters:\n    input_list (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists with the distributed elements.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for index, element in enumerate(input_list):\n        result[index % n].append(element)\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits the input list into n sublists, each containing every nth element.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The number of sublists to create.\n\n    Returns:\n    list of lists: A list containing n sublists with every nth element.\n    \"\"\"\n    # Initialize n empty sublists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list and distribute elements to the sublists\n    for index, element in enumerate(lst):\n        sublist_index = index % n\n        result[sublist_index].append(element)\n    \n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Write a python function to check if the elements of a given list are unique or not.\n    assert all_unique([1,2,3]) == True\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check for uniqueness.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Parameters:\n    lst (list): The list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    :param lst: List of elements to check.\n    :return: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 92.82051282051282, "dps_norm": 96.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # All remaining elements in left are inversions\n                j += 1\n        # Append remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums, 0\n        mid = len(nums) // 2\n        left, inv_left = merge_sort(nums[:mid])\n        right, inv_right = merge_sort(nums[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input list of integers.\n    \n    Returns:\n    int: The total number of inversions.\n    \"\"\"\n    def merge_sort(nums):\n        if len(nums) <= 1:\n            return nums, 0\n        mid = len(nums) // 2\n        left, inv_left = merge_sort(nums[:mid])\n        right, inv_right = merge_sort(nums[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array using a modified merge sort algorithm.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n\n    def merge_sort(arr):\n        # Base case\n        if len(arr) <= 1:\n            return arr, 0\n\n        # Split the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n\n        # Merge the two halves and count inversions\n        merged, inv_split = merge(left, right)\n\n        # Total inversions is sum of left, right and split inversions\n        total_inversions = inv_left + inv_right + inv_split\n        return merged, total_inversions\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n\n        # Merge the two sorted lists and count split inversions\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # All remaining elements in left are inversions\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv_count\n\n    # Call merge_sort and return the inversion count\n    _, total_inv = merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Args:\n        arr (list): The input array of integers.\n        \n    Returns:\n        int: The total number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        \n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        \n        while i < len_left and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n        \n        # Append remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array.\n    \n    Returns:\n    int: The number of inversions.\n    \"\"\"\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array using a modified merge sort.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n                \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int: The number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # All remaining elements in left will form inversions\n                j += 1\n        # Append any remaining elements\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, count = merge_sort(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Returns the number of inversions in the array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array.\n    \n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \n    Args:\n        arr (list): The input array.\n        \n    Returns:\n        int: The number of inversions.\n    \"\"\"\n    \n    def merge_sort(arr):\n        # Base case: a list of zero or one elements is sorted, with zero inversions\n        if len(arr) <= 1:\n            return arr, 0\n        \n        # Divide the array into two halves\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        \n        # Merge the two halves and count split inversions\n        merged, inv_split = merge(left, right)\n        \n        # Total inversions is sum of left, right, and split inversions\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i = j = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        # Merge the two sorted lists and count inversions\n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # All remaining elements in left are inversions\n                j += 1\n        \n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n\n    # Call the merge_sort function and return the inversion count\n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n\n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, count = merge_sort(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of indices (i, j) such that i < j and arr[i] > arr[j].\n    \n    Args:\n        arr (list): The input array of integers.\n        \n    Returns:\n        int: The total number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i\n                j += 1\n        \n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in the array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        return merged, inv_left + inv_right + inv_split\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The number of inversions in the array.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n        len_right = len(right)\n        \n        while i < len_left and j < len_right:\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # All remaining elements in left are inversions\n                j += 1\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The number of inversions.\n    \"\"\"\n    \n    def _merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = _merge_sort(arr[:mid])\n            right, inv_right = _merge_sort(arr[mid:])\n            merged, inv_split = _merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def _merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i\n                j += 1\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = _merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n    \n    An inversion is a pair of elements (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n    \n    Parameters:\n    arr (list): The input array of integers.\n    \n    Returns:\n    int: The total number of inversions in the array.\n    \"\"\"\n    \n    def _merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = _merge_sort(arr[:mid])\n        right, inv_right = _merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n    \n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len(left) - i  # Count inversions\n                j += 1\n        # Append any remaining elements\n        merged += left[i:]\n        merged += right[j:]\n        return merged, inv_count\n    \n    _, total_inv = _merge_sort(arr)\n    return total_inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        total_inv = inv_left + inv_right + inv_split\n        return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Parameters:\n    arr (list): The input array.\n\n    Returns:\n    int: The number of inversions.\n    \"\"\"\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        else:\n            mid = len(arr) // 2\n            left, inv_left = merge_sort(arr[:mid])\n            right, inv_right = merge_sort(arr[mid:])\n            merged, inv_split = merge(left, right)\n            total_inv = inv_left + inv_right + inv_split\n            return merged, total_inv\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # All remaining elements in left are inversions\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in the array using a modified merge sort algorithm.\n\n    Args:\n        arr (list): The input array.\n\n    Returns:\n        int: The number of inversions.\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_split = merge(left, right)\n        \n        total_inversions = inv_left + inv_right + inv_split\n        return merged, total_inversions\n\n    def merge(left, right):\n        merged = []\n        i = j = inv_count = 0\n        len_left = len(left)\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv_count += len_left - i  # Count inversions\n                j += 1\n\n        # Append any remaining elements\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv_count\n\n    _, total_inversions = merge_sort(arr)\n    return total_inversions", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 98.10344827586208, "dps_norm": 70.83333333333334, "pass@1": 70.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n        list1 (List[int]): The first list of integers.\n        list2 (List[int]): The second list of integers.\n        n (int): The number of largest products to return.\n\n    Returns:\n        List[int]: A list containing the n largest products.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Find the n largest products from two lists by multiplying one element from each.\n\n    Parameters:\n    list1 (list of int): The first list of integers.\n    list2 (list of int): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    list of int: A list containing the n largest products in descending order.\n    \"\"\"\n    # Calculate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Use heapq.nlargest to find the n largest products efficiently\n    largest_products = heapq.nlargest(n, products)\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest unique products from two lists.\n    \n    Parameters:\n    list1 (list): First list of integers.\n    list2 (list): Second list of integers.\n    n (int): Number of largest products to return.\n    \n    Returns:\n    list: A list containing the n largest unique products, sorted in descending order.\n    \"\"\"\n    # Generate all possible products using a set to ensure uniqueness\n    products = set(a * b for a in list1 for b in list2)\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top 'n' products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    :param list1: List of integers.\n    :param list2: List of integers.\n    :param n: Number of largest products to return.\n    :return: List of the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the first n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two lists by selecting one element from each.\n\n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - n: Number of largest products to return.\n\n    Returns:\n    - A list containing the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n    assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]\n    \"\"\"\n    # Generate all possible products by multiplying elements from both lists\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top 'n' largest products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    list1 (List[int]): First list of integers.\n    list2 (List[int]): Second list of integers.\n    k (int): Number of largest products to find.\n\n    Returns:\n    List[int]: A list containing the k largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Remove duplicates if necessary (optional)\n    # products = list(set(products))\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest unique products by selecting one element from each of the two lists.\n\n    Parameters:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the n largest unique products in descending order.\n    \"\"\"\n    # Generate all possible products from elements of list1 and list2\n    products = set(a * b for a in list1 for b in list2)\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, N):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Args:\n    - list1: List of integers.\n    - list2: List of integers.\n    - N: Number of largest products to find.\n\n    Returns:\n    - List of N largest products sorted in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top N products\n    return products_sorted[:N]", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    list1 (List[int]): The first list of integers.\n    list2 (List[int]): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the n largest products in descending order.\n    \"\"\"\n    # Compute all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Use heapq.nlargest to get the top n products\n    largest_products = heapq.nlargest(n, products)\n    \n    return largest_products", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    list1 (List[int]): First list of integers.\n    list2 (List[int]): Second list of integers.\n    n (int): Number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the n largest products in descending order.\n    \"\"\"\n    # Compute all possible products between elements of list1 and list2\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the first n products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - n: Number of largest products to return.\n\n    Returns:\n    - A list containing the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest unique products from two lists.\n\n    Parameters:\n    list1 (list of int): First list of integers.\n    list2 (list of int): Second list of integers.\n    n (int): Number of largest products to return.\n\n    Returns:\n    list of int: The n largest unique products in descending order.\n    \"\"\"\n    # Compute all possible products using list comprehension\n    products = set(a * b for a in list1 for b in list2)\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the specified number of largest products from two given lists by selecting one element from each list.\n\n    Parameters:\n    list1 (List[int]): First list of integers.\n    list2 (List[int]): Second list of integers.\n    k (int): Number of largest products to return.\n\n    Returns:\n    List[int]: A list containing the k largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top k products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest unique products from two lists by selecting one element from each list.\n\n    Parameters:\n    list1 (list of int): The first list of integers.\n    list2 (list of int): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    list of int: A list containing the n largest unique products, sorted in descending order.\n    \"\"\"\n    # Generate all possible products using one element from each list\n    products = set(a * b for a in list1 for b in list2)\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return sorted_products[:n]", "matching_cluster_idx": 4}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists.\n    \n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - n: Number of largest products to return.\n    \n    Returns:\n    - A list containing the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products by multiplying elements from both lists\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n    \n    Args:\n        list1 (List[int]): The first list of integers.\n        list2 (List[int]): The second list of integers.\n        k (int): The number of largest products to return.\n    \n    Returns:\n        List[int]: A list containing the k largest products in descending order.\n    \n    Example:\n        >>> large_product([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3)\n        [60, 54, 50]\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return products_sorted[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two lists by selecting one element from each list.\n\n    Parameters:\n    list1 (list of int): The first list of integers.\n    list2 (list of int): The second list of integers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    list of int: A list containing the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products_sorted = sorted(products, reverse=True)\n    \n    # Return the top n products\n    return products_sorted[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    \"\"\"\n    Finds the specified number of largest products from two given lists,\n    selecting one factor from each list.\n\n    Parameters:\n    - list1: First list of integers.\n    - list2: Second list of integers.\n    - k: Number of largest products to return.\n\n    Returns:\n    - A list containing the top k largest products in descending order.\n    \"\"\"\n    # Compute all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the top k products\n    return sorted_products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Finds the specified number of largest products from two given lists by selecting one factor from each list.\n\n    Parameters:\n    list1 (list of int/float): The first list of numbers.\n    list2 (list of int/float): The second list of numbers.\n    n (int): The number of largest products to return.\n\n    Returns:\n    list of int/float: A list containing the n largest products in descending order.\n    \"\"\"\n    # Generate all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n products\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 64.0, "profiled": [{"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Recursively computes the maximum sum based on the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Args:\n        n (int): The input number.\n        memo (dict): A dictionary to memoize computed values.\n    \n    Returns:\n        int: The maximum sum for the given n.\n    \"\"\"\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n    \n    # Compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_children = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # Determine the maximum between the sum and n itself\n    memo[n] = max(sum_children, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Finds the maximum sum possible using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Args:\n        n (int): The input integer.\n        memo (dict): A dictionary to memoize previously computed results.\n    \n    Returns:\n        int: The maximum sum for the given n.\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    # Take the maximum of the computed sum and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n    # Calculate the sum by breaking down the number\n    sum_breakdown = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Take the maximum of the breakdown sum and the number itself\n    memo[n] = max(sum_breakdown, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[0] = 0\n        return 0\n    # Recursively compute the maximum sum\n    sum_split = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    memo[n] = max(sum_split, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Compute the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_parts = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    # Take the maximum between the sum of parts and n\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n        \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        memo[n] = 0\n        return 0\n    \n    # Calculate the sum by breaking n into n/2, n/3, n/4, and n/5\n    sum_sub = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Choose the maximum between the sum of parts and n itself\n    memo[n] = max(sum_sub, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Recursively computes the maximum sum using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    :param n: The integer input\n    :param memo: Dictionary for memoization to store computed f(n) values\n    :return: The maximum sum as per the given equation\n    \"\"\"\n    if memo is None:\n        memo = {}\n        \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        memo[n] = 0\n        return 0\n    \n    # Compute the sum of f(n//2), f(n//3), f(n//4), and f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # The maximum of the sum of parts and n itself\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n == 0:\n        return 0\n    if n in memo:\n        return memo[n]\n    \n    # Compute the sum of the function applied to the divided parts\n    sum_children = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # The maximum sum is the greater of the sum of children or the number itself\n    memo[n] = max(sum_children, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def helper(x):\n        if x == 0:\n            return 0\n        # Compute the sum of the function applied to the subparts\n        sum_sub = helper(x // 2) + helper(x // 3) + helper(x // 4) + helper(x // 5)\n        # Return the maximum between the sum and the current number\n        return max(sum_sub, x)\n    \n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    \n    if n == 0:\n        return 0\n    \n    if n in memo:\n        return memo[n]\n    \n    # Calculate the sum using the given equation\n    sum_val = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Take the maximum between the sum and the current number\n    memo[n] = max(sum_val, n)\n    \n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    # Compute the sum of f(n//2) + f(n//3) + f(n//4) + f(n//5)\n    sum_f = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Take the maximum of the sum and n\n    memo[n] = max(sum_f, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Recursively calculates the maximum sum based on the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n\n    Args:\n        n (int): The input integer.\n        memo (dict, optional): A dictionary to store previously computed results for memoization.\n\n    Returns:\n        int: The maximum sum for the given n.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n == 0:\n        return 0\n\n    if n in memo:\n        return memo[n]\n\n    # Compute the sum by breaking down the number\n    sum_break = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n\n    # Take the maximum of breaking down or keeping the number\n    memo[n] = max(sum_break, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    \"\"\"\n    Compute the maximum sum based on the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    \n    Args:\n        n (int): The input integer.\n    \n    Returns:\n        int: The maximum sum as defined by the equation.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n    \n    return f(n)", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "from functools import lru_cache\ndef get_max_sum(n):\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x == 0:\n            return 0\n        return max(x, f(x//2) + f(x//3) + f(x//4) + f(x//5))\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[0] = 0\n        return 0\n    # Calculate the sum of f(n//2) + f(n//3) + f(n//4) + f(n//5)\n    sum_parts = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    # Take the maximum between the sum of parts and n\n    memo[n] = max(sum_parts, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Finds the maximum sum possible using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n\n    Args:\n        n (int): The input integer.\n        memo (dict, optional): Dictionary for memoization. Defaults to None.\n\n    Returns:\n        int: The maximum sum for the given n.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        return 0\n    \n    # Compute the sum of f(n//2), f(n//3), f(n//4), f(n//5)\n    sum_children = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # The maximum is either the sum of children or n itself\n    memo[n] = max(n, sum_children)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    \"\"\"\n    Calculate the maximum sum using the equation:\n    f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n\n    Args:\n        n (int): The input integer.\n        memo (dict, optional): A dictionary to store computed results for memoization.\n\n    Returns:\n        int: The maximum sum for the given n.\n    \"\"\"\n    if memo is None:\n        memo = {}\n    \n    if n in memo:\n        return memo[n]\n    \n    if n == 0:\n        memo[n] = 0\n        return 0\n    \n    # Compute the sum of f(n//2), f(n//3), f(n//4), f(n//5)\n    sum_children = (\n        get_max_sum(n // 2, memo) +\n        get_max_sum(n // 3, memo) +\n        get_max_sum(n // 4, memo) +\n        get_max_sum(n // 5, memo)\n    )\n    \n    # Take the maximum of the sum or n itself\n    memo[n] = max(sum_children, n)\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        memo[n] = 0\n        return 0\n    # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    sum_sub = (get_max_sum(n // 2, memo) +\n               get_max_sum(n // 3, memo) +\n               get_max_sum(n // 4, memo) +\n               get_max_sum(n // 5, memo))\n    # The maximum of the sum and n itself\n    memo[n] = max(sum_sub, n)\n    return memo[n]", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    Args:\n        s (str): The input string to search.\n    \n    Returns:\n        str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # OrderedDict preserves the insertion order\n    char_counts = OrderedDict()\n\n    # Count occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeated character\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in the given string.\n    \n    :param s: The input string to search.\n    :return: The first non-repeating character, or None if there isn't one.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n\n    for char in s:\n        if counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeated character if found, otherwise None.\n    \"\"\"\n    # Dictionary to store the count of each character\n    char_count = {}\n\n    # First pass: Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no unique character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    Returns the character if found, otherwise returns None.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    Parameters:\n    s (str): The string to search.\n\n    Returns:\n    str or None: The first non-repeating character, or None if there isn't one.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    char_counts = OrderedDict()\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first character with a count of 1\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string to be analyzed.\n    \n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    char_count = OrderedDict()\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    Parameters:\n    s (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    # Dictionary to store the count of each character\n    char_counts = {}\n    \n    # First pass: Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n    \n    # Second pass: Find the first character with a count of 1\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    :param s: The input string to search.\n    :return: The first non-repeated character or None if there isn't one.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Ordered dictionary to maintain the order of characters\n    char_counts = OrderedDict()\n\n    # Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeated character\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import OrderedDict\n    counts = OrderedDict()\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    for char, count in counts.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Parameters:\n    s (str): The input string to search.\n\n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    char_counts = OrderedDict()\n\n    # Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeating character in a string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str or None: The first non-repeating character, or None if there is none.\n    \"\"\"\n    from collections import OrderedDict\n\n    char_count = OrderedDict()\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    Parameters:\n    s (str): The input string to be checked.\n    \n    Returns:\n    str or None: The first non-repeating character if found, else None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Create an ordered dictionary to maintain the insertion order of characters\n    char_count = OrderedDict()\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n\n    Parameters:\n    s (str): The input string to search.\n\n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    char_counts = OrderedDict()\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a string.\n    Returns the character if found, else None.\n    \"\"\"\n    char_counts = {}\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    Returns the character if found, otherwise returns None.\n    \"\"\"\n    char_count = {}\n    \n    # First pass: count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Second pass: find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str or None: The first non-repeating character, or None if there isn't one.\n    \"\"\"\n    counts = Counter(s)\n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    Parameters:\n    s (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    char_counts = OrderedDict()\n\n    # Count the occurrences of each character\n    for char in s:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_counts.items():\n        if count == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Parameters:\n    s (str): The input string to search.\n\n    Returns:\n    str or None: The first non-repeating character if found, otherwise None.\n    \"\"\"\n    from collections import OrderedDict\n\n    # Use OrderedDict to maintain the order of characters\n    char_count = OrderedDict()\n\n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Finds the first non-repeated character in the given string.\n    \n    :param s: The input string to search.\n    :return: The first non-repeating character, or None if there is no such character.\n    \"\"\"\n    counts = {}\n    for char in s:\n        counts[char] = counts.get(char, 0) + 1\n    \n    for char in s:\n        if counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    from collections import OrderedDict\n\n    # Create an ordered dictionary to maintain the order of characters\n    char_count = OrderedDict()\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through the ordered dictionary to find the first non-repeating character\n    for char, count in char_count.items():\n        if count == 1:\n            return char\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tup (tuple): The tuple to search.\n        element: The element to check for.\n\n    Returns:\n        bool: True if element is in tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tup, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found in tup, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the element exists in the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, elem):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    elem: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return elem in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tpl, element):\n    \"\"\"\n    Check if the element exists within the given tuple.\n\n    Parameters:\n    tpl (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tpl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if element is in tup, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if the element exists within the tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find in the tuple.\n\n    Returns:\n    bool: True if element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Args:\n        tup (tuple): The tuple to search.\n        element: The element to find in the tuple.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    element: The element to find.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 86.30434782608695, "dps_norm": 87.22222222222221, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n        \n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence of elements.\n        seq2 (iterable): Second sequence of elements.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence to check.\n        seq2 (iterable): The second sequence to check.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookup\n    set_seq2 = set(seq2)\n    \n    # Iterate through the first sequence and check for any common element\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Args:\n        seq1 (iterable): The first sequence of elements.\n        seq2 (iterable): The second sequence of elements.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for efficient lookup\n    set_seq2 = set(seq2)\n    # Iterate through the first sequence and check for common elements\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence to check.\n        seq2 (iterable): Second sequence to check against.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for efficient look-up\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Args:\n        seq1 (iterable): The first sequence to check.\n        seq2 (iterable): The second sequence to check against.\n\n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookup\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence.\n    seq2 (iterable): Second sequence.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookups\n    set_seq2 = set(seq2)\n    for element in seq1:\n        if element in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for efficient look-up\n    set_seq2 = set(seq2)\n    # Iterate through the first sequence and check for common elements\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n\n    Returns:\n    bool: True if any value from seq1 exists in seq2, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookup\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): The first sequence.\n    seq2 (iterable): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookup\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any common element between two sequences.\n\n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence of elements.\n        seq2 (iterable): Second sequence of elements.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if there is any common element between two sequences.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookup\n    set_seq2 = set(seq2)\n    # Iterate through the first sequence and check for any common element\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in the first sequence exists in the second sequence.\n\n    Parameters:\n    seq1 (iterable): The first sequence.\n    seq2 (iterable): The second sequence.\n\n    Returns:\n    bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    # Convert both sequences to sets for efficient lookup\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check for intersection\n    return not set1.isdisjoint(set2)", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): First sequence.\n        seq2 (iterable): Second sequence.\n\n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (sequence): The first sequence of elements.\n        seq2 (sequence): The second sequence of elements.\n\n    Returns:\n        bool: True if any element of seq1 is in seq2, False otherwise.\n    \"\"\"\n    return any(element in seq2 for element in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    # Convert the second sequence to a set for faster lookup\n    set_seq2 = set(seq2)\n    \n    # Iterate through the first sequence and check for common elements\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence of elements.\n    seq2 (iterable): Second sequence of elements.\n\n    Returns:\n    bool: True if there is at least one common element, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (iterable): The first sequence.\n        seq2 (iterable): The second sequence.\n\n    Returns:\n        bool: True if any value from seq1 is in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (iterable): First sequence to check.\n    seq2 (iterable): Second sequence to check.\n\n    Returns:\n    bool: True if any value from seq1 exists in seq2, False otherwise.\n    \"\"\"\n    set_seq2 = set(seq2)\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 18.312757201646093, "dps_norm": 72.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The string delimiter to separate elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tpl, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple using the specified delimiter.\n\n    Parameters:\n    tpl (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use between elements. Default is '-'.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tpl)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n    \n    Parameters:\n    tup (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The string delimiter to separate the elements. Defaults to '-'.\n    \n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The string used to separate elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the input_tuple into a single string separated by the specified delimiter.\n\n    Args:\n        input_tuple (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    # Convert all elements to strings to handle non-string elements\n    string_elements = [str(element) for element in input_tuple]\n    # Join the string elements using the specified delimiter\n    return delimiter.join(string_elements)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tpl, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the given delimiter.\n\n    Args:\n        tpl (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tpl)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple into a string separated by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to separate elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the given delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple using the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use for concatenation.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by the given delimiter.\n    \n    Args:\n        t (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use for concatenation. Default is '-'.\n    \n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple into a single string separated by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenates each element of the tuple into a string separated by a hyphen.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n\n    Returns:\n        str: A single string with each element separated by a hyphen.\n    \"\"\"\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple whose elements are to be concatenated.\n        delimiter (str): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple using the specified delimiter.\n\n    Args:\n        tup (tuple): The tuple containing elements to concatenate.\n        delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by the specified delimiter.\n\n    Parameters:\n    tup (tuple): The tuple containing elements to concatenate.\n    delimiter (str): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    # Convert each element to string and join with the delimiter\n    return delimiter.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    \"\"\"\n    Concatenates each element of the tuple into a single string separated by '-'.\n    \n    Args:\n        tup (tuple): A tuple containing elements to concatenate.\n        \n    Returns:\n        str: A concatenated string of all tuple elements separated by '-'.\n    \"\"\"\n    return '-'.join(str(element) for element in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tpl, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the tuple using the specified delimiter.\n\n    Args:\n        tpl (tuple): The tuple containing elements to concatenate.\n        delimiter (str): The delimiter to use for concatenation. Defaults to '-'.\n\n    Returns:\n        str: The concatenated string.\n    \"\"\"\n    return delimiter.join(str(item) for item in tpl)", "matching_cluster_idx": 4}]}, "Mbpp/424": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the provided tuple.\n    \n    Args:\n        strings (tuple): A tuple of strings.\n        \n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings_tuple (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Parameters:\n    strings (tuple): A tuple of strings.\n\n    Returns:\n    list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings):\n    \"\"\"\n    Extract the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the last character of each string.\n    \"\"\"\n    return [s[-1] for s in strings]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_lists: List[List[Any]] - The list of sublists to search through.\n    - element: Any - The element to count in the sublists.\n\n    Returns:\n    - int - The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in 'lst' that contain 'element'.\n    \n    Parameters:\n    lst (list of lists): The list of sublists to search.\n    element: The element to count in the sublists.\n    \n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in 'lst' that contain the specified 'element'.\n\n    Parameters:\n    lst (list of lists): The list containing sublists to be searched.\n    element (any): The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_sublists (list of lists): The list containing sublists.\n    - element: The element to search for within the sublists.\n\n    Returns:\n    - int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Args:\n        list_of_sublists (list of lists): The list of sublists to search.\n        element: The element to count occurrences of in the sublists.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_sublists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain a particular element.\n    \n    Parameters:\n    list_of_lists (List[List[Any]]): The list of sublists to search.\n    element (Any): The element to count in the sublists.\n    \n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Args:\n        list_of_lists (list of lists): The list containing sublists to search through.\n        element: The element to search for within each sublist.\n\n    Returns:\n        int: The number of sublists that contain the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Args:\n        list_of_sublists (list of lists): The list containing sublists to search.\n        element: The element to count within the sublists.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_sublists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_sublists (list of lists): The list containing sublists to search through.\n    - element: The element to count within the sublists.\n\n    Returns:\n    - int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Args:\n        list_of_lists (list of lists): The list of sublists to search.\n        element: The element to search for within the sublists.\n\n    Returns:\n        int: The count of sublists that contain the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_sublists (list of lists): The list containing sublists to be searched.\n    - element: The element to search for within the sublists.\n\n    Returns:\n    - int: The count of sublists that contain the specified element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_sublists (List[List[Any]]): A list of sublists to search through.\n    - element (Any): The element to count occurrences of in the sublists.\n\n    Returns:\n    - int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    list_of_sublists (list of lists): The list containing sublists to search.\n    element: The element to count within the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n    \n    Parameters:\n    lst (list of lists): The list containing sublists to be searched.\n    element (any): The element to search for within the sublists.\n    \n    Returns:\n    int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists in `lst` that contain the specified `element`.\n\n    Parameters:\n    lst (list of lists): The list containing sublists to be checked.\n    element (any): The element to search for within the sublists.\n\n    Returns:\n    int: The count of sublists that contain the `element`.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_lists: List[List[Any]] - A list of sublists to search through.\n    - element: Any - The element to count occurrences of in the sublists.\n\n    Returns:\n    - int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_sublists (list of lists): The list containing sublists to search.\n    - element: The element to search for within the sublists.\n\n    Returns:\n    - int: The count of sublists that contain the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    - list_of_lists (list of lists): The list containing sublists to be checked.\n    - element: The element to count within the sublists.\n\n    Returns:\n    - int: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    Parameters:\n    list_of_lists (list of lists): The list containing sublists to search through.\n    element: The element to count within the sublists.\n\n    Returns:\n    int: The number of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Counts the number of sublists that contain the specified element.\n\n    :param sublists: List of sublists to search through.\n    :param element: The element to count occurrences of in the sublists.\n    :return: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 49.09090909090909, "dps_norm": 48.888888888888886, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap and reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements that are gap apart\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap = gap // 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a large gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of the array that are greater than temp\n            # to one position ahead of their current position\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n\n    # Start with a big gap, then reduce the gap.\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration.\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a large gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp in its correct location\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements that are gap apart and greater than temp\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Insert the original element at its correct position\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n\n        gap //= 2  # Reduce the gap for the next iteration.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array in ascending order using the Shell Sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Continue reducing the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements that are gap positions apart.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Insert the current element at its correct position.\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration.\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            # Shift elements that are gap apart\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap until it becomes 0.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location.\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element.\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap = gap // 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap.\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of arr[0..i-gap] that are greater than temp to one position ahead.\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration.\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next iteration\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a larger gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct \n            # location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap = gap // 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts an array using the Shell Sort algorithm.\n\n    Parameters:\n    arr (list): The list of elements to be sorted.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size.\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/433": {"dps": 74.8936170212766, "dps_norm": 76.0, "pass@1": 94.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the number 'num' is greater than all elements in 'arr'.\n\n    Parameters:\n    arr (list of int/float): The list of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if `num` is greater than all elements in `arr`, False otherwise.\n    \"\"\"\n    return all(element < num for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    :param arr: List of integers.\n    :param num: Integer to compare.\n    :return: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list of int): The array of integers to compare.\n    num (int): The number to check against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements in the given array.\n\n    :param arr: List of numbers to compare against.\n    :param num: The number to check.\n    :return: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    # If the array is empty, by definition, num is greater\n    if not arr:\n        return True\n    # Check if num is greater than each element in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than all the elements of the given array.\n\n    Parameters:\n    arr (list of numbers): The array to compare.\n    num (number): The number to compare against the array elements.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare against the array elements.\n\n    Returns:\n    bool: True if 'num' is greater than all elements in 'arr', False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Args:\n        arr (list of int/float): The array of numbers to compare.\n        num (int/float): The number to compare against the array elements.\n\n    Returns:\n        bool: True if `num` is greater than all elements in `arr`, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    if not arr:\n        # If the array is empty, by definition, num is greater\n        return True\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int): The list of integers to compare against.\n    num (int): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): A list of numbers.\n    num (int or float): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(element < num for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks if the entered number is greater than all elements in the given array.\n\n    Parameters:\n    arr (list): The list of numbers to compare against.\n    num (int or float): The number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): List of numbers.\n    num (int or float): Number to compare.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list of int/float): The array of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than all elements in the given array.\n\n    :param arr: List of integers\n    :param num: Integer to compare\n    :return: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}]}, "Mbpp/437": {"dps": 82.3529411764706, "dps_norm": 62.0, "pass@1": 94.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing only characters from even indices.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(s) if index % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing characters from even indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices (0-based) from the input string,\n    effectively keeping characters at odd indices.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A string containing only the characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing only the characters at odd indices.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(s) if index % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing only characters from odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions (1-based indexing) from the input string.\n    \n    Parameters:\n    s (str): The input string from which to remove odd-positioned characters.\n    \n    Returns:\n    str: A new string containing only the characters from even positions.\n    \n    Example:\n    >>> remove_odd(\"python\")\n    'yhn'\n    \"\"\"\n    # Using 0-based indexing: even indices correspond to odd positions (1-based)\n    return ''.join([char for index, char in enumerate(s) if (index + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from odd indices of the input.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string containing characters from odd indices of the input string.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices (0-based) from the input string,\n    effectively keeping characters at odd indices.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string containing only the characters at odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from odd indices of the input.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(s) if index % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    \n    assert remove_odd(\"python\") == \"yhn\"\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at even indices (0-based) from the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A string containing characters from odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd indices from the input string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: A string containing characters from odd indices of the input.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions (1-based indexing) from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters at odd positions removed.\n    \"\"\"\n    # Using list comprehension with enumerate to filter out characters at odd positions\n    return ''.join([char for idx, char in enumerate(s) if (idx + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions (1-based indexing) from the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters at odd positions removed.\n    \"\"\"\n    # In 1-based indexing, odd positions correspond to even indices in 0-based indexing\n    return s[1::2]", "matching_cluster_idx": 3}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove characters at odd indices from the input string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A new string containing characters from odd indices.\n    \"\"\"\n    return ''.join([char for index, char in enumerate(s) if index % 2 != 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at odd positions (1-based) from the input string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: A new string with characters from even positions.\n    \"\"\"\n    # Since string indices are 0-based, odd positions are at even indices\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters from the string that are in odd positions (1-based indexing).\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters in odd positions removed.\n    \"\"\"\n    # Using 1-based indexing, keep characters at even positions\n    return ''.join([char for index, char in enumerate(s, start=1) if index % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes characters at even indices (0, 2, 4, ...) from the string,\n    effectively keeping only the characters at odd indices.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: A new string with characters from odd indices.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 3}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 70.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_list):\n    \"\"\"\n    Counts the total number of occurrences of all elements in elements_list within input_tuple.\n\n    :param input_tuple: Tuple containing elements to search within.\n    :param elements_list: List of elements to count in the tuple.\n    :return: Integer representing the total count of specified elements in the tuple.\n    \"\"\"\n    return sum(input_tuple.count(element) for element in elements_list)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in 'lst' within the tuple 'tup'.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of specified elements in the tuple.\n    \"\"\"\n    return sum(tup.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tup`.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    total = 0\n    for item in lst:\n        total += tup.count(item)\n    return total", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Args:\n        tpl (tuple): The tuple to search within.\n        lst (list): The list of elements to count in the tuple.\n\n    Returns:\n        int: Total count of all specified elements in the tuple.\n\n    Example:\n        >>> count_Occurrence(('a', 'a', 'c', 'b', 'd'), ['a', 'b'])\n        3\n    \"\"\"\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the occurrences of all elements in lst within the tuple tpl.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total number of occurrences of the elements from lst in tpl.\n    \"\"\"\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in 'lst' within the tuple 'tup'.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of elements from lst in the tuple tup.\n\n    Args:\n        tup (tuple): The tuple to search.\n        lst (list): The list of elements to count.\n\n    Returns:\n        int: Total count of occurrences.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tpl`.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the specified elements.\n    \"\"\"\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tpl`.\n\n    Args:\n        tpl (tuple): The tuple in which to count occurrences.\n        lst (list): The list of elements to count in the tuple.\n\n    Returns:\n        int: The total count of occurrences of all specified elements.\n    \"\"\"\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrence of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of the elements from lst in tup.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in 'lst' within the tuple 'tpl'.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tpl.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tpl`.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(tpl.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in lst within the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tup`.\n\n    Args:\n        tup (tuple): The tuple to search within.\n        lst (list): The list of elements to count in the tuple.\n\n    Returns:\n        int: The total count of occurrences.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Counts the total number of occurrences of all elements in `lst` within the tuple `tpl`.\n    \n    Args:\n        tpl (tuple): The tuple to search within.\n        lst (list): The list of elements to count in the tuple.\n        \n    Returns:\n        int: The total count of occurrences.\n    \"\"\"\n    return sum(tpl.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    \"\"\"\n    Count the total number of occurrences of all elements in lst within the tuple tpl.\n\n    Parameters:\n    tpl (tuple): The tuple to search within.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: Total count of occurrences of the list elements in the tuple.\n    \"\"\"\n    return sum(tpl.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_list):\n    \"\"\"\n    Counts the total number of occurrences of all elements in elements_list within input_tuple.\n    \n    Parameters:\n    input_tuple (tuple): The tuple in which to count occurrences.\n    elements_list (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in elements_list:\n        element_count = input_tuple.count(element)\n        count += element_count\n        print(f\"Element '{element}' occurs {element_count} times.\")\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the total number of occurrences of all elements in lst within the tuple tup.\n\n    Args:\n    tup (tuple): The tuple to search through.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of all specified elements in the tuple.\n    \"\"\"\n    return sum(tup.count(element) for element in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, elements_list):\n    \"\"\"\n    Counts the total number of occurrences of all elements in elements_list within input_tuple.\n\n    Parameters:\n    input_tuple (tuple): The tuple to search within.\n    elements_list (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(input_tuple.count(element) for element in elements_list)", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Parameters:\n    strings (list of str): The list of strings to be reversed.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    :param strings: List of string values to be reversed.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(list_of_strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        list_of_strings (list): A list of string values.\n\n    Returns:\n        list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in list_of_strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        string_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list.\n\n    Parameters:\n    string_list (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Parameters:\n    string_list (list of str): The list of strings to reverse.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n\n    Args:\n        string_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        lst (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        string_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        strings (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        string_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        string_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the provided list of strings.\n\n    Args:\n        string_list (list of str): The list of strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Args:\n        string_list (list of str): The list containing strings to be reversed.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        strings (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in the given list of strings.\n\n    Parameters:\n    str_list (list of str): The list containing string values to be reversed.\n\n    Returns:\n    list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    Reverses each string in the provided list.\n\n    Args:\n        str_list (list of str): The list of strings to reverse.\n\n    Returns:\n        list of str: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 97.40384615384616, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns a list containing the first element of each sublist.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list of sublists.\n\n    Returns:\n        List[Any]: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_sublists):\n    \"\"\"\n    Returns the first element of each sublist in the given list of sublists.\n\n    Parameters:\n    list_of_sublists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns the first element of each sublist in the provided list of lists.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists.\n\n    Returns:\n        List[Any]: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the provided list.\n\n    Parameters:\n    lst (list of lists): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the input list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list of lists.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the given list.\n\n    Args:\n        lst (List[List[Any]]): A list of sublists.\n\n    Returns:\n        List[Any]: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Extracts the first element from each sublist.\n\n    Parameters:\n    list_of_lists (list of lists): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns a list containing the first element of each sublist in the input list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): A list containing sublists.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Extracts the first element from each sublist in the provided list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list of lists.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list.\n\n    Parameters:\n    lst (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lists):\n    \"\"\"\n    Extracts the first element from each sublist in a list of lists.\n\n    Args:\n        lists (list of lists): The input list containing sublists.\n\n    Returns:\n        list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_sublists):\n    \"\"\"\n    Extracts the first element from each sublist.\n\n    Args:\n        list_of_sublists (list of lists): The input list containing sublists.\n\n    Returns:\n        list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_sublists):\n    \"\"\"\n    Returns the first element of each sublist in the given list of sublists.\n\n    Parameters:\n    list_of_sublists (list of lists): A list where each element is a sublist.\n\n    Returns:\n    list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_sublists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the given list.\n\n    Args:\n        lst (list of lists): A list containing sublists.\n\n    Returns:\n        list: A list containing the first element from each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    \"\"\"\n    Returns the first element of each sublist in the given list of lists.\n\n    Args:\n        list_of_lists (List[List[Any]]): A list containing sublists.\n\n    Returns:\n        List[Any]: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 93.70731707317073, "dps_norm": 95.0, "pass@1": 98.0, "profiled": [{"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    Args:\n        s (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n        \n    Returns:\n        str: The modified string with replaced characters.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Args:\n        s (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of `old` character with `new` character in the string `s`.\n    \n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    # Initialize an empty list to store characters\n    result = []\n\n    # Iterate through each character in the string\n    for char in s:\n        if char == old:\n            result.append(new)\n        else:\n            result.append(char)\n\n    # Join the list back into a string\n    return ''.join(result)", "matching_cluster_idx": 2}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to replace.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n    \n    Args:\n        s (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n    \n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n        \n    Returns:\n        str: The modified string with replacements.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    :param s: Original string\n    :param old_char: Character to be replaced\n    :param new_char: Character to replace with\n    :return: Modified string with characters replaced\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of a specified character in a string with another character.\n\n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    - s (str): The original string.\n    - old_char (str): The character to be replaced.\n    - new_char (str): The character to replace with.\n\n    Returns:\n    - str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Args:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with replacements.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' character in the string 's'.\n    \n    Args:\n        s (str): The original string.\n        old (str): The character to be replaced.\n        new (str): The character to replace with.\n        \n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n    s (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of a specified character in a string with a new character.\n\n    Parameters:\n    s (str): The original string.\n    old (str): The character to be replaced.\n    new (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the string s.\n\n    Parameters:\n        s (str): The original string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace with.\n\n    Returns:\n        str: The modified string with characters replaced.\n    \"\"\"\n    result = []\n    for char in s:\n        if char == old_char:\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: The sum of the smallest and largest values.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of numbers): The input array.\n\n    Returns:\n    number: Sum of the largest and smallest numbers in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array should not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int/float: Sum of the largest and smallest values.\n    \n    Raises:\n    ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the given array.\n    \n    Parameters:\n    arr (list of numbers): The list of numbers to evaluate.\n    \n    Returns:\n    int or float: The sum of the smallest and largest numbers in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest numbers in the array.\n    \n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n    \n    Returns:\n    int/float: Sum of the smallest and largest numbers in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one number.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the given array.\n    \n    Parameters:\n    arr (list of numbers): The array of numbers.\n    \n    Returns:\n    number: Sum of the smallest and largest numbers in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one number.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int or float: Sum of the largest and smallest values.\n\n    Raises:\n    ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    total = smallest + largest\n    return total", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the given array.\n    \n    Parameters:\n    arr (list of int/float): The array of numbers.\n    \n    Returns:\n    int/float: The sum of the smallest and largest numbers in the array.\n    \n    Raises:\n    ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array must contain at least one element.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: Sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    \n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list): A list of numerical values.\n\n    Returns:\n    int or float: The sum of the largest and smallest numbers in the array.\n\n    Raises:\n    ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must contain at least one number.\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int or float): The input array.\n\n    Returns:\n    int or float: The sum of the largest and smallest values.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of numbers): The input array containing numerical values.\n\n    Returns:\n    number: Sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    \n    largest = max(arr)\n    smallest = min(arr)\n    return largest + smallest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"The array must contain at least one element.\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Array cannot be empty.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the smallest and largest values in the given array.\n    \n    Parameters:\n    arr (list of int/float): A non-empty list of numbers.\n    \n    Returns:\n    int/float: Sum of the smallest and largest numbers in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array containing numerical values.\n\n    Returns:\n    int/float: The sum of the largest and smallest values in the array.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in a given array.\n\n    Parameters:\n    arr (list of numbers): The input array.\n\n    Returns:\n    number: Sum of the smallest and largest values.\n\n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest values in the given array.\n\n    Args:\n        arr (list of int/float): The input array.\n\n    Returns:\n        int/float: The sum of the largest and smallest values.\n\n    Raises:\n        ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array is empty.\")\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Returns the sum of the largest and smallest values in the given array.\n\n    Parameters:\n    arr (list of int/float): The input array.\n\n    Returns:\n    int/float: Sum of the largest and smallest values.\n\n    Raises:\n    ValueError: If the array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty.\")\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lowercase.\n\n    Parameters:\n    s (str): The string to convert.\n\n    Returns:\n    str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The input string to be converted.\n\n    Returns:\n        str: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The input string to be converted.\n\n    Returns:\n        str: The lowercased version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string to be converted.\n\n    Returns:\n        str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        input_str (str): The string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the input string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string to convert.\n\n    Returns:\n        str: The lower-cased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the input string to lowercase.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercase version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n        s (str): The input string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The string to convert.\n\n    Returns:\n    str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The lower case version of the input string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The lowercased string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 88.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from a given string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        List[str]: A list of extracted strings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of strings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values within double quotes.\n\n    Returns:\n        List[str]: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n    s (str): The input string containing values within double quotes.\n\n    Returns:\n    list: A list of extracted values without the surrounding quotes.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks.\n    \n    Args:\n        string (str): The input string containing quoted substrings.\n        \n    Returns:\n        list: A list of extracted strings without the quotation marks.\n    \"\"\"\n    # Regular expression to find text within double quotes\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing values within double quotes.\n\n    Returns:\n        list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts values enclosed in double quotation marks from the input string.\n\n    Parameters:\n    s (str): The input string containing values in quotes separated by commas.\n\n    Returns:\n    list: A list of strings extracted from within the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Parameters:\n    s (str): The input string containing values within double quotes.\n\n    Returns:\n    list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extract values between quotation marks from a string.\n    \n    Args:\n        s (str): The input string containing quoted values.\n        \n    Returns:\n        list: A list of values extracted from between the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Parameters:\n    s (str): The input string containing values within double quotes.\n\n    Returns:\n    list: A list of extracted string values without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # The regular expression r'\"(.*?)\"' matches content within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings between double quotes\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        List[str]: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted values.\n\n    Returns:\n        list: A list of extracted values without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.80246913580247, "dps_norm": 87.85714285714285, "pass@1": 100.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Args:\n        nums (list): The input list of numbers.\n\n    Returns:\n        list: A list containing numbers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n    count = Counter(nums)\n    unique_nums = [num for num in nums if count[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from the provided list and returns a list of numbers that appear exactly once.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only the unique numbers from the original list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Args:\n        lst (list): The input list of numbers.\n\n    Returns:\n        list: A list containing numbers that appear exactly once.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return only the unique numbers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only the numbers that appear exactly once.\n    \"\"\"\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in the list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only the unique integers.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only unique integers from the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    return [num for num in nums if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the given list and return a list of numbers that appear only once.\n\n    Args:\n        nums (list): The list of integers to process.\n\n    Returns:\n        list: A list containing only the unique numbers from the original list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes numbers that appear more than once in the list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only the unique integers from the input list.\n    \"\"\"\n    from collections import Counter\n    count = Counter(nums)\n    return [num for num in nums if count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return a list of unique numbers.\n\n    Args:\n        nums (list): The input list of numbers.\n\n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n    \n    Args:\n    lst (list): The input list of numbers.\n    \n    Returns:\n    list: A list containing only the unique numbers.\n    \"\"\"\n    count = Counter(lst)\n    unique_nums = [num for num in lst if count[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the list and return numbers that appear exactly once.\n\n    Args:\n        lst (list): The input list of integers.\n\n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove duplicate numbers from the list and return only the unique numbers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only unique integers from the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    unique_nums = [num for num in nums if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Remove numbers that appear more than once in the list and return the unique numbers.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing only the unique integers from the original list.\n    \"\"\"\n    from collections import Counter\n\n    count = Counter(nums)\n    unique_nums = [num for num in nums if count[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicate numbers from the given list and returns a list of numbers that appear exactly once.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(nums)\n    unique_nums = [num for num, count in counts.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove numbers that appear more than once in the list.\n\n    Parameters:\n    lst (list): The input list of numbers.\n\n    Returns:\n    list: A list containing only the numbers that appear exactly once.\n    \"\"\"\n    counts = Counter(lst)\n    return [num for num in lst if counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Removes numbers that appear more than once in the list.\n\n    Parameters:\n    lst (list): The input list of numbers.\n\n    Returns:\n    list: A list containing only the unique numbers.\n    \"\"\"\n    counts = Counter(lst)\n    unique_nums = [num for num in lst if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the given list and return numbers that appear exactly once.\n\n    Args:\n        lst (list): The input list of numbers.\n\n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(lst)\n    unique_nums = [num for num, cnt in counts.items() if cnt == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the given list and return a list of numbers that appear exactly once.\n\n    Args:\n        lst (list): The list of numbers to process.\n\n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    counts = Counter(lst)\n    unique_nums = [num for num in lst if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    \"\"\"\n    Removes duplicate numbers from the list and returns a list of numbers that appear exactly once.\n    \n    Args:\n        lst (list): A list of integers.\n    \n    Returns:\n        list: A list containing numbers that appear only once in the input list.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    # Extract numbers that appear exactly once, preserving the original order\n    unique_nums = [num for num in lst if counts[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lst):\n    \"\"\"\n    Remove duplicate numbers from the given list and return a list of unique numbers.\n    \n    Parameters:\n    lst (list): The list of numbers from which to remove duplicates.\n    \n    Returns:\n    list: A list containing only the numbers that appear exactly once in the input list.\n    \"\"\"\n    count = Counter(lst)\n    return [num for num in lst if count[num] == 1]", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 96.82539682539682, "dps_norm": 72.72727272727273, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n\n    Returns:\n        list: A flat list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: A single list with elements interleaved from the three input lists.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A new list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Parameters:\n    - list1, list2, list3: Lists to be interleaved.\n\n    Returns:\n    - A flat list containing elements from list1, list2, and list3 alternately.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    return [item for trio in zip(list1, list2, list3) for item in trio]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from the three lists interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n\n    Returns:\n        list: A new list containing elements from all three lists interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list to interleave.\n        list2 (list): Second list to interleave.\n        list3 (list): Third list to interleave.\n\n    Returns:\n        list: A flat list containing elements from the three lists interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A new list containing elements from the three lists interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    return [element for triplet in zip(list1, list2, list3) for element in triplet]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Parameters:\n    - list1, list2, list3: Lists to be interleaved.\n\n    Returns:\n    - A flat list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n    \n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n\n    Returns:\n        list: A new list containing elements from the three lists interleaved.\n    \"\"\"\n    # Use zip to pair elements from each list and then flatten the pairs\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n\n    Returns:\n        list: A new list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: The interleaved flat list.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n        list3 (list): The third list.\n\n    Returns:\n        list: A flat list containing elements from the three lists interleaved.\n\n    Example:\n        >>> interleave_lists([1,2,3], [4,5,6], [7,8,9])\n        [1, 4, 7, 2, 5, 8, 3, 6, 9]\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list to interleave.\n        list2 (list): Second list to interleave.\n        list3 (list): Third list to interleave.\n\n    Returns:\n        list: A flat list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved.extend([a, b, c])\n    return interleaved", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): First list to interleave.\n        list2 (list): Second list to interleave.\n        list3 (list): Third list to interleave.\n\n    Returns:\n        list: A single flat list with elements interleaved from the three input lists.\n    \"\"\"\n    return [element for trio in zip(list1, list2, list3) for element in trio]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The reordered list after splitting and appending.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list with the first n elements moved to the end.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list 'arr' at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The original list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The split index n must be within the list bounds.\")\n    \n    # Split the list and rearrange\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and reordering.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list `lst` at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The split index n must be within the range of the list length.\")\n\n    first_part = lst[:n]\n    second_part = lst[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The index at which to split the list.\n\n    Returns:\n        list: The rearranged list after splitting and appending.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be between 0 and the length of the list.\")\n    \n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The original list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The split index must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"The split index must be within the list bounds.\")\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Args:\n        lst (list): The list to be split.\n        n (int): The index at which to split the list.\n\n    Returns:\n        list: The reordered list with the first part moved to the end.\n        \n    Example:\n        >>> split_Arr([12, 10, 5, 6, 52, 36], 2)\n        [5, 6, 52, 36, 12, 10]\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the bounds of the list length.\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The original list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The split index must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"The split index must be within the list bounds.\")\n    \n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the length of the list\")\n\n    first_part = lst[:n]\n    second_part = lst[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The original list to be split and rearranged.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list length.\")\n\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and appending.\n    \"\"\"\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be between 0 and the length of the list\")\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    lst (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list after splitting and rearranging.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"First argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"Second argument must be an integer.\")\n    if n < 0 or n > len(lst):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    \n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(n, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and appends the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The rearranged list after splitting and appending.\n    \"\"\"\n    # Ensure n is within the bounds of the list\n    if n < 0 or n > len(arr):\n        raise ValueError(\"n must be within the range of the list indices.\")\n    \n    # Split the list and concatenate\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        tuple: A tuple containing the elements of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"Convert a list to a tuple.\"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n        lst (list): The list to be converted.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The converted tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n        lst (list): The list to convert.\n\n    Returns:\n        tuple: The resulting tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(numbers):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n    \n    :param numbers: List of integers or floats\n    :return: Difference between max and min values\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list must contain at least one number.\")\n    \n    largest = max(numbers)\n    smallest = min(numbers)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Finds the difference between the largest and smallest values in a list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The difference between the largest and smallest values.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list should not be empty.\")\n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest value in the given list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list should not be empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    :param nums: List of integers\n    :return: Integer representing the difference\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list should not be empty.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int or float: The difference between the largest and smallest number.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the largest and smallest values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must not be empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The difference between the maximum and minimum values in the list.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list must contain at least one number.\")\n    maximum = max(nums)\n    minimum = min(nums)\n    return maximum - minimum", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n\n    Args:\n        lst (list of int): The input list of integers.\n\n    Returns:\n        int: The difference between the largest and smallest numbers.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list should not be empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n\n    :param lst: List of integers or floats\n    :return: Difference between max and min values\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list should not be empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The difference between the largest and smallest integers.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list must contain at least one number.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list must contain at least one element.\")\n    \n    largest = max(lst)\n    smallest = min(lst)\n    difference = largest - smallest\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the given list.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    int: The difference between the maximum and minimum values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list should not be empty.\")\n    \n    largest = max(lst)\n    smallest = min(lst)\n    difference = largest - smallest\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest integers in the list.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list must not be empty.\")\n    largest = max(nums)\n    smallest = min(nums)\n    return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n\n    Parameters:\n    nums (list of int): The list of integers.\n\n    Returns:\n    int: The difference between the largest and smallest integers.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list should not be empty.\")\n    largest = max(nums)\n    smallest = min(nums)\n    difference = largest - smallest\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest value in the list.\n    \n    Args:\n    lst (list of int/float): The list of numbers to evaluate.\n    \n    Returns:\n    int/float: The difference between the largest and smallest number.\n    \n    Raises:\n    ValueError: If the list is empty.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Returns the difference between the largest and smallest values in the list.\n    \n    Parameters:\n    lst (list): A list of numerical values.\n    \n    Returns:\n    int or float: The difference between the maximum and minimum values.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list cannot be empty.\")\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in the list.\n    \n    Parameters:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The difference between the maximum and minimum values.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"The list is empty.\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 95.0, "dps_norm": 70.0, "pass@1": 98.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    The function computes the sum:\n        sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    where C(n, k) is the binomial coefficient \"n choose k\".\n\n    Args:\n        n (int): The integer value to calculate the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for k in range(n):\n        coeff1 = math.comb(n, k)\n        coeff2 = math.comb(n, k + 1)\n        product = coeff1 * coeff2\n        total += product\n    return total", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculates the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Specifically, it computes:\n        sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    \n    Args:\n        n (int): The binomial coefficient parameter.\n    \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return sum(comb(n, k) * comb(n, k + 1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is calculated as:\n        sum = C(n,0)*C(n,1) + C(n,1)*C(n,2) + ... + C(n,n-1)*C(n,n)\n    \n    Alternatively, using the combinatorial identity:\n        sum = C(2n, n+1)\n    \n    Args:\n        n (int): The non-negative integer for which the sum is calculated.\n    \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return math.comb(2 * n, n + 1)", "matching_cluster_idx": 9}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The non-negative integer to compute the sum for.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    # Generate all binomial coefficients C(n, k) for k from 0 to n\n    binomial_coeffs = [math.comb(n, k) for k in range(n + 1)]\n\n    # Calculate the sum of the product of consecutive binomial coefficients\n    sum_product = sum(binomial_coeffs[i] * binomial_coeffs[i + 1] for i in range(n))\n\n    return sum_product", "matching_cluster_idx": 8}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Finds the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The function calculates the sum over k from 0 to n-1 of C(n, k) * C(n, k+1).\n    \n    Parameters:\n        n (int): The integer value for which the sum is calculated.\n        \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return sum(math.comb(n, k) * math.comb(n, k+1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The number to calculate binomial coefficients from 0 to n.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    # Generate all binomial coefficients C(n, k) for k from 0 to n\n    binomial_coeffs = [math.comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    total = 0\n    for i in range(len(binomial_coeffs) - 1):\n        product = binomial_coeffs[i] * binomial_coeffs[i + 1]\n        total += product\n        print(f\"C({n},{i}) * C({n},{i+1}) = {binomial_coeffs[i]} * {binomial_coeffs[i+1]} = {product}\")\n    \n    print(f\"Sum of products: {total}\")\n    return total", "matching_cluster_idx": 7}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Computes the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The function calculates the sum:\n        C(n, 0)*C(n, 1) + C(n, 1)*C(n, 2) + ... + C(n, n-1)*C(n, n)\n    \n    Args:\n        n (int): The binomial coefficient parameter.\n        \n    Returns:\n        int: The computed sum of products.\n    \"\"\"\n    total = 0\n    for k in range(n):\n        product = comb(n, k) * comb(n, k + 1)\n        total += product\n    return total", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Parameters:\n    n (int): The exponent in the binomial coefficients (n choose k).\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    # Generate all binomial coefficients for the given n\n    binomials = [comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the product of consecutive binomial coefficients\n    products = [binomials[i] * binomials[i + 1] for i in range(len(binomials) - 1)]\n    \n    # Sum all the products\n    total = sum(products)\n    \n    return total", "matching_cluster_idx": 8}, {"solution": "def sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The binomial coefficient parameter.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    from math import comb\n\n    # Generate the list of binomial coefficients for the given n\n    binomial_coefficients = [comb(n, k) for k in range(n + 1)]\n\n    # Calculate the sum of the product of consecutive pairs\n    total = 0\n    for i in range(len(binomial_coefficients) - 1):\n        product = binomial_coefficients[i] * binomial_coefficients[i + 1]\n        total += product\n\n    return total", "matching_cluster_idx": 8}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum is defined as:\n    sum_{i=0}^{n-1} C(n, i) * C(n, i+1)\n    \n    Args:\n        n (int): The binomial coefficient parameter.\n        \n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        binom1 = math.comb(n, i)\n        binom2 = math.comb(n, i + 1)\n        product = binom1 * binom2\n        total += product\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The non-negative integer to compute binomial coefficients up to.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    # Generate binomial coefficients C(n, 0) to C(n, n)\n    binomial_coeffs = [math.comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of products of consecutive coefficients\n    sum_product = 0\n    for i in range(len(binomial_coeffs) - 1):\n        product = binomial_coeffs[i] * binomial_coeffs[i + 1]\n        sum_product += product\n        print(f\"C({n},{i}) * C({n},{i + 1}) = {binomial_coeffs[i]} * {binomial_coeffs[i + 1]} = {product}\")\n    \n    print(f\"Sum of products: {sum_product}\")\n    return sum_product", "matching_cluster_idx": 7}, {"solution": "def sum_Of_product(n):\n    from math import comb\n    total = 0\n    for k in range(n):\n        total += comb(n, k) * comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The non-negative integer to calculate the sum for.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for k in range(n):\n        product = math.comb(n, k) * math.comb(n, k + 1)\n        total += product\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The non-negative integer to compute the sum for.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for k in range(n):\n        total += math.comb(n, k) * math.comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n    n (int): The binomial coefficient parameter.\n    \n    Returns:\n    int: The sum of the products of consecutive binomial coefficients.\n    \n    Example:\n    >>> sum_Of_product(3)\n    15\n    \"\"\"\n    total = 0\n    for k in range(n):\n        total += math.comb(n, k) * math.comb(n, k + 1)\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    Args:\n        n (int): The non-negative integer to compute the sum for.\n        \n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for k in range(n + 1):\n        # Calculate C(n, k) and C(n, k+1)\n        binom_k = math.comb(n, k)\n        binom_k_plus_1 = math.comb(n, k + 1)\n        total += binom_k * binom_k_plus_1\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    The function computes the sum of C(n, k) * C(n, k+1) for k from 0 to n-1,\n    where C(n, k) is the binomial coefficient \"n choose k\".\n\n    Args:\n        n (int): The non-negative integer to compute the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total = 0\n    for k in range(n):\n        binom_k = math.comb(n, k)\n        binom_k_plus_1 = math.comb(n, k + 1)\n        product = binom_k * binom_k_plus_1\n        total += product\n    return total", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The non-negative integer to calculate the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    return sum(math.comb(n, k) * math.comb(n, k + 1) for k in range(n))", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the products of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The binomial coefficient parameter.\n\n    Returns:\n        int: The sum of the products of consecutive binomial coefficients.\n    \n    Example:\n        sum_Of_product(3) == 15\n    \"\"\"\n    # Generate all binomial coefficients C(n, k) for k from 0 to n\n    binomials = [math.comb(n, k) for k in range(n + 1)]\n    \n    # Calculate the sum of products of consecutive binomial coefficients\n    total = 0\n    for k in range(n):\n        product = binomials[k] * binomials[k + 1]\n        total += product\n    return total", "matching_cluster_idx": 8}, {"solution": "import math\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n\n    Args:\n        n (int): The non-negative integer to calculate the sum for.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    total = 0\n    for k in range(n):\n        binom_k = math.comb(n, k)\n        binom_k1 = math.comb(n, k + 1)\n        product = binom_k * binom_k1\n        total += product\n        # Debug statements (can be commented out or removed in production)\n        # print(f\"k={k}: C({n},{k})={binom_k} * C({n},{k+1})={binom_k1} = {product}\")\n\n    return total", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words, reverse the list of words, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reverse order.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string with spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in the input string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    :param s: A string containing words separated by spaces.\n    :return: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string with spaces\n    reversed_s = ' '.join(reversed_words)\n    return reversed_s", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    :param s: A string containing words separated by spaces.\n    :return: A new string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the order of words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A new string with the words in reversed order.\n    \"\"\"\n    # Split the string into a list of words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into words, reverse the list, and join them back with spaces\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A string with the words in reversed order.\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a single string separated by spaces\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Args:\n        s (str): The input string containing words separated by spaces.\n\n    Returns:\n        str: A new string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string separated by spaces.\n\n    Parameters:\n    s (str): The input string containing words separated by spaces.\n\n    Returns:\n    str: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse the order of words separated by spaces in the given string.\n    \n    Args:\n        s (str): The input string containing words separated by spaces.\n    \n    Returns:\n        str: A string with the order of words reversed.\n    \n    Examples:\n        >>> reverse_words(\"python program\")\n        'program python'\n        >>> reverse_words(\"hello world\")\n        'world hello'\n    \"\"\"\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a string separated by spaces\n    return ' '.join(reversed_words)", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 56.014492753623195, "dps_norm": 56.42857142857143, "pass@1": 98.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based).\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the valid range.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n    \n    Args:\n        lst (list): The original list.\n        k (int): The position of the element to remove (1-based).\n        \n    Returns:\n        list: A new list with the k-th element removed.\n        \n    Raises:\n        IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    # Remove the k-th element by slicing\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k-th element removed.\n    \n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is out of the range of the list indices.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the range of the list indices.\")\n    # Create a new list without the k'th element\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element (1-based index) from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of bounds.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list\")\n    # Convert to 0-based index\n    index = k - 1\n    return lst[:index] + lst[index+1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the list's range.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove (1-based index).\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Example:\n    >>> remove_kth_element([1, 1, 2, 3, 4, 4, 5, 1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the list's bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is out of the list's bounds.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The index k must be an integer.\")\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based indexing).\n\n    Args:\n        lst (list): The original list.\n        k (int): The position of the element to remove (1-based).\n\n    Returns:\n        list: A new list with the k'th element removed.\n\n    Raises:\n        IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n    k is a 1-based index.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list.\")\n    # Remove the k'th element (1-based index)\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list (1-based indexing).\n    \n    Parameters:\n    lst (list): The list from which to remove the element.\n    k (int): The 1-based index of the element to remove.\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of bounds\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based index).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the range of the list indices.\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of range\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list (1-based indexing).\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The position of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the list's bounds.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list.\n\n    Parameters:\n    lst (list): The original list.\n    k (int): The 1-based index of the element to remove.\n\n    Returns:\n    list: A new list with the k'th element removed.\n\n    Raises:\n    IndexError: If k is out of the bounds of the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k is out of the bounds of the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 84.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column.\n\n    Returns:\n    int or float: The maximum value in the n-th column.\n    \"\"\"\n    # Extract the n-th column from each row\n    nth_column = [row[n] for row in matrix]\n    # Return the maximum value from the n-th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column to find the maximum value in.\n    \n    Returns:\n    int or float: The maximum value in the specified column.\n    \n    Raises:\n    IndexError: If the specified column index is out of range.\n    ValueError: If the matrix is empty or contains empty rows.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    max_value = None\n    for row in matrix:\n        if n >= len(row):\n            raise IndexError(f\"Column index {n} is out of range for row {row}.\")\n        if max_value is None or row[n] > max_value:\n            max_value = row[n]\n    \n    if max_value is None:\n        raise ValueError(\"Unable to determine the maximum value.\")\n    \n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the maximum of the n'th column.\n\n    Args:\n        matrix (list of lists): The matrix to process.\n        n (int): The index of the column to find the maximum value in.\n\n    Returns:\n        The maximum value in the specified column.\n\n    Example:\n        >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n        19\n    \"\"\"\n    try:\n        # Extract the nth column from each row\n        column_values = [row[n] for row in matrix]\n        # Return the maximum value in the nth column\n        return max(column_values)\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of range for the given matrix.\")\n    except TypeError:\n        raise ValueError(\"Matrix should be a list of lists with numerical values.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :param n: Index of the column (0-based) to find the maximum value in.\n    :return: The maximum value in the n-th column.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    # Ensure that all rows have the n-th column\n    for row in matrix:\n        if n >= len(row):\n            raise IndexError(f\"Column index {n} is out of bounds for the matrix.\")\n    \n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value from the n-th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column.\n\n    Returns:\n    The maximum value in the n-th column.\n\n    Raises:\n    ValueError: If the matrix is empty or the column index is out of range.\n    TypeError: If the elements of the column are not comparable.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        # Extract the n-th column\n        column = [row[n] for row in matrix]\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of range for the given matrix.\")\n    \n    try:\n        return max(column)\n    except TypeError as e:\n        raise TypeError(\"Elements in the column are not comparable.\") from e", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n    \n    Args:\n        matrix (list of lists): The matrix to process.\n        n (int): The column index to find the maximum in.\n    \n    Returns:\n        The maximum value in the n-th column.\n        \n    Example:\n        max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n    \n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :param n: Zero-based index of the column to find the maximum value in.\n    :return: The maximum value in the nth column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n    \n    Args:\n        matrix (list of lists): The matrix to process.\n        n (int): The column index (0-based).\n        \n    Returns:\n        The maximum value in the n-th column.\n        \n    Raises:\n        ValueError: If the matrix is empty or the column index is out of range.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of range for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix from which to find the maximum.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    int/float: The maximum value in the n-th column.\n\n    Raises:\n    IndexError: If the column index is out of bounds for any row.\n    ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        # Extract the n-th column from each row\n        nth_column = [row[n] for row in matrix]\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of bounds for the given matrix.\")\n    \n    # Return the maximum value in the n-th column\n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column.\n    \n    Returns:\n    The maximum value in the nth column.\n    \"\"\"\n    if not matrix or not isinstance(matrix, list):\n        raise ValueError(\"Matrix must be a non-empty list of lists.\")\n    \n    try:\n        # Extract the nth column\n        nth_column = [row[n] for row in matrix]\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the given matrix.\")\n    \n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The column index (0-based).\n\n    Returns:\n    The maximum value in the nth column.\n\n    Raises:\n    IndexError: If the column index is out of range for the matrix.\n    ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    :param matrix: List of lists where each sublist represents a row in the matrix.\n    :param n: Index of the column (0-based) to find the maximum value.\n    :return: The maximum value in the nth column.\n    :raises ValueError: If the matrix is empty or the column index is out of range.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        # Extract the nth column\n        nth_column = [row[n] for row in matrix]\n    except IndexError:\n        raise ValueError(f\"Column index {n} is out of range for the given matrix.\")\n    \n    return max(nth_column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    max_value: The maximum value in the nth column.\n\n    Raises:\n    IndexError: If 'n' is out of bounds for the matrix columns.\n    ValueError: If the matrix is empty or if any row is shorter than n+1 elements.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n\n    try:\n        column_values = [row[n] for row in matrix]\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the given matrix.\")\n\n    if not column_values:\n        raise ValueError(\"No values found in the specified column.\")\n\n    return max(column_values)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the nth column in a matrix.\n\n    :param matrix: List of lists where each sublist represents a row.\n    :param n: Index of the column (0-based).\n    :return: Maximum value in the nth column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    - matrix: List of lists representing the matrix.\n    - n: The column index (0-based).\n\n    Returns:\n    - The maximum value in the nth column.\n\n    Raises:\n    - IndexError: If the column index is out of range for any row.\n    - ValueError: If the matrix is empty.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(\"Column index out of range.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n-th column of the given matrix.\n\n    Args:\n        matrix (list of lists): The matrix represented as a list of lists.\n        n (int): The index of the column (0-based) to find the maximum value.\n\n    Returns:\n        The maximum value in the n-th column.\n\n    Raises:\n        IndexError: If the matrix is empty or if n is out of range for any row.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n\n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(\"Column index out of range for one or more rows.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    max_value: The maximum value in the nth column.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"The matrix is empty or improperly formatted.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of bounds for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The index of the column (0-based) to find the maximum value in.\n\n    Returns:\n    int/float: The maximum value in the nth column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    - matrix (list of lists): The matrix to search.\n    - n (int): The index of the column.\n\n    Returns:\n    - The maximum value in the nth column.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    try:\n        return max(row[n] for row in matrix)\n    except IndexError:\n        raise IndexError(f\"Column index {n} is out of range for the given matrix.\")", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column of the given matrix.\n\n    Parameters:\n    matrix (list of lists): The matrix to search.\n    n (int): The index of the column.\n\n    Returns:\n    The maximum value in the nth column.\n\n    Raises:\n    ValueError: If the matrix is empty or the column index is out of range.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"The matrix is empty.\")\n    \n    if any(len(row) <= n for row in matrix):\n        raise ValueError(\"Column index out of range.\")\n    \n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 54.097222222222214, "dps_norm": 64.375, "pass@1": 96.0, "profiled": [{"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in a given string.\n    \n    Args:\n        s (str): The input string to be transformed.\n        \n    Returns:\n        str: The transformed string with spaces and underscores swapped.\n    \"\"\"\n    # Create a translation table: space <-> underscore\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Use a temporary placeholder to avoid conflict during replacement\n    placeholder = '\\0'  # Null character as a placeholder assuming it's not in the string\n    s = s.replace(' ', placeholder)    # Replace spaces with placeholder\n    s = s.replace('_', ' ')            # Replace underscores with spaces\n    s = s.replace(placeholder, '_')    # Replace placeholder with underscores\n    return s", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace all whitespace characters with underscores and all underscores with spaces.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isspace():\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the input string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Use a temporary placeholder to avoid conflicts during replacement\n    temp_placeholder = \"#TEMP#\"\n    s = s.replace(' ', temp_placeholder)   # Replace spaces with placeholder\n    s = s.replace('_', ' ')               # Replace underscores with spaces\n    s = s.replace(temp_placeholder, '_')   # Replace placeholder with underscores\n    return s", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if char == ' ' else ' ' if char == '_' else char for char in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Temporary placeholder to avoid collision during replacement\n    temp_placeholder = \"<TEMP_PLACEHOLDER>\"\n    \n    # Replace underscores with the temporary placeholder\n    s = s.replace('_', temp_placeholder)\n    \n    # Replace spaces with underscores\n    s = s.replace(' ', '_')\n    \n    # Replace the temporary placeholder with spaces\n    s = s.replace(temp_placeholder, ' ')\n    \n    return s", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    If the string contains spaces, replace them with underscores.\n    If the string contains underscores, replace them with spaces.\n    If it contains both or neither, handle accordingly.\n    \"\"\"\n    if ' ' in s and '_' in s:\n        # Replace spaces with underscores and underscores with spaces\n        s = s.replace(' ', '_').replace('_', ' ')\n    elif ' ' in s:\n        # Replace spaces with underscores\n        s = s.replace(' ', '_')\n    elif '_' in s:\n        # Replace underscores with spaces\n        s = s.replace('_', ' ')\n    return s", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n        s (str): The input string.\n    \n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    return s.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace spaces with underscores and underscores with spaces in the given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with spaces and underscores swapped.\n    \"\"\"\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('_')\n        elif char == '_':\n            result.append(' ')\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n        s (str): The input string to be transformed.\n        \n    Returns:\n        str: The transformed string with spaces and underscores swapped.\n    \"\"\"\n    translation_table = str.maketrans({' ': '_', '_': ' '})\n    return s.translate(translation_table)", "matching_cluster_idx": 6}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    list: A new list with all zeros moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeros to the end of the list while maintaining the order of non-zero elements.\n\n    Args:\n        nums (list): The input list containing integers.\n\n    Returns:\n        list: The list after moving zeros to the end.\n    \"\"\"\n    # Initialize a pointer for the position of the last non-zero found\n    last_non_zero = 0\n\n    # Iterate through the list\n    for current in range(len(nums)):\n        if nums[current] != 0:\n            # Swap elements\n            nums[last_non_zero], nums[current] = nums[current], nums[last_non_zero]\n            last_non_zero += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros = [0] * (len(lst) - len(non_zero))\n    return non_zero + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: The list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in lst if num != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in the list 'nums' to the end while maintaining the order of non-zero elements.\n\n    :param nums: List of integers\n    :return: A new list with all zeroes moved to the end\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes in the list `nums` to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    nums (list): The list of integers to be rearranged.\n    \n    Returns:\n    list: The rearranged list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = []\n    zero_count = 0\n    \n    # Iterate through the list and separate non-zero elements and count zeroes\n    for num in nums:\n        if num != 0:\n            non_zero.append(num)\n        else:\n            zero_count += 1\n    \n    # Append the counted zeroes at the end of the non-zero elements\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeros moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeros moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes in the list to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    lst (list): The list of integers to be rearranged.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero_elements = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero_elements + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Filter out all non-zero elements\n    non_zero = [num for num in lst if num != 0]\n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    # Append zeroes at the end\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeros in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: A new list with all zeros moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros = [x for x in lst if x == 0]\n    return non_zero + zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeros in the list 'nums' to the end while maintaining the order of non-zero elements.\n    \n    Parameters:\n    nums (list): The list of integers to be rearranged.\n\n    Returns:\n    list: The modified list with all zeros moved to the end.\n    \"\"\"\n    non_zero_index = 0  # Pointer for the position of the next non-zero element\n\n    # Iterate through the list and move non-zero elements forward\n    for num in nums:\n        if num != 0:\n            nums[non_zero_index] = num\n            non_zero_index += 1\n\n    # Fill the remaining positions with zeros\n    for i in range(non_zero_index, len(nums)):\n        nums[i] = 0\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in lst if num != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeroes in the list to the end while maintaining the order of non-zero elements.\n\n    Args:\n        lst (list): The input list containing integers.\n\n    Returns:\n        list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zero_count = lst.count(0)\n    return non_zero + [0] * zero_count", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 75.44715447154472, "dps_norm": 40.0, "pass@1": 64.0, "profiled": [{"solution": "def pair_xor_Sum(nums, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += nums[i] ^ nums[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += nums[i] ^ nums[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs in the given list.\n\n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all possible pairs.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs in the given list.\n\n    :param arr: List of integers\n    :param n: Number of elements in the list\n    :return: Sum of XOR of all possible pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    :param lst: List of integers\n    :param n: Number of elements in the list\n    :return: Sum of XOR of all unique pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs in the list.\n\n    Args:\n    lst (list of int): The list of integers.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The sum of XOR of all pairs.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_value = lst[i] ^ lst[j]\n            total += xor_value\n            print(f\"XOR of {lst[i]} and {lst[j]} is {xor_value}, running total: {total}\")\n    return total", "matching_cluster_idx": -1}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Finds the sum of XOR of all pairs of numbers in the given list.\n\n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all unique pairs.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Function to find the sum of XOR of all pairs in the given list.\n\n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all unique pairs.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Write a python function to find the sum of xor of all pairs of numbers in the given list.\n    assert pair_xor_Sum([5,9,7,6],4) == 47\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    Args:\n    lst (list of int): The list of integers.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The sum of XOR of all unique pairs.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_value = lst[i] ^ lst[j]\n            total += xor_value\n            print(f\"XOR of pair ({lst[i]}, {lst[j]}) = {xor_value}\")\n    return total", "matching_cluster_idx": -1}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    Parameters:\n    lst (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all unique pairs.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    :param lst: List of integers.\n    :param n: Number of elements in the list.\n    :return: Sum of XOR of all unique pairs.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += lst[i] ^ lst[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Function to find the sum of XOR of all pairs in the given list.\n    \n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n    \n    Returns:\n    int: Sum of XOR of all possible pairs.\n    \"\"\"\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_value = arr[i] ^ arr[j]\n            result += xor_value\n            print(f\"XOR of pair ({arr[i]}, {arr[j]}) = {xor_value}\")\n    return result", "matching_cluster_idx": -1}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all unique pairs.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_value = arr[i] ^ arr[j]\n            total += xor_value\n            print(f\"XOR of {arr[i]} and {arr[j]} is {xor_value}\")\n    return total", "matching_cluster_idx": -1}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    Parameters:\n    lst (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all pairs.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += lst[i] ^ lst[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    Parameters:\n    arr (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all unique pairs.\n    \"\"\"\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += arr[i] ^ arr[j]\n    return total", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(lst, n):\n    \"\"\"\n    Calculate the sum of XOR of all unique pairs in the list.\n\n    Args:\n    lst (list): List of integers.\n    n (int): Number of elements in the list.\n\n    Returns:\n    int: Sum of XOR of all unique pairs.\n    \"\"\"\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum_xor += lst[i] ^ lst[j]\n    return sum_xor", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 71.80851063829786, "dps_norm": 73.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The input list to be reversed up to position k.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing the first k elements.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n\n    # Slice the array into two parts: up to k and from k onwards\n    first_part = arr[:k]\n    second_part = arr[k:]\n\n    # Reverse the first part and concatenate with the second part\n    reversed_part = first_part[::-1]\n    return reversed_part + second_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array\")\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position (1-based index).\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list with elements up to position k reversed.\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"Position k must be non-negative.\")\n    # Adjust k to not exceed the list length\n    k = min(k, len(arr))\n    # Reverse the first k elements and concatenate with the rest of the array\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position (1-based index).\n\n    Parameters:\n    arr (list): The input list to be modified.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list with elements up to position k reversed.\n    \"\"\"\n    if k < 1:\n        # If k is less than 1, do not modify the array\n        return arr\n    if k > len(arr):\n        # If k exceeds array length, reverse the entire array\n        k = len(arr)\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to be reversed up to position k.\n    k (int): The position up to which the array should be reversed (1-based index).\n\n    Returns:\n    list: The array with elements up to position k reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length.\")\n    \n    # Convert to 0-based index\n    k_index = k\n    # Reverse the first k elements\n    reversed_part = arr[:k_index][::-1]\n    # Keep the rest of the array unchanged\n    remaining_part = arr[k_index:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The number of elements from the start of the array to reverse.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n    # Adjust k if it's larger than the array length\n    k = min(k, len(arr))\n    # Reverse the first k elements and concatenate with the rest of the array\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to be reversed up to position k.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n\n    Raises:\n    ValueError: If k is not within the valid range.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array.\")\n\n    # Reverse the first k elements\n    reversed_part = arr[:k][::-1]\n    # Combine with the remaining elements\n    return reversed_part + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The list of elements to be reversed up to position k.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \n    Raises:\n    ValueError: If k is negative or exceeds the length of the array.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be a non-negative integer within the array length.\")\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to be reversed up to position k.\n    k (int): The position up to which the array should be reversed (1-based index).\n\n    Returns:\n    list: The array with elements up to position k reversed.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array.\")\n\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array should be reversed (1-based index).\n\n    Returns:\n    list: The modified list with elements reversed up to the k-th position.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise ValueError(\"k must be between 1 and the length of the array\")\n\n    # Slice the array up to k, reverse it, and concatenate with the remaining elements\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which to reverse the array.\n\n    Returns:\n    list: The array with elements up to position k reversed.\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"Position k must be non-negative.\")\n    \n    # Adjust k if it exceeds the array length\n    k = min(k, len(arr))\n    \n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(lst, k):\n    \"\"\"\n    Reverses the first k elements of the list lst.\n\n    Parameters:\n    lst (list): The list to be modified.\n    k (int): The position up to which the list should be reversed.\n\n    Returns:\n    list: The modified list with the first k elements reversed.\n    \"\"\"\n    if k < 0 or k > len(lst):\n        raise ValueError(\"k must be between 0 and the length of the list.\")\n\n    # Reverse the first k elements\n    reversed_part = lst[:k][::-1]\n    # Keep the remaining elements as they are\n    remainder = lst[k:]\n    return reversed_part + remainder", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The number of elements from the start of the array to reverse.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer\")\n    # Ensure k does not exceed the length of the array\n    k = min(k, len(arr))\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list of elements to be reversed.\n    k (int): The position up to which the array needs to be reversed.\n\n    Returns:\n    list: The array after reversing up to the k-th position.\n    \"\"\"\n    if k < 0:\n        raise ValueError(\"k must be a non-negative integer.\")\n    # If k is greater than the length of the array, reverse the entire array\n    k = min(k, len(arr))\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to reverse.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements up to k reversed.\n    \"\"\"\n    if k > len(arr) or k < 1:\n        raise ValueError(\"k must be between 1 and the length of the array\")\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the k-th position.\n\n    Parameters:\n    arr (list): The input array to be modified.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified array with the first k elements reversed.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"The first argument must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"The second argument must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array.\")\n\n    # Reverse the first k elements and concatenate with the remaining elements\n    reversed_part = arr[:k][::-1]\n    remaining_part = arr[k:]\n    return reversed_part + remaining_part", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n\n    Parameters:\n    arr (list): The list of elements to be reversed up to position k.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed and the rest unchanged.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be within the range of the array length\")\n    # Reverse the first k elements and concatenate with the remaining elements\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The list of elements to be reversed up to position k.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified list with the first k elements reversed.\n    \"\"\"\n    if not isinstance(arr, list):\n        raise TypeError(\"Input must be a list.\")\n    if not isinstance(k, int):\n        raise TypeError(\"Position k must be an integer.\")\n    if k < 0 or k > len(arr):\n        raise ValueError(\"Position k is out of bounds.\")\n\n    # Reverse the first k elements and concatenate with the rest of the list\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the array up to the k-th position.\n\n    Parameters:\n    arr (list): The list to reverse.\n    k (int): The position up to which to reverse the array.\n\n    Returns:\n    list: The modified list with elements up to k reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The number of elements to reverse.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k < 0 or k > len(arr):\n        raise ValueError(\"k must be between 0 and the length of the array\")\n    return arr[:k][::-1] + arr[k:]", "matching_cluster_idx": 10}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n\n    Args:\n        tup (tuple): The original tuple.\n        dict_to_add (dict): The dictionary to add.\n\n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dict_to_add, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns a new tuple.\n\n    Parameters:\n    input_tuple (tuple): The original tuple.\n    input_dict (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return input_tuple + (input_dict, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added as the last element.\n    \"\"\"\n    return tup + (dct, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the new tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Add a dictionary to a tuple and return the new tuple.\n\n    Args:\n        tup (tuple): The original tuple.\n        dct (dict): The dictionary to add.\n\n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the tuple and returns a new tuple.\n    \n    Parameters:\n        tup (tuple): The original tuple.\n        dct (dict): The dictionary to add to the tuple.\n    \n    Returns:\n        tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n        original_tuple (tuple): The original tuple.\n        new_dict (dict): The dictionary to add.\n\n    Returns:\n        tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    original_tuple (tuple): The original tuple.\n    new_dict (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    if not isinstance(original_tuple, tuple):\n        raise TypeError(\"First argument must be a tuple.\")\n    if not isinstance(new_dict, dict):\n        raise TypeError(\"Second argument must be a dictionary.\")\n    \n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    \n    Parameters:\n    original_tuple (tuple): The original tuple.\n    new_dict (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    # Create a new tuple by concatenating the original tuple with a new tuple containing the dictionary\n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the given tuple and returns the new tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple containing all elements of the original tuple plus the dictionary.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tpl + (dct, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns a new tuple.\n\n    :param tup: The original tuple.\n    :param dictionary: The dictionary to add to the tuple.\n    :return: A new tuple containing the original elements and the dictionary.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"First argument must be a tuple.\")\n    if not isinstance(dictionary, dict):\n        raise TypeError(\"Second argument must be a dictionary.\")\n    \n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the new tuple.\n\n    Parameters:\n    tpl (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tpl + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to a tuple and returns a new tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to add.\n    \n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dct (dict): The dictionary to be added.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dct, )", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(original_tuple, new_dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    original_tuple (tuple): The original tuple.\n    new_dict (dict): The dictionary to add.\n\n    Returns:\n    tuple: A new tuple with the dictionary added.\n    \"\"\"\n    return original_tuple + (new_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 54.86338797814207, "dps_norm": 66.25, "pass@1": 96.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all values enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    # Use a regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expressions to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all content within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extract all substrings enclosed in double quotes from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of substrings found between double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Parameters:\n    s (str): The input string containing quoted substrings.\n\n    Returns:\n    list: A list of substrings found between double quotation marks.\n    \"\"\"\n    # Use regex to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expressions to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n    \n    Args:\n        s (str): The input string containing quoted substrings.\n        \n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the given string.\n\n    Parameters:\n        s (str): The input string.\n\n    Returns:\n        List[str]: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expressions to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n\n    Args:\n        text (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(text):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given text.\n\n    Args:\n        text (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of extracted substrings without the quotation marks.\n    \"\"\"\n    # Use regular expression to find all matches between double quotes\n    return re.findall(r'\"(.*?)\"', text)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expression to find all occurrences within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed within double quotation marks.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        list: A list of extracted substrings.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found between double quotes.\n    \"\"\"\n    pattern = r'\"(.*?)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the input string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        list: A list of substrings found within double quotes.\n    \"\"\"\n    # Use regular expression to find all occurrences between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotation marks from the given string.\n\n    Args:\n        s (str): The input string containing quoted substrings.\n\n    Returns:\n        List[str]: A list of substrings found between double quotes.\n    \"\"\"\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts all substrings enclosed in double quotes from the given string.\n    \n    Parameters:\n    s (str): The input string containing quoted substrings.\n    \n    Returns:\n    list: A list of substrings found between double quotes.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 16.2015503875969, "dps_norm": 47.0, "pass@1": 96.0, "profiled": [{"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to be processed.\n    \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to substitute spaces, commas, or dots with ':'\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to process.\n        \n    Returns:\n        str: The processed string with specified characters replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, or dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, or dots with colon\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n    s (str): The input string containing spaces, commas, or dots.\n    \n    Returns:\n    str: The modified string with specified characters replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, or dots with ':'\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the string with a colon.\n    \n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace space, comma, or dot with colon\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, and dots with colon\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all spaces, commas, and dots in the input string with colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, and dots with ':'\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with specified characters replaced by colons.\n    \"\"\"\n    # Use regular expression to substitute spaces, commas, and dots with colons\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the string with a colon.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The modified string with spaces, commas, or dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to process.\n    \n    Returns:\n        str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, or dots with ':'\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to process.\n        \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replaces all spaces, commas, and dots in the input string with colons.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to replace\n    characters_to_replace = {' ', ',', '.'}\n    \n    # Replace each character if it's in the set\n    return ''.join([':' if char in characters_to_replace else char for char in s])", "matching_cluster_idx": 5}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replaces all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string to be modified.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string.\n        \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Use regular expression to replace spaces, commas, and dots with colon\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, and dots in the string with a colon.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n    \n    Args:\n        s (str): The input string to be processed.\n        \n    Returns:\n        str: The modified string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', s)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all spaces, commas, or dots in the input string with a colon.\n\n    Args:\n        s (str): The input string to process.\n\n    Returns:\n        str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    # Define the characters to replace\n    special_chars = [' ', ',', '.']\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        s = s.replace(char, ':')\n    \n    return s", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 88.54545454545455, "dps_norm": 76.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        t (tuple): The input tuple with an even number of elements.\n        \n    Returns:\n        dict: A dictionary constructed from the tuple.\n        \n    Raises:\n        ValueError: If the tuple does not contain an even number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        input_tuple (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from adjacent key-value pairs.\n\n    Raises:\n        ValueError: If the input tuple has an odd number of elements.\n    \"\"\"\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key-value pairs.\n\n    Parameters:\n    t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    it = iter(t)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    it = iter(t)\n    return dict(zip(it, it))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n        \n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t: tuple) -> dict:\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The tuple to convert. It should contain an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \n    Example:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: Tuple containing an even number of elements.\n    :return: Dictionary with adjacent elements as key-value pairs.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        tup (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple's adjacent elements.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from adjacent pairs in the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple's adjacent elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple contains an odd number of elements, cannot form key-value pairs.\")\n    \n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements.\n    \n    Args:\n        t (tuple): A tuple containing an even number of elements.\n        \n    Returns:\n        dict: A dictionary with keys and values derived from the tuple's adjacent elements.\n        \n    Raises:\n        ValueError: If the tuple contains an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n    \n    Args:\n        t (tuple): The input tuple with an even number of elements.\n        \n    Returns:\n        dict: A dictionary mapping each key to its corresponding value.\n        \n    Raises:\n        ValueError: If the tuple contains an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary mapping keys to values from the tuple.\n\n    Raises:\n        ValueError: If the tuple has an odd number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple contains an odd number of elements.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n\n    Raises:\n        ValueError: If the tuple does not contain an even number of elements.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n\n    Parameters:\n    t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n    dict: A dictionary with keys and values from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements.\")\n    \n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple into a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        t (tuple): The input tuple with an even number of elements.\n\n    Returns:\n        dict: A dictionary constructed from the tuple.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must contain an even number of elements.\")\n    \n    return dict(zip(t[::2], t[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 60.54794520547945, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to check.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the tuple contains any None value.\n\n    :param tup: Tuple to check\n    :return: True if any element is None, else False\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tpl (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple contains any None values.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        tpl (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, otherwise False.\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Checks if the given tuple has any None value.\n\n    Args:\n        tpl (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(item is None for item in tpl)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is present in the tuple, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Parameters:\n    input_tuple (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if any element is None, False otherwise.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None values.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Checks if the given tuple contains any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if any element is None, False otherwise.\n    \"\"\"\n    return any(element is None for element in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Args:\n        input_tuple (tuple): The tuple to check.\n\n    Returns:\n        bool: True if None is found in the tuple, otherwise False.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple contains any None value.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n\n    Returns:\n    bool: True if None is present, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 52.38095238095238, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the list and returns the new list.\n    \n    :param lst: List to which elements will be added\n    :param tpl: Tuple containing elements to add\n    :return: New list with tuple elements appended\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Args:\n        lst (list): The list to which the tuple will be added.\n        tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n        list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple whose elements are to be added to the list.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the tuple to the end of the list.\n\n    Parameters:\n    lst (list): The list to which elements will be added.\n    tup (tuple): The tuple containing elements to add.\n\n    Returns:\n    list: The resulting list after adding the tuple elements.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple `tpl` to the end of the list `lst`.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list containing the elements of `lst` followed by the elements of `tpl`.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Args:\n        lst (list): The list to which the tuple elements will be added.\n        tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n        list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: The combined list after adding the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the end of the list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The updated list with tuple elements added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: A new list containing elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The combined list with tuple elements appended.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: The updated list with tuple elements added.\n    \"\"\"\n    # Convert the tuple to a list and concatenate\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the end of the list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: The combined list.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple `tpl` to the end of the list `lst`.\n    \n    Parameters:\n    lst (list): The list to which elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n    \n    Returns:\n    list: A new list containing elements from `lst` followed by elements from `tpl`.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tpl (tuple): The tuple containing elements to add to the list.\n\n    Returns:\n    list: A new list containing the elements of lst followed by the elements of tpl.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the end of the list.\n\n    Parameters:\n    lst (list): The list to which the tuple will be added.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: A new list containing the elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds elements of a tuple to a list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The new list with tuple elements added.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of a tuple to the end of a list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: A new list containing elements of the original list followed by the tuple elements.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the tuple to the list.\n\n    Parameters:\n    lst (list): The original list.\n    tup (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The updated list with tuple elements added.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Adds the elements of the tuple to the end of the list.\n\n    Parameters:\n    lst (list): The original list.\n    tpl (tuple): The tuple to add to the list.\n\n    Returns:\n    list: The combined list.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 68.0, "profiled": [{"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from the list based on the second element of each tuple.\n    \n    Parameters:\n    records (list of tuples): List containing tuples with a name and a numerical value.\n    k (int): Number of minimum records to return.\n    \n    Returns:\n    list of tuples: The k tuples with the smallest numerical values.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list of tuples): The list of records where each record is a tuple.\n        k (int): The number of minimum records to retrieve.\n\n    Returns:\n        list of tuples: The list containing the k records with the smallest second elements.\n\n    Test Cases:\n    >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n    [('Akash', 2), ('Akshat', 4)]\n    >>> min_k([('Alice', 5), ('Bob', 3), ('Charlie', 9)], 1)\n    [('Bob', 3)]\n    >>> min_k([], 3)\n    []\n    >>> min_k([('Dave', 7)], 2)\n    [('Dave', 7)]\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda record: record[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element.\n\n    Parameters:\n    records (list of tuples): The list of tuples to evaluate.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the k tuples with the smallest second elements, sorted in ascending order.\n\n    Parameters:\n    tuple_list (list of tuples): A list where each tuple contains a name and a numeric value.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Write a function to find minimum k records from tuple list.  - in this case a verbatim copy of test cases\n    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from the list based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): List where each tuple contains (name, value).\n    k (int): Number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest values.\n    \"\"\"\n    # Sort the records based on the second element of each tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from the list based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): The list of tuples to process.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from the list of tuples based on the second element of each tuple.\n    \n    Parameters:\n    records (list of tuples): A list where each tuple contains a name and a numerical value.\n    k (int): The number of minimum records to return.\n    \n    Returns:\n    list of tuples: The k tuples with the smallest numerical values, sorted in ascending order.\n    \"\"\"\n    # Sort the records based on the numerical value (second element of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): The list of records where each record is a tuple.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The list containing the k records with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list of tuples): List of tuples where each tuple contains (name, value).\n        k (int): Number of minimum records to return.\n\n    Returns:\n        list of tuples: The k tuples with the smallest second element.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): The list of tuples to evaluate.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param records: List of tuples where each tuple contains a name and a numeric value.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest numeric values.\n    \"\"\"\n    # Sort the records based on the second element of each tuple (numeric value)\n    sorted_records = sorted(records, key=lambda record: record[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Returns the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): The list of tuples to process.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Write a function to find minimum k records from tuple list.\n    \n    Test case:\n    assert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list of tuples): The list of tuples to process. Each tuple should contain a name and a numeric value.\n        k (int): The number of minimum records to return.\n\n    Returns:\n        list of tuples: A list containing the k tuples with the smallest second elements.\n\n    Example:\n        >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n        [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda record: record[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): A list where each tuple contains a name and a numerical value.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest numerical values, sorted in ascending order.\n    \"\"\"\n    # Sort the records based on the second element of each tuple (the numerical value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list of tuples): The list of records where each record is a tuple.\n        k (int): The number of minimum records to retrieve.\n\n    Returns:\n        list of tuples: The list containing the minimum k records.\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    \"\"\"\n    Returns the minimum k records from the tuple list based on the second element of each tuple.\n\n    Parameters:\n    tuple_list (list of tuples): The list containing tuples with at least two elements.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The list containing the k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Args:\n        records (list of tuples): A list where each tuple contains a name and a numerical value.\n        k (int): The number of minimum records to return.\n\n    Returns:\n        list of tuples: The k tuples with the smallest second elements, sorted in ascending order.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    records (list of tuples): The list containing tuples with at least two elements.\n    k (int): The number of minimum records to return.\n\n    Returns:\n    list of tuples: The k tuples with the smallest second elements, sorted in ascending order.\n    \"\"\"\n    # Sort the records based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 92.75862068965517, "dps_norm": 91.25, "pass@1": 92.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that appear in all three lists at the same index.\n\n    Parameters:\n    l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n    list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3: Lists of elements to compare.\n    \n    Returns:\n    A list containing elements that are the same in all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements across three lists at the same index.\n\n    Args:\n        l1 (list): The first list.\n        l2 (list): The second list.\n        l3 (list): The third list.\n\n    Returns:\n        list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Parameters:\n    l1, l2, l3 (list): Three input lists.\n\n    Returns:\n    list: A list of elements common to all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \n    Example:\n    >>> extract_index_list([1, 1, 3, 4, 5, 6, 7],\n    ...                    [0, 1, 2, 3, 4, 5, 7],\n    ...                    [0, 1, 2, 3, 4, 5, 7])\n    [1, 7]\n    \"\"\"\n    common_elements = []\n    # Iterate up to the minimum length to handle lists of different lengths\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common_elements.append(a)\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that appear at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of common elements appearing at the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    # Iterate over the indices and elements of all three lists simultaneously\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common_elements.append(a)\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of elements common to all three lists at the same indices.\n    \"\"\"\n    common_elements = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common_elements.append(a)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of common elements appearing at the same index in all three lists.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through each index up to the minimum length\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n    list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    common_elements = []\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of elements common to all three lists at the same index.\n    \"\"\"\n    # Determine the minimum length to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Use list comprehension to collect common elements\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Returns a list of elements that are common to l1, l2, and l3 at the same index.\n    \n    Parameters:\n    l1 (list): First list.\n    l2 (list): Second list.\n    l3 (list): Third list.\n    \n    Returns:\n    list: List of common elements at the same indices.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index in all three lists.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of common elements appearing at the same indices in all three lists.\n    \"\"\"\n    # Use zip to iterate over the three lists simultaneously\n    common_elements = [x for x, y, z in zip(l1, l2, l3) if x == y == z]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of elements common to all three lists at the same index.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of common elements appearing at the same index in all three lists.\n    \"\"\"\n    # Use zip to iterate over all three lists concurrently\n    common_elements = [a for a, b, c in zip(l1, l2, l3) if a == b == c]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same indices.\n\n    Parameters:\n    l1, l2, l3 (list): Three lists to compare.\n\n    Returns:\n    list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    # Use list comprehension with zip to iterate over all three lists simultaneously\n    common_elements = [a for a, b, c in zip(l1, l2, l3) if a == b == c]\n    return common_elements", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of common elements appearing at the same index in all three lists.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n\n    # Iterate through each index up to the minimum length\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find elements that are common to all three lists at the same index.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of elements that are common to all three lists at the same index.\n    \"\"\"\n    common_elements = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            common_elements.append(a)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements from three lists that appear at the same index in all lists.\n\n    Args:\n        l1 (list): First list of elements.\n        l2 (list): Second list of elements.\n        l3 (list): Third list of elements.\n\n    Returns:\n        list: A list of common elements found at the same indices in all three lists.\n    \"\"\"\n    # Use zip to iterate over the elements of all three lists simultaneously\n    return [x for x, y, z in zip(l1, l2, l3) if x == y == z]", "matching_cluster_idx": 7}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds elements that are common to all three lists at the same index.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of elements that appear in all three lists at the same index.\n    \"\"\"\n    min_length = min(len(l1), len(l2), len(l3))\n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Finds common elements in three lists that are the same at the same indices.\n\n    Parameters:\n    l1 (list): First list of elements.\n    l2 (list): Second list of elements.\n    l3 (list): Third list of elements.\n\n    Returns:\n    list: A list of elements common to all three lists at the same indices.\n    \"\"\"\n    # Determine the minimum length among the three lists to avoid IndexError\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    common_elements = []\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/758": {"dps": 73.29150579150578, "dps_norm": 78.75, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Converts each sublist to a tuple to use as a dictionary key.\n\n    Args:\n        lst (List[List[Any]]): A list of lists to be counted.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with tuple keys and their counts.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        t = tuple(sublist)\n        counts[t] = counts.get(t, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    Each sublist is converted to a tuple to be used as a dictionary key.\n    \n    Args:\n        lst (list of lists): The list containing sublists to count.\n        \n    Returns:\n        dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    \n    Args:\n        lst (list of lists): The input list containing sublists.\n        \n    Returns:\n        dict: A dictionary with each sublist converted to a tuple as keys and their counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in counts:\n            counts[key] += 1\n        else:\n            counts[key] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    \n    Args:\n        lst (list of lists): The input list containing sublists.\n    \n    Returns:\n        dict: A dictionary with each sublist converted to a tuple as keys and their counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        tup = tuple(sublist)\n        if tup in counts:\n            counts[tup] += 1\n        else:\n            counts[tup] = 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        count_dict[key] = count_dict.get(key, 0) + 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n    Converts each sublist to a tuple to use as a dictionary key.\n\n    Args:\n        lst (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    count = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in count:\n            count[key] += 1\n        else:\n            count[key] = 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Each sublist is converted to a tuple to be used as a dictionary key.\n\n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n        dict: A dictionary with tupleified sublists as keys and their counts as values.\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in count_dict:\n            count_dict[key] += 1\n        else:\n            count_dict[key] = 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Converts each sublist to a tuple to use as a dictionary key.\n\n    Args:\n        lst (list of lists): The list containing sublists to count.\n\n    Returns:\n        dict: A dictionary with tuple keys representing the sublists and \n              integer values representing their counts.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    \"\"\"\n    Count occurrences of sublists in a list.\n\n    Args:\n        list_of_lists (list of lists): The input list containing sublists.\n\n    Returns:\n        dict: A dictionary where each key is a tuple representing a sublist,\n              and the value is the number of times that sublist appears in the input.\n    \"\"\"\n    # Convert each sublist to a tuple to make them hashable\n    tuple_sublists = map(tuple, list_of_lists)\n    \n    # Use Counter to count the occurrences of each tuple\n    counts = Counter(tuple_sublists)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n    Converts each sublist to a tuple to use as dictionary keys.\n\n    Args:\n        lst (List[List[Any]]): A list containing sublists.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary mapping each unique tuple to its count.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    \n    Args:\n        lst (List[List[Any]]): A list of lists.\n        \n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with each unique sublist converted to a tuple as keys\n                                     and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n    Converts each sublist to a tuple to use as dictionary keys.\n\n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n        dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in counts:\n            counts[key] += 1\n        else:\n            counts[key] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count the occurrences of each sublist within a list.\n    \n    Args:\n        lst (List[List[Any]]): A list of lists to be counted.\n        \n    Returns:\n        Dict[Tuple, int]: A dictionary where each key is a tuple converted from a sublist,\n                          and the value is the number of times it appears in the original list.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Each sublist is converted to a tuple to be used as a dictionary key.\n\n    Parameters:\n    lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n    dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n    Each sublist is converted to a tuple to be used as a dictionary key.\n\n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n        dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    result = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in result:\n            result[key] += 1\n        else:\n            result[key] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n    Converts each sublist to a tuple to use as dictionary keys.\n\n    Args:\n        lst (list of lists): The list containing sublists to count.\n\n    Returns:\n        dict: A dictionary with tuples as keys and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the provided list.\n    Each sublist is converted to a tuple to make it hashable for dictionary keys.\n\n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n        dict: A dictionary with tuple representations of the sublists as keys and their counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in counts:\n            counts[key] += 1\n        else:\n            counts[key] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list.\n\n    Args:\n        lst (List[List[Any]]): A list of lists to be counted.\n\n    Returns:\n        Dict[Tuple[Any, ...], int]: A dictionary with each sublist converted to a tuple as keys,\n                                    and their occurrence counts as values.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within a list of lists.\n\n    Args:\n        lst (list of lists): The list containing sublists to count.\n\n    Returns:\n        dict: A dictionary where each key is a tuple converted from a sublist,\n              and the value is the number of its occurrences.\n    \"\"\"\n    # Convert each sublist to a tuple to make them hashable\n    tuple_sublists = [tuple(sublist) for sublist in lst]\n    \n    # Use Counter to count occurrences of each tuple\n    counts = Counter(tuple_sublists)\n    \n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist within the given list.\n\n    Args:\n        lst (list of lists): The list containing sublists to be counted.\n\n    Returns:\n        dict: A dictionary where each key is a tuple converted from a sublist,\n              and the value is the number of times that sublist appears in the original list.\n    \"\"\"\n    counts = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        counts[key] = counts.get(key, 0) + 1\n    return counts", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": 59.416058394160586, "dps_norm": 80.0, "pass@1": 98.0, "profiled": [{"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n    \n    Args:\n        lst (list): List of numbers.\n        \n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    # An empty list does not contain any elements, hence return False\n    if not lst:\n        return False\n\n    # Use a set to identify unique elements\n    unique_elements = set(lst)\n    \n    # If the set has only one element, return True\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1 if lst else False", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list contains only one distinct element.\n\n    Args:\n        lst (list): The list of numbers to check.\n\n    Returns:\n        bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        # An empty list does not contain any elements, hence not unique\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n\n    Args:\n        lst (list): The list of numbers to check.\n\n    Returns:\n        bool: True if only one distinct element exists, else False.\n    \"\"\"\n    if not lst:\n        # Depending on the requirement, an empty list can be considered as not having any elements\n        return False\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Args:\n    lst (list): List of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        # Assuming an empty list does not contain any elements\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Checks if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same or the list is non-empty with one distinct element, False otherwise.\n    \"\"\"\n    if not lst:\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Define behavior for empty list\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are identical.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:  # Handle empty list\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    # An empty list does not have distinct elements\n    if not lst:\n        return False\n    # Use a set to identify unique elements\n    unique_elements = set(lst)\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    :param lst: List of numbers.\n    :return: True if all elements are identical, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list contains only one distinct element.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same or the list is empty, False otherwise.\n    \"\"\"\n    if not lst:\n        return True  # Considering an empty list as having only one distinct element\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if the list contains only one distinct element.\n\n    Args:\n        lst (list): The list of elements to check.\n\n    Returns:\n        bool: True if only one distinct element exists, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if all elements are identical, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming empty list does not contain any elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check if all elements in the list are the same.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if only one distinct element exists, False otherwise.\n    \"\"\"\n    if not lst:\n        return False  # Assuming an empty list does not contain any elements\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether the list contains only one distinct element.\n\n    Args:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if all elements are the same, False otherwise.\n    \"\"\"\n    if not lst:\n        # Assuming an empty list does not contain any elements\n        return False\n    first_element = lst[0]\n    for element in lst:\n        if element != first_element:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digit characters in the input string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    input_string (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be analyzed.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be processed.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        input_string (str): The string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to be examined.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        input_string (str): The string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    count = 0\n    for char in input_string:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Args:\n        s (str): The input string to be evaluated.\n\n    Returns:\n        int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digit characters in the given string.\n\n    Parameters:\n    s (str): The string to be evaluated.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(1 for c in s if c.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in the given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: The count of digit characters in the string.\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 78.83177570093459, "dps_norm": 75.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Parameters:\n    lst (list): The input list from which pairs are to be formed.\n    \n    Returns:\n    list of tuples: A list where each tuple contains a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst (list): The input list.\n        \n    Returns:\n        list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: A list containing tuples of consecutive pairs.\n    \n    Example:\n        >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Example:\n    >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n    [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \n    Args:\n        lst (list): The input list from which to form pairs.\n    \n    Returns:\n        list of tuples: A list containing tuples of consecutive items.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \n    Parameters:\n    lst (list): The input list of items.\n\n    Returns:\n    list of tuples: Each tuple contains a pair of consecutive items.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    lst (list): The input list from which to generate pairs.\n\n    Returns:\n    list of tuples: A list containing tuples of consecutive elements.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n\n    Parameters:\n    lst (list): The input list from which to form consecutive pairs.\n\n    Returns:\n    list of tuples: A list containing tuples of consecutive elements.\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of tuples, each containing a pair of consecutive items from the input list.\n    \n    Parameters:\n    lst (list): The list from which to create consecutive pairs.\n\n    Returns:\n    list: A list of tuples with each tuple containing two consecutive elements from lst.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}]}, "Mbpp/775": {"dps": 92.96, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at odd indices in the list is an odd number.\n\n    Args:\n        lst (list): The list of integers to check.\n\n    Returns:\n        bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    return all(num % 2 != 0 for i, num in enumerate(lst) if i % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n    \n    Parameters:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    lst (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1 with a step of 2\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Parameters:\n    nums (list): The list of integers to check.\n\n    Returns:\n    bool: True if every odd index has an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1, stepping by 2 to get odd indices\n    for index in range(1, len(nums), 2):\n        if nums[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Args:\n        lst (list): The list of integers to check.\n\n    Returns:\n        bool: True if every odd index has an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Args:\n        lst (list): The list of integers to check.\n\n    Returns:\n        bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1, stepping by 2 to get odd indices\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if every odd-indexed element is odd, False otherwise.\n    \"\"\"\n    # Iterate through odd indices starting from 1\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at odd indices in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of numbers to check.\n\n    Returns:\n    bool: True if every element at odd indices is odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at odd indices in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1 with a step of 2 (odd indices)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every element at odd indices in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1 with a step of 2 (odd indices)\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd numbers, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1, stepping by 2 to access odd indices\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Args:\n        lst (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index in the list contains an odd number.\n\n    Args:\n        lst (list of int): The list of integers to check.\n\n    Returns:\n        bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at odd indices in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if every element at odd indices is odd, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1 with a step of 2 (odd indices)\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at odd indices in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n    \n    Parameters:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    # Iterate over the list starting from index 1, stepping by 2 to get odd indices\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list of int): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd, False otherwise.\n    \"\"\"\n    for index in range(1, len(lst), 2):\n        if lst[index] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every element at an odd index in the list is an odd number.\n\n    Parameters:\n    lst (list): The list of integers to check.\n\n    Returns:\n    bool: True if all elements at odd indices are odd numbers, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 84.0, "profiled": [{"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (non-repeated) elements in the given list.\n    \n    Args:\n    lst (list): The list of integers to process.\n    \n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique (non-repeated) elements in the list.\n    \n    Parameters:\n    lst (list): The input list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    int: Sum of unique elements in the list.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (non-repeated) elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Find the sum of non-repeated (distinct) elements in the given list.\n    \n    Args:\n    lst (list): The input list of integers.\n    \n    Returns:\n    int: Sum of distinct elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Args:\n        lst (list): The list of integers to process.\n\n    Returns:\n        int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Find the sum of non-repeated elements in the list.\n    Non-repeated elements are the unique elements in the list.\n    \n    Args:\n        lst (list): The input list of integers.\n    \n    Returns:\n        int: The sum of unique elements in the list.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (non-repeated) elements in the given list.\n\n    Parameters:\n    lst (list): The list of integers.\n\n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Find the sum of unique elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique elements in the given list.\n    Each element is counted only once, regardless of how many times it appears.\n    \n    Args:\n        lst (list): The list of integers.\n        \n    Returns:\n        int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (non-repeated) elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique (non-repeated) elements in the list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n\n    Args:\n        lst (list): The list of integers.\n\n    Returns:\n        int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: Sum of unique elements.\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n    \n    Args:\n    lst (list): The list of integers.\n    \n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of unique (non-repeated) elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers to process.\n    \n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n    \n    Parameters:\n    lst (list): The list of integers to process.\n    \n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Returns the sum of unique (non-repeated) elements in the list.\n    \n    Parameters:\n    lst (list): The input list containing integers.\n\n    Returns:\n    int: Sum of non-repeated elements.\n    \"\"\"\n    unique_elements = set(lst)\n    total = sum(unique_elements)\n    return total", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    Finds the sum of non-repeated (unique) elements in the given list.\n    \n    Args:\n    lst (list): The list of integers to evaluate.\n\n    Returns:\n    int: The sum of unique elements.\n    \"\"\"\n    unique_elements = set(lst)\n    return sum(unique_elements)", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 91.18110236220473, "dps_norm": 81.0, "pass@1": 96.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of n is even.\n\n    Parameters:\n    n (int): The number to evaluate.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"Check whether the count of divisors of n is even.\"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the count of divisors of n is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n    \n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "import math\ndef count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    sqrt_n = math.isqrt(n)\n    # If n is a perfect square, it has an odd number of divisors\n    return sqrt_n * sqrt_n != n", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if sqrt_n * sqrt_n == n:\n        count -=1  # Correct the count if n is a perfect square\n    \n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, False otherwise.\n    \n    Parameters:\n    n (int): The integer to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1  # Perfect square\n            else:\n                count += 2  # Divisor pair\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Returns True if the number of divisors of n is even, False otherwise.\n    \"\"\"\n    count = 0\n    sqrt_n = int(n**0.5)\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only once\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n    \n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2  # i and n//i\n\n    if sqrt_n * sqrt_n == n:\n        count -= 1  # Correct the count if n is a perfect square\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    from math import isqrt\n\n    count = 0\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:\n            count += 2  # i and n//i are both divisors\n    if isqrt(n) ** 2 == n:\n        count -= 1  # Correct the count if n is a perfect square\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors of n is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of positive divisors of n is even.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number of divisors is even, False otherwise.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    count = 0\n    sqrt_n = int(n**0.5)\n\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n\n    return count % 2 == 0", "matching_cluster_idx": 3}]}, "Mbpp/800": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    # Initialize with the first list\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n    \n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Args:\n        list_of_lists (List[List[int]]): A list of lists containing integers.\n        \n    Returns:\n        List[int]: The sublist with the highest sum of its elements.\n        \n    Example:\n        >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n        [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    # Initialize with the first sublist\n    max_sublist = list_of_lists[0]\n    max_sum = sum(max_sublist)\n    \n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sublist = sublist\n    \n    return max_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum. If the input is empty, returns an empty list.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Args:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Initialize with the first sublist\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n\n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Args:\n        list_of_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n        List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    # Initialize with the first sublist\n    max_sum_sublist = list_of_lists[0]\n    max_sum = sum(max_sum_sublist)\n    \n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sum_sublist = sublist\n    \n    return max_sum_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    # Initialize with the first list\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n    \n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum.\n\n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The input list_of_lists is empty.\")\n    \n    # Initialize with the first sublist\n    max_sum = sum(list_of_lists[0])\n    max_list = list_of_lists[0]\n    \n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    :param list_of_lists: List[List[int]]\n    :return: List[int]\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"The list of lists is empty.\")\n    \n    # Use the max function with sum as the key to find the sublist with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the maximum sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Args:\n        list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n        List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Initialize with the first sublist\n    max_sublist = list_of_lists[0]\n    max_sum = sum(max_sublist)\n\n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_sublist = sublist\n\n    return max_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (list of lists of int): The list containing sublists of integers.\n\n    Returns:\n    list: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Args:\n        list_of_lists (list of lists): A list containing sublists of numbers.\n\n    Returns:\n        list: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Use the max function with sum as the key to find the sublist with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n    \n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n    \n    Returns:\n    List[int]: The sublist with the highest sum of its elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of its elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Use the built-in max function with sum as the key to find the sublist with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    # Initialize with the first sublist\n    max_list = list_of_lists[0]\n    max_sum = sum(max_list)\n    \n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements from a list of lists.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Use the max function with sum as the key to find the sublist with the highest sum\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the sublist with the highest sum of elements.\n\n    Parameters:\n    list_of_lists (List[List[int]]): A list containing multiple lists of integers.\n\n    Returns:\n    List[int]: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return []\n\n    # Initialize with the first sublist\n    max_sum = sum(list_of_lists[0])\n    max_list = list_of_lists[0]\n\n    # Iterate through the list of lists to find the sublist with the maximum sum\n    for sublist in list_of_lists[1:]:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple 'tup' contains the element 'k'.\n\n    Parameters:\n    tup (tuple): The tuple to check.\n    k (any): The element to look for in the tuple.\n\n    Returns:\n    bool: True if 'k' is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the value k is present in the given tuple.\n\n    Parameters:\n    tuples (tuple): The tuple to search within.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the integer k is present in the tuple tup.\n\n    Args:\n        tup (tuple): A tuple of integers.\n        k (int): The integer to check for in the tuple.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the given tuple contains the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to search within.\n    k: The element to search for.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the given key 'k' is present in the tuple.\n\n    Parameters:\n    tuples (tuple): The tuple to search within.\n    k (any): The key to search for.\n\n    Returns:\n    bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the integer k is present in the tuple tup.\n\n    Args:\n        tup (tuple): A tuple of integers.\n        k (int): The integer to check for in the tuple.\n\n    Returns:\n        bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to search.\n    k (any): The element to find in the tuple.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the integer k is present in the given tuple.\n\n    Parameters:\n    tuples (tuple): A tuple of integers.\n    k (int): The integer to check for.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to search in.\n    k (int): The element to search for.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the value k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Args:\n        tuples (tuple): The tuple to search.\n        k: The element to find in the tuple.\n\n    Returns:\n        bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    Args:\n    tup (tuple): The tuple to search.\n    k (any): The element to find.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the value k is present in the given tuple.\n\n    Parameters:\n    tuples (tuple): The tuple to search within.\n    k: The value to search for.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Checks if the value k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search.\n    k: The value to search for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the value k is present in the tuple tup.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    Parameters:\n    tuples (tuple): The tuple to search.\n    k (any): The element to find.\n\n    Returns:\n    bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Checks if the value k is present in the given tuple.\n\n    Args:\n        tuples (tuple): The tuple to check.\n        k: The value to look for in the tuple.\n\n    Returns:\n        bool: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the value `k` is present in the given tuple.\n\n    Parameters:\n    tuples (tuple): The tuple to search within.\n    k (any): The value to search for.\n\n    Returns:\n    bool: True if `k` is in `tuples`, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the tuple contains the element k.\n\n    :param tuples: A tuple of elements.\n    :param k: The element to check for in the tuple.\n    :return: True if k is in tuples, False otherwise.\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tuples, k):\n    \"\"\"\n    Check if the tuple contains the value k.\n    \n    :param tuples: Tuple of elements\n    :param k: Element to check\n    :return: True if k is in tuples, False otherwise\n    \"\"\"\n    return k in tuples", "matching_cluster_idx": 5}]}}}
