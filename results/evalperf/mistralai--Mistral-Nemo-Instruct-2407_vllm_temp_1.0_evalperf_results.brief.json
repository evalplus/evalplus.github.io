{"date": "2024-10-19 16:30", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 81.98436677712466, "dps_norm": 77.61969110961331, "pass@1": 57.389830508474574}, "eval": {"HumanEval/9": {"dps": 64.93690851735016, "dps_norm": 57.77777777777778, "pass@1": 65.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    max_val = float('-inf')\n    result = []\n    for num in numbers:\n        max_val = max(max_val, num)\n        result.append(max_val)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n    max_value = numbers[0]\n    result = [max_value]\n    for num in numbers[1:]:\n        max_value = max(max_value, num)\n        result.append(max_value)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_val = numbers[0]\n    result = [max_val]\n\n    for num in numbers[1:]:\n        max_val = max(max_val, num)\n        result.append(max_val)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_so_far = float('-inf')\n    results = []\n\n    for num in numbers:\n        max_so_far = max(max_so_far, num)\n        results.append(max_so_far)\n\n    return results", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    max_num = float('-inf')\n    result = []\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_num = float('-inf')\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = [max_so_far]\n\n    for num in numbers[1:]:\n        max_so_far = max(max_so_far, num)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    max_value = float('-inf')\n    for num in numbers:\n        max_value = max(max_value, num)\n        rolling_max_list.append(max_value)\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    max_list = [max_num]\n\n    for num in numbers[1:]:\n        max_num = max(max_num, num)\n        max_list.append(max_num)\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    result = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\"\"\"\n    result = []\n    max_num = float('-inf')\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    result = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_val = numbers[0]\n    result = [max_val]\n\n    for num in numbers[1:]:\n        max_val = max(max_val, num)\n        result.append(max_val)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    result = []\n    max_num = numbers[0]\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    rolling_max_list = []\n    max_value = float('-inf')\n\n    for num in numbers:\n        max_value = max(max_value, num)\n        rolling_max_list.append(max_value)\n\n    return rolling_max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_val, result = numbers[0], [numbers[0]]\n    for num in numbers[1:]:\n        if num > max_val:\n            max_val = num\n        result.append(max_val)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n\n    max_num = numbers[0]\n    result = [max_num]\n    for num in numbers[1:]:\n        max_num = max(max_num, num)\n        result.append(max_num)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(max(result[-1], num))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_num = float('-inf')\n\n    for num in numbers:\n        max_num = max(max_num, num)\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 45.2906976744186, "dps_norm": 53.57142857142858, "pass@1": 61.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Sort the numbers in ascending order\n    numbers.sort()\n\n    # Check if the difference between consecutive numbers is less than the threshold\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n\n    # If no pair of numbers is found to be closer than the threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()  # Sort the numbers for easier checking\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True  # If two adjacent numbers are closer than threshold, return True\n    return False  # If no pair of numbers is closer than threshold, return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if len(numbers) < 2:\n        return False\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make the comparison easier\n    numbers.sort()\n\n    # Check each pair of adjacent numbers in the sorted list\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no pair of numbers is closer than threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()  # Sort the list in ascending order\n    return any(abs(numbers[i] - numbers[i - 1]) < threshold for i in range(1, len(numbers)))", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    return any(abs(a - b) < threshold for i, a in enumerate(numbers) for b in numbers[i + 1:])", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than given threshold.\"\"\"\n\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate over the sorted list with a step of 1\n    for i in range(len(numbers) - 1):\n        # If the difference between consecutive numbers is less than the threshold, return True\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no pair of numbers is found to be closer than the threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if len(numbers) < 2:\n        return False\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if not numbers:\n        return False\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()  # Sort the list to facilitate easy comparison\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if not numbers:  # If the list is empty, return False\n        return False\n\n    min_diff = float('inf')  # Initialize minimum difference as infinity\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff  # Update minimum difference if a smaller one is found\n\n    return min_diff < threshold", "matching_cluster_idx": -1}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    sorted_numbers = sorted(numbers)\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i+1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    # Check if list length is less than 2, as we need at least two numbers to compare\n    if len(numbers) < 2:\n        return False\n\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate over the list, comparing each number with its subsequent number\n    for i in range(len(numbers) - 1):\n        # Check if difference between two consecutive numbers is less than the threshold\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n\n    # If no pair of numbers found to be closer than threshold, return False\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    sorted_numbers = sorted(numbers)\n    return any(sorted_numbers[i + 1] - sorted_numbers[i] < threshold for i in range(len(sorted_numbers) - 1))", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers = sorted(numbers)  # sort the list of numbers\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True  # found a pair of numbers closer than threshold\n    return False  # no pair of numbers found that is closer than threshold", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than given threshold.\"\"\"\n\n    # Sort the numbers in ascending order\n    numbers.sort()\n\n    # Check if adjacent pairs of numbers are closer than the threshold\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    if not numbers:\n        return False\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Check if the input list is empty or has only one element\n    if len(numbers) < 2:\n        return False\n\n    # Sort the list to reduce the number of comparisons\n    numbers.sort()\n\n    # Iterate through the list and check the difference between each pair of consecutive numbers\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n\n    # If no pair is found, return False\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 53.90822784810127, "dps_norm": 60.833333333333336, "pass@1": 94.0, "profiled": [{"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    numbers_mean = mean(numbers)\n    return mean(abs(num - numbers_mean) for num in numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = statistics.mean(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return statistics.mean(absolute_differences)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean|\n\n    Args:\n    numbers (List[float]): A list of float numbers\n\n    Returns:\n    float: Mean Absolute Deviation\n    \"\"\"\n    mean = statistics.mean(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Calculate Mean Absolute Deviation around the mean of the dataset. \"\"\"\n    mean_value = statistics.mean(numbers)\n    deviations = [abs(x - mean_value) for x in numbers]\n    return statistics.mean(deviations)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean_value = sum(numbers) / len(numbers)\n    deviation = [abs(x - mean_value) for x in numbers]\n    return sum(deviation) / len(deviation)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(num - mean) for num in numbers]\n    return sum(absolute_differences) / len(absolute_differences)", "matching_cluster_idx": 4}, {"solution": "from typing import List\nfrom statistics import mean, StatisticsError\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average |x - x_mean|\n    \"\"\"\n    try:\n        mean_val = mean(numbers)\n    except StatisticsError:\n        return \"Error: Input list is empty\"\n\n    return sum([abs(x - mean_val) for x in numbers]) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ValueError(\"Empty dataset provided\")\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List is empty\")\n\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean, stdev\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0\n    mean_val = mean(numbers)\n    return sum(abs(x - mean_val) for x in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    n = len(numbers)\n    mean = sum(numbers) / n\n    return sum(abs(x - mean) for x in numbers) / n", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = statistics.mean(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    deviation = sum(abs(num - mean) for num in numbers)\n    mad = deviation / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    x_mean = mean(numbers)\n    return mean(abs(n - x_mean) for n in numbers)", "matching_cluster_idx": 0}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"For a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    mean = statistics.mean(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    return sum(deviations) / len(deviations)", "matching_cluster_idx": 0}]}, "HumanEval/16": {"dps": 95.81395348837209, "dps_norm": 96.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase to handle case insensitivity\n    string = string.lower()\n    # Use a set to store distinct characters, as sets automatically remove duplicates\n    distinct_characters = set(string)\n    # Return the count of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase and use a set to automatically eliminate duplicates\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to a set to automatically remove duplicates,\n    # then convert it back to a list to count the elements.\n    return len(set([char.lower() for char in string]))", "matching_cluster_idx": 2}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert the string to lowercase and then get the set of unique characters.\n    # The set data structure in Python ensures that there are no duplicate characters.\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert string to set to remove duplicates, then convert it back to list to count elements\n    # The 'lower()' function is used to ensure case-insensitivity\n    return len(list(set(string.lower())))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # Convert string to lower case to ensure case insensitivity\n    string = string.lower()\n\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    # Convert the string to lowercase to make case insensitive\n    string = string.lower()\n    # Use a set to store unique characters and then get its length\n    return len(set(string))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of \"\"\"\n    # Convert string to lowercase and use set to remove duplicates\n    distinct_chars = set(string.lower())\n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    # Using set to automatically get distinct characters, then lower() to ignore case\n    return len(set(string.lower()))", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 52.893462469733656, "dps_norm": 68.88888888888889, "pass@1": 75.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    closest_pair = (float('inf'), float('-inf'))\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements.\")\n\n    min_diff = float('inf')\n    pair = (None, None)\n\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the numbers\n    numbers.sort()\n\n    # Initialize smallest difference and closest numbers\n    smallest_diff = float('inf')\n    closest = (float('inf'), float('inf'))\n\n    # Iterate through the list\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]  # difference between two consecutive numbers\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest = (numbers[i], numbers[i + 1])  # save the closest numbers\n\n    return closest", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    sorted_numbers = sorted(numbers)\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    for i in range(1, len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < closest_pair[1] - closest_pair[0]:\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"At least two numbers are required\")\n\n    min_diff = float('inf')\n    min_tuple = None\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                min_tuple = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return min_tuple", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = None\n\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                result = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list\n    numbers.sort()\n\n    # Initialize minimum difference and closest numbers\n    min_diff = float('inf')\n    closest_numbers = (float('inf'), float('-inf'))\n\n    # Find the closest numbers\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n\n        if diff < min_diff:\n            min_diff = diff\n            closest_numbers = (numbers[i], numbers[i + 1])\n\n    return closest_numbers", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers\")\n\n    numbers.sort()\n    min_diff = float('inf')\n    result = (numbers[0], numbers[0])\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = (None, None)\n\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < min_diff:\n                min_diff = abs(numbers[i] - numbers[j])\n                result = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"At least two elements are needed\")\n\n    min_diff = float('inf')\n    pair = (None, None)\n\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n\n    min_diff = float('inf')\n    pair = (0, 0)\n\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                pair = (numbers[i], numbers[j])\n\n    return min(pair), max(pair)", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n    # Initialize the closest numbers and their difference\n    closest = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    # Loop through the sorted list to find the closest pair\n    for i in range(2, len(sorted_numbers)):\n        if abs(sorted_numbers[i] - sorted_numbers[i-1]) < min_diff:\n            min_diff = abs(sorted_numbers[i] - sorted_numbers[i-1])\n            closest = (sorted_numbers[i-1], sorted_numbers[i])\n    # Return the closest pair in order (smaller number, larger number)\n    return min(closest), max(closest)", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (None, None)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"Input list must contain at least two elements\")\n\n    min_diff = float('inf')\n    pair = ()\n\n    for i in range(len(numbers)-1):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < min_diff:\n                min_diff = abs(numbers[i] - numbers[j])\n                pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Check if the list has at least two elements\n    if len(numbers) < 2:\n        raise ValueError(\"The list must have at least two elements.\")\n\n    # Initialize minimum difference and closest numbers\n    min_diff = float('inf')\n    closest_numbers = ()\n\n    # Iterate through the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n\n            # Update the closest numbers if the current difference is smaller\n            if diff < min_diff:\n                min_diff = diff\n                closest_numbers = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    sorted_numbers = sorted(numbers)\n    diff_list = [sorted_numbers[i+1] - sorted_numbers[i] for i in range(len(sorted_numbers)-1)]\n    min_diff_idx = diff_list.index(min(diff_list))\n    return (sorted_numbers[min_diff_idx], sorted_numbers[min_diff_idx+1])", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < min_diff:\n                min_diff = abs(numbers[i] - numbers[j])\n                result = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < min_diff:\n                min_diff = abs(numbers[i] - numbers[j])\n                result = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Initialize the result with the first two elements of the list\n    result = (numbers[0], numbers[1])\n\n    # Iterate through the list to find a closer pair\n    for i in range(1, len(numbers) - 1):\n        # Calculate the difference between the current pair and the result\n        diff = abs(numbers[i+1] - numbers[i])\n        result_diff = abs(result[1] - result[0])\n\n        # Update the result if a closer pair is found\n        if diff < result_diff:\n            result = (numbers[i], numbers[i+1])\n\n    return result", "matching_cluster_idx": 7}]}, "HumanEval/24": {"dps": 69.35374149659864, "dps_norm": 36.25, "pass@1": 61.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    # Check for base case, where n is 1\n    if n == 1:\n        return 1\n\n    # Iterate through numbers from n // 2 down to 1\n    for i in range(n // 2, 0, -1):\n        # If i divides n evenly, return i as the largest divisor\n        if n % i == 0:\n            return i\n\n    # If no divisor is found, return 1 (as 1 is the largest number that divides every number)\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n\n    # Handle edge cases\n    if n < 2:\n        return None\n\n    # Iterate from n down to 2\n    for i in range(n-1, 1, -1):\n\n        # If i divides n evenly, return i\n        if n % i == 0:\n            return i\n\n    # If no divisor is found, return 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input should be a positive integer\")\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    raise ValueError(\"Number has no positive divisor smaller than itself\")", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    if n < 2:\n        return None  # None is returned for numbers less than 2 as there's no positive integer divisor for them\n\n    # start checking from n//2 and move downwards\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    if n < 2:\n        return 1\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    if n < 2:\n        return 1\n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n.\"\"\"\n    # Check if the input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    # Start from the largest possible divisor, which is the input number itself,\n    # and decrement until finding the first number that divides n evenly\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    # Start checking divisors from the largest possible, which is n//2\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n\n    if n < 2:  # Base case: for numbers less than 2, they are not divisible by any other number\n        return 1\n\n    # Start from the largest possible divisor: n//2\n    # The reason is that if n is divisible by i, then n is also divisible by n//i, and n//i < i.\n    for i in range(n // 2, 0, -1):  # from n//2 down to 1\n        if n % i == 0:  # If n is divisible by i, i is the largest divisor\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    if n < 2:\n        return 1\n\n    for i in range(n - 1, 1, -1):\n        if n % i == 0:\n            return i\n\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"The input should be a positive integer greater than 1\")\n\n    i = n // 2\n    while i > 0 and n % i != 0:\n        i -= 1\n    return i", "matching_cluster_idx": 2}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n    n (int): The input number.\n\n    Returns:\n    int: The largest divisor smaller than n.\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Input must be a positive integer\")\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    if n < 2:\n        return 1\n\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    # Start from half of the number and go down to 1\n    for i in range(n // 2, 0, -1):\n        # If the number is divisible evenly, return it\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    \"\"\"\n    # Check if input is a positive integer\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n\n    # Start checking divisors from n // 2 (since 1 is always a divisor) and decrease until reaching 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n\n    # If no divisor was found, return 1 (as 1 is always a divisor)\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    Args:\n        n (int): input number\n\n    Returns:\n        int: the largest divisor of n\n    \"\"\"\n    if n < 1:\n        raise ValueError('Input should be a positive integer')\n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n\n    Args:\n    n (int): The number to find the largest divisor of.\n\n    Returns:\n    int: The largest divisor of n that is smaller than n.\n\n    Examples:\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start from the largest possible divisor which is n//2\n    divisor = n // 2\n    while n % divisor != 0:\n        # Decrease the divisor by 1 and continue until a divisor is found\n        divisor -= 1\n    return divisor", "matching_cluster_idx": 3}]}, "HumanEval/26": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/31": {"dps": 78.73417721518987, "dps_norm": 82.5, "pass@1": 98.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n\n    Arguments:\n    n -- integer to check if it's prime or not\n\n    Returns:\n    bool -- True if number is prime, False otherwise\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        i = 3\n        while i * i <= n:\n            if n % i:\n                i += 2\n            else:\n                return False\n        return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1): # loop only up to square root of n\n        if n % i == 0: # if n is divisible by any number up to its square root, it is not prime\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n\n    This function checks if a number is prime by iterating from 2 to the square root of the number,\n    and checks if the number is divisible by any of these values. If it is, then it is not a prime.\n    \"\"\"\n\n    if n < 2:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_div = int(n**0.5) + 1\n    for i in range(3, max_div, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 50.9837962962963, "dps_norm": 71.81818181818181, "pass@1": 73.0, "profiled": [{"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    to_sort = [l[i] for i in range(0, len(l), 3)]\n    to_sort.sort()\n    l[::3] = to_sort\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three,\n    while its values at the indicies that are divisible by three are equal to\n    the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    threes = [l[i] for i in range(0, len(l), 3)]\n    threes.sort()\n    return [threes.pop(0) if i % 3 == 0 else val for i, val in enumerate(l)]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # Create a list of elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the list of elements\n    divisible_by_three.sort()\n\n    # Create a new list with sorted elements at indices divisible by three\n    sorted_l = [divisible_by_three.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]\n\n    return sorted_l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Separate elements at indices divisible by 3\n    divisible_by_three = sorted([l[i] for i in range(0, len(l), 3)])\n    # Replace elements at indices divisible by 3 with sorted elements\n    return [divisible_by_three.pop(0) if i % 3 == 0 else val for i, val in enumerate(l)]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l):\n    # Extract elements at indices divisible by three and sort them\n    sorted_thirds = sorted([l[i] for i in range(0, len(l), 3)])\n    # Construct the output list by replacing elements at indices divisible by three with sorted elements\n    l_prime = [sorted_thirds.pop(0) if i % 3 == 0 else elem for i, elem in enumerate(l)]\n    return l_prime", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    # Separate elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    third_elements.sort()  # Sort them\n\n    # Replace elements at indices divisible by 3 with sorted elements\n    l = [third_elements.pop(0) if i % 3 == 0 else val for i, val in enumerate(l)]\n\n    return l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices\n    that are divisible by three are equal to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Create a new list with the values at indices divisible by 3\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the new list\n    sorted_to_sort = sorted(to_sort)\n    # Replace the values at indices divisible by 3 in the original list with the sorted values\n    l_copy = l.copy()\n    for i, value in enumerate(to_sort):\n        l_copy[i * 3] = sorted_to_sort.pop(0)\n    return l_copy", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    # Extract elements at indices divisible by three\n    to_sort = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the extracted elements\n    to_sort.sort()\n\n    # Place the sorted elements back into the list\n    result = l.copy()\n    i = 0\n    for j in range(0, len(l), 3):\n        result[j] = to_sort[i]\n        i += 1\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract elements at indices divisible by 3, sort them, and replace them in the original list\n    sorted_third_elements = sorted(l[i] for i in range(0, len(l), 3))\n    for i in range(0, len(l), 3):\n        l[i] = sorted_third_elements.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract elements at indices divisible by three and sort them\n    to_sort = sorted([l[i] for i in range(0, len(l), 3)])\n\n    # Create a list of indices divisible by three\n    indices = list(range(0, len(l), 3))\n\n    # Create a list with same values as l but at indices divisible by three are filled with sorted values\n    l_prime = [to_sort.pop(0) if i in indices else val for i, val in enumerate(l)]\n\n    return l_prime", "matching_cluster_idx": 2}, {"solution": "def sort_third(l):\n    # Extract values at indices divisible by three\n    third_indices = [i for i in range(0, len(l), 3)]\n    third_values = [l[i] for i in third_indices]\n\n    # Sort the extracted values\n    third_values.sort()\n\n    # Replace the values at indices divisible by three with the sorted values\n    for i, value in zip(third_indices, third_values):\n        l[i] = value\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    # List to store elements at indices divisible by three\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the list of elements divisible by three\n    divisible_by_three.sort()\n\n    # Iterate over list and replace elements at indices divisible by three with sorted list\n    for i in range(0, len(l), 3):\n        l[i] = divisible_by_three.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    to_sort = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the extracted elements\n    to_sort.sort()\n\n    # Place sorted elements back in the original list\n    for i in range(0, len(l), 3):\n        l[i] = to_sort.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    divisible_by_three.sort()\n    return [divisible_by_three.pop(0) if i % 3 == 0 else val for i, val in enumerate(l)]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list):\n    # Separate elements at indices divisible by 3\n    by_three = sorted([l[i] for i in range(0, len(l), 3)])\n    # Replace elements at indices divisible by 3 with sorted elements\n    l[::3] = by_three\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three and sort them\n    third_els = sorted([l[i] for i in range(0, len(l), 3)])\n    # Create a new list with sorted elements at indices divisible by three\n    new_l = [third_els.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]\n    return new_l", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three\n    are equal to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    threes = [l[i] for i in range(0, len(l), 3)]\n    threes.sort()\n    return [threes.pop(0) if i % 3 == 0 else val for i, val in enumerate(l)]", "matching_cluster_idx": 6}, {"solution": "def sort_third(l: list) -> list:\n    # Collect all elements at indices divisible by three\n    to_sort = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the collected elements\n    to_sort.sort()\n\n    # Replace the elements at indices divisible by three with the sorted elements\n    for i, element in zip(range(0, len(l), 3), to_sort):\n        l[i] = element\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Initialize an empty list to hold elements at indices divisible by 3\n    sort_list = [l[i] for i in range(0, len(l), 3)]\n    sort_list.sort()  # Sort the list\n\n    # Replace elements at indices divisible by 3 in the original list with sorted elements\n    for i in range(0, len(l), 3):\n        l[i] = sort_list.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list) -> list:\n    # Create a list of the elements at positions divisible by 3\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n\n    # Sort the list of elements divisible by three\n    divisible_by_three.sort()\n\n    # Replace the elements at positions divisible by three with the sorted elements\n    for i in range(0, len(l), 3):\n        l[i] = divisible_by_three.pop(0)\n\n    return l", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 86.41509433962264, "dps_norm": 97.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list.\n\n    Args:\n        l (list): Input list.\n\n    Returns:\n        list: Unique elements in sorted order.\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 3}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 3}, {"solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\"\"\"\n\n    # Using set to get unique elements, then convert it back to list and sort it\n    return sorted(list(set(l)))", "matching_cluster_idx": 3}]}, "HumanEval/36": {"dps": 72.58064516129032, "dps_norm": 67.14285714285714, "pass@1": 66.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    if n < 1:\n        return 0\n\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            while i > 0:\n                if i % 10 == 7:\n                    count += 1\n                i = i // 10\n    return count", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:  # Check divisibility by 11 or 13\n            while i > 0:  # Count digits\n                if i % 10 == 7:  # Check if digit is 7\n                    count += 1\n                i //= 10\n    return count", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    # Check if number is divisible by 11 or 13\n    def is_fizz_buzz(num: int) -> bool:\n        return num % 11 == 0 or num % 13 == 0\n\n    count = 0\n    for num in range(1, n):\n        if is_fizz_buzz(num):\n            # Count the digit 7 in the number\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for num in range(11, n):\n        if num % 11 == 0 or num % 13 == 0:\n            while num > 0:\n                if num % 10 == 7:\n                    count += 1\n                num //= 10\n    return count", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    # Helper function to count occurrences of digit 7 in an integer\n    def count_sevens(num: int) -> int:\n        return str(num).count('7')\n\n    # Initialize counter for occurrences of digit 7\n    total_sevens = 0\n\n    # Iterate over integers less than n\n    for i in range(n):\n        # Check if the integer is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # If so, count the occurrences of digit 7 and add it to the total\n            total_sevens += count_sevens(i)\n\n    return total_sevens", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    def count_sevens(m: int) -> int:\n        return ''.join(str(m)).count('7')\n\n    return sum(count_sevens(i) for i in range(1, n) if i % 11 == 0 or i % 13 == 0)", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    # Check for the divisibility of numbers less than n by 11 or 13\n    divisible_by_11_or_13 = (i for i in range(1, n) if i % 11 == 0 or i % 13 == 0)\n\n    # Calculate the number of times the digit 7 appears in the numbers\n    count = sum(str(i).count('7') for i in divisible_by_11_or_13)\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n\n    count = 0\n\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            while i > 0:\n                if i % 10 == 7:\n                    count += 1\n                i = i // 10\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    # Initialize counter\n    count = 0\n\n    # Iterate from 1 to n\n    for num in range(1, n):\n        # Check if number is divisible by 11 or 13\n        if num % 11 == 0 or num % 13 == 0:\n            # Convert number to string to easily count digit 7\n            num_str = str(num)\n\n            # Iterate through each digit in the number\n            for digit in num_str:\n                # Check if digit is 7\n                if digit == '7':\n                    # Increment counter if digit is 7\n                    count += 1\n\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_sevens(n):\n    \"\"\"Helper function to count number of digits 7 in a given number.\"\"\"\n    return str(n).count('7')\ndef fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    if n < 1:\n        return 0\n    return sum(count_sevens(i) for i in range(1, n) if i % 11 == 0 or i % 13 == 0)", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:  # Check divisibility by 11 or 13\n            count += str(i).count('7')  # Count occurrences of 7 in the number\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\"\"\n    count = 0\n    for i in range(11, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:  # check divisibility by 11 or 13\n            num = str(i)  # convert the number to a string for easy iteration\n            count += num.count('7')  # count the occurrences of '7' in the string\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 95.6873977086743, "dps_norm": 91.5, "pass@1": 90.0, "profiled": [{"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Extract elements at even indices and sort them\n    even_elements = sorted(l[::2])\n\n    # Replace elements at even indices with sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\"\"\"\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    return [l[i] if i % 2 else evens.pop(0) for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Create a new list with even indices from the original list\n    even_nums = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the even_nums list\n    even_nums.sort()\n\n    # Zip even_nums back into the original list at even indices\n    result = [even_nums[i//2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    for i, num in enumerate(evens):\n        if i < len(l) and l[i*2] != num:\n            l[i*2] = num\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Extract even-index elements\n    even_elements = sorted(l[::2])\n    # Create new list using even_elements for even indices\n    result = [even_elements.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies\n    are equal to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract even-indexed values, sort them and put them back in the correct order\n    evens = sorted(l[::2])\n    new_l = l.copy()\n    new_l[::2] = evens\n    return new_l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"Sort the even indices of the input list while keeping the odd indices the same.\"\"\"\n    # Extract elements at even indices and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    # Create a new list with sorted even elements at even indices and original elements at odd indices\n    return [even_elements[i//2] if i % 2 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    evens = sorted(l[::2])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l):\n    # Separate even and odd indexed values\n    evens = [l[i] for i in range(0, len(l), 2)]\n    odds = [l[i] for i in range(1, len(l), 2)]\n\n    # Sort the even indexed values\n    evens.sort()\n\n    # Combine the sorted evens with the odds\n    return [evens.pop(0) if i % 2 == 0 else odds[i // 2] for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    even_nums = sorted(l[::2])\n    l[::2] = even_nums\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\"\"\"\n    # Extract the elements at even indexes and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n\n    # Replace the elements at even indexes in the original list with the sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = even_elements.pop(0)\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indexes = [l[i] for i in range(0, len(l), 2)]\n    even_indexes.sort()\n    for i, val in enumerate(even_indexes):\n        l[i*2] = val\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\"\"\"\n    # Get even-indexed elements and sort them\n    sorted_even = sorted([l[i] for i in range(0, len(l), 2)])\n\n    # Create a new list with sorted even-indexed elements and keep odd-indexed elements the same\n    result = [sorted_even[i//2] if i % 2 == 0 else l[i] for i in range(len(l))]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    even_inds = [i for i in range(0, len(l), 2)]\n    even_elems = [l[i] for i in even_inds]\n    even_elems.sort()\n    return [even_elems.pop(0) if i % 2 == 0 else val for i, val in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    l[::2] = evens\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    even_els = sorted(l[::2])  # Get even-indexed elements and sort them\n    result = l[:]  # Copy the input list\n    for i, el in enumerate(even_els):\n        # Replace even-indexed elements in the result list\n        result[i*2] = el\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Separate even and odd index values\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    odd_values = [l[i] for i in range(1, len(l), 2)]\n\n    # Sort the even values\n    even_values.sort()\n\n    # Create the new list with sorted even values and original odd values\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_values.pop(0))\n        else:\n            result.append(odd_values.pop(0))\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_elements = sorted(l[::2])\n    return [even_elements.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list) -> list:\n    # Separate even and odd indexed elements\n    even = sorted([l[i] for i in range(0, len(l), 2)])\n    odd = [l[i] for i in range(1, len(l), 2)]\n\n    # Combine them back together\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even.pop(0))\n        else:\n            result.append(odd.pop(0))\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 37.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics)\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    # return 2^n modulo p\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics)\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 81.25603864734299, "dps_norm": 67.5, "pass@1": 99.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    # Define the vowels\n    vowels = 'aeiouAEIOU'\n\n    # Use list comprehension to create a new string without vowels\n    text_without_vowels = ''.join([char for char in text if char not in vowels])\n\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"Remove vowels (both lowercase and uppercase) from a given string.\"\"\"\n    return ''.join([char for char in text if char.lower() not in 'aeiou'])", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(ch for ch in text if ch not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(ch for ch in text if ch not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join([char for char in text if char.lower() not in 'aeiou'])", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    # Define the vowels, both lowercase and uppercase\n    vowels = 'aeiouAEIOU'\n\n    # Use the translate() function to remove all vowels\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(ch for ch in text if ch.lower() not in 'aeiou')", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    # Define the vowels, both lower-case and upper-case\n    vowels = 'aeiouAEIOU'\n\n    # Use the join() method to combine characters from the text after removing vowels\n    result = ''.join(char for char in text if char not in vowels)\n\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    return ''.join(char for char in text if char.lower() not in 'aeiou')", "matching_cluster_idx": 2}]}, "HumanEval/54": {"dps": 93.9209726443769, "dps_norm": 98.9795918367347, "pass@1": 14.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n\n    # Create sets of characters from each string\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Compare the sets, if they are equal, the strings have the same characters\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Create sets from the strings to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Create two sets of characters from s0 and s1\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # If the lengths of the two sets are not equal, they cannot have the same characters\n    if len(set_s0) != len(set_s1):\n        return False\n\n    # If both sets are equal, then all characters in s0 are in s1 and vice versa\n    if set_s0 == set_s1:\n        return True\n\n    # Otherwise, the two strings do not have the same characters\n    return False", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Converting strings to sets to remove duplicates and then checking if the sets are equal\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Use two hashsets to keep track of characters in each string.\n    # This method allows for O(1) time complexity to check if a character exists.\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Return True if every character in s0 is in s1, and vice versa.\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets and compare them\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create two sets from the strings to remove duplicates and then compare them\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create sets of the unique characters from each word\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # If the lengths of the sets are not equal, they cannot be equal\n    if len(set_s0) != len(set_s1):\n        return False\n\n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Convert strings to sets of characters and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Converting both strings into sets of characters to remove duplicates\n    # and checking if the sets are equal\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    # Remove spaces and convert the strings to sets to eliminate duplications\n    s0, s1 = set(s0.replace(\" \", \"\")), set(s1.replace(\" \", \"\"))\n    # Check if both sets are equal\n    return s0 == s1", "matching_cluster_idx": 5}]}, "HumanEval/58": {"dps": 84.03543307086613, "dps_norm": 75.83333333333333, "pass@1": 98.0, "profiled": [{"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Use set intersection to find unique common elements\n    # Then convert the resulting set to a list and sort it\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    Args:\n    l1 (list): the first list\n    l2 (list): the second list\n    Returns:\n    list: the sorted list of unique common elements\n    \"\"\"\n    # Convert lists to sets to easily find unique common elements\n    set1, set2 = set(l1), set(l2)\n    common_set = set1 & set2  # Set intersection to find common elements\n\n    # Convert the set back to a list and sort it\n    common_list = sorted(list(common_set))\n\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n\n    # Convert lists to sets to remove duplicates and perform faster operations\n    set1 = set(l1)\n    set2 = set(l2)\n\n    # Find common elements and convert back to list\n    common_elements = list(set1.intersection(set2))\n\n    # Sort the list\n    common_elements.sort()\n\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    # Use set to get unique elements and list comprehension to get common elements\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    # Use list comprehension to find common elements and set data structure to eliminate duplicates\n    common_elements = list(set([i for i in l1 if i in l2]))\n\n    # Sort the resulting list\n    common_elements.sort()\n\n    return common_elements", "matching_cluster_idx": 0}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    Args:\n    l1 (list): A list of integers.\n    l2 (list): A list of integers.\n\n    Returns:\n    list: A sorted list of unique common elements.\n\n    Examples:\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n\n    # Find common elements by using set intersection\n    common_elements = set(l1) & set(l2)\n\n    # Sort and return the common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Use set to remove duplicates and then list comprehension to find common elements\n    common_elements = [i for i in set(l1) if i in set(l2)]\n\n    # Sort the common elements\n    common_elements.sort()\n\n    return common_elements", "matching_cluster_idx": -1}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    # Use set operations for efficient element intersection and uniqueness\n    # Convert lists to sets, find intersection, and then convert back to list\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    # Convert lists to sets to remove duplicates and perform set intersection\n    common_set = set(l1) & set(l2)\n    # Convert set back to list and sort\n    return sorted(list(common_set))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 67.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n if n > 1 else i", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    if n < 2:\n        raise ValueError(\"n should be greater than 1\")\n\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    # Assume n > 1 and is not a prime\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    # Check if input is greater than 1 and is not a prime number\n    if n <= 1 or is_prime(n):\n        raise ValueError(\"Input must be an integer greater than 1 and not a prime number\")\n\n    # Initialize the largest prime factor\n    largest = -1\n\n    # Try all potential factors starting from 2\n    # Iterate until the square of the potential factor is less than or equal to n\n    potential_factor = 2\n    while potential_factor * potential_factor <= n:\n        # While n is divisible by the potential factor, update the largest prime factor and divide n\n        while n % potential_factor == 0:\n            largest = potential_factor\n            n //= potential_factor\n        # Increment the potential factor\n        potential_factor += 1\n\n    # The remaining n must be a prime number greater than 1\n    if n > 1:\n        largest = n\n\n    return largest\ndef is_prime(n: int) -> bool:\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    factor = 2\n    while factor * factor <= n:\n        if n % factor:\n            factor += 1\n        else:\n            n //= factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    # check if input is valid\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n\n    # find the largest prime factor\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    # Check if input is a positive integer greater than 1\n    assert n > 1 and isinstance(n, int), \"Input should be an integer greater than 1\"\n\n    # Check if input is a prime number and return 1 as the largest prime factor\n    if n == 2:\n        return n\n    elif all(n % i for i in range(2, int(n**0.5) + 1)):\n        return 1\n\n    # Find the largest prime factor\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n if n > 1 else i", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "HumanEval/74": {"dps": 88.8780487804878, "dps_norm": 86.66666666666666, "pass@1": 33.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(word) for word in lst1)\n    len_lst2 = sum(len(word) for word in lst2)\n\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst1 > len_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in both lists\n    total1 = sum(len(word) for word in lst1)\n    total2 = sum(len(word) for word in lst2)\n\n    # Determine which list to return based on the total number of characters\n    if total1 < total2:\n        return lst1\n    elif total2 < total1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_chars_lst1 = sum(len(word) for word in lst1)\n    sum_chars_lst2 = sum(len(word) for word in lst2)\n\n    if sum_chars_lst1 < sum_chars_lst2:\n        return lst1\n    elif sum_chars_lst2 < sum_chars_lst1:\n        return lst2\n    else:\n        return lst1  # if both lists have the same number of chars, return the first list", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(s) for s in lst1)\n    len_lst2 = sum(len(s) for s in lst2)\n\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst1 > len_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate total number of characters in each list\n    lst1_total = sum(len(word) for word in lst1)\n    lst2_total = sum(len(word) for word in lst2)\n\n    # Return the list with fewer total characters, or the first list if they're equal\n    return lst1 if lst1_total <= lst2_total else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(word) for word in lst1)\n    len_lst2 = sum(len(word) for word in lst2)\n\n    if len_lst1 < len_lst2:\n        return lst1\n    elif len_lst1 > len_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total1 = sum(len(s) for s in lst1)\n    total2 = sum(len(s) for s in lst2)\n\n    # If the totals are equal, return the first list\n    if total1 == total2:\n        return lst1\n\n    # Otherwise, return the list with fewer total characters\n    return lst1 if total1 < total2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate total characters for each list\n    total_chars_l1 = sum(len(s) for s in lst1)\n    total_chars_l2 = sum(len(s) for s in lst2)\n\n    # Return the list with fewer total characters\n    if total_chars_l1 < total_chars_l2:\n        return lst1\n    elif total_chars_l1 > total_chars_l2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum_chars_lst1 = sum(len(word) for word in lst1)\n    sum_chars_lst2 = sum(len(word) for word in lst2)\n\n    if sum_chars_lst1 < sum_chars_lst2:\n        return lst1\n    elif sum_chars_lst1 > sum_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    length1 = sum(len(word) for word in lst1)\n    length2 = sum(len(word) for word in lst2)\n\n    if length1 < length2:\n        return lst1\n    elif length1 > length2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    if sum1 < sum2:\n        return lst1\n    elif sum1 > sum2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 < total_chars_lst2:\n        return lst1\n    elif total_chars_lst1 > total_chars_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    if sum(len(s) for s in lst1) < sum(len(s) for s in lst2):\n        return lst1\n    elif sum(len(s) for s in lst1) > sum(len(s) for s in lst2):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 5}, {"solution": "def total_match(lst1, lst2):\n    total_lst1 = sum(len(item) for item in lst1)\n    total_lst2 = sum(len(item) for item in lst2)\n\n    if total_lst1 < total_lst2:\n        return lst1\n    elif total_lst1 > total_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    count1 = sum(len(word) for word in lst1)\n    count2 = sum(len(word) for word in lst2)\n\n    if count1 < count2:\n        return lst1\n    elif count2 < count1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # If the totals are the same, return the first list\n    if total_chars_lst1 == total_chars_lst2:\n        return lst1\n\n    # Otherwise, return the list with fewer characters\n    return lst1 if total_chars_lst1 < total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    if sum(len(s) for s in lst1) < sum(len(s) for s in lst2):\n        return lst1\n    elif sum(len(s) for s in lst1) > sum(len(s) for s in lst2):\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 5}, {"solution": "def total_match(lst1, lst2):\n    count_lst1 = sum(len(word) for word in lst1)\n    count_lst2 = sum(len(word) for word in lst2)\n\n    if count_lst1 < count_lst2:\n        return lst1\n    elif count_lst1 > count_lst2:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n\n    if sum1 < sum2:\n        return lst1\n    elif sum2 < sum1:\n        return lst2\n    else:\n        return lst1", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 92.35148514851484, "dps_norm": 60.833333333333336, "pass@1": 95.0, "profiled": [{"solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A list of integers\n\n    Returns:\n        int: The sum of even elements at odd indices\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) => 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 1 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers\n\n    Returns:\n        int: The sum of even elements at odd indices\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): List of integers\n\n    Returns:\n        int: Sum of even elements at odd indices\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The sum of the even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0])", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list of int): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) -> 2\n    \"\"\"\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) -> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of the even elements at odd indices in the list.\n    \"\"\"\n    return sum(l for i, l in enumerate(lst) if i % 2 and not l % 2)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)", "matching_cluster_idx": 3}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 25.0, "profiled": [{"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        chars = list(word)\n        chars.sort()\n        result.append(''.join(chars))\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join(''.join(sorted(w)) for w in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(word, key=ord)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n\n    # For each word, sort its characters in ascending order and join them back together\n    ordered_words = [''.join(sorted(word)) for word in words]\n\n    # Join the ordered words back into a single string\n    ordered_string = ' '.join(ordered_words)\n\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # split the string into a list of words\n    words = s.split(' ')\n    # map over the list of words\n    words = [ ''.join(sorted(word)) for word in words ]\n    # join the list of sorted words back into a string\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    It replaces each word in the string with a new word where all the characters are\n    arranged in ascending order based on ascii value, while preserving the order of words and blank spaces.\n    \"\"\"\n    words = s.split(' ')  # Split the string into words\n    for i in range(len(words)):  # Iterate over each word\n        sorted_word = ''.join(sorted(words[i]))  # Sort the characters in the word and join them back into a string\n        words[i] = sorted_word  # Replace the original word with the sorted word\n    return ' '.join(words)  # Join the words back into a string with spaces between them", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(w)) for w in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the string into words\n    words = s.split(' ')\n\n    # For each word, sort its characters in ascending order and join them back together\n    ordered_words = [''.join(sorted(word)) for word in words]\n\n    # Join the ordered words back into a string\n    ordered_string = ' '.join(ordered_words)\n\n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(' ')\n    result = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        result.append(sorted_word)\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    words = s.split(\" \")\n    ordered_words = [\"\".join(sorted(word)) for word in words]\n    return \" \".join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Split the input string into words\n    words = s.split(' ')\n    # Iterate over each word\n    for i in range(len(words)):\n        # Sort characters in the word based on ASCII value\n        words[i] = ''.join(sorted(words[i]))\n    # Join words back into a single string with space separator\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    return ' '.join(''.join(sorted(word)) for word in s.split(' '))", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 83.42939481268012, "dps_norm": 57.85714285714286, "pass@1": 61.0, "profiled": [{"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2-dimensional list lst and an integer x, find all occurrences\n    of x in lst and return a list of tuples representing the coordinates\n    (row, column) of each occurrence, starting with 0 for both axes.\n    Sort the coordinates initially by rows in ascending order and then by\n    columns in descending order within the same row.\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_idx, row in enumerate(lst):\n        col_idxs = [idx for idx, val in enumerate(row) if val == x]\n        for idx in sorted(col_idxs, reverse=True):\n            result.append((row_idx, idx))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    return sorted(((i, j) for i, row in enumerate(lst) for j, v in enumerate(row) if v == x),\n                  key=lambda c: (c[0], -c[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coordinates.append((i, j))\n    return sorted(coordinates, key=lambda c: (c[0], -c[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Filter list to only include elements equal to x\n    indices = [(i, j) for i, sublist in enumerate(lst) for j, element in enumerate(sublist) if element == x]\n\n    # Sort the coordinates by rows in ascending order and columns in descending order\n    sorted_indices = sorted(indices, key=lambda y: (y[0], -y[1]))\n\n    return sorted_indices", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Define empty list to store coordinates\n    coordinates = []\n\n    # Iterate over the list with index i for row number\n    for i, row in enumerate(lst):\n        # Iterate over the row with index j for column number\n        for j, val in enumerate(row):\n            # If the value is equal to x, append coordinates to the list\n            if val == x:\n                coordinates.append((i, j))\n\n    # Sort coordinates by rows and columns in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n\n    # Sort coordinates by rows in ascending order and columns in descending order\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order, then by columns in descending order\n    coordinates.sort(key=lambda c: (c[0], -c[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda c: (c[0], -c[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        indices = [(i, j) for j, num in enumerate(row) if num == x]\n        indices.sort(key=lambda x: (x[0], -x[1]))  # Sort by row (ascending) and column (descending)\n        result.extend(indices)\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, num in enumerate(row):\n            if num == x:\n                result.append((row_idx, col_idx))\n    result.sort(key=lambda r: (r[0], -r[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        if x in row:\n            coordinates.extend([(i, j) for j, num in enumerate(row) if num == x])\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 5}, {"solution": "def get_row(lst, x):\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i, j))\n    result.sort(key=lambda tup: (tup[0], -tup[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, sublist in enumerate(lst):\n        for j, num in enumerate(sublist):\n            if num == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                coords.append((i, j))\n    coords.sort(key=lambda y: (y[0], -y[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = [(i, j) for i, row in enumerate(lst) for j, num in enumerate(row) if num == x]\n    coords.sort(key=lambda x: (x[0], -x[1]))\n    return coords", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coords = []\n    for i, row in enumerate(lst):\n        if x in row:\n            coords.extend((i, j) for j, num in enumerate(row) if num == x)\n    coords.sort(key=lambda c: (c[0], -c[1]))\n    return coords", "matching_cluster_idx": 5}]}, "HumanEval/89": {"dps": 96.64948453608248, "dps_norm": 28.571428571428573, "pass@1": 52.0, "profiled": [{"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate_character(char):\n        if not char.isalpha():\n            return char\n        ascii_offset = 97 if char.islower() else 65  # ASCII values for 'a' and 'A'\n        return chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)  # Rotate by 2*2 = 4\n\n    return ''.join(rotate_character(char) for char in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Shift down by two places\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char  # Append non-alphabetic characters as is\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shifted = lambda c: chr((ord(c) - 97 + 4) % 26 + 97) if 'a' <= c <= 'z' else chr((ord(c) - 65 + 4) % 26 + 65) if 'A' <= c <= 'Z' else c\n    return ''.join(shifted(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def shift_char(char):\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            return chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        return char\n\n    return ''.join(shift_char(c) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts the input string by shifting each character by 4 positions in the alphabet.\"\"\"\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    shift = 2 * 2  # The letters shift down by two multiplied by two places\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    # Define a string of all alphabets (both lower and upper case)\n    alphabets = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n    # Initialize the encrypted string\n    encrypted = ''\n\n    # Iterate over each character in the input string\n    for char in s:\n        if char.isalpha():  # Check if the character is an alphabet\n            # Shift the character by 4 places in the alphabet\n            encrypted += alphabets[(alphabets.index(char) + 4) % 26]\n        else:\n            # If the character is not an alphabet, add it to the encrypted string as it is\n            encrypted += char\n\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def shift(ch, shift):\n        if not ch.isalpha():\n            return ch\n        shift_amount = 2 * 2\n        return chr(((ord(ch.lower()) - ord('a') + shift_amount) % 26) + ord('a'))\n\n    return ''.join(shift(c, 2) for c in s)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 97 if char.islower() else 65\n            result += chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 40.68093385214008, "dps_norm": 43.333333333333336, "pass@1": 53.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = min(lst)\n    next_smallest = float('inf')\n    for num in lst:\n        if num > smallest and num < next_smallest:\n            next_smallest = num\n    return next_smallest if next_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def next_smallest(lst):\n    if not lst or len(set(lst)) < 2:  # if the list is empty or all elements are the same\n        return None\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:  # update smallest and second_smallest\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if not lst or len(set(lst)) < 2:\n        return None\n    return min(x for x in lst if x > min(lst))", "matching_cluster_idx": -1}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list, or None if no such element exists.\n    \"\"\"\n    if not lst:  # If the list is empty, return None\n        return None\n    smallest = second_smallest = float('inf')  # Initialize both as positive infinity\n    for num in lst:\n        if num < smallest:  # If a smaller number is found, update both smallest and second_smallest\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:  # If a number is found that's not the smallest but smaller than second_smallest\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None  # Return second_smallest if it's not still infinity", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    min_val, next_min = float('inf'), float('inf')\n    for num in lst:\n        if num < min_val:\n            next_min = min_val\n            min_val = num\n        elif num < next_min and num != min_val:\n            next_min = num\n    return None if next_min == float('inf') else next_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    first, second = float('inf'), float('inf')\n    for num in lst:\n        if num < first:\n            first, second = num, first\n        elif num < second and num != first:\n            second = num\n\n    return None if second == float('inf') else second", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            smallest, second_smallest = num, smallest\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    min_val = float('inf')\n    second_min = float('inf')\n\n    for num in lst:\n        if num < min_val:\n            second_min = min_val\n            min_val = num\n        elif num < second_min and num != min_val:\n            second_min = num\n\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    first_min = second_min = float('inf')\n    for num in lst:\n        if num < first_min:\n            first_min, second_min = num, first_min\n        elif num < second_min and num != first_min:\n            second_min = num\n    return None if second_min == float('inf') else second_min", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if not lst or len(set(lst)) < 2:\n        return None\n\n    return min([i for i in lst if i > min(lst)])", "matching_cluster_idx": -1}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list. Returns None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    else:\n        smallest = second_smallest = float('inf')\n\n        for num in lst:\n            if num < smallest:\n                smallest, second_smallest = num, smallest\n            elif num < second_smallest and num != smallest:\n                second_smallest = num\n\n        return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    first_smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < first_smallest:\n            first_smallest, second_smallest = num, first_smallest\n        elif num < second_smallest and num != first_smallest:\n            second_smallest = num\n\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    smallest, next_smallest = float('inf'), float('inf')\n\n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif num < next_smallest and num != smallest:\n            next_smallest = num\n\n    if next_smallest == float('inf'):\n        return None\n\n    return next_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n\n    for num in lst:\n        if num < first_smallest:\n            second_smallest = first_smallest\n            first_smallest = num\n        elif first_smallest < num < second_smallest:\n            second_smallest = num\n\n    if second_smallest == float('inf'):\n        return None\n\n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if not lst or len(lst) < 2:\n        return None\n    first_smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < first_smallest:\n            first_smallest, second_smallest = num, first_smallest\n        elif num < second_smallest and num != first_smallest:\n            second_smallest = num\n    return None if second_smallest == float('inf') else second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if not lst or len(set(lst)) < 2:\n        return None\n\n    min_val = float('inf')\n    second_min_val = float('inf')\n\n    for num in lst:\n        if num < min_val:\n            second_min_val = min_val\n            min_val = num\n        elif num < second_min_val and num != min_val:\n            second_min_val = num\n\n    return second_min_val if second_min_val != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \"\"\"\n    if not lst or len(set(lst)) < 2:\n        return None\n    lst = list(set(lst))\n    lst.sort()\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}]}, "HumanEval/113": {"dps": 89.65517241379311, "dps_norm": 61.66666666666667, "pass@1": 21.0, "profiled": [{"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(1 for digit in s if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(string):\n        return str(sum(1 for digit in string if int(digit) % 2 != 0))\n\n    return [f\"the number of odd elements {count_odd_digits(i)}n the str{count_odd_digits(i)}ng {count_odd_digits(i)} of the {count_odd_digits(i)}nput.\"\n            for i in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, 1):\n        num_odds = sum(int(x) % 2 == 1 for x in s)\n        res = f\"the number of odd elements {num_odds}n the str{num_odds}ng {num_odds} of the {num_odds}nput.\"\n        result.append(res)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(int(digit) % 2 != 0 for digit in s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def odd_count_str(s):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        return f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    return [odd_count_str(s) for s in lst]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(int(c) % 2 for c in s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        odd_count = len([digit for digit in s if int(digit) % 2 != 0])\n        result.append(f'the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.')\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, s in enumerate(lst, 1):\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        output.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        count_odd = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f'the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.')\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    # Function to calculate number of odd elements in a string\n    def count_odd_digits(s):\n        return len([c for c in s if int(c) % 2 != 0])\n\n    # Use list comprehension to generate the result\n    return [f\"the number of odd elements {count_odd_digits(s)}n the str{count_odd_digits(s)}ng {count_odd_digits(s)} of the {count_odd_digits(s)}nput.\" for s in lst]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    def odd_str(num):\n        return \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(num, num, num, num)\n\n    return [odd_str(sum(int(n) % 2 for n in s)) for s in lst]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        odd_count = sum(int(n) % 2 for n in s)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst, start=1):\n        count = sum(int(digit) % 2 != 0 for digit in string)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst, start=1):\n        odd_digits = sum(int(digit) % 2 != 0 for digit in string)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        num_odd = sum(int(digit) % 2 != 0 for digit in s)\n        result.append(f\"the number of odd elements {num_odd}n the str{num_odd}ng {num_odd} of the {num_odd}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, 1):\n        count_odd = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count_odd}n the str{count_odd}ng {count_odd} of the {count_odd}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(num_str):\n        return sum(1 for digit in num_str if int(digit) % 2 != 0)\n\n    result = []\n    for i, num_str in enumerate(lst, 1):\n        odd_count = count_odd_digits(num_str)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def odd_number(digit):\n        return '1' if digit % 2 != 0 else '8'\n\n    def format_string(count):\n        return f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n\n    return [format_string(sum(int(digit) % 2 != 0 for digit in s)) for s in lst]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for i, s in enumerate(lst, start=1):\n        count = sum(int(digit) % 2 != 0 for digit in s)\n        output.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return output", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 31.0, "profiled": [{"solution": "def match_parens(lst):\n    def count_brackets(string):\n        open_brackets = close_brackets = 0\n        for char in string:\n            if char == '(':\n                open_brackets += 1\n            elif char == ')':\n                close_brackets += 1\n                if close_brackets > open_brackets:\n                    return \"No\"\n        return 'Yes' if open_brackets == close_brackets else 'No'\n\n    return count_brackets(lst[0] + lst[1]) if count_brackets(lst[1] + lst[0]) == 'No' else 'Yes'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    s1, s2 = lst\n\n    def balance(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                if count == 0:\n                    return False\n                count -= 1\n        return count == 0\n\n    return 'Yes' if balance(s1+s2) or balance(s2+s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def helper(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')' and stack:\n                stack.pop()\n            else:\n                return 'No'\n        return 'Yes' if not stack else 'No'\n\n    str1, str2 = lst\n\n    # Check if concatenating both strings in either order results in a valid string\n    return 'Yes' if helper(str1 + str2) == 'Yes' or helper(str2 + str1) == 'Yes' else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:  # Early exit if string is unbalanced\n                    return False\n        return count == 0\n\n    def can_balance(a, b):\n        return is_balanced(a + b) or is_balanced(b + a)\n\n    return 'Yes' if can_balance(lst[0], lst[1]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def helper(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                if count == 0:\n                    return False\n                count -= 1\n        return count == 0\n\n    first, second = lst\n    return 'Yes' if helper(first + second) or helper(second + first) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balance(string):\n        balance = 0\n        for char in string:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if not lst:\n        return 'Yes'\n\n    lst1, lst2 = lst\n\n    if is_balance(lst1 + lst2) or is_balance(lst2 + lst1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def helper(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst\n    if helper(s1) and helper(s2):\n        return 'Yes'\n    if helper(s2 + s1) or helper(s1 + s2):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    a, b = lst\n    return 'Yes' if is_balanced(a + b) or is_balanced(b + a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def count_parens(s):\n        count = 0\n        for c in s:\n            count += 1 if c == '(' else -1\n            if count < 0: return False\n        return count == 0\n\n    a, b = lst\n    return 'Yes' if count_parens(a + b) or count_parens(b + a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    \"\"\"\n    def is_good(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')' and count > 0:\n                count -= 1\n            elif c == ')':\n                return False\n        return count == 0\n\n    str1, str2 = lst\n    return 'Yes' if is_good(str1 + str2) or is_good(str2 + str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:  # Not balanced\n                    return False\n        return count == 0  # Balanced\n\n    a, b = lst\n    # Concatenate strings in all possible orders and check if any result is balanced\n    return 'Yes' if is_balanced(a + b) or is_balanced(b + a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    str1 = lst[0]\n    str2 = lst[1]\n\n    # function to check if a string has balanced parentheses\n    def is_good(str):\n        stack = []\n        for char in str:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # check if both strings are good or if they can be merged to be good\n    return 'Yes' if is_good(str1) and is_good(str2) or is_good(str1+str2) or is_good(str2+str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    first, second = lst[0], lst[1]\n    return 'Yes' if is_balanced(first + second) or is_balanced(second + first) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst\n    # Concatenate and check balance for both possible combinations\n    return 'Yes' if check_balance(s1 + s2) or check_balance(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    def can_form_good_string(s1, s2):\n        return is_balanced(s1 + s2) or is_balanced(s2 + s1)\n\n    s1, s2 = lst\n    return 'Yes' if can_form_good_string(s1, s2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    # Helper function to check if a string is good\n    def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Concatenate the two strings in both orders\n    str1, str2 = lst\n    combined1 = str1 + str2\n    combined2 = str2 + str1\n\n    # Check if either of the combined strings is good\n    return 'Yes' if is_good(combined1) or is_good(combined2) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balanced(s):\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    a, b = lst\n    return 'Yes' if check_balanced(a+b) or check_balanced(b+a) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def count_parens(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    string1, string2 = lst\n    return 'Yes' if count_parens(string1 + string2) or count_parens(string2 + string1) else 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "HumanEval/121": {"dps": 84.88789237668162, "dps_norm": 63.57142857142858, "pass@1": 92.0, "profiled": [{"solution": "def solution(lst):\n    return sum(el for i, el in enumerate(lst) if i % 2 == 0 and el % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    # Sum of the odd elements at even indices\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    # Initialize the sum of odd elements in even positions\n    sum_of_odd = 0\n\n    # Iterate over the list with the step of 2 (only even positions)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current even position is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_of_odd += lst[i]\n\n    # Return the sum of odd elements in even positions\n    return sum_of_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(num for index, num in enumerate(lst) if index % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(len(lst)) if i % 2 == 0 and lst[i] % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all the odd elements that are in even positions.\"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    # Initialize sum to 0\n    sum = 0\n    # Iterate over the list with an index and value\n    for i, num in enumerate(lst):\n        # Check if the index is even and the number is odd\n        if i % 2 == 0 and num % 2 != 0:\n            # Add the number to the sum\n            sum += num\n    # Return the sum\n    return sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 96.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # Filter out words with odd lengths and convert them to a list of tuples with their lengths as first element\n    filtered_list = [(len(word), word) for word in lst if len(word) % 2 == 0]\n    # Sort the list first by length (using the first element of the tuple) and then alphabetically (using the second element)\n    filtered_list.sort(key=lambda x: (x[0], x[1]))\n    # Return only the words from the sorted list\n    return [word for _, word in filtered_list]", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out the strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter out strings of odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # sort by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings of odd length\n    even_len_strings = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the strings by length and then alphabetically if lengths are equal\n    even_len_strings.sort(key=lambda s: (len(s), s))\n\n    return even_len_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort by length first, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length and alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings of odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length and then by alphabetical order\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    lst = [word for word in lst if len(word) % 2 == 0]\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings of odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # Sort the list first by length, then alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out words with odd length\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sort the list first by word length and then by alphabetical order\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length first, then alphabetically for strings of same length\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length in ascending order, then alphabetically if lengths are equal\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # remove strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # sort by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list first by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths and sort by length first, then alphabetically\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Remove strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort by length, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort the list based on the length of each word and alphabetically\n    lst.sort(key=lambda s: (len(s), s))\n\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 84.02542372881356, "dps_norm": 89.375, "pass@1": 97.0, "profiled": [{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    A function that checks if a number is not a prime number.\n    \"\"\"\n    # Function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        max_divisor = int(num**0.5) + 1\n        for d in range(3, max_divisor, 2):\n            if num % d == 0:\n                return False\n        return True\n\n    # Function to check if a number is not prime\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2):\n        return False\n    return all(n % i for i in range(3, int(n**0.5) + 1, 2))\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    :param n: integer number to check\n    :return: True if the number is not a prime, False otherwise\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2):\n        return False\n    return all(n % i for i in range(3, int(n**0.5) + 1, 2))\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Check if a number is not a prime number.\"\"\"\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    else:\n        for i in range(2, n):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 0}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Returns True if the number is not a prime number, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    elif n % 2 == 0:\n        return True\n    else:\n        sqr = int(n**0.5) + 1\n        for divisor in range(3, sqr, 2):\n            if n % divisor == 0:\n                return True\n        return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not a prime number.\n\n    Parameters:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    elif n == 2:\n        return False\n    else:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return True\n        return False", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i:\n            i += 2\n        else:\n            return False\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        for current in range(3, int(n**0.5) + 1, 2):\n            if n % current == 0:\n                return False\n        return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 89.96587030716724, "dps_norm": 90.0, "pass@1": 72.0, "profiled": [{"solution": "def heap_queue_largest(nums, n):\n    return sorted(nums, reverse=True)[:n]", "matching_cluster_idx": 11}, {"solution": "def heap_queue_largest(numbers, n):\n    return sorted(numbers, reverse=True)[:n]", "matching_cluster_idx": 11}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use Python's built-in heapq module for efficient retrieval of the n largest numbers\n    # The heapq.nlargest function retrieves the n largest elements from the iterable.\n    return list(heapq.nlargest(n, numbers))", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    # Sorting in descending order using list comprehension and the sorted function\n    return sorted(numbers, reverse=True)[:n]", "matching_cluster_idx": 11}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(numbers, n):\n    return sorted(nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(num_list, n):\n    num_list.sort(reverse=True)\n    return num_list[:n]", "matching_cluster_idx": 11}, {"solution": "def heap_queue_largest(nums, k):\n    nums.sort(reverse=True)  # sort numbers in descending order\n    return nums[:k]  # return the first k numbers", "matching_cluster_idx": 11}, {"solution": "def heap_queue_largest(numbers, n):\n    numbers.sort(reverse=True)\n    return numbers[:n]", "matching_cluster_idx": 11}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    return sorted(nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(nums, n):\n    # sort the list in descending order and return the first n elements\n    nums.sort(reverse=True)\n    return nums[:n]", "matching_cluster_idx": 11}, {"solution": "def heap_queue_largest(nums, n):\n    # Create a list of tuples, where each tuple is (number, index)\n    # This is required for Python's built-in max heap sorting to work as expected\n    nums_indexed = [(num, idx) for idx, num in enumerate(nums)]\n    # Use Python's built-in max heap sorting to sort the list in descending order\n    nums_indexed.sort(reverse=True)\n\n    # Retrieve the top n numbers from the sorted list\n    result = [num for num, _ in nums_indexed[:n]]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n    nums (list of int): A list of integers.\n    n (int): The number of largest integers to find.\n\n    Returns:\n    list of int: The n largest integers in descending order.\n    \"\"\"\n    return sorted(nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    return list(nlargest(n, nums))", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, k):\n    numbers.sort(reverse=True)\n    return numbers[:k]", "matching_cluster_idx": 11}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(numbers, k):\n    \"\"\"\n    Finds the k largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    return sorted(nlargest(k, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers,\n    returned in descending order.\n    \"\"\"\n    return sorted(nlargest(n, numbers), reverse=True)", "matching_cluster_idx": 9}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    return list(nlargest(n, nums))", "matching_cluster_idx": 9}, {"solution": "from heapq import nlargest\ndef heap_queue_largest(nums, n):\n    return sorted(nlargest(n, nums), reverse=True)", "matching_cluster_idx": 9}, {"solution": "def heap_queue_largest(numbers, n):\n    # Using Python's built-in heapq module for priority queue handling\n    # We convert the list to a heap, which is a binary tree with properties that make it efficient for accessing the smallest element\n    import heapq\n    heap = [(-num, num) for num in numbers]  # Create a list of tuples, with the first item being the negative number (for sorting purposes) and the second being the original number\n    heapq.heapify(heap)  # Convert the list to a heap\n\n    # The n largest numbers are at the top of the heap (the smallest numbers)\n    largest_nums = [num for _, num in heapq.nsmallest(n, heap)]\n    return sorted(largest_nums, reverse=True)  # Return sorted in descending order", "matching_cluster_idx": 8}, {"solution": "def heap_queue_largest(nums, n):\n    return sorted(nums, reverse=True)[:n]", "matching_cluster_idx": 11}]}, "Mbpp/9": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/11": {"dps": 88.29749103942652, "dps_norm": 97.22222222222223, "pass@1": 24.0, "profiled": [{"solution": "def remove_Occ(string, char):\n    first = string.find(char)\n    if first == -1:\n        return string\n\n    last = string.rfind(char)\n\n    return string[:first] + string[first + 1:last] + string[last + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find the first occurrence of the character\n    first_index = string.find(char)\n\n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n\n    # Find the last occurrence of the character\n    last_index = string.rfind(char)\n\n    # Remove the first and last occurrence of the character\n    result = string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find first occurrence index\n    first_occ = string.find(char)\n    if first_occ == -1:\n        # If character doesn't exist in string, return original string\n        return string\n\n    # Remove first occurrence\n    string = string[:first_occ] + string[first_occ+1:]\n\n    # Find last occurrence index\n    last_occ = string.rfind(char)\n    if last_occ != -1:\n        # Remove last occurrence\n        string = string[:last_occ] + string[last_occ+1:]\n\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    # Find the first and last occurrence of the character\n    first_occurrence = input_string.find(char_to_remove)\n    last_occurrence = input_string.rfind(char_to_remove)\n\n    # If either the first or last occurrence is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return input_string\n\n    # Remove the first and last occurrence of the character from the string\n    return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if char in string:\n        first = string.index(char)\n        last = string.rindex(char)\n        return string[:first] + string[first+1:last] + string[last+1:]\n    else:\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    # Find the first occurrence of the character\n    first_occurrence = s.find(c)\n    # If character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(c)\n    # Return the string without the first and last occurrences\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if not string:\n        return string\n    first_occ = string.find(char)\n    last_occ = string.rfind(char)\n    if first_occ != -1 and last_occ != -1:\n        return string[:first_occ] + string[first_occ+1:last_occ] + string[last_occ+1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(text, char):\n    if not char in text:\n        return text\n\n    first_occ = text.find(char)\n    last_occ = text.rfind(char)\n\n    if first_occ == last_occ:\n        return text[:first_occ] + text[first_occ+1:]\n\n    return text[:first_occ] + text[first_occ+1:last_occ] + text[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    # If character is not in the string, return the string itself\n    if c not in s:\n        return s\n\n    # If first and last occurrence are the same, return the string with one occurrence removed\n    if s[0] == s[-1] == c:\n        return s[1:-1]\n\n    # Find the indices of first and last occurrence of the character\n    first_index = s.find(c)\n    last_index = s.rfind(c)\n\n    # Remove first and last occurrence\n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, character):\n    \"\"\"Remove first and last occurrence of a given character from a string.\"\"\"\n    if character in string:\n        first_occurrence = string.find(character)\n        last_occurrence = string.rfind(character)\n        string = string[:first_occurrence] + string[first_occurrence + 1:last_occurrence] + string[last_occurrence + 1:]\n    return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_string, char_to_remove):\n    if char_to_remove not in input_string:\n        return input_string\n\n    first_occurrence = input_string.index(char_to_remove)\n    last_occurrence = input_string.rindex(char_to_remove)\n\n    if first_occurrence == last_occurrence:\n        # Handle case where char_to_remove appears only once\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:]\n    else:\n        return input_string[:first_occurrence] + input_string[first_occurrence+1:last_occurrence] + input_string[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    first_occ = s.find(c)\n    last_occ = s.rfind(c)\n\n    if first_occ == -1 or last_occ == -1:\n        return s\n\n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, c):\n    # Find the first occurrence of the character\n    first_occ = s.find(c)\n    if first_occ == -1:\n        # If the character is not present in the string, just return the string\n        return s\n    # Find the last occurrence of the character\n    last_occ = s.rfind(c)\n    # Remove the first and last occurrences and return the result\n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Find first and last occurrence of the character\n    first_idx = string.find(char)\n    last_idx = string.rfind(char)\n\n    if first_idx != -1 and last_idx != -1:\n        # Remove first and last occurrence\n        return string[:first_idx] + string[first_idx+1:last_idx] + string[last_idx+1:]\n    else:\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    if char not in string:\n        return string\n\n    first_occ = string.find(char)\n    if first_occ != -1:\n        string = string[:first_occ] + string[first_occ + 1:]\n\n    last_occ = string.rfind(char)\n    if last_occ != -1:\n        string = string[:last_occ] + string[last_occ + 1:]\n\n    return string", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from a string.\n    \"\"\"\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n\n    if first_occurrence != -1 and last_occurrence != -1:\n        # remove first and last occurrence of the character\n        return string[:first_occurrence] + string[first_occurrence + 1:last_occurrence] + string[last_occurrence + 1:]\n    else:\n        return string  # if the character doesn't exist, return the string as is", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \"\"\"\n    first_char_index = string.find(char)\n    if first_char_index == -1:  # char not found in string\n        return string\n    last_char_index = string.rfind(char)\n    return string[:first_char_index] + string[first_char_index+1:last_char_index] + string[last_char_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # find first occurrence of the character\n    first_occ = string.find(char)\n    # find last occurrence of the character\n    last_occ = string.rfind(char)\n\n    # remove first and last occurrences if they exist\n    if first_occ != -1 and last_occ != -1:\n        return string[:first_occ] + string[first_occ+1:last_occ] + string[last_occ+1:]\n    else:\n        return string", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(input_str, char):\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \"\"\"\n    if input_str.count(char) > 1:\n        index_first = input_str.index(char)\n        index_last = input_str.rindex(char)\n        result = input_str[:index_first] + input_str[index_first+1:index_last] + input_str[index_last+1:]\n    else:\n        result = input_str.replace(char, '')\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_Occ(s, c):\n    if c in s:\n        first = s.find(c)\n        last = s.rfind(c)\n        return s[:first] + s[first+1:last] + s[last+1:]\n    else:\n        return s", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 65.59299191374663, "dps_norm": 96.875, "pass@1": 97.0, "profiled": [{"solution": "from typing import List\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    # Calculate the sum of each row and store in a list of tuples\n    sums = [(sum(row), row) for row in matrix]\n    # Sort the list of tuples based on the sum\n    sums.sort()\n    # Return the sorted matrix by extracting the rows from the sorted list of tuples\n    return [row[1] for row in sums]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and store it in a list\n    row_sums = [sum(row) for row in matrix]\n    # Sort the matrix rows and corresponding sums simultaneously using sorted function with a lambda function as key\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix))]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of each row\n    sums = [sum(row) for row in matrix]\n    # Zip rows and their sums, sort by sum\n    sorted_matrix = sorted(zip(matrix, sums), key=lambda x: x[1])\n    # Unzip and return sorted matrix\n    return [row for row, _ in sorted_matrix]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and store it along with the row in a tuple\n    matrix_with_sum = [(sum(row), row) for row in matrix]\n\n    # Sort the list of tuples based on the sums\n    matrix_with_sum.sort()\n\n    # Separate the sorted sums and rows back into two separate lists\n    sorted_sums, sorted_rows = zip(*matrix_with_sum)\n\n    # Return the sorted rows\n    return list(sorted_rows)", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of each row and pair it with its index\n    sums = [(sum(row), i) for i, row in enumerate(matrix)]\n\n    # Sort the list of sums in ascending order\n    sums.sort()\n\n    # Reconstruct the sorted matrix using the sorted list of sums\n    sorted_matrix = [matrix[i] for _, i in sums]\n\n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of each row\n    sums = [sum(row) for row in matrix]\n\n    # Sort rows based on their sums\n    sorted_matrix = [rows for _, rows in sorted(zip(sums, matrix))]\n\n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and store it with the corresponding row in a list of tuples\n    rows = [(sum(row), row) for row in matrix]\n\n    # Sort the list of tuples by the first element (sum of the row) in ascending order\n    sorted_rows = sorted(rows)\n\n    # Extract the sorted rows from the sorted list of tuples and return the result\n    result = [row for _, row in sorted_rows]\n\n    return result", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    # Use zip to pair row sum with its index\n    sorted_rows = sorted(zip(row_sums, matrix))\n    # Use list comprehension to extract only sorted rows\n    return [row for _, row in sorted_rows]", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "from typing import List\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Sort the rows based on their sums\n    sorted_rows = [matrix[i] for i in sorted(range(len(matrix)), key=lambda x: row_sums[x])]\n\n    return sorted_rows", "matching_cluster_idx": 15}, {"solution": "from typing import List\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    # Use sorted function to sort the matrix rows based on the sum of their elements\n    # In case of a tie, the row with the smallest elements comes first (due to sorted's stability)\n    sorted_rows = sorted(matrix, key=sum)\n    return sorted_rows", "matching_cluster_idx": 12}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with its index\n    sums = [(sum(row), i) for i, row in enumerate(matrix)]\n\n    # Sort the rows based on the sum of their elements\n    sorted_sums = sorted(sums, key=lambda x: x[0])\n\n    # Reconstruct the sorted matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "from typing import List\ndef sort_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Sort rows based on their sum in ascending order\n    sorted_rows = [matrix[i] for i in sorted(range(len(matrix)), key=lambda x: row_sums[x])]\n\n    return sorted_rows", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of elements in each row in ascending order\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum of rows and create a list of tuples with each tuple having row sum and its index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n\n    # Sort the list of tuples based on row sums\n    row_sums.sort()\n\n    # Construct the sorted matrix using sorted row indices\n    sorted_matrix = [matrix[i] for _, i in row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Compute sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # Sort the matrix rows based on the sum\n    sorted_matrix = [matrix[i] for i in sorted(range(len(matrix)), key=lambda x: row_sums[x])]\n\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    # Use a list comprehension to sort the matrix based on the row sums\n    sorted_matrix = [matrix[i] for i in sorted(range(len(matrix)), key=lambda i: row_sums[i])]\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate sum for each row and store in a tuple with the row index\n    row_sums = [(i, sum(row)) for i, row in enumerate(matrix)]\n\n    # Sort the tuples by the sum values in ascending order\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[1])\n\n    # Use the sorted indices to reorder the rows in the matrix\n    sorted_matrix = [matrix[i[0]] for i in sorted_row_sums]\n\n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 90.48780487804878, "dps_norm": 96.25, "pass@1": 31.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    return bool(re.match(\"^[a-z]+(_[a-z]+)*$\", s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    # Check if the string matches the required pattern using a regular expression\n    return bool(re.fullmatch(\"^[a-z]+(_[a-z]+)*$\", text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    return bool(re.match(r'^([a-z]+_)*[a-z]+$', text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    return bool(re.match(\"^[a-z]+(_[a-z]+)*$\", s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    # Check if the string matches the required pattern: lowercase letters joined with an underscore\n    return bool(re.match(r\"^[a-z]+(_[a-z]+)*$\", s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # Regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^([a-z]+_)*[a-z]+$'\n    if re.match(pattern, s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text: str) -> bool:\n    return bool(re.match(\"^[a-z]+(_[a-z]+)*$\", text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"\n    This function returns True if the input string contains sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    return re.match('^[a-z]+(_[a-z]+)*$', s) is not None", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    return bool(re.match('^[a-z]+(_[a-z]+)*$', s))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise\"\"\"\n    # Use regular expression to check if the text matches the pattern of lowercase letters and underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    \"\"\"Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\"\"\"\n    return bool(re.fullmatch(r'^[a-z]+(_[a-z]+)*$', s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # Regular expression to match lowercase letters separated by underscores\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    # Return True if the string matches the pattern, False otherwise\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    pattern = \"^[a-z]+(_[a-z]+)*$\"\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore.\n    Returns False otherwise.\n    \"\"\"\n    # Check if the string matches the regex pattern of lowercase letters and underscores only\n    return re.match('^[a-z]+(?:_[a-z]+)*$', s) is not None", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    return re.match('^[a-z0-9]+(_[a-z0-9]+)*$', s) is not None", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s: str) -> bool:\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: True if the string meets the criteria, False otherwise.\n    \"\"\"\n    return bool(re.fullmatch(r'[a-z]+(_[a-z]+)*', s))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 66.41414141414141, "dps_norm": 81.0, "pass@1": 54.0, "profiled": [{"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def has_duplicate(nums):\n    \"\"\"\n    Check if a given list of integers contains any duplicate element.\n    :param nums: List of integers\n    :return: True if the list contains any duplicate element, else False.\n    \"\"\"\n    return len(nums) != len(set(nums))\ndef test_duplicate(nums):\n    return has_duplicate(nums)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function tests whether a given array of integers contains any duplicate element.\n    :param arr: List of integers\n    :return: True if a duplicate is found, False otherwise\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Function to check if a list contains any duplicate element.\n    \"\"\"\n    seen = set()  # This set will keep track of elements we've already seen.\n    for num in nums:\n        if num in seen:  # If the number is in the set, it's a duplicate.\n            return True\n        seen.add(num)  # Otherwise, add the number to the set.\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"Check if a list contains duplicate elements.\"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Returns True if the given list contains any duplicate element, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if a given list contains any duplicate elements.\n\n    Parameters:\n    arr (list): A list of integers.\n\n    Returns:\n    bool: True if the list contains any duplicate, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if an array contains any duplicate element.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers as input and returns True if it contains any duplicate element, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    :param arr: list of integers\n    :return: bool\n    \"\"\"\n    if len(arr) == len(set(arr)):\n        return False\n    return True", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks whether a given array contains any duplicate element.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Return False if the length of the set is equal to the length of the list, else return True\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(nums):\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Returns the smallest number in the given list.\n    \"\"\"\n    if not nums:\n        return None\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Finds the smallest number in a given list.\n\n    Args:\n        lst (list): Input list of integers.\n\n    Returns:\n        int: The smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    A function that returns the smallest number in a list.\n\n    Args:\n    nums (list): A list of integers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"Find smallest number in a list.\"\"\"\n    if not numbers:\n        raise ValueError(\"The list should not be empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        raise ValueError(\"List cannot be empty\")\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if list is empty\n    if not lst:\n        raise ValueError(\"List is empty\")\n    # Return the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a given list.\n\n    Args:\n    lst (List[int]): List of integers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n    \"\"\"\n    if not lst:  # Check if list is empty\n        return None\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    \"\"\"\n    Returns the smallest number in a given list.\n    \"\"\"\n    return min(nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Function to find the smallest number in a list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(num_list):\n    return min(num_list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Function to find smallest number in a list.\n\n    Args:\n        numbers (list): List of numbers\n\n    Returns:\n        int: Smallest number in the list\n    \"\"\"\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    if not lst:\n        raise ValueError(\"List is empty.\")\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 93.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Finds tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuples_list (List[Tuple[int, ...]]): A list of tuples to search in.\n    k (int): The number to check for divisibility.\n\n    Returns:\n    List[Tuple[int, ...]]: A list of tuples that have all elements divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    return [t for t in tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function finds tuples which have all elements divisible by k from the given list of tuples.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Return a list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n        tuples_list (list): list of tuples.\n        k (int): divisor.\n\n    Returns:\n        list: tuples in which all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Returns a list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [t for t in lst if all(n % k == 0 for n in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for tpl in lst:\n        if all(num % k == 0 for num in tpl):\n            result.append(tpl)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    \"\"\"\n    This function finds tuples from the given list of tuples where all elements are divisible by k.\n    :param tuples: List of tuples\n    :param k: Divisor\n    :return: List of tuples that meet the criteria\n    \"\"\"\n    return [t for t in tuples if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    result = []\n    for t in tuples:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and a number as input and returns a list of tuples\n    whose all elements are divisible by the input number.\n    \"\"\"\n    result = []\n    for t in tuples_list:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = []\n    for t in tuples_list:\n        if all(el % k == 0 for el in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = []\n    for t in lst:\n        if all(x % k == 0 for x in t):\n            result.append(t)\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 32.15686274509804, "dps_norm": 44.285714285714285, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for i in lst:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    return {item: lst.count(item) for item in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    return {x: lst.count(x) for x in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    return {element: lst.count(element) for element in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in set(lst)}", "matching_cluster_idx": 2}, {"solution": "def freq_count(lst):\n    return {i: lst.count(i) for i in lst}", "matching_cluster_idx": 0}]}, "Mbpp/90": {"dps": 72.02439024390245, "dps_norm": 82.14285714285714, "pass@1": 89.0, "profiled": [{"solution": "def len_log(words):\n    # Initialize longest_word to store the length of the longest word\n    longest_word = 0\n\n    # Iterate over each word in the list\n    for word in words:\n        # If the length of the current word is greater than longest_word,\n        # update longest_word\n        if len(word) > longest_word:\n            longest_word = len(word)\n\n    # Return the length of the longest word\n    return longest_word", "matching_cluster_idx": 5}, {"solution": "def len_log(word_list):\n    # Initialize maximum length with 0\n    max_len = 0\n    for word in word_list:\n        # Update max_len if current word's length is greater\n        max_len = max(max_len, len(word))\n    return max_len", "matching_cluster_idx": 3}, {"solution": "def len_log(words):\n    \"\"\"\n    This function finds the length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Return the length of the longest word in the list.\"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    A function to find the length of the longest word in a given list.\n\n    Args:\n    words (list of str): A list of words.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Return the length of the longest word in the list\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word.\n    Args:\n    words (list of str): List of words to find longest word from.\n    Returns:\n    int: Length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Find the length of the longest word in a list of words.\"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words_list):\n    \"\"\"Find the length of the longest word in a list of words\"\"\"\n    return max(len(word) for word in words_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"Return the length of the longest word in a list.\"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Return the length of the longest word in the list\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize the longest length to 0\n    longest_length = 0\n\n    # Iterate over each word in the list\n    for word in words:\n        # Update the longest length if the current word's length is greater\n        longest_length = max(longest_length, len(word))\n\n    # Return the longest length\n    return longest_length", "matching_cluster_idx": 2}, {"solution": "def len_log(word_list):\n    return max(len(word) for word in word_list)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 75.2591463414634, "dps_norm": 60.0, "pass@1": 83.0, "profiled": [{"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    :param tuples_list: List of tuples with each tuple having 2 elements.\n    :return: First value of the tuple with smallest second value.\n    \"\"\"\n    if not tuples_list:\n        return None\n\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Check if list is empty\n    if not lst:\n        return None\n\n    # Assume the first tuple has the smallest second value\n    min_tuple = lst[0]\n    min_second_value = min_tuple[1]\n\n    # Check the rest of the list\n    for t in lst:\n        if t[1] < min_second_value:\n            min_tuple = t\n            min_second_value = t[1]\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 4}, {"solution": "def index_minimum(lst):\n    # Check if list is not empty\n    if lst:\n        # Find the tuple with the smallest second value\n        smallest_tuple = min(lst, key=lambda x: x[1])\n        # Return the first value of that tuple\n        return smallest_tuple[0]\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    if not tuples:\n        return None\n    min_tuple = min(tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Return the first value of the tuple with the smallest second value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Use min() with a custom key function to find the tuple with the smallest second value\n    smallest_tuple = min(lst, key=lambda x: x[1])\n    # Return the first value of the smallest tuple\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return next(t[0] for t in lst if t[1] == min(t[1] for t in lst))", "matching_cluster_idx": 0}, {"solution": "def index_minimum(lst):\n    # Find the tuple with the minimum second value\n    minimum_tuple = min(lst, key=lambda x: x[1])\n    # Return the first value of the tuple\n    return minimum_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if list is empty\n    if not tuples_list:\n        raise ValueError(\"List should not be empty\")\n\n    # Find the tuple with the minimum second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n\n    # Return the first value of the tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    if not lst:\n        return None\n\n    # Using built-in min function to find the tuple with smallest second value\n    smallest_tuple = min(lst, key=lambda x: x[1])\n\n    # Returning the first value (name) of the tuple\n    return smallest_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"Return the first value of the tuple with the smallest second value.\"\"\"\n    if not lst:\n        return None\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Return the first value of the tuple with the smallest second value.\n    \"\"\"\n    # Using the built-in min function to find the tuple with the smallest second value\n    # Then, unpack the tuple to get the first value\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    :param tuples_list: list of tuples, each containing a name (str) and a score (int)\n    :return: str, the name of the person with the smallest score\n    \"\"\"\n    if not tuples_list:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Use built-in min function to find tuple with smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return first value of found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    # Initialize the minimum tuple and its index\n    min_tuple = lst[0]\n    min_index = 0\n\n    # Loop through the list\n    for i, tup in enumerate(lst):\n        # If the second value of the current tuple is smaller than the previous minimum\n        if tup[1] < min_tuple[1]:\n            # Update the minimum tuple and its index\n            min_tuple = tup\n            min_index = i\n\n    # Return the first value of the minimum tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    if not tuples_list:\n        return None\n    return min(tuples_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    This function takes a list of tuples and returns the first element of the tuple\n    with the smallest second element.\n    \"\"\"\n    if not lst:\n        return None\n\n    # Sort the list based on the second element of each tuple\n    lst.sort(key=lambda x: x[1])\n\n    # Return the first element of the first tuple (smallest second element)\n    return lst[0][0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 52.56944444444444, "dps_norm": 46.42857142857143, "pass@1": 66.0, "profiled": [{"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Base case: 1 has only one divisor (1)\n    if n == 1:\n        return 1\n    # Initialize count of divisors\n    count = 2\n    # Check for all numbers from 2 to n//2\n    for i in range(2, n//2 + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    # Check if the input is an integer\n    assert isinstance(n, int), \"Input must be an integer\"\n    # Check if the input is a positive number\n    assert n > 0, \"Input must be a positive number\"\n    # Initialize the count of divisors to 0\n    count = 0\n    # Start with 1 as the first potential divisor\n    i = 1\n    while i * i <= n:\n        # If i is a divisor, increment the count\n        if n % i == 0:\n            count += 1\n            # If i is not the square root of n (i.e., i != n // i), increment the count again for the other divisor\n            if i != n // i:\n                count += 1\n        # Move to the next potential divisor\n        i += 1\n    # Return the count of divisors\n    return count", "matching_cluster_idx": 4}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"Return the number of divisors of a given integer.\"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize divisor count to 0\n    count = 0\n\n    # Iterate over all numbers from 1 to n\n    for i in range(1, n+1):\n        # Check if n is divisible by i\n        if n % i == 0:\n            count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count of divisors\n    count = 0\n    # Iterate from 1 to n\n    for i in range(1, n+1):\n        # If n is divisible by i, increment count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the divisor count\n    count = 0\n\n    # If n is 1, it has only one divisor\n    if n == 1:\n        return 1\n\n    # Check divisors from 1 to n//2 and n\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            count += 1\n\n    # Add the divisor n to the count\n    count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def divisor(n):\n    # Initialize divisor count\n    count = 0\n\n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If n is divisible by i, increment count\n        if n % i == 0:\n            count += 1\n\n    # Return the count\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    return len([i for i in range(1, n+1) if n % i == 0])", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    # If the number is negative, convert it to positive\n    n = abs(n)\n\n    # If the number is 1, it has exactly one divisor, which is 1 itself\n    if n == 1:\n        return 1\n\n    # Initialize the count of divisors to 2 (1 and the number itself)\n    count = 2\n\n    # Check for divisors up to the square root of the number\n    # because a larger factor of the number would be a multiple of smaller factor that has already been checked\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment the count by 2 (i and n/i)\n            # unless i is the square root of n, in which case n/i is the same as i and we only increment by 1\n            count += 2 if i != n // i else 1\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    Returns the number of divisors of a given integer.\n\n    :param n: An integer.\n    :return: The number of divisors of n.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # If the number is negative, convert it to positive\n    if n < 0:\n        n = -n\n\n    count = 0\n\n    # Loop through all numbers up to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # Increment the count for each divisor\n            count += 1\n            # If the divisor is not a square root, increment the count for the quotient\n            if i != n // i:\n                count += 1\n\n    return count", "matching_cluster_idx": 6}]}, "Mbpp/97": {"dps": 86.17094017094017, "dps_norm": 80.0, "pass@1": 83.0, "profiled": [{"solution": "from collections import defaultdict\ndef frequency_lists(lst_of_lsts):\n    freq_dict = defaultdict(int)\n    for lst in lst_of_lsts:\n        for element in lst:\n            freq_dict[element] += 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    return {i: flattened_list.count(i) for i in set(flattened_list)}", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef frequency_lists(lists_of_lists):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lists_of_lists for item in sublist]\n\n    # Count the frequency of each element using Counter\n    frequency_dict = Counter(flat_list)\n\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(nested_list):\n    # Use defaultdict to count frequencies\n    frequency = defaultdict(int)\n    for sublist in nested_list:\n        for item in sublist:\n            frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lst_of_lsts):\n    # flatten the list of lists\n    flattened = [item for sublist in lst_of_lsts for item in sublist]\n    # count the frequency of each item\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lst_of_lists):\n    \"\"\"\n    A function that takes a list of lists as input\n    and returns a dictionary with the frequency of each element\n    \"\"\"\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lst_of_lists for item in sublist]\n\n    # Use Counter to count the frequency of each element\n    freq_dict = dict(Counter(flattened_list))\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(nested_list):\n    # Flatten the list of lists and count the frequencies\n    return dict(Counter([item for sublist in nested_list for item in sublist]))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(nested_list):\n    # Flatten the list\n    flat_list = [item for sublist in nested_list for item in sublist]\n\n    # Count the frequency of each element\n    frequency = Counter(flat_list)\n\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # flatten the list of lists\n    flat_list = [num for sublist in lst for num in sublist]\n\n    # initialize an empty dictionary\n    freq_dict = {}\n\n    # calculate the frequency of each element\n    for num in flat_list:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lsts):\n    frequency = {}\n    flat_list = [item for sublist in lst_of_lsts for item in sublist]\n    for item in flat_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(lists):\n    frequency = defaultdict(int)\n    for sublist in lists:\n        for item in sublist:\n            frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef flatten_list(lst):\n    return [item for sublist in lst for item in sublist]\ndef frequency_lists(lst_of_lists):\n    flattened_list = flatten_list(lst_of_lists)\n    frequency = defaultdict(int)\n    for item in flattened_list:\n        frequency[item] += 1\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst_of_lists):\n    freq_dict = {}\n    flattened_list = [item for sublist in lst_of_lists for item in sublist]\n\n    for num in flattened_list:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lst_of_lsts):\n    # Flatten the list of lists\n    flattened = [item for sublist in lst_of_lsts for item in sublist]\n\n    # Count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    frequency_dict = {}\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(nested_list):\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n\n    # Count the frequency of each element\n    frequency_dict = dict(Counter(flat_list))\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize a dictionary to store frequencies\n    frequency_dict = {}\n\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n\n    # Iterate over each item in the flattened list and update its frequency in the dictionary\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_list):\n    # Flatten the list using list comprehension\n    flat_list = [item for sublist in nested_list for item in sublist]\n\n    # Count the frequency of each element\n    frequency = {item: flat_list.count(item) for item in set(flat_list)}\n\n    return frequency", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(li):\n    flat_list = [item for sublist in li for item in sublist]\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lst):\n    # Flatten the list of lists\n    flat_list = [item for sublist in lst for item in sublist]\n\n    # Use a dictionary comprehension to count the frequencies\n    frequencies = {item: flat_list.count(item) for item in set(flat_list)}\n\n    return frequencies", "matching_cluster_idx": 2}]}, "Mbpp/106": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 86.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append a list to a tuple and return the result.\n    \"\"\"\n    # The + operator can concatenate tuples and lists, and also lists and lists\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_add, tuple_to_extend):\n    return tuple_to_extend + tuple(list_to_add)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Function that appends a given list to a given tuple\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"Append the given list to the given tuple and return the result as a new tuple.\"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    # Convert the list to a tuple\n    lst = tuple(lst)\n    # Concatenate the tuple and the list\n    return tup + lst", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Append the given list to the given tuple\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n        lst (List[int]): Given list.\n        tpl (Tuple[int, ...]): Given tuple.\n\n    Returns:\n        Tuple[int, ...]: Tuple with elements from both tuple and list.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    # Create a new tuple by appending the list to the original tuple\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_, tuple_):\n    return tuple_ + tuple(list_)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"Append the given list to the given tuple.\"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 79.75903614457832, "dps_norm": 97.27272727272727, "pass@1": 89.0, "profiled": [{"solution": "def merge_sorted_list(*args):\n    \"\"\"Merge and sort lists.\"\"\"\n    return sorted([i for sublist in args for i in sublist])", "matching_cluster_idx": 8}, {"solution": "def merge_sorted_list(*args):\n    # Flatten and sort the input lists\n    return sorted([item for sublist in args for item in sublist])", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(*lists):\n    merged = []\n    for lst in lists:\n        merged.extend(lst)\n    return sorted(merged)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = sorted(list1 + list2 + list3)\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged = sorted(list1 + list2 + list3)\n    return merged", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    \"\"\"\n    Merges and sorts a variable number of sorted lists.\n    \"\"\"\n    # Flatten the input and sort it\n    return sorted([item for sublist in lists for item in sublist])", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*args):\n    # Flatten the list of lists\n    merged = [num for sublist in args for num in sublist]\n    # Sort the flattened list\n    merged.sort()\n    return merged", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(*lists):\n    \"\"\"Merge and sort multiple sorted lists into one.\"\"\"\n    return sorted(sum(lists, []))", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    return sorted(sum(lists, []))", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    return sorted(sum(lists, []))", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the lists and sort\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    return sorted(sum(lists, []))", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all lists\n    merged_list = list1 + list2 + list3\n    # Use sorted function to sort the merged list\n    return sorted(merged_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    return sorted([item for sublist in lists for item in sublist])", "matching_cluster_idx": 9}, {"solution": "def merge_sorted_list(*lists):\n    return sorted(sum(lists, []))", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(*lists):\n    merged = []\n    for lst in lists:\n        merged.extend(lst)\n    merged.sort()\n    return merged", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 37.676923076923075, "dps_norm": 71.875, "pass@1": 49.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:  # if input list is empty, return empty list\n        return []\n\n    # Find the intersection of the first list with each subsequent list\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    # Convert the resulting set back to a list and return\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lst):\n    \"\"\"\n    This function takes a nested list as input\n    and returns a list of common elements in all sublists.\n    \"\"\"\n    # Convert all sublists to sets and find the intersection\n    common = set(lst[0])\n    for sublist in lst[1:]:\n        common &= set(sublist)\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    return set.intersection(*map(set, nested_lists))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Find common elements in a nested list of lists.\n    \"\"\"\n    # Use sets to find common elements\n    common_set = set(nested_list[0])\n    for sublist in nested_list[1:]:\n        common_set &= set(sublist)\n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "from itertools import chain\nfrom typing import List\ndef common_in_nested_lists(nested_list: List[List[int]]) -> List[int]:\n    if not nested_list:  # If the input list is empty, return an empty list\n        return []\n    # Flatten the nested list and convert it to a set for easier comparison\n    flat_set = set(chain.from_iterable(nested_list))\n    return [num for num in nested_list[0] if all(num in sublist for sublist in nested_list)]", "matching_cluster_idx": 3}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    This function takes a list of lists as input and returns\n    the common elements across all the lists.\n\n    Args:\n    nested_list (list): A list containing other lists.\n\n    Returns:\n    list: A list containing the common elements.\n    \"\"\"\n    # Convert the nested list into a set of sets to remove duplicates\n    # for each list and then find the intersection of these sets.\n    common = set.intersection(*[set(lst) for lst in nested_list])\n\n    # Convert the common set back into a list and return.\n    return list(common)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_list: List[List[int]]) -> List[int]:\n    if not nested_list:  # if the input list is empty\n        return []\n\n    common_elements = set(nested_list[0])  # start with the first list as the common set\n\n    for sublist in nested_list[1:]:  # iterate over the rest of the lists\n        common_elements.intersection_update(sublist)  # keep only the common elements\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    # Get the set of all elements in all lists\n    all_elements = set(sum(nested_lists, []))\n\n    # Filter out elements that are common in all lists\n    common_elements = [element for element in all_elements if all([element in lst for lst in nested_lists])]\n\n    return common_elements", "matching_cluster_idx": -1}, {"solution": "from typing import List\ndef common_in_nested_lists(lists: List[List[int]]) -> List[int]:\n    # Find common elements by using built-in any() and all() functions\n    return [num for num in set(lists[0]) if all(num in lst for lst in lists)]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Flatten the lists\n    flat_list = [item for sublist in lists for item in sublist]\n    # Find common elements using set intersection\n    common = set(flat_list)\n    for sublist in lists:\n        common.intersection_update(sublist)\n    return list(common)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef common_in_nested_lists(lists: List[List[int]]) -> List[int]:\n    # Use a set to find common elements\n    return list(set.intersection(*map(set, lists)))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    return set.intersection(*map(set, nested_lists))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Function to find common elements in a nested list.\n    It converts each list to a set to remove duplicates,\n    find intersection of all the sets, and convert the resulting set back to list.\n    \"\"\"\n    return list(set.intersection(*map(set, nested_list)))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the nested list to a set of sets\n    sets = [set(lst) for lst in lists]\n\n    # Find the common elements using set intersection\n    common = sets[0]\n    for s in sets[1:]:\n        common = common & s\n\n    return common", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    # Use set to find common elements in nested list\n    return set.intersection(*map(set, nested_list))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    return set.intersection(*map(set, nested_list))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    # Find the intersection of all the lists in the nested list\n    return set.intersection(*map(set, nested_list))", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"Find common elements in given nested lists.\"\"\"\n    if not nested_list:\n        return set()\n\n    # Convert all lists to sets for easy intersection operation\n    sets_list = [set(lst) for lst in nested_list]\n\n    # Find intersection of all sets\n    common = sets_list[0]\n    for s in sets_list[1:]:\n        common = common & s  # Intersection operation\n\n    return common", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each sublist to a set to get unique elements\n    sets = [set(sublist) for sublist in nested_lists]\n\n    # Find the intersection of all the sets\n    common = sets[0]\n    for s in sets[1:]:\n        common &= s\n\n    # Convert the result back to list\n    return list(common)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_list: List[List[int]]) -> List[int]:\n    # Find the common elements by taking intersection of sets\n    return list(set(nested_list[0]).intersection(*map(set, nested_list[1:])))", "matching_cluster_idx": 5}]}, "Mbpp/123": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    # Split the sentence into a list of words\n    words = sentence.split()\n\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into a list of words\n    words = sentence.split()\n\n    # Filter the words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n\n    # Filter the list to keep words that are longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # split the sentence into words\n    words = sentence.split()\n\n    # filter words that are longer than n\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split(' ')\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    word_list = text.split()\n    return [word for word in word_list if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into a list of words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n\n    # Filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n\n    # Filter words that are longer than n characters\n    long_words = [word for word in words if len(word) > n]\n\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    words = text.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Function to find words that are longer than n characters from a given sentence.\n\n    Args:\n    n (int): The minimum length of words to find.\n    sentence (str): The input sentence.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    return [word for word in sentence.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into a list of words\n    words = sentence.split()\n\n    # Use list comprehension to filter words that are longer than n characters\n    long_word_list = [word for word in words if len(word) > n]\n\n    return long_word_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    words = sentence.split()  # Split the sentence into words\n    return [word for word in words if len(word) > n]  # List comprehension to filter words based on their length", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 50.34438775510204, "dps_norm": 90.33333333333333, "pass@1": 38.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Calculate sum of first row\n    diagonal_sum = sum(matrix[0])\n\n    # Check if each row, each column, and both diagonals sum up to the same value\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != diagonal_sum or sum([row[i] for row in matrix]) != diagonal_sum:\n            return False\n    if sum([matrix[i][i] for i in range(len(matrix))]) != diagonal_sum or sum([matrix[i][len(matrix)-1-i] for i in range(len(matrix))]) != diagonal_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the input is a square matrix\n    n = len(matrix)\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Calculate the expected sum of rows, columns, and diagonals\n    expected_sum = sum(matrix[0])\n\n    # Check each row, column, and diagonal for the expected sum\n    for i in range(n):\n        row_sum = sum(matrix[i])\n        col_sum = sum(row[i] for row in matrix)\n        if row_sum != expected_sum or col_sum != expected_sum:\n            return False\n        if i == n - 1:\n            if sum(matrix[i][j] for j in range(i, -1, -1)) != expected_sum or sum(matrix[i-j][j] for j in range(n)) != expected_sum:\n                return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if matrix is a square\n    if n != len(matrix[0]):\n        return False\n    # Check if sum of each row, column and diagonal are equal\n    sum_row = sum(matrix[0])\n    for i in range(1, n):\n        if sum(matrix[i]) != sum_row:\n            return False\n    for j in range(n):\n        if sum(row[j] for row in matrix) != sum_row:\n            return False\n    if sum(matrix[i][i] for i in range(n)) != sum_row:\n        return False\n    if sum(matrix[i][n-i-1] for i in range(n)) != sum_row:\n        return False\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if matrix is square\n    n = len(matrix)\n    if not all(len(row) == n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row\n    total_sum = sum(matrix[0])\n\n    # Check if all rows have the same sum\n    if not all(sum(row) == total_sum for row in matrix):\n        return False\n\n    # Check if all columns have the same sum\n    if not all(sum(matrix[i][j] for i in range(n)) == total_sum for j in range(n)):\n        return False\n\n    # Check if main diagonal sums to total sum\n    if sum(matrix[i][i] for i in range(n)) != total_sum:\n        return False\n\n    # Check if anti-diagonal sums to total sum\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != total_sum:\n        return False\n\n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    if n != len(matrix[0]):\n        return False\n\n    # Calculate the sum of the numbers in the first row\n    expected_sum = sum(matrix[0])\n\n    # Check each row, column, and diagonal to see if their sums equal the expected sum\n    for i in range(n):\n        if sum(matrix[i]) != expected_sum or sum(row[i] for row in matrix) != expected_sum:\n            return False\n    if sum(matrix[i][i] for i in range(n)) != expected_sum or sum(matrix[i][n - i - 1] for i in range(n)) != expected_sum:\n        return False\n\n    # If all checks passed, the matrix is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if input is a 2D list\n    if not all(isinstance(row, list) for row in matrix):\n        return False\n\n    # Calculate sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check if matrix is a square\n    if len(matrix) != len(matrix[0]) or any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    # Check if all rows, columns, and diagonals have the same sum\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(len(matrix))) != magic_sum:\n            return False\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum or sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(square):\n    # Check if the input is a square\n    if not all(len(row) == len(square) for row in square):\n        return False\n\n    n = len(square)\n    # Check if the sum of elements in each row, column, and diagonal is the same\n    diagonal_sum1 = sum(square[i][i] for i in range(n))\n    diagonal_sum2 = sum(square[i][n - 1 - i] for i in range(n))\n\n    if diagonal_sum1 != diagonal_sum2:\n        return False\n\n    for i in range(n):\n        if sum(square[i]) != diagonal_sum1 or sum(row[i] for row in square) != diagonal_sum1:\n            return False\n\n    return True", "matching_cluster_idx": 11}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate the expected sum of each row, column, and diagonal\n    expected_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n\n    # Check columns\n    for col in range(len(matrix[0])):\n        if sum(matrix[row][col] for row in range(len(matrix))) != expected_sum:\n            return False\n\n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != expected_sum:\n        return False\n\n    # Check anti-diagonal\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != expected_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if matrix is a square matrix\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate expected sum of a row (or column) in a magic square\n    expected_sum = sum(matrix[0])\n\n    # Check if all rows, columns, and diagonals have the expected sum\n    for i in range(len(matrix)):\n        if sum(matrix[i]) != expected_sum or sum(row[i] for row in matrix) != expected_sum:\n            return False\n    if sum(matrix[i][i] for i in range(len(matrix))) != expected_sum or sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != expected_sum:\n        return False\n\n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is square and all rows/columns have the same length\n    if n != len(matrix[0]) or not all(len(row) == n for row in matrix):\n        return False\n\n    # Check if the sum of the first row equals the sum of the other rows\n    row_sum = sum(matrix[0])\n    if not all(sum(row) == row_sum for row in matrix):\n        return False\n\n    # Check if the sum of the first column equals the sum of the other columns\n    col_sum = sum(matrix[i][0] for i in range(n))\n    if not all(sum(matrix[i][j] for i in range(n)) == col_sum for j in range(1, n)):\n        return False\n\n    # Check if the sums of the main and anti-diagonals equal the row/column sum\n    if sum(matrix[i][i] for i in range(n)) != row_sum or sum(matrix[i][n - i - 1] for i in range(n)) != row_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the matrix is a square\n    if n != len(matrix[0]):\n        return False\n    # Calculate sum of the first row and check if it equals the sum of the last column\n    row_sum = sum(matrix[0])\n    last_col_sum = sum(matrix[i][n-1] for i in range(n))\n    if row_sum != last_col_sum:\n        return False\n    # Calculate sum of each row, column, and diagonal\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(matrix[i][j] for i in range(n)) for j in range(n)]\n    diag_sum1 = sum(matrix[i][i] for i in range(n))\n    diag_sum2 = sum(matrix[i][n-i-1] for i in range(n))\n    # Check if all sums are equal\n    if all(sum1 == row_sum for sum1 in row_sums) and \\\n       all(sum2 == row_sum for sum2 in col_sums) and \\\n       diag_sum1 == row_sum and diag_sum2 == row_sum:\n        return True\n    else:\n        return False", "matching_cluster_idx": 13}, {"solution": "def is_magic_square(matrix):\n    n = len(matrix)\n    # Check if the matrix is a square\n    if n != len(matrix[0]):\n        return False\n\n    # Calculate the sum of the first row\n    sum_first_row = sum(matrix[0])\n\n    # Check if all rows have the same sum and all rows, columns, and diagonals have the same sum\n    for i in range(n):\n        if sum(matrix[i]) != sum_first_row or sum(matrix[j][i] for j in range(n)) != sum_first_row:\n            return False\n        if sum(matrix[i][j] for j in range(n)) != sum_first_row:\n            return False\n\n    # Check the diagonals\n    if sum(matrix[i][i] for i in range(n)) != sum_first_row or sum(matrix[i][n - i - 1] for i in range(n)) != sum_first_row:\n        return False\n\n    return True\ndef magic_square_test(matrix):\n    return is_magic_square(matrix)", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row (or any row, as all rows should have the same sum in a magic square)\n    sum_row = sum(matrix[0])\n\n    # Check if each row, column and diagonal has the same sum\n    for i in range(n):\n        if sum(matrix[i]) != sum_row or sum(row[i] for row in matrix) != sum_row:\n            return False\n    if sum(matrix[i][i] for i in range(n)) != sum_row or sum(matrix[i][n-i-1] for i in range(n)) != sum_row:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the input is a valid square matrix\n    size = len(matrix)\n    for row in matrix:\n        if len(row) != size:\n            return False\n        for num in row:\n            if not isinstance(num, int):\n                return False\n\n    # Calculate the sum of the first row\n    row_sum = sum(matrix[0])\n\n    # Check if each row, each column, and both diagonals have the same sum\n    for i in range(size):\n        if sum(matrix[i]) != row_sum or sum(row[i] for row in matrix) != row_sum or sum(matrix[j][j] for j in range(size)) != row_sum or sum(matrix[j][size-j-1] for j in range(size)) != row_sum:\n            return False\n\n    # If all conditions are met, the matrix is a magic square\n    return True", "matching_cluster_idx": 4}, {"solution": "def magic_square_test(matrix):\n    \"\"\"Check if a matrix is a magic square.\"\"\"\n    size = len(matrix)\n    # Check if the matrix is square\n    if any(len(row) != size for row in matrix):\n        return False\n    # Check if the sum of elements in each row is the same\n    row_sum = sum(matrix[0])\n    if any(sum(row) != row_sum for row in matrix):\n        return False\n    # Check if the sum of elements in each column is the same\n    if any(sum(matrix[i][j] for i in range(size)) != row_sum for j in range(size)):\n        return False\n    # Check if the sum of elements in both diagonals is the same\n    if sum(matrix[i][i] for i in range(size)) != row_sum or sum(matrix[i][size - i - 1] for i in range(size)) != row_sum:\n        return False\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Check if the matrix is a square\n    if n != len(matrix[0]):\n        return False\n\n    # Calculate sum of the first row\n    row_sum = sum(matrix[0])\n\n    # Check each row, column, and diagonal sum\n    for i in range(n):\n        if sum(matrix[i]) != row_sum or sum(matrix[j][i] for j in range(n)) != row_sum:\n            return False\n    if sum(matrix[i][i] for i in range(n)) != row_sum or sum(matrix[i][n-i-1] for i in range(n)) != row_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Check if the input is a square matrix\n    if n != len(matrix[0]):\n        return False\n    # Calculate the sum of the first row\n    sum_row = sum(matrix[0])\n    # Check each row, column, and diagonal sum\n    for i in range(n):\n        if sum(matrix[i]) != sum_row or sum([matrix[j][i] for j in range(n)]) != sum_row:\n            return False\n        if i < n-1 and sum([matrix[i][j] for j in range(n)]) != sum_row:\n            return False\n    # All sums are equal, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if matrix is a square matrix\n    rows = len(matrix)\n    cols = len(matrix[0])\n    if rows != cols:\n        return False\n\n    # Calculate the sum of the first row\n    first_row_sum = sum(matrix[0])\n\n    # Check each row, column, and diagonal\n    for i in range(rows):\n        row_sum = sum(matrix[i])\n        if row_sum != first_row_sum:\n            return False\n\n        col_sum = sum(matrix[j][i] for j in range(rows))\n        if col_sum != first_row_sum:\n            return False\n\n    # Check diagonals\n    left_diag_sum = sum(matrix[i][i] for i in range(rows))\n    right_diag_sum = sum(matrix[i][rows - 1 - i] for i in range(rows))\n    if left_diag_sum != first_row_sum or right_diag_sum != first_row_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)  # Assuming the matrix is a square\n\n    # Check if all rows and columns have the same sum\n    row_sum = sum(matrix[0])\n    for i in range(n):\n        if sum(matrix[i]) != row_sum or sum(j[i] for j in matrix) != row_sum:\n            return False\n\n    # Check if the two main diagonals have the same sum\n    diag_sum = sum(matrix[i][i] for i in range(n))\n    if sum(matrix[i][n-i-1] for i in range(n)) != diag_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Check if the matrix is a square\n    if len(matrix) != len(matrix[0]):\n        return False\n\n    # Calculate the expected sum of each row, column and diagonal\n    size = len(matrix)\n    expected_sum = sum(matrix[0])\n\n    # Check each row, column and diagonal\n    for i in range(size):\n        row_sum = sum(matrix[i])\n        if row_sum != expected_sum:\n            return False\n\n        col_sum = sum(matrix[j][i] for j in range(size))\n        if col_sum != expected_sum:\n            return False\n\n    # Check both diagonals\n    diag_sum = sum(matrix[i][i] for i in range(size))\n    if diag_sum != expected_sum:\n        return False\n\n    anti_diag_sum = sum(matrix[i][size-i-1] for i in range(size))\n    if anti_diag_sum != expected_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}]}, "Mbpp/130": {"dps": 91.7713004484305, "dps_norm": 78.33333333333333, "pass@1": 71.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"Find the item with maximum frequency in a given list.\"\"\"\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(numbers):\n    counter = Counter(numbers)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for num in lst:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    return max(counts, key=counts.get)", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    counts = {}\n    for item in lst:\n        if item in counts:\n            counts[item] += 1\n        else:\n            counts[item] = 1\n    return max(counts, key=counts.get)", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n\n    # Find the most common item(s)\n    max_freq = max(frequency.values())\n    most_common = [item for item, freq in frequency.items() if freq == max_freq]\n\n    # Return the first most common item\n    return most_common[0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"Find the item with maximum frequency in a given list\"\"\"\n    return max(Counter(lst).items(), key=lambda x: x[1])[0]", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \"\"\"\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    This function finds the item with maximum frequency in a given list.\n    \"\"\"\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Using Counter to get frequencies of all items in the list\n    frequency = Counter(lst)\n\n    # Returning item with maximum frequency\n    return frequency.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef max_occurrences(lst: List[int]) -> int:\n    count_dict = {}\n    for num in lst:\n        if num not in count_dict:\n            count_dict[num] = 1\n        else:\n            count_dict[num] += 1\n    return max(count_dict, key=count_dict.get)", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \"\"\"\n    # Count occurrences of items in the list\n    occurrences = Counter(lst)\n\n    # Find the most common item and its frequency\n    most_common = occurrences.most_common(1)[0]\n\n    return most_common[0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"Find the item with maximum frequency in a given list.\"\"\"\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # count the occurrence of each item\n    count = Counter(lst)\n    # find the most common element\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    max_occurrence = max(list(counter.values()))\n    return next((k for k, v in counter.items() if v == max_occurrence), None)", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    freq_dict = {}\n    for num in lst:\n        if num in freq_dict:\n            freq_dict[num] += 1\n        else:\n            freq_dict[num] = 1\n\n    return max(freq_dict, key=freq_dict.get)", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"Find the item with maximum frequency in a given list\"\"\"\n    return max(Counter(lst).items(), key=lambda x: x[1])[0]", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 36.08870967741935, "dps_norm": 50.0, "pass@1": 16.0, "profiled": [{"solution": "from math import isclose\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    if non_zeroes == 0:  # Avoid division by zero\n        return math.inf\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeros = len(arr) - zeroes\n    if non_zeros == 0:\n        return float('inf') if zeroes > 0 else float('-inf')\n    else:\n        return zeroes / non_zeros", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\nimport unittest\ndef zero_count(arr):\n    zero_count = 0\n    non_zero_count = 0\n\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n\n    if non_zero_count == 0:\n        return float('inf')  # to handle division by zero\n\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "from math import isclose\ndef zero_count(arr):\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # or any suitable value representing infinite ratio\n    return zeroes / non_zeroes", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(i == 0 for i in arr)\n    non_zeros = sum(i != 0 for i in arr)\n    if non_zeros == 0:\n        return float('inf')  # return infinity if there are no non-zero elements\n    return zeroes / non_zeros", "matching_cluster_idx": 0}, {"solution": "from math import isclose\ndef zero_count(arr):\n    # Count zeroes and non-zeroes in the array\n    zeroes = sum(1 for num in arr if num == 0)\n    non_zeroes = sum(1 for num in arr if num != 0)\n\n    # Avoid division by zero\n    if non_zeroes == 0:\n        return float('inf')\n\n    # Return the ratio of zeroes to non-zeroes\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "def zero_count(arr):\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len([num for num in arr if num != 0])\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "matching_cluster_idx": 2}, {"solution": "from math import isclose\ndef zero_count(arr):\n    zeros = sum(1 for i in arr if i == 0)\n    non_zeros = sum(1 for i in arr if i != 0)\n    if non_zeros == 0:\n        return float('inf')  # Avoid division by zero\n    return zeros / non_zeros", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"Find the ratio of zeroes to non-zeroes in an array of integers.\"\"\"\n    zeroes = sum(1 for num in arr if num == 0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return 0 if zeroes == 0 else float('inf')\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    zero_count = sum(x == 0 for x in arr)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count if non_zero_count != 0 else float('inf')", "matching_cluster_idx": 4}, {"solution": "import math\nimport unittest\ndef zero_count(arr):\n    num_zeros = arr.count(0)\n    num_non_zeros = len(arr) - num_zeros\n    if num_non_zeros == 0:\n        return float('inf')  # special handling for division by zero\n    return num_zeros / num_non_zeros", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(numbers):\n    zeroes = sum(1 for num in numbers if num == 0)\n    non_zeroes = sum(1 for num in numbers if num != 0)\n    if non_zeroes == 0:\n        return float('inf')\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum(1 for num in arr if num == 0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(nums):\n    \"\"\"\n    This function takes an array of integers and returns the ratio of zeroes to non-zeroes.\n    If there are no zeroes, it returns 0. If there are no non-zeroes, it returns inf.\n    \"\"\"\n    zeroes = sum(1 for num in nums if num == 0)\n    non_zeroes = sum(1 for num in nums if num != 0)\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}]}, "Mbpp/140": {"dps": 68.74223602484471, "dps_norm": 73.125, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(nested_list):\n    return set(number for sublist in nested_list for number in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst_of_tuples):\n    # Using list comprehension to flatten the list of tuples and then converting it to a set\n    return set(x for sublist in lst_of_tuples for x in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(input_list):\n    # Using list comprehension to flatten the list of lists into a single list\n    return [item for sublist in input_list for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"Flatten a nested list of lists into a single set of numbers\"\"\"\n    return set(number for sublist in nested_list for number in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst):\n    return set(num for sublist in lst for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lists):\n    return set(item for sublist in lst_of_lists for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Use list comprehension to flatten the nested list and convert it to a set\n    return set(item for sublist in nested_list for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    \"\"\"Flatten the list of lists into a single set of numbers.\"\"\"\n    # Using list comprehension to iterate through all sublists,\n    # and then adding each item to the set.\n    return set(item for sublist in lst for item in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst_of_lists):\n    # Using list comprehension to extract elements from each inner list\n    # and converting the result into a set\n    return set(x for sublist in lst_of_lists for x in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    # Initialize an empty set to store unique numbers\n    flattened_set = set()\n\n    # Use a list comprehension to extract all numbers from the nested list\n    # and add them to the set\n    flattened_set = {num for sublist in nested_list for num in sublist}\n\n    return flattened_set", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Initialize an empty set to store the numbers\n    numbers = set()\n\n    # Iterate over each sublist in the nested list\n    for sublist in nested_list:\n        # Add each number from the sublist to the set\n        numbers.update(sublist)\n\n    return numbers\nnested_list = [(3, 4, 5), (4, 5, 7), (1, 4)]", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lst):\n    # Initialize an empty set\n    result_set = set()\n\n    # Iterate over each tuple in the input list\n    for tup in lst:\n        # Add each element of the tuple to the result set\n        result_set.update(tup)\n\n    # Return the flattened result set\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(nested_list):\n    \"\"\"Extract and return numbers from a list of tuples to a single set.\"\"\"\n    return set(num for tup in nested_list for num in tup)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    A function that takes a list of lists and returns a set of the numbers.\n    \"\"\"\n    return set(num for sublist in nested_list for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(lst_of_lsts):\n    # Using list comprehension to flatten the list of lists\n    return {num for sublist in lst_of_lsts for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    return set(item for sublist in nested_list for item in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lists):\n    \"\"\"\n    Extracts and returns unique elements from a list of lists.\n\n    Args:\n        lst_of_lists (list of lists): A nested list of integers.\n\n    Returns:\n        set: A set of unique integers extracted from the nested list.\n    \"\"\"\n    return set(num for sublist in lst_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(nested_list):\n    # Using list comprehension to flatten the nested list and then convert it to a set\n    return set([num for sublist in nested_list for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst):\n    return set(x for sublist in lst for x in sublist)", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 80.09070294784581, "dps_norm": 45.0, "pass@1": 24.0, "profiled": [{"solution": "def pancake_sort(lst):\n    # Find the maximum element and its index for each subarray\n    for i in range(len(lst) - 1, 0, -1):\n        max_idx = i\n        for j in range(i):\n            if lst[j] > lst[max_idx]:\n                max_idx = j\n\n        # If the maximum element is not at the end, flip the elements\n        if max_idx != i:\n            # Flip the first max_idx + 1 elements\n            lst = lst[:max_idx + 1][::-1] + lst[max_idx + 1:]\n\n            # Flip the first i+1 elements\n            lst = lst[:i + 1][::-1] + lst[i + 1:]\n\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr), 0, -1):\n        max_idx = max(range(i), key=arr.__getitem__)\n        arr[0:max_idx + 1] = reversed(arr[0:max_idx + 1])\n        arr[0:i] = reversed(arr[0:i])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 0, -1):\n        # Find the index of the maximum element in the current unsorted part of the list\n        max_idx = max(range(i), key=lst.__getitem__)\n        # If the maximum element is not at the correct position, flip the part of the list before the maximum element\n        if max_idx != i - 1:\n            if max_idx != 0:\n                lst[:max_idx + 1] = reversed(lst[:max_idx + 1])\n            lst[:i] = reversed(lst[:i])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # We will iterate over the input array from end to start\n    for i in range(len(arr), 0, -1):\n        # Find the maximum element from index 0 to i\n        max_idx = max(range(i), key=arr.__getitem__)\n\n        # If the maximum element is not at the current position\n        if max_idx != i - 1:\n            # If the maximum element is not at the beginning, flip the subarray from max_idx to i - 1\n            if max_idx != 0:\n                arr[:max_idx+1] = reversed(arr[:max_idx+1])\n\n            # Flip the whole array from 0 to i - 1 to make the maximum element come to its correct position\n            arr[:i] = reversed(arr[:i])\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr)-1, 0, -1):\n        max_index = find_max_index(arr, i)\n        if max_index != i:\n            arr = flip(arr, max_index) if max_index > 0 else arr\n            arr = flip(arr, i)\n    return arr\ndef find_max_index(arr, end):\n    max_index = 0\n    for i in range(1, end + 1):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\ndef flip(arr, index):\n    return arr[:index+1][::-1] + arr[index+1:]", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        return arr[:k][::-1] + arr[k:]\n\n    for i in range(len(arr), 0, -1):\n        max_idx = arr[:i].index(max(arr[:i]))\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr), 0, -1):\n        # Find the index of the maximum element in arr[0..i]\n        max_idx = max(range(i), key=lambda idx: arr[idx])\n        # If the max element is not at the current position, swap it\n        if max_idx != i - 1:\n            if max_idx != 0:\n                # Flip the first max_idx+1 elements\n                arr = [arr[j] for j in range(max_idx, -1, -1)] + arr[max_idx + 1:]\n            # Flip the first i elements\n            arr = [arr[j] for j in range(i - 1, -1, -1)] + arr[i:]\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Initialize an empty list to store sorted elements\n    sorted_arr = []\n\n    # While there are still unsorted elements in arr\n    while arr:\n        # Find the index of the maximum element in arr\n        max_index = max(range(len(arr)), key=arr.__getitem__)\n\n        # If the maximum element is at the end of arr, remove it and append to sorted_arr\n        if max_index == len(arr) - 1:\n            sorted_arr.append(arr.pop())\n        # If the maximum element is not at the end of arr, move it to the end and then remove it\n        else:\n            # Reverse arr up to the maximum element\n            arr[:max_index + 1] = arr[:max_index + 1][::-1]\n            # Reverse arr again to move the maximum element to the end\n            arr = arr[::-1]\n            # Remove and append the maximum element to sorted_arr\n            sorted_arr.append(arr.pop())\n\n    # Return the sorted list in reverse order\n    return sorted_arr[::-1]", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst), 0, -1):\n        # Find the index of the maximum element in the unsorted sublist\n        max_idx = max(range(i), key=lst.__getitem__)\n        # If the maximum element is not at the correct position\n        if max_idx != i - 1:\n            # Flip the sublist to move the maximum element to the end\n            lst[:max_idx+1] = reversed(lst[:max_idx+1])\n            # Flip the sublist again to move the maximum element to its correct position\n            lst[:i] = reversed(lst[:i])\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(lst):\n    # This function sorts the list by iteratively finding the maximum element and moving it to the end\n    for i in range(len(lst)-1, 0, -1):\n        max_index = 0\n        for j in range(i+1):\n            if lst[j] > lst[max_index]:\n                max_index = j\n        # If the maximum element is not at the end, flip the part of the list up to the max element\n        if max_index != i:\n            if max_index != 0:\n                lst[:max_index+1] = reversed(lst[:max_index+1])\n            # Then flip the whole list to move the maximum to the end\n            lst[:i+1] = reversed(lst[:i+1])\n    return lst", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to flip elements up to index 'k'\n    def flip(k):\n        arr[:k + 1] = arr[:k + 1][::-1]\n\n    # Iterate through the array from last to first element\n    for i in range(len(arr), 0, -1):\n        # Find the index of the maximum element up to the current position\n        max_idx = arr[:i].index(max(arr[:i]))\n\n        # If the maximum element is not at the correct position,\n        # flip the array to move it to the correct position\n        if max_idx != i - 1:\n            if max_idx != 0:\n                flip(max_idx)\n            flip(i - 1)\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Iterate over the length of the array in reverse order\n    for i in range(len(arr), 0, -1):\n        # Find the index of the maximum element in the current subarray\n        max_idx = max(range(i), key=arr.__getitem__)\n        # If the maximum element is not at the correct position\n        if max_idx != i - 1:\n            # Flip the subarray up to the max element\n            arr[:max_idx+1] = reversed(arr[:max_idx+1])\n            # Flip the subarray up to the end\n            arr[:i] = reversed(arr[:i])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    for i in range(len(arr), 0, -1):\n        max_idx = 0\n        for j in range(1, i):\n            if arr[j] > arr[max_idx]:\n                max_idx = j\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = [arr[max_idx]] + arr[0:max_idx][::-1] + arr[max_idx+1:]\n            arr = arr[0:i][::-1] + arr[i:]\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    for size in range(len(arr), 0, -1):\n        # Find the index of the maximum element in the current unsorted part\n        max_index = max(range(size), key=lambda i: arr[i])\n        # If the maximum is not at the correct position\n        if max_index < size - 1:\n            # If it's not at the beginning, flip it to the beginning\n            if max_index != 0:\n                arr = pancake_flip(arr, max_index + 1) if max_index != 0 else arr\n            # Flip the last element to its correct position\n            arr = pancake_flip(arr, size)\n    return arr\ndef pancake_flip(arr, n):\n    return arr[:n][::-1] + arr[n:]", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse elements up to a certain index\n    def flip(arr, k):\n        return arr[:k+1][::-1] + arr[k+1:]\n\n    # Main sorting logic\n    for i in range(len(arr), 0, -1):\n        # Find the index of the maximum element in the current unsorted sublist\n        max_idx = arr[:i].index(max(arr[:i]))\n        # If the maximum is not at the end, flip the array at the max index and then at the current index\n        if max_idx != i - 1:\n            arr = flip(arr, max_idx)\n            arr = flip(arr, i - 1)\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Helper function to find index of the maximum element in list[0...end]\n    def find_max(arr, end):\n        max_idx = 0\n        for i in range(1, end + 1):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n\n    # Flip the array [0, 1, ... i] on 0, 1, ..., i\n    def flip(arr, i):\n        i = i + 1\n        for j in range(i // 2):\n            arr[j], arr[i - j - 1] = arr[i - j - 1], arr[j]\n\n    n = len(arr)\n    for i in range(n):\n        max_idx = find_max(arr, n - i - 1)\n        # If the largest element is at its correct place, skip\n        if max_idx != n - i - 1:\n            # Move the largest element to its correct place\n            # First, move the largest element to end of the subarray\n            if max_idx != n - i - 1:\n                flip(arr, max_idx)\n            flip(arr, n - i - 1)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for i in range(n, 0, -1):\n        max_idx = find_max(arr, i)\n        if max_idx != i - 1:\n            # reverse elements up to the max element\n            arr = reverse(arr, max_idx + 1)\n            # reverse the entire list\n            arr = reverse(arr, i)\n    return arr\ndef find_max(arr, n):\n    max_idx = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_idx]:\n            max_idx = i\n    return max_idx\ndef reverse(arr, n):\n    return arr[:n][::-1] + arr[n:]", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    for i in range(len(lst)):\n        max_idx = lst[:len(lst) - i].index(max(lst[:len(lst) - i])) + 1\n        if max_idx != len(lst) - i:\n            if max_idx != 1:\n                lst[:max_idx] = lst[:max_idx][::-1]\n            lst[:len(lst) - i] = lst[:len(lst) - i][::-1]\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Helper function to find the index of the maximum element in the list\n    def find_max_idx(arr):\n        return arr.index(max(arr))\n\n    # Helper function to reverse the list up to the given index\n    def reverse_list(arr, idx):\n        return arr[:idx + 1][::-1] + arr[idx + 1:]\n\n    # Main sorting function\n    for i in range(len(arr) - 1, 0, -1):\n        max_idx = find_max_idx(arr[:i + 1])\n        if max_idx != i:\n            arr = reverse_list(arr, max_idx)\n            arr = reverse_list(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        max_idx = arr[:i + 1].index(max(arr[:i + 1]))\n        if max_idx != i:\n            if max_idx != 0:\n                arr[:max_idx + 1] = reversed(arr[:max_idx + 1])\n            arr[:i + 1] = reversed(arr[:i + 1])\n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 95.28888888888888, "dps_norm": 59.72222222222222, "pass@1": 18.0, "profiled": [{"solution": "def find_even_pair(nums):\n    # Initialize count\n    count = 0\n\n    # Iterate through all pairs\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n\n            # Check if XOR is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"Count the number of pairs in a list that XOR to an even number.\"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    even_count = sum(1 for num in nums if num % 2 == 0) # count even numbers\n    odd_count = len(nums) - even_count # count odd numbers\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    even_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Initialize counter\n    count = 0\n    # Iterate through pairs in the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # If XOR is even, increment counter\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    even_count = sum(1 for num in arr if num % 2 == 0)  # Count even numbers\n    odd_count = sum(1 for num in arr if num % 2 != 0)  # Count odd numbers\n\n    # Two cases can result in an even XOR:\n    # 1. Pair of even numbers\n    # 2. Pair of odd numbers\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(numbers):\n    even_parity = [num % 2 == 0 for num in numbers]\n    return sum(even_parity[i] ^ even_parity[j] == 0 for i in range(len(even_parity)) for j in range(i+1, len(even_parity)))", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    # Initialize counters for even and odd numbers\n    even_count, odd_count = 0, 0\n\n    # Count even and odd numbers\n    for num in numbers:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Calculate pairs that XOR to an even number\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # We know that XOR of two even numbers is even,\n    # XOR of two odd numbers is even, and XOR of an even and odd number is odd.\n    # So we can count the number of even numbers and odd numbers separately,\n    # and return the sum of their combinations (even*even + odd*odd).\n\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    # Return the sum of combinations\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 3}, {"solution": "def find_even_pair(nums):\n    even_count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        lst (list): List of integers.\n\n    Returns:\n        int: Number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    # In order for xor to be even, both numbers must be even or both must be odd\n    # We count the frequency of even and odd numbers in the list\n    count_even = count_odd = 0\n    for num in nums:\n        if num % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n\n    # We calculate the number of pairs of even numbers and odd numbers separately,\n    # and then we add those two results together. Since the order of choosing\n    # two numbers from the list doesn't matter, we use combinations (nC2) formula.\n    return count_even * (count_even - 1) // 2 + count_odd * (count_odd - 1) // 2", "matching_cluster_idx": 2}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 53.0, "profiled": [{"solution": "def sum_range_list(numbers, start_index, end_index):\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    :param lst: List of numbers\n    :param start: Start index\n    :param end: End index\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    This function returns the sum of elements in a list between two specific indices (inclusive).\n    \"\"\"\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    return sum(lst[start_idx:end_idx + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    lst (list): The input list of numbers.\n    start (int): The start index, inclusive.\n    end (int): The end index, inclusive.\n\n    Returns:\n    int: The sum of the numbers within the specified range.\n    \"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_idx, end_idx):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n        lst (list): Input list of numbers\n        start_idx (int): Start index\n        end_idx (int): End index\n\n    Returns:\n        int: Sum of numbers in the specified range\n    \"\"\"\n    return sum(lst[start_idx:end_idx+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specific range.\n\n    Args:\n    lst (List[int]): The input list of integers.\n    start_index (int): The starting index in the list.\n    end_index (int): The ending index in the list.\n\n    Returns:\n    int: The sum of numbers in the specified range.\n    \"\"\"\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"Return the sum of numbers in a list within the specified range.\"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 76.24031007751938, "dps_norm": 35.0, "pass@1": 64.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    \"\"\"Remove characters at odd indexes from a given string.\"\"\"\n    return \"\".join([char for idx, char in enumerate(input_string) if idx % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(0, len(s), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(0, len(s), 2)])", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove the characters which have odd index values of a given string.\n    :param s: input string\n    :return: string with odd indexed characters removed\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(0, len(s), 2)])", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Function to remove characters from a given string which have odd index values.\n    \"\"\"\n    # By using Python's list comprehension we can achieve this with a single line of code.\n    # We start with an empty string and then for each index in the string,\n    # if the index is even (not odd) we add the corresponding character to the result.\n    return ''.join([s[i] for i in range(0, len(s), 2)])", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(input_str):\n    return ''.join([input_str[i] for i in range(0, len(input_str), 2)])", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(input_str):\n    return ''.join([input_str[i] for i in range(len(input_str)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return \"\".join(c for i, c in enumerate(s) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(0, len(s), 2)])", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s: str) -> str:\n    return ''.join(c for i, c in enumerate(s) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s: str) -> str:\n    \"\"\"Removes characters at odd indices from the given string.\"\"\"\n    return ''.join(s[i] for i in range(0, len(s), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_values_string(s: str) -> str:\n    return ''.join([s[i] for i in range(0, len(s), 2)])", "matching_cluster_idx": 4}, {"solution": "def odd_values_string(s: str) -> str:\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store result\n    result = ''\n\n    # Loop through the string, only add characters with even index\n    for i in range(0, len(input_string), 2):\n        result += input_string[i]\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def odd_values_string(s):\n    return ''.join(s[i] for i in range(0, len(s), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Removes the characters which have odd index values of a given string.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([c for i, c in enumerate(s) if i % 2 == 0])", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(string, char):\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"Replaces blanks with a given character in a string.\"\"\"\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replace_char):\n    \"\"\"\n    This function takes a string and a character, replaces blank spaces in the string with the given character,\n    and returns the modified string.\n    \"\"\"\n    return input_string.replace(' ', replace_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replaces blank spaces in the input string with a given character.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    \"\"\"Replace blank spaces in the given string with the provided character.\n\n    Args:\n        text (str): The input string.\n        char (str): The character to replace spaces with.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    return input_string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    \"\"\"Replace blank spaces in a string with a given character.\n\n    Args:\n        s (str): Input string.\n        c (str): Character to replace spaces.\n\n    Returns:\n        str: String with spaces replaced by the given character.\n    \"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text: str, char: str) -> str:\n    \"\"\"\n    This function takes in a string and character, replaces blank spaces in the string with the character,\n    and returns the resulting string.\n    \"\"\"\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    \"\"\"\n    Replaces blank spaces in the input string with the given character.\n\n    Args:\n        s (str): Input string.\n        ch (str): Character to replace blank spaces.\n\n    Returns:\n        str: String with blank spaces replaced by the given character.\n    \"\"\"\n    return s.replace(\" \", ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    \"\"\"Replaces blank spaces in the string with the given character.\"\"\"\n    return s.replace(' ', c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(text, char):\n    \"\"\"\n    Replace blank spaces in the given text with the provided character.\n\n    :param text: Input string\n    :param char: Character to replace spaces with\n    :return: Modified string\n    \"\"\"\n    return text.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    \"\"\"Replace spaces in the given string with the provided character.\n\n    Args:\n    s (str): The input string\n    c (str): The character to replace spaces with\n\n    Returns:\n    str: The modified string\n    \"\"\"\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    # Use the replace() function to substitute blank spaces with the character\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, c):\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    \"\"\"\n    Replace blank spaces in a given string with a specified character.\n    \"\"\"\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s: str, c: str) -> str:\n    \"\"\"Replace all spaces in a string with a given character.\"\"\"\n    return s.replace(\" \", c)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the given string with the provided character.\n\n    :param string: The input string\n    :param character: The character to replace spaces with\n    :return: The modified string\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/240": {"dps": 78.04878048780489, "dps_norm": 86.66666666666666, "pass@1": 21.0, "profiled": [{"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Check if the first list is not empty\n    if lst1:\n        # Replace the last element of the first list with the second list\n        lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Copy the first list\n    modified_list = list1[:]\n    # Replace the last element of the first list with elements of the second list\n    modified_list[-1:] = list2\n    return modified_list", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element from the first list\n    lst1 = lst1[:-1]\n    # Append the elements of the second list to the first list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 6}, {"solution": "def replace_list(lst1, lst2):\n    # Get the last element of the first list\n    last_element = lst1.pop()\n    # Extend the first list with the second list starting from the index of the last element\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Make sure list1 has at least one element\n    if not list1:\n        return list1\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    if len(lst1) == 0:\n        return lst2\n    else:\n        return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    if lst1:\n        lst1[-1:] = lst2\n    else:\n        return lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    if len(lst1) < 1:\n        return lst2\n    return lst1[:-1] + lst2", "matching_cluster_idx": 5}, {"solution": "def replace_list(lst1, lst2):\n    if not lst1:\n        return lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Replaces the last element of list1 with elements of list2\n    if list1:\n        list1[-1:] = list2\n    else:\n        list1 = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Check if lst1 is not empty\n    if lst1:\n        lst1[-1:] = lst2  # Replace the last element of lst1 with lst2\n    else:\n        # If lst1 is empty, return lst2 as it is\n        lst1 = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"Replaces the last element of the first list with the elements of the second list.\"\"\"\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/256": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/265": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 11.0, "profiled": [{"solution": "def list_split(lst, n):\n    \"\"\"\n    This function takes a list and an integer n and splits the list into lists of every nth element.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Use list comprehension to create new lists every 'n' elements\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 90.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Parameters:\n    lst (list): A list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Using a set data structure to check for unique elements\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Args:\n        lst (list): List to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    :param lst: A list of elements.\n    :return: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    # Convert list to set and compare the lengths\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    # Create a set from the list. If the list contains duplicate elements, a set will contain only one instance of them.\n    # Therefore, the size of the set will be less than the size of the list.\n    return len(set(input_list)) == len(input_list)", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Args:\n        lst (list): Input list\n\n    Returns:\n        bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Using a set to check uniqueness because it automatically removes duplicates\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Args:\n        lst (list): Input list.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in the list are unique.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Args:\n    lst (list): Input list\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    :param lst: list to be checked\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(elements):\n    \"\"\"\n    Checks if all elements in a list are unique.\n\n    Args:\n    elements (List): The list of elements to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(elements) == len(set(elements))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"Check if all elements in a list are unique.\"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in a list are unique.\n\n    Args:\n    lst (list): input list\n\n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 64.1025641025641, "dps_norm": 83.33333333333334, "pass@1": 57.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    merge_sort_count = 0\n\n    def merge_sort(arr):\n        nonlocal merge_sort_count\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        left = merge_sort(left)\n        right = merge_sort(right)\n\n        return merge(left, right)\n\n    def merge(left, right):\n        nonlocal merge_sort_count\n        merged = []\n        while left and right:\n            if left[0] > right[0]:\n                merge_sort_count += len(left)\n                merged.append(right.pop(0))\n            else:\n                merged.append(left.pop(0))\n        merged.extend(left if left else right)\n        return merged\n\n    merge_sort(arr)\n    return merge_sort_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count inversions in an array.\n\n    An inversion is defined as a pair of elements where the first element is larger than the second.\n\n    Args:\n        arr (list of integers): Input array.\n\n    Returns:\n        int: Number of inversions in the array.\n    \"\"\"\n    inv_count = 0\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    def merge_sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left, left_inv = merge_sort_count(arr[:mid])\n        right, right_inv = merge_sort_count(arr[mid:])\n\n        merged, merge_inv = merge_count(left, right)\n        return merged, left_inv + right_inv + merge_inv\n\n    def merge_count(left, right):\n        inv = 0\n        result = []\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                inv += len(left) - i\n                j += 1\n\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result, inv\n\n    _, inv = merge_sort_count(arr)\n    return inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Merge sort approach to count inversions\n    if len(arr) <= 1:\n        return 0\n\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n\n    inv_count = (get_Inv_Count(left) +\n                 get_Inv_Count(right))\n\n    i = j = k = 0\n\n    # Counting inversions during merge\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n            inv_count += len(left) - i\n        k += 1\n\n    # Copying remaining elements\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr, 0\n\n    mid = len(arr) // 2\n    left, left_inv = merge_sort(arr[:mid])\n    right, right_inv = merge_sort(arr[mid:])\n    merged, merge_inv = merge(left, right)\n\n    return merged, left_inv + right_inv + merge_inv\ndef merge(left, right):\n    merged = []\n    inversions = 0\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inversions += len(left) - i\n\n    merged.extend(left[i:])\n    merged.extend(right[j:])\n\n    return merged, inversions\ndef get_Inv_Count(arr):\n    _, inversions = merge_sort(arr)\n    return inversions", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Initialize count and merge sort\n    inv_count = 0\n    temp = arr.copy()\n\n    # Core merge sort function\n    def merge_sort(arr, start, end):\n        nonlocal inv_count, temp\n        if end - start > 1:\n            mid = start + (end - start) // 2\n            merge_sort(arr, start, mid)\n            merge_sort(arr, mid, end)\n            merge(arr, start, mid, end)\n\n    # Merge function for merge sort\n    def merge(arr, start, mid, end):\n        nonlocal inv_count, temp\n        left = arr[start:mid]\n        right = arr[mid:end]\n\n        i = j = 0\n        for k in range(start, end):\n            if j >= len(right) or (i < len(left) and left[i] <= right[j]):\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n                inv_count += len(left) - i  # Count inversions\n\n    # Start merge sort from the whole array\n    merge_sort(temp, 0, len(temp))\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Merge sort based approach to count inversions\n    # Similar to the solution provided in the problem statement\n    temp_arr = [0] * len(arr)\n    return merge_sort(arr, temp_arr, 0, len(arr) - 1)\ndef merge_sort(arr, temp_arr, left, right):\n    inv_count = 0\n    if right > left:\n        mid = (right + left) // 2\n\n        inv_count = merge_sort(arr, temp_arr, left, mid)\n        inv_count += merge_sort(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += mid - i + 1\n            j += 1\n        k += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inv_count = 0\n\n    # Calculate the number of inversions\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Merge sort based approach to count inversions\n    # The idea is to divide the array in two halves and\n    # find the number of inversions in each half and\n    # then combine the two halves in a way that we can\n    # keep track of inversions\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left_half, inv_left = merge_sort(arr[:mid])\n        right_half, inv_right = merge_sort(arr[mid:])\n\n        merged, inv_merge = merge(left_half, right_half)\n        inv_total = inv_left + inv_right + inv_merge\n\n        return merged, inv_total\n\n    def merge(left, right):\n        merged = []\n        inv = 0\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                inv += len(left) - i\n                j += 1\n\n        merged.extend(left[i:])\n        merged.extend(right[j:])\n\n        return merged, inv\n\n    _, inv = merge_sort(arr)\n\n    return inv", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # Merge sort function to count inversions\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n\n        mid = len(arr) // 2\n        left, left_inv = merge_sort(arr[:mid])\n        right, right_inv = merge_sort(arr[mid:])\n\n        merge_inv = 0\n        sorted_arr = []\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                sorted_arr.append(left[i])\n                i += 1\n            else:\n                sorted_arr.append(right[j])\n                merge_inv += len(left) - i\n                j += 1\n\n        sorted_arr += left[i:]\n        sorted_arr += right[j:]\n\n        return sorted_arr, merge_inv + left_inv + right_inv\n\n    # Call merge_sort function\n    _, inv_count = merge_sort(arr)\n\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array\n    :param arr: list of integers\n    :return: integer, number of inversions\n    \"\"\"\n    # length of the array\n    n = len(arr)\n\n    # To store the final count of inversions\n    inv_count = 0\n\n    for i in range(n):\n        for j in range(i+1, n):\n            # Count the inversion\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inv_count = 0\n\n    # Traverse through all array elements\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            # If this pair is found to be in increasing order ( inverter ), increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Merge sort based solution to find inversions\n    def merge(arr, l, m, r):\n        inv_count = 0\n        n1 = m - l + 1\n        n2 = r - m\n        L = [0] * n1\n        R = [0] * n2\n        for i in range(n1):\n            L[i] = arr[l + i]\n        for i in range(n2):\n            R[i] = arr[m + 1 + i]\n        i = j = 0\n        k = l\n        while i < n1 and j < n2:\n            if L[i] <= R[j]:\n                arr[k] = L[i]\n                i += 1\n            else:\n                arr[k] = R[j]\n                inv_count += n1 - i\n                j += 1\n            k += 1\n        while i < n1:\n            arr[k] = L[i]\n            i += 1\n            k += 1\n        while j < n2:\n            arr[k] = R[j]\n            j += 1\n            k += 1\n        return inv_count\n\n    def merge_sort(arr, l, r):\n        inv_count = 0\n        if r > l:\n            m = (l + r) // 2\n            inv_count += merge_sort(arr, l, m)\n            inv_count += merge_sort(arr, m + 1, r)\n            inv_count += merge(arr, l, m, r)\n        return inv_count\n\n    return merge_sort(arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    # helper function to merge two sorted arrays and count inversions\n    def merge(arr1, arr2, inv_count):\n        merged = []\n        i = j = 0\n        while i < len(arr1) and j < len(arr2):\n            if arr1[i] <= arr2[j]:\n                merged.append(arr1[i])\n                i += 1\n            else:\n                merged.append(arr2[j])\n                inv_count[0] += len(arr1) - i  # count inversions\n                j += 1\n        merged.extend(arr1[i:])\n        merged.extend(arr2[j:])\n        return merged, inv_count\n\n    # merge sort algorithm to count inversions\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, [0]\n        mid = len(arr) // 2\n        left, left_inv_count = merge_sort(arr[:mid])\n        right, right_inv_count = merge_sort(arr[mid:])\n        merged, total_inv_count = merge(left, right, [0])\n        return merged, [left_inv_count[0] + right_inv_count[0] + total_inv_count[0]]\n\n    arr, inv_count = merge_sort(arr)\n    return inv_count[0]", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 67.79310344827587, "dps_norm": 59.16666666666667, "pass@1": 41.0, "profiled": [{"solution": "from itertools import product\ndef large_product(lst1, lst2, n):\n    # Get all combinations of factors from lst1 and lst2\n    combinations = [a * b for a, b in product(lst1, lst2)]\n\n    # Sort the combinations in descending order\n    combinations.sort(reverse=True)\n\n    # Return the n largest products\n    return combinations[:n]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\nfrom heapq import nlargest\ndef large_product(list1, list2, n):\n    # Generate all possible products from one factor from each list\n    products = [a * b for a, b in product(list1, list2)]\n    # Find the largest n products\n    largest_products = nlargest(n, products)\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "from itertools import product\nfrom typing import List, Tuple\ndef large_product(lst1: List[int], lst2: List[int], n: int) -> List[int]:\n    # Create pairs of factors\n    pairs = product(lst1, lst2)\n    # Calculate products\n    products = [a*b for a, b in pairs]\n    # Sort products in descending order and return the largest n\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "from operator import mul\nfrom functools import reduce\ndef large_product(l1, l2, n):\n    # Make sure the inputs are lists\n    assert isinstance(l1, list) and isinstance(l2, list), \"Both inputs should be lists.\"\n\n    # Calculate the Cartesian product of the two lists\n    products = [(i, j) for i in l1 for j in l2]\n\n    # Calculate the product for each pair and sort the result in descending order\n    products.sort(key=lambda x: reduce(mul, x), reverse=True)\n\n    # Return the first 'n' largest products\n    return [reduce(mul, product) for product in products[:n]]", "matching_cluster_idx": 2}, {"solution": "from itertools import product\nfrom operator import mul\nfrom functools import reduce\ndef large_product(list1, list2, n):\n    # Generate all possible products of elements taken from each list\n    products = [reduce(mul, p) for p in product(list1, list2)]\n\n    # Sort the products in descending order and return the top n\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, num):\n    # Combine two lists and sort them in descending order\n    products = sorted((i * j for i in list1 for j in list2), reverse=True)\n\n    # Return the specified number of largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\nfrom operator import mul\ndef large_product(list1, list2, num_products):\n    # Combine the two lists using Cartesian product\n    products = [mul(a, b) for a, b in product(list1, list2)]\n\n    # Sort the products in descending order and return the first 'num_products' items\n    return sorted(products, reverse=True)[:num_products]", "matching_cluster_idx": 2}, {"solution": "from itertools import product\ndef large_product(list1, list2, n):\n    # Multiply each pair of numbers from the two lists\n    products = [a * b for a, b in product(list1, list2)]\n\n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n\n    # Return the top n products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\ndef large_product(nums1, nums2, k):\n    # Get all possible products\n    products = [(a * b, a, b) for a, b in product(nums1, nums2)]\n\n    # Sort by product value in descending order and take the top k\n    top_k_products = sorted(products, reverse=True)[:k]\n\n    # Extract the product values\n    results = [product[0] for product in top_k_products]\n\n    return results", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef large_product(list1: List[int], list2: List[int], n: int) -> List[int]:\n    # Create a list of tuples with products and indices\n    products = [(list1[i] * list2[j], i, j) for i in range(len(list1)) for j in range(len(list2))]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the first n products\n    return [products[i][0] for i in range(n)]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef large_product(nums1: List[int], nums2: List[int], k: int) -> List[int]:\n    # Multiply each element from first list with each element from second list\n    products = [num1 * num2 for num1 in nums1 for num2 in nums2]\n\n    # Sort products in descending order and select top k\n    return sorted(products, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Ensure n is not greater than the number of elements in both lists\n    assert n <= min(len(list1), len(list2)), \"n cannot be greater than the number of elements in both lists\"\n\n    # Initialize a list to store the products\n    products = []\n\n    # Generate all possible products from one element in list1 and one in list2\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n\n    # Sort the products in descending order and return the top n products\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 2}, {"solution": "def large_product(lst1, lst2, k):\n    # Combine the two lists into a single list\n    combined = [(a, b) for a in lst1 for b in lst2]\n    # Sort the combined list by the product of each pair in descending order\n    sorted_combined = sorted(combined, key=lambda x: x[0] * x[1], reverse=True)\n    # Return the specified number of largest products\n    return [pair[0] * pair[1] for pair in sorted_combined[:k]]", "matching_cluster_idx": 2}, {"solution": "from itertools import product\nfrom operator import mul\ndef large_product(list1, list2, k):\n    # Create a list of products from all combinations of elements from both lists\n    products = [a * b for a, b in product(list1, list2)]\n\n    # Sort the products in descending order and return the first k largest products\n    return sorted(products, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Handle edge cases\n    if not list1 or not list2 or n <= 0:\n        return []\n\n    # Create a list of tuples, each containing a product and its corresponding pair of indices\n    products = [(list1[i] * list2[j], i, j) for i in range(len(list1)) for j in range(len(list2))]\n\n    # Sort the products in descending order\n    products.sort(reverse=True)\n\n    # Return the n largest products\n    return [products[i][0] for i in range(n)]", "matching_cluster_idx": 2}, {"solution": "from functools import reduce\ndef large_product(lst1, lst2, k):\n    # Sort the lists in reverse order\n    lst1.sort(reverse=True)\n    lst2.sort(reverse=True)\n\n    # Generate all possible products and store them in a list\n    products = [x * y for x in lst1 for y in lst2]\n\n    # Sort the list of products in reverse order\n    products.sort(reverse=True)\n\n    # Return the k largest products\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Get all possible products\n    products = [i * j for i in list1 for j in list2]\n\n    # Sort products in descending order and return the top n products\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "from itertools import product\nfrom heapq import nlargest\ndef large_product(list1, list2, n):\n    # Create all possible products from elements of both lists\n    products = [a * b for a, b in product(list1, list2)]\n\n    # Get the n largest products\n    return nlargest(n, products)", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef large_product(list1: List[int], list2: List[int], k: int) -> List[int]:\n    # Get all possible products from multiplying one number from each list\n    products = [a * b for a in list1 for b in list2]\n\n    # Sort the products in descending order and return the first k\n    return sorted(products, reverse=True)[:k]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef large_product(lst1: List[int], lst2: List[int], n: int) -> List[int]:\n    # Create a list of tuples, each containing the product of two numbers from lst1 and lst2\n    products = [(a * b, a, b) for a in lst1 for b in lst2]\n\n    # Sort the list of tuples by the first element (the product) in descending order\n    products.sort(reverse=True)\n\n    # Return the first n elements (products and their corresponding factors)\n    return [p for p, _, _ in products[:n]]", "matching_cluster_idx": 2}]}, "Mbpp/392": {"dps": 80.02347417840376, "dps_norm": 90.0, "pass@1": 30.0, "profiled": [{"solution": "def get_max_sum(n):\n    memo = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n\n    def helper(n):\n        if n < 1:\n            return 0\n        if n in memo:\n            return memo[n]\n        memo[n] = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n        return memo[n]\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5], i)\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    memo = {}\n\n    def helper(n):\n        if n < 2:\n            return n\n\n        if n in memo:\n            return memo[n]\n\n        result = max(\n            helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5),\n            n\n        )\n        memo[n] = result\n        return result\n\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Helper function to find max sum using given equation\n    def helper(memo, n):\n        if n < 2:\n            return n\n        if n in memo:\n            return memo[n]\n        memo[n] = max(helper(memo, n//2) + helper(memo, n//3) + helper(memo, n//4) + helper(memo, n//5), n)\n        return memo[n]\n\n    # Initialize a memoization dictionary\n    memo = {}\n    # Call the helper function\n    return helper(memo, n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # base case: for n <= 5, the maximum sum is just n itself\n    if n <= 5:\n        return n\n\n    # Initialize a list to store the maximum sum for each number up to n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 3\n    dp[4] = 4\n    dp[5] = 5\n\n    for i in range(6, n + 1):\n        dp[i] = max(dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5], i)\n\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    if n < 1:\n        return 0\n\n    max_sum = [0] * (n + 1)\n    max_sum[1] = 1\n\n    for i in range(2, n + 1):\n        max_sum[i] = max(max_sum[i//2] + max_sum[i//3] + max_sum[i//4] + max_sum[i//5], i)\n\n    return max_sum[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    # DP table to store results of subproblems\n    dp = [0] * (n + 1)\n    # Base case initialization\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i//2] + dp[i//3] + dp[i//4] + dp[i//5], i)\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    def f(x):\n        if x <= 2:\n            return x\n        else:\n            return max(f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5), x)\n\n    return f(n)", "matching_cluster_idx": 5}, {"solution": "def get_max_sum(n):\n    def helper(n):\n        if n in memo:\n            return memo[n]\n\n        if n <= 5:\n            return n\n\n        res = max(helper(n // 2) + helper(n // 3) + helper(n // 4) + helper(n // 5), n)\n\n        memo[n] = res\n        return res\n\n    memo = {}\n    return helper(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a dictionary to store calculated sums for memoization\n    memo = {}\n\n    def f(n):\n        if n < 2:\n            return n\n        if n in memo:\n            return memo[n]\n\n        # Calculate the maximum sum for n using the given equation\n        max_sum = max(\n            (f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)),\n            n\n        )\n        memo[n] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n < 2:\n        return n\n    if n in memo:\n        return memo[n]\n    memo[n] = max(\n        get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo),\n        n\n    )\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 6, return n as the maximum sum\n    if n < 6:\n        return n\n\n    # List to store maximum sum for each number up to n\n    max_sums = [0] * (n+1)\n    max_sums[1] = 1\n    max_sums[2] = 2\n    max_sums[3] = 3\n    max_sums[4] = 4\n    max_sums[5] = 5\n\n    # Compute maximum sum for numbers from 6 to n\n    for i in range(6, n+1):\n        # Find the maximum value of (f(i/2) + f(i/3) + f(i/4) + f(i/5)) + i\n        max_sums[i] = max(max_sums[i//2] + max_sums[i//3] + max_sums[i//4] + max_sums[i//5], i)\n\n    return max_sums[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    def memoize(function):\n        memo = {}\n        def helper(x):\n            if x not in memo:\n                memo[x] = function(x)\n            return memo[x]\n        return helper\n\n    @memoize\n    def f(x):\n        if x <= 5:\n            return x\n        return max(f(x//2) + f(x//3) + f(x//4) + f(x//5), x)\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization to store results of subproblems\n    memo = {}\n\n    def max_sum(n):\n        # Base case: n must be greater than 5 for the function to make sense\n        if n <= 5:\n            return n\n        # If we've already solved this subproblem, return the memoized result\n        elif n in memo:\n            return memo[n]\n        else:\n            # Calculate the maximum sum using the given equation and store the result\n            memo[n] = max(max_sum(n // 2) + max_sum(n // 3) + max_sum(n // 4) + max_sum(n // 5), n)\n            return memo[n]\n\n    return max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n\n    if n <= 2:\n        result = n\n    else:\n        result = max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)\n\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Initialize a list to store the maximum sum for each number up to n\n    max_sums = [0] * (n + 1)\n\n    # Calculate the maximum sum for each number\n    for i in range(1, n + 1):\n        max_sums[i] = max(max_sums[i // 2] + max_sums[i // 3] + max_sums[i // 4] + max_sums[i // 5], i)\n\n    # Return the maximum sum for n\n    return max_sums[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n):\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        dp[i] = max(i, dp[i//2] + dp[i//3] + dp[i//4] + dp[i//5])\n    return dp[n]", "matching_cluster_idx": 10}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 5:\n        return n\n    result = max(\n        get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo),\n        n\n    )\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization to store calculated results\n    memo = {}\n\n    def dp(n):\n        if n in memo:\n            return memo[n]\n\n        if n < 2:\n            result = n\n        else:\n            result = max(dp(n//2) + dp(n//3) + dp(n//4) + dp(n//5), n)\n\n        memo[n] = result\n        return result\n\n    return dp(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    def solve(n):\n        if n < 4:\n            return n\n        elif n == 4:\n            return 4\n        else:\n            return max(solve(n // 2) + solve(n // 3) + solve(n // 4) + solve(n // 5), n)\n\n    return solve(n)", "matching_cluster_idx": 7}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 99.0, "profiled": [{"solution": "def first_non_repeating_character(string: str) -> str:\n    char_count = {}\n\n    # Count the occurrence of each character in the string\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Returns the first non-repeated character in a given string, else None if all characters are repeated.\n    \"\"\"\n    count_dict = {}\n    for char in string:\n        if char in count_dict:\n            count_dict[char] += 1\n        else:\n            count_dict[char] = 1\n    for char in string:\n        if count_dict[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    char_dict = {}\n    for char in s:\n        if char in char_dict:\n            char_dict[char] += 1\n        else:\n            char_dict[char] = 1\n    for char in s:\n        if char_dict[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    counter = {}\n    for c in s:\n        if c in counter:\n            counter[c] += 1\n        else:\n            counter[c] = 1\n\n    for c in s:\n        if counter[c] == 1:\n            return c\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    char_count = {}\n\n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If there's no non-repeating character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeating character in a string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The first non-repeating character if one exists, otherwise None.\n    \"\"\"\n    char_dict = {}\n    for char in s:\n        char_dict[char] = char_dict.get(char, 0) + 1\n\n    for char, count in char_dict.items():\n        if count == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string: str) -> str:\n    char_count = {}\n\n    # Count the occurrence of each character\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first non-repeating character\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # If there is no non-repeating character, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Count occurrences of each character in the string\n    counts = {char: s.count(char) for char in set(s)}\n\n    # Find the first character with a count of 1\n    for char in s:\n        if counts[char] == 1:\n            return char\n\n    # If no such character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string: str) -> str:\n    \"\"\"Find the first non-repeated character in a given string.\"\"\"\n    char_counts = {}\n    for char in string:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    counter = Counter(string)\n    for char in string:\n        if counter[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function finds the first non-repeated character in a given string.\n    If all characters are repeating, it returns None.\n    \"\"\"\n    count_dict = {}\n    for char in s:\n        if char in count_dict:\n            count_dict[char] += 1\n        else:\n            count_dict[char] = 1\n\n    for char in s:\n        if count_dict[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequencies\n    freq = {}\n\n    # Populate the dictionary\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n\n    # Iterate over the string and return the first non-repeating character\n    for char in s:\n        if freq[char] == 1:\n            return char\n\n    # Return None if there's no non-repeating character\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    # Create a dictionary to store character frequencies.\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n\n    # Return the first character that appears only once.\n    for char in s:\n        if freq[char] == 1:\n            return char\n\n    # If no non-repeating character is found, return None.\n    return None", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef first_non_repeating_character(string):\n    char_counts = Counter(string)\n    for char in string:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    # Iterate through the string to find the first character with a count of 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # If no such character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Return the first non-repeated character in the given string.\n    If all characters are repeated, return None.\n    \"\"\"\n    count = {}\n\n    # Count the occurrence of each character\n    for char in s:\n        count[char] = count.get(char, 0) + 1\n\n    # Find the first character with a count of 1\n    for char in s:\n        if count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character counts\n    char_counts = {}\n    for char in s:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n\n    # Iterate through the string to find the first non-repeating character\n    for char in s:\n        if char_counts[char] == 1:\n            return char\n\n    # Return None if all characters are repeated\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_str):\n    char_counts = {}\n    for char in input_str:\n        if char in char_counts:\n            char_counts[char] += 1\n        else:\n            char_counts[char] = 1\n    for char in input_str:\n        if char_counts[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeating character in a given string.\n    If all characters are repeating, return None.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 46.0, "profiled": [{"solution": "def check_tuplex(tup, element):\n    \"\"\"Check if an element exists in a tuple.\n\n    Args:\n        tup (tuple): The tuple to search in.\n        element: The element to search for.\n\n    Returns:\n        bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n\n    Args:\n        tup (tuple): A tuple to search.\n        element: The element to search for in the tuple.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n    \"\"\"\n    # Check if the element is in the tuple and return the result\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n    Args:\n    tup : tuple\n    elem : any\n    Returns:\n    bool\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    Args:\n    tup (tuple): The tuple to check.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    \"\"\"Check if an element exists in a tuple.\"\"\"\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tupl, element):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return element in tupl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element exists in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, item):\n    \"\"\"Check if an item exists in a tuple\"\"\"\n    return item in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tupl, element):\n    return element in tupl", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Using 'in' keyword to check if element exists in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, element):\n    # Check if element exists in tuple\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(input_tuple, target):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n    \"\"\"\n    return target in input_tuple", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"\n    This function checks if an element exists in a given tuple.\n    \"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"Check if an element exists in a tuple.\"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, elem):\n    \"\"\"Check if an element exists in a tuple.\"\"\"\n    return elem in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"Check if an element exists within a tuple.\"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, elem):\n    return elem in t", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 89.375612945407, "dps_norm": 88.88888888888889, "pass@1": 19.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): A sequence of values.\n    seq2 (list): A sequence of values.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(a, b):\n    return not set(a).isdisjoint(b)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    Check if any value in list1 exists in list2.\n    \"\"\"\n    return any(item in list2 for item in list1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2 or not.\n\n    :param seq1: The first sequence.\n    :param seq2: The second sequence.\n    :return: True if there is an overlap, False otherwise.\n    \"\"\"\n    return any(x in seq1 for x in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Check if any value in sequence1 exists in sequence2.\n\n    Parameters:\n    sequence1 (list): First sequence to check.\n    sequence2 (list): Second sequence to check.\n\n    Returns:\n    bool: True if any value from sequence1 is present in sequence2, else False.\n    \"\"\"\n    return any(item in sequence2 for item in sequence1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the sequences to sets and use intersection operation\n    return not set(seq1).isdisjoint(seq2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Check whether any value in sequence1 exists in sequence2.\n    \"\"\"\n    return any(item in sequence2 for item in sequence1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Checks if any value in sequence1 exists in sequence2\n    \"\"\"\n    return any(i in sequence2 for i in sequence1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    Check if any value in the first list exists in the second list.\n    \"\"\"\n    return any(item in list2 for item in list1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    This function checks whether any value in the first sequence exists in the second sequence.\n    \"\"\"\n    return any(val in list2 for val in list1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    # Check if any value from seq1 exists in seq2\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    # Using set operations for efficient lookups\n    return not set(list1).isdisjoint(list2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    Check whether any value in list1 exists in list2 or not.\n    \"\"\"\n    # Use set operations for efficient lookup\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # If there is any common element, return True\n    if set1 & set2:\n        return True\n    # If there are no common elements, return False\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    Checks if any value in list1 exists in list2.\n    Returns True if overlapping values are found, False otherwise.\n    \"\"\"\n    return any(item in list2 for item in list1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Function to check if any value in the first sequence exists in the second sequence.\n    \"\"\"\n    # Check if any value in sequence1 is in sequence2 using list comprehension and any() function\n    return any(item in sequence2 for item in sequence1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Checks if any value in sequence1 exists in sequence2.\n\n    :param sequence1: The first sequence to check.\n    :param sequence2: The second sequence to check against.\n    :return: True if any value in sequence1 exists in sequence2, False otherwise.\n    \"\"\"\n    return not set(sequence1).isdisjoint(sequence2)", "matching_cluster_idx": 7}, {"solution": "def overlapping(list1, list2):\n    \"\"\"\n    Check if any value in one list exists in the other list.\n    \"\"\"\n    return any(i in list2 for i in list1)", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 66.02880658436214, "dps_norm": 84.28571428571428, "pass@1": 81.0, "profiled": [{"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    # Initialize an empty string\n    result = \"\"\n\n    # Iterate over each element in the tuple\n    for element in input_tuple:\n        # Add the current element to the result\n        result += str(element) + delimiter\n\n    # Remove the trailing delimiter and return the result\n    return result.rstrip(delimiter)", "matching_cluster_idx": 3}, {"solution": "def concatenate_tuple(t):\n    # Check if input is a tuple\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input should be a tuple\")\n    # Join all elements of tuple with '-'\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    # Use the join() method to concatenate tuple elements with a specified delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    \"\"\"\n    This function takes a tuple and concatenates each element with a delimiter.\n    \"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t: tuple, delimiter: str = '-') -> str:\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenates each element of a tuple by a hyphen delimiter.\n    \"\"\"\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    This function concatenates each element of a tuple with a given delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Convert tuple to string with dash (-) as delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    \"\"\"Concatenates each element of a tuple with a delimiter.\"\"\"\n    return '-'.join(str(element) for element in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t, delimiter=\"-\"):\n    \"\"\"Concatenates each element of a tuple with a specified delimiter.\"\"\"\n    return delimiter.join(str(item) for item in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(str(item) for item in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup):\n    return '-'.join(str(t) for t in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t: tuple, delimiter: str = '-') -> str:\n    \"\"\"\n    Concatenates each element of the given tuple by the specified delimiter.\n    :param t: Tuple of elements to concatenate.\n    :param delimiter: String to use as a delimiter between elements (default is '-').\n    :return: Concatenated string.\n    \"\"\"\n    return delimiter.join(map(str, t))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 51.624548736462096, "dps_norm": 80.0, "pass@1": 96.0, "profiled": [{"solution": "def extract_rear(tup):\n    \"\"\"Extract the last character of each string in a given tuple.\"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    # Using list comprehension to get the last character of each string in the tuple.\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [string[-1] for string in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    \"\"\"\n    This function extracts the last character from each string in a tuple.\n    \"\"\"\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Use list comprehension to extract the rear element of each string in the tuple\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(lst):\n    return [x[-1] for x in lst]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    A function that extracts the last character of each string from a given tuple.\n    :param input_tuple: A tuple of strings\n    :return: A list of the last characters of each string in the tuple\n    \"\"\"\n    return [string[-1] for string in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(str_tuple):\n    return [s[-1] for s in str_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(lst):\n    \"\"\"\n    Function to extract only the rear index element of each string in the given tuple.\n    :param lst: A tuple of strings\n    :return: A list of rear index characters from each string in the tuple\n    \"\"\"\n    return [s[-1] for s in lst]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [word[-1] for word in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tpl):\n    return [s[-1] for s in tpl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(str_tuple):\n    # Use a list comprehension to extract the last character of each string\n    return [s[-1] for s in str_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    return [s[-1] for s in t]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    \"\"\"Extracts the rear index element of each string in the given tuple.\"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    # Use list comprehension to extract the rear index element from each string\n    return [string[-1] for string in strings]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    \"\"\"\n    Function to count the number of sublists containing a particular element.\n    \"\"\"\n    count = sum(element in sublist for sublist in sublists)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Parameters:\n    lst (list of lists): list of sublists.\n    element: the element to search for.\n\n    Returns:\n    int: count of sublists containing the element.\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists containing a particular element.\n    :param lst: list of lists\n    :param element: the element to be counted\n    :return: the count of sublists containing the given element\n    \"\"\"\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = sum(1 for sublist in sublists if element in sublist)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists containing a particular element in a nested list.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(sublists, element):\n    count = 0\n    for sublist in sublists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"Counts the number of sublists containing a particular element in a nested list.\"\"\"\n    count = sum(1 for sublist in nested_list if element in sublist)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists in a nested list that contain a specific element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 97.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Dive into a cycle of increasing order\n    while gap > 0:\n\n        for i in range(gap, n):\n            # add [arr[i], arr[i+1], ...] to the elements that have been gap sorted\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # reduce gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr) // 2\n\n    # While gap size is positive, update elements\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n\n            # Shift elements up to unsorted part\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # Place temp (the original arr[i]) in its correct location\n            arr[j] = temp\n\n        # Reduce gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap,n):\n            # add arr[i] to the elements that have been gap sorted save a[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n//2\n\n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in place\n    while gap > 0:\n        for i in range(gap,n):\n\n            # add arr[i] to the elements that have been gap sorted\n            # save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct\n            # location for arr[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original a[i]) into its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    gap = len(arr) // 2\n\n    # Perform insertion sort for this gap size.\n    # The last gap is 0, so there is no insertion in that case.\n    while gap > 0:\n\n        # Perform an insertion sort for this gap size.\n        # The loop starts at the appropriate point and it goes till the length of the array\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n\n            # shift earlier stripe's element up until correct location for current element is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # decrease the gap size\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    gap = len(arr) // 2\n    while gap > 0:\n        for i in range(gap, len(arr)):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Dive into a loop until the gap is 0\n    while gap > 0:\n        # Compare the elements at indices 'i' and 'j'\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                # Shift elements to the right if they're greater than temp\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Insert the temporary element\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Dive into a loop until gap becomes 0\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size.\n        # The first gap elements a[0..gap-1] are already in gapped order keep adding one more element until the entire array is gap sorted\n        for i in range(gap,n):\n\n            # add arr[i] to the elements that have been gap sorted save a gap sorted array in temp array\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while  j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Dive into a loop and make multiple passes\n    while gap > 0:\n        for i in range(gap, n):\n            # add [arr[i], arr[i-gap], ..., arr[0]] into the sorted array\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] > temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 63.82978723404255, "dps_norm": 60.0, "pass@1": 79.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"Check if the input number is greater than all elements in the array.\"\"\"\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, n):\n    \"\"\"\n    This function checks if all the elements in the given array are less than the input number.\n    :param arr: List of integers\n    :param n: Integer\n    :return: Boolean value, True if all elements are less than n, otherwise False\n    \"\"\"\n    return all([x < n for x in arr])", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all([i < num for i in arr])", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the given number is greater than all elements of the array.\n\n    :param arr: Array of integers\n    :param num: Number to be compared with array elements\n    :return: Boolean value - True if num is greater than all elements, else False\n    \"\"\"\n    return all(num > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if the given number is greater than all elements in the array.\n    \"\"\"\n    return all(item < number for item in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all([x < num for x in arr])", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"Check if a number is greater than all elements in an array.\"\"\"\n    return all(num > elem for elem in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks if the given number is greater than all the elements in the array.\n\n    Args:\n    array (list): A list of numbers.\n    number (int): A number to compare with.\n\n    Returns:\n    bool: True if the number is greater than all elements in the array, else False.\n    \"\"\"\n    return all(num < number for num in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(i < num for i in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if a given number is greater than all elements in the array.\n    \"\"\"\n    return all(n < num for n in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Function to check whether the given number is greater than all elements of the array.\n    Args:\n    arr (list): the input array\n    num (int): the number to compare\n    Returns:\n    bool: True if number is greater, False otherwise\n    \"\"\"\n    return all(n < num for n in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all([i < num for i in arr])", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, target):\n    \"\"\"\n    Check if the target number is greater than all elements in the array.\n    :param arr: list of integers\n    :param target: integer\n    :return: bool\n    \"\"\"\n    return all(target > i for i in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(nums, num):\n    return all(x < num for x in nums)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"Check if a number is greater than all elements of a list.\n\n    Args:\n    arr (list): The list to compare.\n    num (int): The number to compare with the elements in the list.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n    \"\"\"\n    return all([x < num for x in arr])", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    return all(element < num for element in array)", "matching_cluster_idx": 2}, {"solution": "def check_greater(array, num):\n    \"\"\"Check if all elements in the array are less than the given number.\"\"\"\n    return all(element < num for element in array)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 63.529411764705884, "dps_norm": 18.0, "pass@1": 29.0, "profiled": [{"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join(char for i, char in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return \"\".join(c for i, c in enumerate(s) if (i + 1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    return ''.join(c for i, c in enumerate(s) if (i + 1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    return \"\".join([char for i, char in enumerate(string) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s) if (i + 1) % 2 == 0)", "matching_cluster_idx": -1}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    Remove odd characters in a string.\n\n    Args:\n    input_string (str): The input string.\n\n    Returns:\n    str: The string with odd characters removed.\n    \"\"\"\n    return ''.join([char for i, char in enumerate(input_string) if (i + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    return ''.join(c for i, c in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": -1}, {"solution": "def remove_odd(string):\n    return ''.join([char for idx, char in enumerate(string) if (idx + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([c for i, c in enumerate(s) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    return ''.join([c for i, c in enumerate(s) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    return ''.join([char for idx, char in enumerate(input_string) if (idx+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Remove odd-positioned characters from a string.\n    :param s: input string\n    :return: string with odd-positioned characters removed\n    \"\"\"\n    return ''.join([c for i, c in enumerate(s) if (i + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    # Use a list comprehension to filter out odd indexed characters.\n    return ''.join(char for i, char in enumerate(string) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"Remove odd characters from a string.\"\"\"\n    return ''.join(ch for i, ch in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"Remove odd-positioned characters from the input string.\"\"\"\n    return ''.join(c for i, c in enumerate(s) if (i+1) % 2 == 0)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([c for i, c in enumerate(s) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    # Check if input is a string\n    assert isinstance(input_string, str), \"Input must be a string\"\n    return \"\".join([char for index, char in enumerate(input_string) if (index + 1) % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    return \"\".join([c for i, c in enumerate(input_string) if (i+1) % 2 == 0])", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 2.0, "profiled": []}, "Mbpp/446": {"dps": 96.45320197044335, "dps_norm": 64.0, "pass@1": 10.0, "profiled": [{"solution": "def count_Occurrence(tup: tuple, lst: list) -> int:\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(item) for item in lst)", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef count_Occurrence(tup: tuple, lst: list) -> int:\n    # Convert the tuple to a Counter object and the list to a list of keys\n    count = Counter(tup)\n    keys = [key for key in lst]\n    # Return the sum of counts for each key in the list\n    return sum(count[key] for key in keys)", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Counts the occurrences of all elements from lst in tup.\n    \"\"\"\n    return sum(tup.count(lst[i]) for i in range(len(lst)))", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tpl, lst):\n    return sum(tpl.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    return sum(t.count(i) for i in lst)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(input_tuple, input_list):\n    count = 0\n    for elem in input_list:\n        count += input_tuple.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for i in lst:\n        count += tup.count(i)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"\n    Function to remove all whitespaces from the given string.\n    :param s: string to remove whitespaces from\n    :return: string with all whitespaces removed\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    \"\"\"Removes all whitespaces from a given string.\"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"Removes all whitespaces from the input string.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    This function removes all whitespace characters from the given string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    \"\"\"Remove all whitespaces from the given string.\"\"\"\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string: str) -> str:\n    \"\"\"\n    Removes all whitespace characters from the given string.\n\n    :param input_string: The input string\n    :return: The input string without any whitespaces\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n        s (str): Input string.\n\n    Returns:\n        str: String without any whitespaces.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"Remove all whitespaces from the given string.\"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    \"\"\"\n    This function removes all whitespaces from the given string.\n    \"\"\"\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s: str) -> str:\n    # This function removes all whitespaces from the given string\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_str):\n    # Use string's replace method to replace all whitespaces with empty string\n    return input_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        s (str): input string\n\n    Returns:\n        str: output string without whitespaces\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string: str) -> str:\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(str_list):\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"Reverse each string in a given list.\"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"\n    This function takes a list of strings as an input and returns a new list\n    where each string in the original list is reversed.\n    \"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    \"\"\"Reverse each string in the input list.\"\"\"\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"Reverse each string in a given list of strings.\"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of strings and returns a new list where each string is reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Use list comprehension and the slicing trick to reverse each string in the list\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    \"\"\"Reverse each string in the input list.\"\"\"\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use list comprehension to reverse each string\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(input_list):\n    return [s[::-1] for s in input_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    This function takes a list of strings as an argument and returns a new list\n    containing the reversed version of each string.\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace occurrences of old_char in string s with new_char\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old: str, new: str) -> str:\n    \"\"\"Replace old with new in string s.\n\n    Args:\n    s (str): input string\n    old (str): substring to replace\n    new (str): replacement\n\n    Returns:\n    str: modified string\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    This function replaces all occurrences of 'old' character with 'new' in the given string 's'.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of 'old_char' in 'string' with 'new_char'.\n    Returns the modified string.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of a character in a string with another character.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"Replace all occurrences of old_char in s with new_char and return the result.\"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_str, old_char, new_char):\n    return input_str.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    This function replaces all occurrences of a specified old character\n    with a new character in a given string.\n\n    Args:\n    string (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The new character.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces occurrences of old_char with new_char in the given string.\n\n    :param string: input string\n    :param old_char: character to be replaced\n    :param new_char: character to replace old_char with\n    :return: modified string\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"Replace all occurrences of the old character with the new one in the given string.\"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char, replacement):\n    return string.replace(char, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"Replace specified character(s) with another in a given string\"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char, new_char):\n    return string.replace(char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of 'old_char' with 'new_char' in the 'input_string'.\n\n    Args:\n        input_string (str): The string to replace characters in.\n        old_char (str): The character to replace.\n        new_char (str): The character to replace 'old_char' with.\n\n    Returns:\n        str: The modified string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, target_char, replacement_char):\n    \"\"\"\n    Replace occurrences of target_char in input_string with replacement_char.\n\n    Args:\n    input_string (str): The string in which to perform the replacement.\n    target_char (str): The character to replace.\n    replacement_char (str): The character to replace target_char with.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    return input_string.replace(target_char, replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 50.0, "profiled": [{"solution": "def big_sum(numbers):\n    return sum([min(numbers), max(numbers)])", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the sum of the largest and smallest values in the list.\n    \"\"\"\n    return max(numbers) + min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"Find the sum of the largest and smallest value in a given array.\"\"\"\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Return the sum of the smallest and largest value in a given array.\"\"\"\n    if not arr:\n        raise ValueError(\"Array can't be empty\")\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    if not arr:  # if array is empty\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the input is an empty list\n    if not arr:\n        return 0\n\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n\n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the input is a list\n    assert isinstance(arr, list), \"Input should be a list.\"\n\n    # Check if the list is not empty\n    assert arr, \"List cannot be empty.\"\n\n    # Return the sum of the smallest and largest elements in the list\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Calculate the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"Return the sum of the smallest and largest values in an array.\"\"\"\n    if not arr:\n        return 0  # Handle case when the array is empty\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) == 0:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return sum([min(arr), max(arr)])", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes a list of numbers as an argument and returns the sum of the largest and smallest values in the list.\n\n    Args:\n        arr (list): A list of numbers\n\n    Returns:\n        int: The sum of the largest and smallest values in the list\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:  # Empty array\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 11.0, "profiled": [{"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert a string to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The string to convert.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function converts a given string to lower case.\n    Args:\n        s (str): The string to be converted.\n    Returns:\n        str: The converted string.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    :param s: input string\n    :return: string in lower case\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"Convert the given string to lower case.\"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 84.86338797814209, "dps_norm": 83.63636363636363, "pass@1": 26.0, "profiled": [{"solution": "import re\ndef extract_values(string):\n    # Define the pattern to match items inside quotation marks\n    pattern = r'\"([^\"]*)\"'\n    # Find all matches using regex\n    matches = re.findall(pattern, string)\n    # Return the list of matches\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use a regular expression to find all sequences of characters between double quotes.\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    # Return the found matches as a list.\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regex to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # Initialize an empty list to store the extracted values\n    result = []\n\n    # Use regular expression to find all substrings between quotation marks\n    import re\n    matches = re.findall(r'\"([^\"]*)\"', s)\n\n    # Convert the matches to a list and return\n    result.extend(matches)\n    return result", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    import re\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # Initialize an empty list to store the extracted values\n    values = []\n\n    # Check for quotation marks, and if found extract the value\n    start = s.find('\"')\n    while start != -1:\n        end = s.find('\"', start + 1)\n        if end != -1:\n            values.append(s[start + 1:end])\n            start = s.find('\"', end + 1)\n        else:\n            break\n\n    return values", "matching_cluster_idx": 10}, {"solution": "import re\ndef extract_values(s):\n    \"\"\"Extract values between quotation marks from a string.\"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    # Using regular expression to extract values between quotation marks\n    import re\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # Start by initializing an empty list to store the extracted values\n    result = []\n\n    # Initialize starting index of the current word\n    start = 0\n\n    # Loop through each character in the input string\n    for i in range(len(s)):\n\n        # If the current character is a double quote and the start index is not at the beginning of the string,\n        # it means we've found a complete word, so add it to the result list\n        if s[i] == '\"' and start != 0:\n            result.append(s[start:i])\n            start = 0\n        # If the current character is a double quote and the start index is at the beginning of the string,\n        # it means we've found the start of a new word, so update the start index to the current position\n        elif s[i] == '\"' and start == 0:\n            start = i + 1\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_values(s):\n    values = []\n    start = 0\n    while start < len(s):\n        i = s.find('\"', start)\n        if i < 0:\n            break\n        j = s.find('\"', i+1)\n        if j < 0:\n            break\n        values.append(s[i+1:j])\n        start = j+1\n    return values", "matching_cluster_idx": 10}, {"solution": "import re\ndef extract_values(s: str) -> list:\n    \"\"\"Extracts values between quotation marks from a string.\"\"\"\n    # Use regex to find all substrings enclosed in quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    values = []\n    start = string.find('\"')\n    while start != -1:\n        end = string.find('\"', start + 1)\n        if end != -1:\n            values.append(string[start+1:end])\n            start = string.find('\"', end + 1)\n        else:\n            break\n    return values", "matching_cluster_idx": 10}, {"solution": "def extract_values(input_string):\n    # Using regular expression to find strings enclosed in quotation marks\n    import re\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # The regex pattern for extraction\n    pattern = r'\"([^\"]*)\"'\n    # find all matches\n    matches = re.findall(pattern, string)\n    return [match for match in matches]", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    # Use regular expression to find all substrings within quotation marks\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"Extract values between quotation marks from a string.\"\"\"\n    return re.findall(r'\"([^\"]*)\"', string)", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    result = []\n    start = input_string.find('\"')\n    while start != -1:\n        end = input_string.find('\"', start + 1)\n        if end != -1:\n            result.append(input_string[start + 1:end])\n            start = input_string.find('\"', end + 1)\n        else:\n            break\n    return result", "matching_cluster_idx": 10}, {"solution": "def extract_values(s):\n    values = []\n    start = s.find('\"')\n    while start != -1:\n        end = s.find('\"', start + 1)\n        if end != -1:\n            values.append(s[start+1:end])\n            start = s.find('\"', end + 1)\n        else:\n            break\n    return values", "matching_cluster_idx": 10}]}, "Mbpp/572": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/578": {"dps": 73.6031746031746, "dps_norm": 66.81818181818183, "pass@1": 89.0, "profiled": [{"solution": "def interleave_lists(*args):\n    # Check all lists have same length\n    if not all(len(lst) == len(args[0]) for lst in args):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Interleave the lists\n    result = []\n    for lst in zip(*args):\n        for item in lst:\n            result.append(item)\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*lists):\n    return [item for sublist in zip(*lists) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "from itertools import zip_longest\ndef interleave_lists(*lists):\n    return [item for sublist in zip_longest(*lists) for item in sublist if item is not None]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*lists):\n    return [val for sublist in zip(*lists) for val in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    \"\"\"Interleave multiple lists of the same length into a single list\"\"\"\n    length = len(args[0])\n    for lst in args[1:]:\n        if len(lst) != length:\n            raise ValueError(\"All input lists must be of the same length\")\n    return [value for sublist in zip(*args) for value in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    return [elem for sublist in zip(*args) for elem in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    result = []\n    max_len = max([len(arg) for arg in args])\n    for i in range(max_len):\n        for arg in args:\n            if i < len(arg):\n                result.append(arg[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def interleave_lists(*args):\n    interleave_list = []\n    for i in range(max(len(arg) for arg in args)):\n        for arg in args:\n            try:\n                interleave_list.append(arg[i])\n            except IndexError:\n                pass\n    return interleave_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*lists):\n    \"\"\"Interleave multiple lists into a single flat list.\"\"\"\n    # Find the length of the shortest list\n    min_length = min(len(l) for l in lists)\n\n    # Use list comprehension to interleave the lists\n    return [x for i in range(min_length) for x in [l[i] for l in lists]]", "matching_cluster_idx": 4}, {"solution": "def interleave_lists(*lists):\n    # Check if all lists have the same length\n    if not all(len(l) == len(lists[0]) for l in lists):\n        raise ValueError(\"All lists must have the same length\")\n\n    # Interleave elements from all lists\n    return [element for sublist in zip(*lists) for element in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    return [element for sublist in zip(*lists) for element in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if the input lists have the same length\n    assert len(list1) == len(list2) == len(list3), \"Input lists must have the same length\"\n\n    # Initialize an empty list to store the interleave results\n    result = []\n\n    # Use a for loop to iterate over each element in the first list\n    for i in range(len(list1)):\n        # Interleave the elements from all three lists and append them to the result list\n        result.extend([list1[i], list2[i], list3[i]])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*args):\n    # zip_longest with fillvalue=None would give us pairs of lists until the shortest list ends\n    # then we take the first item of each pair, then the second item and so on until all lists are done\n    return [x for pair in zip(*args) for x in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    return [item for sublist in zip(*args) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    return [item for sublist in zip(*lists) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*lists):\n    # Ensure all lists are of the same length\n    assert all(len(lst) == len(lists[0]) for lst in lists), \"All lists must have the same length\"\n\n    # Interleave lists using zip_longest from itertools which fills missing values with None\n    from itertools import zip_longest\n    return [elem for sublist in zip_longest(*lists) for elem in sublist if elem is not None]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(*args):\n    result = []\n    max_len = max(len(lst) for lst in args)\n    for i in range(max_len):\n        for lst in args:\n            if i < len(lst):\n                result.append(lst[i])\n    return result", "matching_cluster_idx": 4}, {"solution": "def interleave_lists(list1, list2, list3):\n    return [val for sublist in zip(list1, list2, list3) for val in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(*args):\n    # Check if all input lists have the same length\n    assert all(len(args[0]) == len(lst) for lst in args), \"All input lists should have the same length\"\n\n    result = []\n    for lst in zip(*args):\n        result.extend(lst)\n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(*args):\n    return [num for sublist in zip(*args) for num in sublist]", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 16.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Function to split a list at the nth element and add the first part to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Check if index is within range\n    if n < 0 or n > len(arr):\n        raise ValueError(\"Invalid index\")\n\n    # Split the list at the nth element and concatenate the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    if n < 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # split the array at the nth element\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list at the nth element and add the first part to the end\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Slice the list into two parts at the nth element\n    first_part, second_part = lst[:n], lst[n:]\n\n    # Add the first part to the end of the second part\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    \"\"\"\n    This function takes a list and an index as input, splits the list at the nth element\n    and adds the first part to the end of the second part.\n    \"\"\"\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    return lst[n:] + lst[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    if not nums:\n        return 0\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function takes a list of numbers and returns the difference between the largest and smallest values.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n\n    Args:\n    nums (list): Input list\n\n    Returns:\n    int: Difference between the largest and smallest values in the list\n    \"\"\"\n    if len(nums) == 0:\n        return 0  # edge case: empty list\n    else:\n        return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    # Check if list is empty\n    if not lst:\n        return 0\n    else:\n        # Return the difference between the largest and smallest value in the list\n        return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Find the difference between largest and smallest value in a given list.\"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst) if lst else 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Find the difference between the largest and smallest value in a given list.\"\"\"\n    if not nums:  # check if the list is empty\n        raise ValueError(\"List must not be empty\")\n\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst) if lst else 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(num_list):\n    # Check if the list is not empty\n    if not num_list:\n        return \"Error: The list is empty.\"\n\n    # Find the maximum and minimum values\n    max_val = max(num_list)\n    min_val = min(num_list)\n\n    # Return the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Find the difference between the largest and smallest value in a list\"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"Find the difference between the largest and smallest value in the given list.\"\"\"\n    if not nums:  # If the list is empty\n        raise ValueError(\"List must not be empty\")\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 35.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    # Concatenate and sort the two arrays\n    merged = sorted(arr1 + arr2)\n    # Return the kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    Args:\n        arr1 (List[int]): The first sorted array.\n        arr2 (List[int]): The second sorted array.\n        k (int): The index of the kth element.\n\n    Returns:\n        int: The kth element from the combined array of arr1 and arr2.\n    \"\"\"\n    combined = sorted(arr1 + arr2)\n    return combined[k-1] if k-1 < len(combined) else None", "matching_cluster_idx": 3}, {"solution": "def find_kth(lst1, lst2, k):\n    merged = sorted(lst1 + lst2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(lst1, lst2, k):\n    # Merge the two sorted arrays\n    merged = sorted(lst1 + lst2)\n    # Return the kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n\n    # Return the kth element from the merged array\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combining two arrays and sorting them\n    combined = sorted(arr1 + arr2)\n\n    # Returning the kth element\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1] if k <= len(merged) else None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    merged = sorted(arr1 + arr2)\n\n    # Return the kth element from the merged array\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Combine the two sorted arrays\n    combined = sorted(arr1 + arr2)\n\n    # Return the kth element from the combined array\n    return combined[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge two sorted arrays\n    merged = sorted(arr1 + arr2)\n    # Return the kth element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays into one and sort it\n    merged = sorted(arr1 + arr2)\n\n    # Return the kth element\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    merged = sorted(arr1 + arr2)\n    return merged[k - 1] if k <= len(merged) else None", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 74.0, "profiled": [{"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    return ' '.join(input_string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    return ' '.join(input_string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    # Split the input string into words using space as a separator\n    words = input_str.split()\n\n    # Reverse the list of words\n    reversed_words = words[::-1]\n\n    # Join the reversed words back into a single string with spaces\n    result = ' '.join(reversed_words)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    return ' '.join(string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    return ' '.join(input_str.split()[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 56.594202898550726, "dps_norm": 57.85714285714286, "pass@1": 34.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"Remove the k'th element from the list.\"\"\"\n    if 1 <= k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        raise ValueError(\"k is out of range\")", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"Remove the k'th element from the list.\"\"\"\n    if 0 < k <= len(lst):\n        lst.pop(k - 1)  # Python lists are 0-indexed, so we adjust k for this.\n    return lst", "matching_cluster_idx": 5}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Function to remove the k'th element from the list.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        raise ValueError(\"Invalid value of k. It should be between 1 and length of the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if 1 <= k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"Remove the k'th element from a list.\"\"\"\n    if 0 < k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst  # or raise an exception, depending on what you want to do when k is out of bounds", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst  # Return the list as it is, if k is out of bounds\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if 1 <= k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Check if k is within the range of the list\n    if 0 < k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        raise ValueError(\"k should be between 1 and the length of the list.\")", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Check if k is within valid range\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k must be within the range of list indices.\")\n\n    # Remove k'th element\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(input_list, k):\n    # Check if k is within the valid range\n    if k < 1 or k > len(input_list):\n        raise ValueError(\"k should be within the range 1 to length of the list\")\n    return input_list[:k-1] + input_list[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Ensure the list is not empty and k is a valid index\n    assert lst, \"List is empty\"\n    assert 0 < k <= len(lst), \"k is out of range\"\n\n    # Remove the k'th element (0-indexed) and return the resulting list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Check if the input list is valid\n    if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst) or not isinstance(k, int) or k <= 0 or k > len(lst):\n        raise ValueError(\"Invalid input. Please provide a list of integers and a valid k.\")\n\n    # Remove the k'th element from the list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 2}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Returns a new list with the k-th element removed from the original list.\n    List index starts from 1.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Check if k is within range\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k is out of range\")\n    # Remove k'th element and return the new list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    # Make sure k is within the list's length\n    if k < 1 or k > len(lst):\n        raise ValueError(\"k is out of range\")\n    # Remove the k'th element and return the updated list\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if 1 <= k <= len(lst):\n        return lst[:k-1] + lst[k:]\n    else:\n        return lst", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        raise ValueError(\"Invalid k. It should be between 1 and the length of the list.\")\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 41.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(col[n] for col in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(m, n):\n    return max(row[n] for row in m)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    if len(matrix) == 0 or n >= len(matrix[0]):\n        return None\n\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return the max value of the nth column in a given matrix.\"\"\"\n    return max(col[n] for col in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Return the max value of the n'th column in the given matrix.\n    \"\"\"\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Return the max of the n'th column of the given matrix.\n\n    Args:\n    matrix (list of lists): The input matrix.\n    n (int): The index of the column (0-based).\n\n    Returns:\n    int: The max value in the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return the maximum of the n'th column in the given matrix.\n\n    Args:\n        matrix (List[List[int]]): A matrix represented as a list of lists.\n        n (int): The column number.\n\n    Returns:\n        int: The maximum value in the n'th column.\n    \"\"\"\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"Return the maximum of the n'th column in the matrix.\"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value in the n'th column of the input matrix.\n    \"\"\"\n    # First, check if the matrix is empty or the n'th column doesn't exist\n    if not matrix or n >= len(matrix[0]):\n        return None\n\n    # Initialize max_value with the first element of the n'th column\n    max_value = matrix[0][n]\n\n    # Iterate over the rest of the matrix and update max_value if needed\n    for row in matrix[1:]:\n        max_value = max(max_value, row[n])\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(column[n] for column in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/632": {"dps": 95.28142589118198, "dps_norm": 98.57142857142857, "pass@1": 34.0, "profiled": [{"solution": "def move_zero(lst):\n    # Initialize a new list with only non-zero values from the input list\n    non_zero = [x for x in lst if x != 0]\n\n    # If the input list is not empty, append zeros at the end\n    if non_zero:\n        return non_zero + [0] * (len(lst) - len(non_zero))\n    else:\n        # If the input list is empty, return an empty list\n        return []", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    return [i for i in nums if i != 0] + [0] * nums.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Use list comprehension to create a new list with only non-zero elements\n    non_zero_lst = [x for x in lst if x != 0]\n    # Use list comprehension to create a new list with only zero elements\n    zero_lst = [0] * (len(lst) - len(non_zero_lst))\n    # Combine the two lists and return the result\n    return non_zero_lst + zero_lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Iterate over the list and remove zeroes\n    zeroes = lst.count(0)\n    for _ in range(zeroes):\n        lst.remove(0)\n    # Append zeroes to the end\n    return lst + [0]*zeroes", "matching_cluster_idx": 4}, {"solution": "def move_zero(lst):\n    # Using two pointers to keep track of non-zero elements\n    ptr = 0\n    n = len(lst)\n\n    for i in range(n):\n        if lst[i] != 0:\n            lst[ptr], lst[i] = lst[i], lst[ptr]\n            ptr += 1\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Using list comprehension to create a new list with all non-zero elements\n    # followed by zero elements from the original list\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeroes in the list\n    zero_count = lst.count(0)\n\n    # Remove all zeroes from the list\n    lst = [i for i in lst if i != 0]\n\n    # Append zeroes at the end\n    lst.extend([0]*zero_count)\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    This function takes a list of integers and returns a new list with all zeroes moved to the end.\n\n    :param arr: List of integers.\n    :return: A new list with zeroes moved to the end.\n    \"\"\"\n    return [i for i in arr if i != 0] + [i for i in arr if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Function that moves all zeroes to the end of the given list.\n\n    :param lst: List of integers\n    :return: List with all zeroes moved to the end\n    \"\"\"\n    # Use list comprehension to filter out the zeroes and create a new list\n    # Then, append the remaining zeroes to the end of the new list\n    return [x for x in lst if x != 0] + [0] * lst.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the list.\n    \"\"\"\n    # Create two empty lists to hold non-zero and zero elements\n    non_zero, zero = [], []\n\n    # Iterate through the input list\n    for num in lst:\n        if num == 0:\n            zero.append(num)\n        else:\n            non_zero.append(num)\n\n    # Concatenate the two lists\n    return non_zero + zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"Move all zeroes to the end of the list while maintaining order of other elements.\"\"\"\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i != 0] + [0] * lst.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Using list comprehension to create a new list with zeroes removed\n    # and then appending zeroes to the end\n    return [i for i in lst if i != 0] + [0] * lst.count(0)", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of zeros\n    count = lst.count(0)\n\n    # Filter out the zeros and join them at the end\n    result = [i for i in lst if i != 0] + [0]*count\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"Move all zeros to the end of the given list.\"\"\"\n    return [i for i in lst if i != 0] + [i for i in lst if i == 0]", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    return [num for num in nums if num != 0] + [0] * nums.count(0)", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "Mbpp/644": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/720": {"dps": 93.84615384615384, "dps_norm": 98.0, "pass@1": 90.0, "profiled": [{"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t: tuple, d: dict) -> tuple:\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple.\n\n    Args:\n        tup (tuple): The tuple to add the dictionary to.\n        d (dict): The dictionary to add to the tuple.\n\n    Returns:\n        tuple: The tuple with the dictionary added at the end.\n    \"\"\"\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(input_tuple, input_dict):\n    return input_tuple + (input_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"Adds a dictionary to a tuple and returns a tuple.\"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    # Check if input is valid\n    if not isinstance(tup, tuple) or not isinstance(dic, dict):\n        raise ValueError(\"Both inputs must be a tuple and a dictionary respectively.\")\n\n    # Add dictionary to tuple and return\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"Adds a dictionary to a tuple and returns the result as a tuple.\"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"Add a dictionary to a tuple and return the new tuple\"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dct):\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    # Check if the input is indeed a tuple\n    if not isinstance(tup, tuple):\n        raise TypeError(\"First argument should be a tuple\")\n    # Check if the input is indeed a dictionary\n    if not isinstance(dict_to_add, dict):\n        raise TypeError(\"Second argument should be a dictionary\")\n\n    # Add the dictionary to the tuple\n    new_tuple = tup + (dict_to_add,)\n    return new_tuple", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    This function adds a dictionary to the end of the input tuple.\n\n    Args:\n    tup (tuple): Input tuple.\n    dictionary (dict): Dictionary to be added.\n\n    Returns:\n    tuple: Tuple with the dictionary added.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"Add a dictionary to a tuple and return the resulting tuple\"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup: tuple, dct: dict) -> tuple:\n    return tup + (dct,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    \"\"\"Add a dictionary to a tuple.\n\n    Args:\n    tup (tuple): Tuple to which dictionary will be added.\n    dict_to_add (dict): Dictionary to add to the tuple.\n\n    Returns:\n    tuple: New tuple with the dictionary as the last element.\n    \"\"\"\n    # Combine the tuple and dictionary into a list\n    combined = list(tup)\n    combined.append(dict_to_add)\n\n    # Convert the list back into a tuple and return\n    return tuple(combined)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dict_to_add):\n    return tup + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    \"\"\"Adds a dictionary to a tuple and returns the new tuple.\"\"\"\n    return tup + (d,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 74.53551912568305, "dps_norm": 75.625, "pass@1": 38.0, "profiled": [{"solution": "def extract_quotation(s: str) -> list:\n    result = []\n    start = s.find('\"')\n    while start != -1:\n        end = s.find('\"', start + 1)\n        if end != -1:\n            result.append(s[start+1:end])\n            start = s.find('\"', end + 1)\n        else:\n            break\n    return result", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    # Using regular expression to find values between double quotations\n    results = re.findall(r'\"(.*?)\"', s)\n    return results", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    # Start a list to store extracted values\n    extracted_values = []\n\n    # Start of the string to check for opening quotation marks\n    start = 0\n\n    while True:\n        # Find the index of the opening quotation mark\n        start = input_string.find('\"', start)\n\n        if start == -1:  # If no opening quotation mark is found, break the loop\n            break\n\n        # Find the index of the closing quotation mark\n        end = input_string.find('\"', start + 1)\n\n        if end == -1:  # If no closing quotation mark is found, break the loop\n            break\n\n        # Add the extracted value to the list\n        extracted_values.append(input_string[start + 1: end])\n\n        # Move the start index to the character after the closing quotation mark\n        start = end + 1\n\n    return extracted_values", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    result = []\n    start = s.find('\"')\n    while start != -1:\n        end = s.find('\"', start + 1)\n        if end != -1:\n            result.append(s[start + 1:end])\n            start = s.find('\"', end + 1)\n        else:\n            break\n    return result", "matching_cluster_idx": 4}, {"solution": "def extract_quotation(s):\n    # Use regular expression to find all substrings between quotation marks\n    import re\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regex to find everything between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(input_string):\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\nimport unittest\ndef extract_quotation(text):\n    \"\"\"\n    Extract values between quotation marks of the given string.\n\n    Args:\n        text (str): The input string.\n\n    Returns:\n        list: A list of extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regex to match anything enclosed by double quotes and return as a list\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    result = []\n    start_index = input_string.find('\"')\n    while start_index != -1:\n        end_index = input_string.find('\"', start_index + 1)\n        if end_index != -1:\n            result.append(input_string[start_index+1 : end_index])\n            start_index = input_string.find('\"', end_index + 1)\n        else:\n            break\n    return result", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"Extract values between quotation marks \" \" from a given string.\"\"\"\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ',':').replace(',',':').replace('.',':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    s = s.replace(' ', ':')\n    s = s.replace(',', ':')\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(input_string):\n    return input_string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    \"\"\"Replace all occurrences of spaces, commas, or dots with a colon.\"\"\"\n    return string.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # Replace spaces, commas, and dots with a colon\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(\" \", \":\").replace(\",\", \":\").replace(\".\", \":\")", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 81.14545454545456, "dps_norm": 67.77777777777779, "pass@1": 99.0, "profiled": [{"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a given tuple into a dictionary using adjacent elements as key-value pairs.\n    \"\"\"\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    :param t: input tuple\n    :return: a dictionary using adjacent elements as key-value pairs\n    \"\"\"\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    This function converts a given tuple to a key-value dictionary\n    using adjacent elements as key-value pairs.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    # Check if the tuple has even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements.\")\n\n    # Convert the tuple to a dictionary\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(sequence):\n    # Check if the length of sequence is odd, as it needs to be even for the conversion\n    if len(sequence) % 2 != 0:\n        raise ValueError(\"Sequence must have an even length\")\n\n    # Initialize the dictionary and iterate over the sequence with a step of 2\n    result = {}\n    for i in range(0, len(sequence), 2):\n        key, value = sequence[i], sequence[i + 1]\n        result[key] = value\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    # Check if the input is a tuple\n    if not isinstance(tup, tuple) or len(tup) % 2 != 0:\n        raise ValueError(\"Input must be a tuple of even length\")\n\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tt):\n    \"\"\"\n    This function converts a given tuple of elements into a key-value dictionary using adjacent elements.\n    :param tt: tuple\n    :return: dictionary\n    \"\"\"\n    return {tt[i]: tt[i+1] for i in range(0, len(tt)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError(\"Input tuple must have an even number of elements\")\n\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"Convert a tuple to a key-value dictionary using adjacent elements.\"\"\"\n    return {t[i]: t[i+1] for i in range(0, len(t) - 1, 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 89.31506849315069, "dps_norm": 92.5, "pass@1": 99.0, "profiled": [{"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value or not.\n\n    Args:\n        t (tuple): Input tuple.\n\n    Returns:\n        bool: True if the tuple has any None value, False otherwise.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any None value or not.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"Check if given tuple has any None value.\"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"Check if the given tuple has any None value or not.\"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"Check if any value in the given tuple is None.\"\"\"\n    return any(x is None for x in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"Check if the given tuple has any None value or not.\"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the input tuple has any None value or not\"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    # Check if None is present in the tuple\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n\n    Args:\n        input_tuple (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: Returns True if the tuple contains None, else returns False.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    # Check if any element in the tuple is None\n    return any(x is None for x in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Check if the given tuple has any None value or not.\n    :param input_tuple: tuple\n    :return: bool\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    # Iterate over each element in the tuple\n    for i in t:\n        # Check if any element is None\n        if i is None:\n            return True\n    # If no None found, return False\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tpl):\n    \"\"\"\n    Checks if the given tuple has any None value or not.\n    Args:\n        tpl (tuple): Input tuple\n    Returns:\n        bool: Returns True if tuple contains None, False otherwise\n    \"\"\"\n    return None in tpl", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    if None in t:\n        return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    :param tup: Tuple to check\n    :return: True if None is found, False otherwise\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(input_tuple):\n    \"\"\"Check if the given tuple has any None value.\"\"\"\n    # Iterate through the tuple and return True if None is found\n    return None in input_tuple", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 45.64625850340136, "dps_norm": 50.833333333333336, "pass@1": 85.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    \"\"\"Add the given tuple to the given list\"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"Extend the given list with the elements from the given tuple.\"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    # Use the extend() function to add elements of the tuple to the list\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"Add the elements of the given tuple to the given list.\"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(to_list, to_add):\n    to_list.extend(to_add)\n    return to_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(to_list, to_add):\n    return to_list + list(to_add)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(to_list, to_add):\n    \"\"\"Add the given tuple to the given list.\"\"\"\n    return to_list + list(to_add)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"Add the elements of the given tuple to the given list.\"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Args:\n    lst (list): The input list.\n    tpl (tuple): The tuple to be added.\n\n    Returns:\n    list: The resulting list.\n    \"\"\"\n    return lst + list(tpl)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"Add a tuple to the end of a list.\"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"Add the given tuple to the given list.\"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst: list, tup: tuple) -> list:\n    return lst + list(tup)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(lst, tpl):\n    return lst + list(tpl)", "matching_cluster_idx": 1}, {"solution": "def add_tuple(to_list, to_add):\n    return to_list + list(to_add)", "matching_cluster_idx": 1}]}, "Mbpp/753": {"dps": 78.12080536912752, "dps_norm": 70.0, "pass@1": 89.0, "profiled": [{"solution": "def min_k(tuples, k):\n    # Sort the tuples by their second element in ascending order\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n\n    # Return the first k tuples\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records by the second element in ascending order (i.e., by value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first 'k' records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    # Sort the records by second element in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuples, k):\n    # Sort the tuples by the second element (value) in ascending order\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n\n    # Return the first k tuples\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort tuples based on second element in ascending order\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n\n    # Return the first k elements\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records by the second element (score) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort records by second element of tuple (record's score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k records with the lowest scores\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    return sorted(tuples, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element in each tuple (score)\n    sorted_records = sorted(records, key=lambda x: x[1])\n\n    # Return the first k records\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(tuples_list, k):\n    return sorted(tuples_list, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the list based on the second element of each tuple\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n\n    # Return the first k elements of the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort the list of tuples based on the second element in each tuple (ascending order)\n    sorted_tuples = sorted(tuples, key=lambda x: x[1])\n    # Return the first k tuples from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples, k):\n    # Sort tuples based on the second element (score) in ascending order\n    tuples.sort(key=lambda x: x[1])\n    # Return the first k tuples\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "from typing import Tuple, List\ndef min_k(tuples: Tuple[Tuple[str, int]], k: int) -> List[Tuple[str, int]]:\n    # Sorting tuple based on the second item in ascending order\n    tuples.sort(key=lambda x: x[1])\n    # Returning the first k tuples\n    return tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort tuples based on the second element (score) in ascending order\n    tuples_list.sort(key=lambda x: x[1])\n    # Return the first k tuples\n    return tuples_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(record_list, k):\n    # Sort the record list based on the second element of each tuple in ascending order\n    record_list.sort(key=lambda x: x[1])\n    # Return the first k tuples\n    return record_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Function to find minimum k records from a list of records (represented as tuples)\n    Each record is represented as (name, score)\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element in ascending order\n    records.sort(key=lambda x: x[1])\n    # Return the first k records\n    return records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 75.3448275862069, "dps_norm": 78.75, "pass@1": 31.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(len(l1)):\n        if i < len(l2) and i < len(l3) and l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extract common elements from three lists at the same indices.\n    \"\"\"\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))  # find the minimum length among the three lists\n\n    for i in range(min_length):\n        # check if elements are the same and append them to the result list\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the length of the shortest list\n    length = min(len(l1), len(l2), len(l3))\n\n    # Create a list to store common elements\n    common_elements = []\n\n    # Iterate over the length of the shortest list\n    for i in range(length):\n        # Check if the elements at the current index in all lists are the same\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, append the element to the list of common elements\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(*args):\n    common_elements = []\n    # check for the length of the shortest list to iterate over indices\n    for i in range(min(len(arg) for arg in args)):\n        # check if elements at current index in all lists are the same\n        if all(args[j][i] == args[0][i] for j in range(1, len(args))):\n            common_elements.append(args[0][i])\n    return common_elements", "matching_cluster_idx": 1}, {"solution": "def extract_index_list(l1, l2, l3):\n    return [e for i, e in enumerate(l1) if i < len(l2) and i < len(l3) and e == l2[i] and e == l3[i]]", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the length of the smallest list to iterate up to\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n\n    # Iterate over indices up to the min_length\n    for i in range(min_length):\n        # Check if elements at current index in all lists are equal\n        if l1[i] == l2[i] == l3[i]:\n            # If yes, add it to the common_elements list\n            common_elements.append(l1[i])\n\n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Determine the length of the shortest list\n    min_len = min(len(l1), len(l2), len(l3))\n\n    # Initialize the result list\n    result = []\n\n    # Iterate over the minimum length\n    for i in range(min_len):\n        # Check if the elements at the current index are equal in all lists\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Get common lengths of the lists\n    common_length = min(len(l1), len(l2), len(l3))\n\n    # Extract common elements\n    common_elements = [l1[i] for i in range(common_length) if l1[i] == l2[i] == l3[i]]\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Get the minimum length of the lists to iterate\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Return list of common elements at same index\n    return [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Zip the lists and convert to list of tuples\n    zipped = list(zip(l1, l2, l3))\n    # Use list comprehension to filter elements where all elements in tuple are equal\n    result = [item for item in zipped if all(x == item[0] for x in item)]\n    # Extract the common elements and return as list\n    return [item[0] for item in result]", "matching_cluster_idx": 1}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Get the minimum length of the lists\n    min_len = min(len(l1), len(l2), len(l3))\n\n    # Initialize an empty list for common elements\n    common_elements = []\n\n    # Iterate over the indices up to the minimum length\n    for i in range(min_len):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, append the element to the list of common elements\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find common indices\n    common_indices = [i for i in range(min(len(l1), len(l2), len(l3))) if l1[i] == l2[i] == l3[i]]\n\n    # Return common elements at these indices\n    return [l1[i] for i in common_indices]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    # Check length of all lists and iterate up to the length of the shortest one\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        # Check if the elements at the same index in all lists are equal\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n\n    # Extract common elements\n    common_elements = [l1[i] for i in range(min_length) if l1[i] == l2[i] == l3[i]]\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 75.57522123893806, "dps_norm": 90.0, "pass@1": 49.0, "profiled": [{"solution": "def second_smallest(numbers):\n    if len(set(numbers)) < 2:\n        return None\n    return sorted(set(numbers))[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Remove duplicates to prevent an empty list\n    unique_numbers = list(set(numbers))\n\n    # If there are less than 2 unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n\n    unique_numbers.sort()\n    # Return the second element (index 1) in the sorted list\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Filter out duplicate values\n    unique_numbers = list(set(numbers))\n    # Sort unique numbers in ascending order\n    unique_numbers.sort()\n    # Return the second smallest number\n    if len(unique_numbers) >= 2:\n        return unique_numbers[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None\n\n    nums = sorted(set(nums))\n    return nums[1] if len(nums) >= 2 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Removing duplicate elements and sorting the list\n    sorted_nums = sorted(set(nums))\n\n    # Checking if there are at least two distinct elements in the list\n    if len(sorted_nums) < 2:\n        return None\n\n    return sorted_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Removes duplicates by converting the list to a set, then back to a list\n    numbers = list(set(numbers))\n    # Returns None if there are less than 2 unique numbers in the list\n    if len(numbers) < 2:\n        return None\n    # Sorts the list in ascending order and returns the second element\n    return sorted(numbers)[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates and sort the list in ascending order\n    unique_sorted_lst = sorted(set(lst))\n\n    # Check if there are at least two unique elements in the list\n    if len(unique_sorted_lst) < 2:\n        return None\n\n    # Return the second element\n    return unique_sorted_lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Removing duplicates and sorting the list\n    unique_nums = sorted(list(set(nums)))\n    # Checking if list has at least two elements\n    if len(unique_nums) < 2:\n        return None\n    else:\n        return unique_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(lst):\n    # Remove duplicates by converting to a set, then convert back to list\n    lst = list(set(lst))\n\n    # If there are less than 2 unique numbers, return None\n    if len(lst) < 2:\n        return None\n\n    # Sort the list in ascending order\n    lst.sort()\n\n    # The second smallest number is the second element in the sorted list\n    return lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(set(nums)) < 2:\n        return None\n    nums = sorted(set(nums))\n    return nums[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function finds the second smallest number in a list.\n\n    Args:\n    numbers (list of int or float): The list of numbers.\n\n    Returns:\n    The second smallest number, or None if the list has less than 2 distinct elements.\n    \"\"\"\n    unique_numbers = set(numbers)\n    if len(unique_numbers) < 2:\n        return None\n    unique_numbers = list(unique_numbers)\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Return None if the list has less than 2 elements\n    if len(nums) < 2:\n        return None\n\n    # Initialize the smallest and second_smallest variables with the first and second elements\n    smallest = second_smallest = float('inf')\n\n    # Iterate over the numbers\n    for num in nums:\n        # If the current number is smaller than the smallest, update smallest and second_smallest\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        # If the current number is between smallest and second_smallest, update second_smallest\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    # Return second_smallest if it's not infinity\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Handle edge cases\n    if len(numbers) < 2:\n        return None\n\n    # Initialize smallest and second_smallest variables\n    smallest = float('inf')\n    second_smallest = float('inf')\n\n    # Iterate through the list\n    for num in numbers:\n        # Update smallest and second_smallest if necessary\n        if num < smallest:\n            smallest, second_smallest = num, smallest\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    # Return second_smallest or None if not found\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 3}, {"solution": "def second_smallest(lst):\n    # If length of the list is less than 2, return None (or any appropriate value depending on the problem context)\n    if len(lst) < 2:\n        return None\n\n    # Initialize variables to store the smallest and second smallest numbers\n    smallest = second_smallest = float('inf')\n\n    # Iterate through the list and update the smallest and second smallest numbers\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    # If second_smallest remained as float('inf'), it means there's no unique second smallest number in the list\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # First, remove duplicates from the list\n    unique_numbers = list(set(numbers))\n    # Sort the list in ascending order\n    unique_numbers.sort()\n    # Check if the list has at least two elements\n    if len(unique_numbers) >= 2:\n        return unique_numbers[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Filter out the duplicates\n    unique_numbers = list(set(numbers))\n    # Check if there are at least two unique numbers\n    if len(unique_numbers) < 2:\n        return None\n    # Sort the list and return the second item\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    first, second = float('inf'), float('inf')\n    for num in numbers:\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    smallest, second_smallest = float('inf'), float('inf')\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(lst):\n    if len(set(lst)) < 2:\n        return None\n    else:\n        return sorted(set(lst))[1]", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Check if there are at least two unique numbers in the list\n    if len(set(numbers)) < 2:\n        return None\n\n    # Sort the list and return the second smallest number\n    return sorted(set(numbers))[1]", "matching_cluster_idx": 4}]}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 45.0, "profiled": [{"solution": "def count_reverse_pairs(str_list):\n    return sum(1 for i in range(len(str_list)) for j in range(i+1, len(str_list)) if str_list[i][::-1] == str_list[j])", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    pairs_count = 0\n    for i in range(len(word_list)):\n        for j in range(i+1, len(word_list)):\n            if word_list[i] == word_list[j][::-1]:\n                pairs_count += 1\n    return pairs_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] == arr[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Count the number of pairs of reverse strings in the given list.\n\n    :param lst: List of strings\n    :return: Number of reverse pairs\n    \"\"\"\n    return sum(1 for i in range(len(lst)) for j in range(i+1, len(lst)) if lst[i] == lst[j][::-1])", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:  # Check if strings are reverse of each other\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    \"\"\"Count pairs of reverse strings in the given string list.\"\"\"\n    pairs = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i][::-1] == str_list[j]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    pairs = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    # Helper function to check if two strings are reverse of each other\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    # Initialize counter\n    count = 0\n\n    # Iterate over all pairs of strings\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            # If strings are reverse of each other, increment count\n            if is_reverse(strings[i], strings[j]):\n                count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(input_list):\n    count = 0\n    for i in range(len(input_list)):\n        for j in range(i + 1, len(input_list)):\n            if input_list[i] == input_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i + 1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"Count the number of pairs of reverse strings in the given list.\"\"\"\n    pairs = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    reverse_count = 0\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i] == words[j][::-1]: # Check if strings are reverse of each other\n                reverse_count += 1\n    return reverse_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i][::-1] == str_list[j]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(strings):\n    count = 0\n    for i in range(len(strings)):\n        for j in range(i+1, len(strings)):\n            if strings[i] == strings[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 74.2084942084942, "dps_norm": 78.75, "pass@1": 89.0, "profiled": [{"solution": "def unique_sublists(sublists):\n    result = {}\n    for sublist in sublists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(input_list):\n    # Convert sublists to tuples and count occurrences\n    counts = Counter(tuple(sublist) for sublist in input_list)\n    return dict(counts)", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_counter = {}\n    for sublist in lst:\n        tuple_sub = tuple(sublist)\n        if tuple_sub in sublist_counter:\n            sublist_counter[tuple_sub] += 1\n        else:\n            sublist_counter[tuple_sub] = 1\n    return sublist_counter", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    counts = defaultdict(int)\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        counts[sublist_tuple] += 1\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublists = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in sublists:\n            sublists[tuple_sublist] += 1\n        else:\n            sublists[tuple_sublist] = 1\n    return sublists", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_dict = {}\n    for sublist in lst:\n        tpl = tuple(sublist)\n        sublist_dict[tpl] = sublist_dict.get(tpl, 0) + 1\n    return sublist_dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(nested_list):\n    sublist_dict = defaultdict(int)\n    for sublist in nested_list:\n        sublist_tuple = tuple(sublist)\n        sublist_dict[sublist_tuple] += 1\n    return dict(sublist_dict)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    # Use a dictionary to count occurrences\n    count_dict = {}\n    for sublist in input_list:\n        tuple_sublist = tuple(sublist)\n        count_dict[tuple_sublist] = count_dict.get(tuple_sublist, 0) + 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "from typing import List, Dict, Tuple\ndef unique_sublists(input_list: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    counter = {}\n    for sublist in input_list:\n        tuple_sublist = tuple(sublist)\n        counter[tuple_sublist] = counter.get(tuple_sublist, 0) + 1\n    return counter", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    sublist_count = defaultdict(int)\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        sublist_count[sublist_tuple] += 1\n    return dict(sublist_count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_freq = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in sublist_freq:\n            sublist_freq[sublist_tuple] += 1\n        else:\n            sublist_freq[sublist_tuple] = 1\n    return sublist_freq", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Convert lists to tuples and store them in a dictionary\n    # with counts of their occurrence\n    counts = {}\n    for sublist in lst:\n        counts[tuple(sublist)] = counts.get(tuple(sublist), 0) + 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(nested_list):\n    count_dict = defaultdict(int)\n    for sublist in nested_list:\n        # Convert the sublist to a tuple\n        tpl = tuple(sublist)\n        count_dict[tpl] += 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    counter = defaultdict(int)\n    for sublist in lst:\n        counter[tuple(sublist)] += 1\n    return dict(counter)", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    count = defaultdict(int)\n\n    for sublist in lst:\n        # Convert sublist to tuple and count its occurrences\n        count[tuple(sublist)] += 1\n\n    return dict(count)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(input_list):\n    result = {}\n    for sublist in input_list:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple not in result:\n            result[sublist_tuple] = 0\n        result[sublist_tuple] += 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    sublist_counts = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        sublist_counts[tuple_sublist] = sublist_counts.get(tuple_sublist, 0) + 1\n    return sublist_counts", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    tuples = [tuple(item) for item in lst]\n    return dict(Counter(tuples))", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(nested_list):\n    # Create a defaultdict to store count of each sublist\n    counts = defaultdict(int)\n\n    # Iterate over the nested list\n    for sublist in nested_list:\n        # Convert each sublist to a tuple and increment its count in the dictionary\n        counts[tuple(sublist)] += 1\n\n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "from typing import List, Tuple, Dict\ndef unique_sublists(sublists: List[List[int]]) -> Dict[Tuple, int]:\n    counter = {}\n    for s in sublists:\n        t = tuple(s)\n        counter[t] = counter.get(t, 0) + 1\n    return counter", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/764": {"dps": 90.86419753086419, "dps_norm": 53.333333333333336, "pass@1": 88.0, "profiled": [{"solution": "def number_ctr(s: str) -> int:\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Function to count the number of digits in a given string.\n\n    Args:\n    string (str): Input string\n\n    Returns:\n    int: Number of digits in the string\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return len([char for char in string if char.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s):\n    return sum(1 for c in s if c.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"Counts the number of digits in a given string\"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    \"\"\"Counts the number of digits in a given string.\"\"\"\n    return sum(1 for char in input_string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    This function counts the number of digits in the given string.\n\n    :param s: str - the input string\n    :return: int - the count of digits\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    :param s: Input string\n    :return: Number of digits in the string\n    \"\"\"\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return len([digit for digit in s if digit.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s):\n    \"\"\"\n    This function takes a string as input and returns the number of digits in the string.\n    \"\"\"\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    s (str): the input string\n\n    Returns:\n    int: the count of digits in the string\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    return len([char for char in s if char.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    Args:\n    s (str): Input string\n    Returns:\n    int: Count of digits in the string\n    \"\"\"\n    return sum(char.isdigit() for char in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"Count the number of digits in a given string.\"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Using built-in filter function to find digits\n    # sum() is used to count the number of True values (i.e., digits)\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    count = sum(c.isdigit() for c in input_string)\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    return len([char for char in s if char.isdigit()])", "matching_cluster_idx": 3}, {"solution": "def number_ctr(s):\n    \"\"\"Return the number of digits in the given string.\"\"\"\n    return sum(1 for char in s if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    # Return the count of digits in the string using a list comprehension\n    return sum(1 for c in s if c.isdigit())", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 81.35514018691589, "dps_norm": 68.33333333333334, "pass@1": 94.0, "profiled": [{"solution": "def pair_wise(lst):\n    # Use zip() with a range offset to get pairs of consecutive items\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Check if input is a list\n    if not isinstance(lst, list):\n        raise TypeError(\"Input should be a list\")\n\n    # Return a list of pairs of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Check if the list has at least two elements\n    if len(lst) < 2:\n        return []\n\n    # Use list comprehension to create pairs of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in the given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    # Iterate over the input list, pair each item with the next one\n    # If we're at the last item, return an empty list for this pair\n    return [(input_list[i], input_list[i+1]) for i in range(len(input_list)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(input_list):\n    # Using list comprehension and zip function to generate pairs of consecutive items\n    return [(input_list[i], input_list[i + 1]) for i in range(len(input_list) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 69.03999999999999, "dps_norm": 47.14285714285714, "pass@1": 61.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(nums):\n    return all(num % 2 == 1 for i, num in enumerate(nums) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Args:\n        lst (List[int]): The input list\n\n    Returns:\n        bool: True if every odd index contains odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n\n    Parameters:\n    lst (list): The list to check\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Check if every element at odd indices is odd\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Function to check whether every odd index contains odd number in a given list.\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Check if every element at an odd index is odd\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(x % 2 == 1 for i, x in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    # Check if the list is empty\n    if not lst:\n        return False\n\n    # Check if every odd index contains odd numbers\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Function to check if every odd index contains odd numbers in a given list.\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Checks if every odd index in the given list contains an odd number.\n\n    Args:\n        numbers: list of integers\n\n    Returns:\n        bool: True if all odd-indexed numbers are odd, False otherwise\n    \"\"\"\n    return all(numbers[i] % 2 == 1 for i in range(1, len(numbers), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Function to check whether every odd index contains odd numbers in a given list.\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every odd index of the list contains an odd number.\n    \"\"\"\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check if every odd index contains an odd number in a given list.\n    \"\"\"\n    # Loop through the list starting from the first element (odd index)\n    for i in range(1, len(lst), 2):\n        # If an element at an odd index is even, return False\n        if lst[i] % 2 == 0:\n            return False\n    # If the function didn't return earlier, return True\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 79.54081632653062, "dps_norm": 85.55555555555556, "pass@1": 79.0, "profiled": [{"solution": "def find_sum(nums):\n    # Use a set to automatically remove duplicates (not allowing repeat insertions)\n    unique_nums = set(nums)\n    return sum(unique_nums)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"Find the sum of non-repeated elements in a given list.\"\"\"\n    seen = set()\n    total = 0\n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            total += num\n    return total", "matching_cluster_idx": 4}, {"solution": "def find_sum(numbers):\n    return sum(num for num in set(numbers))", "matching_cluster_idx": 5}, {"solution": "def find_sum(numbers):\n    no_repeat = set(numbers)\n    return sum(no_repeat)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"Return the sum of unique numbers in the given list.\"\"\"\n    return sum(set(numbers))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    # Use set to remove duplicates, then return sum\n    return sum(set(nums))", "matching_cluster_idx": 8}, {"solution": "def find_sum(input_list):\n    # Using a set to remove duplicates, then sum the remaining numbers\n    return sum(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to eliminate repeated elements and sum the remaining elements\n    return sum(set(numbers))", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    # Using set to remove duplicates and then calculate the sum\n    return sum(set(nums))", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Function to find the sum of non-repeated elements in a given list.\n\n    Args:\n        numbers (list): Input list\n\n    Returns:\n        int: Sum of non-repeated elements in the list\n    \"\"\"\n    seen = set()  # Keep track of seen numbers\n    sum_of_non_repeated = 0  # Initialize sum to 0\n\n    for num in numbers:\n        if num not in seen:  # If number is not seen before\n            sum_of_non_repeated += num  # Add it to the sum\n            seen.add(num)  # Mark the number as seen\n\n    return sum_of_non_repeated", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    return sum(i for i in set(lst))", "matching_cluster_idx": 5}, {"solution": "def find_sum(nums):\n    # Use set to remove duplicates and then sum the unique elements\n    return sum(set(nums))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # use a set to automatically remove duplicates\n    unique_nums = set(lst)\n    # then sum up the unique numbers\n    return sum(unique_nums)", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    # Use a set to store unique numbers and calculate their sum\n    unique_sum = sum(set(nums))\n    return unique_sum", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to automatically remove duplicates, then sum the remaining elements\n    return sum(set(numbers))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    seen = set()\n    sum_of_non_repeated = 0\n\n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            sum_of_non_repeated += num\n\n    return sum_of_non_repeated", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    seen = set()\n    sum_nums = 0\n\n    for num in nums:\n        if num not in seen:\n            seen.add(num)\n            sum_nums += num\n\n    return sum_nums", "matching_cluster_idx": 4}, {"solution": "def find_sum(nums):\n    non_repeated_sum = 0\n    seen = set()\n\n    for num in nums:\n        if num not in seen:\n            non_repeated_sum += num\n            seen.add(num)\n\n    return non_repeated_sum", "matching_cluster_idx": 4}]}, "Mbpp/781": {"dps": 83.26771653543307, "dps_norm": 42.0, "pass@1": 53.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "from math import isqrt\ndef count_divisors(n):\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    count = 0\n    for i in range(1, isqrt(n) + 1):\n        if n % i == 0:\n            count += 1 if i == n // i else 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function takes an integer 'n' as input and returns the number of divisors of 'n'.\n    It then checks if the count of divisors is even.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Helper function to check if a number is a divisor\n    def is_divisor(x):\n        return n % x == 0\n\n    # Count the number of divisors using a generator\n    count = sum(1 for i in range(1, n + 1) if is_divisor(i))\n\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": -1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    This function counts the number of divisors for a given number n.\n    It returns True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Remove all whitespaces from a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"Remove all whitespaces from a given string\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from a string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    \"\"\"\n    Remove all whitespaces from a string.\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Using the replace() function to replace all spaces with empty string\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Remove all whitespaces using the `replace()` method.\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s: str) -> str:\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"Removes all spaces from a string.\"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # Using string method replace to remove all spaces\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    This function removes all whitespaces from a string.\n\n    :param s: str: input string\n    :return: str: output string without whitespaces\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def max_sum_list(lst_of_lists):\n    return max(lst_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lists):\n    # Initialize the result with the first list from the input list\n    result = lst_of_lists[0]\n    # Initialize the maximum sum with the sum of the first list\n    max_sum = sum(result)\n\n    for sublist in lst_of_lists[1:]:\n        # Calculate the sum of the current sublist\n        sublist_sum = sum(sublist)\n        # If the sum of the current sublist is greater than the current maximum sum, update the result and the maximum sum\n        if sublist_sum > max_sum:\n            result = sublist\n            max_sum = sublist_sum\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize max_sum and max_list\n    max_sum = sum(lst[0])\n    max_list = lst[0]\n\n    # Loop through each sub-list\n    for sublist in lst:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    \"\"\"Return the list in a list of lists whose sum of elements is the highest.\"\"\"\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    return max(nested_list, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    return max(nested_list, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    \"\"\"Returns the list in a list of lists whose sum of elements is the highest.\"\"\"\n    return max(nested_list, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize max_sum and max_list with the first sublist\n    max_sum = sum(lst[0])\n    max_list = lst[0]\n\n    # Iterate over each sublist\n    for sublist in lst[1:]:\n        sublist_sum = sum(sublist)\n\n        # If the sublist sum is greater than max_sum, update max_sum and max_list\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Use list comprehension to calculate the sum of elements in each sublist and find the index of maximum sum\n    max_sum_idx = max((sum(sublst), i) for i, sublst in enumerate(lst))[1]\n    return lst[max_sum_idx]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    return max(nested_list, key=sum)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef max_sum_list(lst: List[List[int]]) -> List[int]:\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    return max(nested_list, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    return max(lst, key=sum)", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef max_sum_list(nested_list: List[List[int]]) -> List[int]:\n    \"\"\"Return the list in a list of lists whose sum of elements is the highest.\"\"\"\n    if not nested_list:\n        raise ValueError(\"Input list is empty\")\n\n    max_sum = sum(nested_list[0])\n    max_list = nested_list[0]\n\n    for sublist in nested_list[1:]:\n        sublist_sum = sum(sublist)\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            max_list = sublist\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize max_list and max_sum\n    max_list = lists[0]\n    max_sum = sum(max_list)\n\n    # Iterate through the lists\n    for lst in lists[1:]:\n        lst_sum = sum(lst)\n        # Update max_list and max_sum if lst_sum is greater\n        if lst_sum > max_sum:\n            max_list = lst\n            max_sum = lst_sum\n\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    return max(nested_list, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(nested_list):\n    # Initialize max_sum and result_list\n    max_sum = float('-inf')\n    result_list = None\n\n    # Iterate through each sublist\n    for sublist in nested_list:\n        # Calculate the sum of elements in the sublist\n        sublist_sum = sum(sublist)\n\n        # If the sum is higher than max_sum, update max_sum and result_list\n        if sublist_sum > max_sum:\n            max_sum = sublist_sum\n            result_list = sublist\n\n    return result_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 74.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if a given tuple contains the element 'k' or not.\n    :param tup: input tuple\n    :param k: element to search for\n    :return: True if 'k' is found, False otherwise\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_t, k):\n    return k in tuple_t", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if a given tuple contains the specified element k.\"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"Check if the given tuple contains the value 'k'.\"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if the given tuple contains k or not.\n\n    Args:\n        tup (tuple): Input tuple to search.\n        k: Element to search for in the tuple.\n\n    Returns:\n        bool: True if 'k' is present in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if given tuple contains the given integer.\"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value.\n\n    Args:\n    tup (tuple): Input tuple.\n    k (any): Value to search for.\n\n    Returns:\n    bool: True if 'k' is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    \"\"\"Check if a tuple contains 'k'\"\"\"\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tpl, k):\n    return k in tpl", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the element k or not.\n\n    Args:\n    tup (tuple): Input tuple\n    k (int or str): Element to search for in the tuple\n\n    Returns:\n    bool: True if the element is found, False otherwise\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if the given tuple contains the element 'k'.\"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    This function checks if the given tuple contains the integer 'k'.\n\n    :param t: a tuple of integers\n    :param k: an integer\n    :return: True if 'k' is in the tuple, False otherwise\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if the given tuple contains the element k.\"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Check if the given tuple contains the k or not.\n\n    :param t: Tuple to search for k\n    :param k: Value to search for in tuple\n    :return: bool, True if k found in tuple, False otherwise\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"Check if the given tuple contains k or not.\"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value 'k' or not.\n\n    Parameters:\n    tup (tuple): Input tuple\n    k (any): Value to search in the tuple\n\n    Returns:\n    bool: True if 'k' is in the tuple, False otherwise\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if the given tuple contains the value k.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
