{"date": "2024-11-04 13:56", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 85.2149636780295, "dps_norm": 80.2567431433853, "pass@1": 88.00847457627118}, "eval": {"HumanEval/9": {"dps": 63.09148264984227, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = float('-inf')\n    \n    for num in numbers:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    current_max = numbers[0]\n    \n    for num in numbers[1:]:\n        current_max = max(current_max, num)\n        result.append(current_max)\n    \n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 71.51162790697674, "dps_norm": 75.71428571428572, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to optimize comparison\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to optimize comparisons\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to optimize comparisons\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    \n    sorted_numbers = sorted(numbers)\n    \n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i+1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to compare adjacent elements\n    \n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to optimize comparisons\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the list to compare adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the sum of absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    sum_absolute_deviations = sum(absolute_deviations)\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum_absolute_deviations / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n\n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n\n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n\n    # Calculate the average of the absolute deviations\n    mad = sum(absolute_deviations) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the average of the absolute differences\n    mad = sum(absolute_differences) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n\n    # Calculate the average of the absolute differences\n    mad = sum(absolute_differences) / len(numbers)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n\n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n\n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the dataset\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute deviations from the mean\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute deviations\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the length of the set\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the length of the set, which is the count of distinct characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to get unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(string)\n    \n    # Return the length of the set, which is the count of distinct characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the length of the set\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to keep track of unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the count of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    unique_chars = set(lowercase_string)\n    \n    # Return the length of the set\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    lowercase_string = string.lower()\n    \n    # Use a set to count unique characters\n    distinct_chars = set(lowercase_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = None\n    \n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = None\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = None\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i+1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i+1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers)):\n        difference = abs(sorted_numbers[i] - sorted_numbers[i-1])\n        if difference < min_difference:\n            min_difference = difference\n            closest_pair = (sorted_numbers[i-1], sorted_numbers[i])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to\n    each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 72.10884353741497, "dps_norm": 25.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line will only be reached if n is 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This will only happen if n is 1 or prime", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(24)\n    12\n    >>> largest_divisor(7)\n    1\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line is reached only if n is 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This will only be reached if n is 1 or a prime number", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # This line will only be reached if n is 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}]}, "HumanEval/26": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Create a new list with elements that occur only once\n    result = [num for num in numbers if num_count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Create a new list with elements that occur only once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Create a new list with elements that occur only once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that appear once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Create a new list with elements that occur only once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_dict = {}\n    result = []\n    \n    # Count occurrences of each number\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only numbers that occur once\n    for num in numbers:\n        if count_dict[num] == 1:\n            result.append(num)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to store the count of each number\n    count_dict = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Create a new list with elements that occur only once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for num in numbers:\n        count[num] = count.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Keep only the numbers that occur once\n    return [num for num in numbers if count_dict[num] == 1]", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 95.12658227848101, "dps_norm": 86.875, "pass@1": 100.0, "profiled": [{"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 5}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort the extracted elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the sorted elements at indices divisible by 3\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    # Fill in the remaining elements from the original list\n    for i in range(len(l)):\n        if i % 3 != 0:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    third_elements.sort()\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(third_elements):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the sorted elements at indices divisible by 3\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    # Fill in the remaining elements from the original list\n    for i in range(len(l)):\n        if i % 3 != 0:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the elements\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third[third_index]\n            third_index += 1\n        else:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the elements\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = third_elements[third_index]\n            third_index += 1\n        else:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the elements\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third[third_index]\n            third_index += 1\n        else:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = sorted([l[i] for i in range(0, len(l), 3)])\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the elements\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = third_elements[third_index]\n            third_index += 1\n        else:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort the extracted elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    third_elements.sort()\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(third_elements):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the elements\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_third[third_index]\n            third_index += 1\n        else:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the sorted elements at indices divisible by 3\n    for i, elem in enumerate(sorted_third):\n        result[i*3] = elem\n    \n    # Fill in the remaining elements from the original list\n    for i in range(len(l)):\n        if i % 3 != 0:\n            result[i] = l[i]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_third = sorted(third_elements)\n    \n    # Create a new list with the same length as the input list\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted values\n    for i, value in enumerate(sorted_third):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Extract elements at indices divisible by 3\n    third_indices = [i for i in range(0, len(l), 3)]\n    third_elements = [l[i] for i in third_indices]\n    \n    # Sort the extracted elements\n    sorted_third = sorted(third_elements)\n    \n    # Place the sorted elements back into the result list\n    for i, value in zip(third_indices, sorted_third):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Args:\n    n (int): The upper limit of the range to check.\n    \n    Returns:\n    int: The count of digit 7 appearances in numbers divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = l[::2]\n    \n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd-indexed elements (which remain unchanged)\n    result[1::2] = l[1::2]\n    \n    # Fill in the sorted even-indexed elements\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    even_elements.sort()\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = even_elements\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = l[::2]\n    \n    # Sort the even-indexed elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd-indexed elements (which remain unchanged)\n    result[1::2] = l[1::2]\n    \n    # Fill in the sorted even-indexed elements\n    result[::2] = even_elements_sorted\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = l[::2]\n    \n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd-indexed elements (which remain unchanged)\n    result[1::2] = l[1::2]\n    \n    # Fill in the sorted even-indexed elements\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with the original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with the sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = l[::2]\n    \n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd-indexed elements (which remain unchanged)\n    result[1::2] = l[1::2]\n    \n    # Fill in the sorted even-indexed elements\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = l[::2]\n    \n    # Sort the even-indexed elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd-indexed elements (which remain unchanged)\n    result[1::2] = l[1::2]\n    \n    # Fill in the sorted even-indexed elements\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with the original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with the sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in even indices with sorted values\n    result[::2] = even_elements_sorted\n    \n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract elements at even indices\n    even_elements = l[::2]\n    \n    # Sort the even elements\n    sorted_even = sorted(even_elements)\n    \n    # Create a new list with the same length as the input list\n    result = [0] * len(l)\n    \n    # Fill in the odd indices with original values\n    result[1::2] = l[1::2]\n    \n    # Fill in the even indices with sorted values\n    result[::2] = sorted_even\n    \n    return result", "matching_cluster_idx": 9}]}, "HumanEval/49": {"dps": null, "dps_norm": null, "pass@1": 1.0, "profiled": []}, "HumanEval/51": {"dps": 53.091787439613526, "dps_norm": 46.875, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)", "matching_cluster_idx": 5}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}, {"solution": "import re\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return re.sub(r'[aeiouAEIOU]', '', text)", "matching_cluster_idx": 0}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert strings to sets of unique characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = list(set1.intersection(set2))\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using set intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the common elements using set intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "import doctest\ndef common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = list(set1.intersection(set2))\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = list(set1.intersection(set2))\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets for efficient intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the common elements\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Remove all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors up to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it's prime\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Remove all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it's the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Divide out all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors up to sqrt(n)\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        else:\n            factor += 2\n    \n    # If n is greater than 1 at this point, it is prime\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Check for 2 as a factor\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd numbers starting from 3\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Divide out all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd numbers from 3 to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it's prime and the largest factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd numbers starting from 3\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Check for 2 as a factor\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Check for 2 as a factor\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors from 3 to sqrt(n)\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd numbers starting from 3\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it's the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime number\n    factor = 2\n    last_factor = 1\n\n    # Continue until the square root of n\n    while factor <= math.isqrt(n):\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n\n    # If n is greater than 1 at this point, it is the largest prime factor\n    return max(n, last_factor)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd numbers starting from 3\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Handle even numbers\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is the largest prime factor\n    if n > 2:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Divide out all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors up to sqrt(n)\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        else:\n            factor += 2\n    \n    # If n is greater than 1 at this point, it is prime\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest_factor = 1\n    \n    # Divide out all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors up to sqrt(n)\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        else:\n            factor += 2\n    \n    # If n is still greater than 1, it's the largest prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "import math\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start with the smallest prime factor, 2\n    largest_factor = 2\n    \n    # Divide out all factors of 2\n    while n % 2 == 0:\n        n = n // 2\n    \n    # Check odd numbers up to sqrt(n)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            largest_factor = i\n            n = n // i\n    \n    # If n is still greater than 2, it is prime and the largest factor\n    if n > 2:\n        largest_factor = n\n    \n    return int(largest_factor)", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 92.20779220779221, "dps_norm": 62.5, "pass@1": 100.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = set('aeiouAEIOU')\n    count = sum(1 for char in s if char in vowels)\n    \n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    \n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 83.66336633663366, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n\n    Args:\n    lst (list): A non-empty list of integers.\n\n    Returns:\n    int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of even elements at odd indices.\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort the result list based on the requirements\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort the result list\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row (ascending) and then by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row (ascending) and then by column (descending)\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the given 2D list.\n    \n    Args:\n    lst (List[List[int]]): A 2D list of integers.\n    x (int): The integer to search for.\n    \n    Returns:\n    List[Tuple[int, int]]: Sorted list of coordinates (row, column) where x is found.\n    \"\"\"\n    result = []\n    \n    # Iterate through each row\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        column_indices = [col_index for col_index, value in enumerate(row) if value == x]\n        \n        # Add coordinates to the result list\n        for col_index in column_indices:\n            result.append((row_index, col_index))\n    \n    # Sort the result list\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort the result list\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, val in enumerate(row):\n            if val == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row (ascending) and then by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the nested list lst.\n    \n    Args:\n    lst (List[List[int]]): A 2D list where each row may have a different number of columns.\n    x (int): The integer to search for in the list.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates (row, column) where x is found.\n    The list is sorted by rows in ascending order and by columns in descending order within each row.\n    \"\"\"\n    result = []\n    \n    # Iterate through each row\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        col_indices = [col_index for col_index, value in enumerate(row) if value == x]\n        \n        # Add coordinates to the result list\n        result.extend((row_index, col_index) for col_index in col_indices)\n    \n    # Sort the result list\n    # First, sort by row (ascending)\n    # Then, for each row, sort by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the nested list lst.\n    Return sorted list of tuples (row, column) as per the given conditions.\n    \"\"\"\n    result = []\n    \n    # Iterate through each row\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        col_indices = [col_index for col_index, value in enumerate(row) if value == x]\n        \n        # Add tuples (row_index, col_index) to the result\n        result.extend((row_index, col_index) for col_index in col_indices)\n    \n    # Sort the result list\n    # First by row (ascending), then by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result\nadditional_test = [[1, 1, 1], [1, 1], [1, 1, 1, 1]]\nresult = get_row(additional_test, 1)", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the nested list lst.\n    \n    Args:\n    lst (List[List[int]]): A 2D list where each row may have a different number of columns.\n    x (int): The integer to search for in the list.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates (row, column) \n                           where x is found, sorted by row (ascending) and then by column (descending).\n    \"\"\"\n    result = []\n    \n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort the result list by row (ascending) and then by column (descending)\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the nested list lst.\n    \n    Args:\n    lst (List[List[int]]): A 2D list where each row may have different number of columns.\n    x (int): The integer to search for in the list.\n    \n    Returns:\n    List[Tuple[int, int]]: List of tuples representing coordinates (row, column) of x,\n                           sorted by row (ascending) and then by column (descending).\n    \"\"\"\n    result = []\n    \n    # Iterate through each row\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        column_indices = [col_index for col_index, value in enumerate(row) if value == x]\n        \n        # Add coordinates to the result list\n        result.extend((row_index, col_index) for col_index in column_indices)\n    \n    # Sort the result list\n    # First by row (ascending), then by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the nested list lst.\n    Return a list of tuples (row, column) sorted by row ascending and column descending.\n    \"\"\"\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort the result list by row ascending and column descending\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    result.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of each row by columns in descending order\n    final_result = []\n    current_row = -1\n    current_row_coords = []\n    \n    for coord in result:\n        if coord[0] != current_row:\n            if current_row_coords:\n                current_row_coords.sort(key=lambda c: c[1], reverse=True)\n                final_result.extend(current_row_coords)\n            current_row = coord[0]\n            current_row_coords = [coord]\n        else:\n            current_row_coords.append(coord)\n    \n    # Add the last row's coordinates\n    if current_row_coords:\n        current_row_coords.sort(key=lambda c: c[1], reverse=True)\n        final_result.extend(current_row_coords)\n    \n    return final_result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    \n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row (ascending) and then by column (descending)\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort the result list\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order and columns in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the nested list lst.\n    \n    Args:\n    lst (List[List[int]]): A 2D list where each row may have a different number of columns.\n    x (int): The integer to search for.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the coordinates (row, column) of x,\n                           sorted by row ascending and then by column descending.\n    \"\"\"\n    result = []\n    \n    # Iterate through each row\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        column_indices = [col_index for col_index, value in enumerate(row) if value == x]\n        \n        # Add coordinates to the result list\n        result.extend((row_index, col_index) for col_index in column_indices)\n    \n    # Sort the result list\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find coordinates of integer x in the given 2D list and return sorted coordinates.\n    \n    Args:\n    lst (List[List[int]]): A 2D list of integers.\n    x (int): The integer to search for.\n    \n    Returns:\n    List[Tuple[int, int]]: Sorted list of coordinates (row, column) where x is found.\n    \"\"\"\n    result = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                result.append((row_index, col_index))\n    \n    # Sort by row (ascending) and then by column (descending)\n    return sorted(result, key=lambda coord: (coord[0], -coord[1]))", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.70103092783506, "dps_norm": 31.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied by two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (a or A) depending on whether the letter is lowercase or uppercase\n            base = 'a' if char.islower() else 'A'\n            # Convert letter to number (0-25), shift it, and convert back to letter\n            shifted = (ord(char) - ord(base) + 4) % 26\n            result += chr(shifted + ord(base))\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the rotation amount\n    rotation = 2 * 2  # 2 multiplied to 2 places = 4\n    \n    # Create the translation table\n    lowercase = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_lowercase = lowercase[rotation:] + lowercase[:rotation]\n    uppercase = lowercase.upper()\n    shifted_uppercase = shifted_lowercase.upper()\n    \n    translation_table = str.maketrans(\n        lowercase + uppercase,\n        shifted_lowercase + shifted_uppercase\n    )\n    \n    # Apply the translation to the input string\n    return s.translate(translation_table)", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (a or A) depending on whether the letter is lowercase or uppercase\n            base = 'a' if char.islower() else 'A'\n            # Convert letter to number (0-25), rotate, and convert back to letter\n            rotated = (ord(char) - ord(base) + 4) % 26\n            result += chr(rotated + ord(base))\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            offset = 97 if char.islower() else 65\n            # Rotate the letter by 4 places, wrapping around if necessary\n            rotated = (ord(char) - offset + 4) % 26 + offset\n            result += chr(rotated)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (a or A) depending on whether the letter is lowercase or uppercase\n            base = 'a' if char.islower() else 'A'\n            # Convert letter to number (0-25), shift it, and convert back to letter\n            shifted = (ord(char) - ord(base) + 4) % 26\n            result += chr(shifted + ord(base))\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (97 for lowercase, 65 for uppercase)\n            base = 97 if char.islower() else 65\n            # Convert to 0-25 range, shift by 4, wrap around, and convert back\n            shifted = (ord(char) - base + 4) % 26 + base\n            result += chr(shifted)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            offset = 97 if char.islower() else 65\n            # Convert char to number (0-25), rotate, and convert back to char\n            rotated = (ord(char) - offset + 4) % 26 + offset\n            result += chr(rotated)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied by two places.\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            ascii_offset = 97 if char.islower() else 65\n            \n            # Convert letter to number (0-25), shift it, and wrap around if needed\n            shifted = (ord(char) - ascii_offset + 4) % 26\n            \n            # Convert back to character and add to result\n            result += chr(shifted + ascii_offset)\n        else:\n            # If not a letter, keep the character as is\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (a or A) depending on whether the letter is lowercase or uppercase\n            base = 'a' if char.islower() else 'A'\n            # Convert letter to number (0-25), rotate, and convert back to letter\n            rotated = (ord(char) - ord(base) + 4) % 26\n            result += chr(rotated + ord(base))\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            ascii_offset = 97 if char.islower() else 65\n            # Convert char to number (0-25), shift it, and wrap around if necessary\n            shifted = (ord(char) - ascii_offset + 4) % 26\n            # Convert back to character and add to result\n            result += chr(shifted + ascii_offset)\n        else:\n            # If not a letter, keep the character as is\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied by two places.\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            offset = 97 if char.islower() else 65\n            # Calculate the new position with rotation\n            new_pos = (ord(char) - offset + (2 * 2)) % 26\n            # Convert back to character and add to result\n            result += chr(new_pos + offset)\n        else:\n            # If not a letter, keep the character as is\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            offset = 97 if char.islower() else 65\n            # Convert to 0-25 range, shift by 4, wrap around, and convert back to ASCII\n            shifted = (ord(char) - offset + 4) % 26 + offset\n            result += chr(shifted)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (97 for lowercase, 65 for uppercase)\n            base = 97 if char.islower() else 65\n            # Convert char to number (0-25), rotate, and convert back to char\n            rotated = (ord(char) - base + 4) % 26 + base\n            result += chr(rotated)\n        else:\n            # If not a letter, keep the character as is\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (a or A) depending on whether the character is lowercase or uppercase\n            base = ord('a') if char.islower() else ord('A')\n            # Shift the character by 4 places, wrapping around if necessary\n            shifted = (ord(char) - base + 4) % 26 + base\n            result += chr(shifted)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied by two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            offset = 97 if char.islower() else 65\n            # Convert char to number (0-25), rotate, and convert back to char\n            rotated = (ord(char) - offset + 4) % 26 + offset\n            result += chr(rotated)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet by two multiplied to two places (4 places).\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            ascii_offset = 97 if char.islower() else 65\n            # Convert char to number (0-25), rotate by 4, and convert back to char\n            rotated = (ord(char) - ascii_offset + 4) % 26 + ascii_offset\n            result += chr(rotated)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the base (97 for lowercase, 65 for uppercase)\n            base = 97 if char.islower() else 65\n            # Convert letter to number (0-25), shift it, and convert back to letter\n            shifted = (ord(char) - base + 4) % 26 + base\n            result += chr(shifted)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            ascii_offset = 97 if char.islower() else 65\n            # Convert to 0-25 range, shift by 4, and wrap around if necessary\n            shifted = (ord(char) - ascii_offset + 4) % 26\n            # Convert back to ASCII and append to result\n            result += chr(shifted + ascii_offset)\n        else:\n            # If not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            ascii_offset = 97 if char.islower() else 65\n            # Convert char to number (0-25), rotate, and convert back to char\n            rotated = (ord(char) - ascii_offset + 4) % 26\n            result += chr(rotated + ascii_offset)\n        else:\n            # If the character is not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet.\n    Each letter is shifted down by two multiplied to two places (4 places).\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            # Determine the ASCII offset (97 for lowercase, 65 for uppercase)\n            ascii_offset = 97 if char.islower() else 65\n            # Convert to 0-25 range, shift by 4, and wrap around if necessary\n            shifted = (ord(char) - ascii_offset + 4) % 26\n            # Convert back to ASCII and append to result\n            result += chr(shifted + ascii_offset)\n        else:\n            # If not a letter, leave it unchanged\n            result += char\n    return result", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 87.54863813229572, "dps_norm": 58.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the given list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are at least 2 unique elements, return the second one\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element or None if it doesn't exist\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element or None if it doesn't exist\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least two unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the 2nd element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there are at least 2 unique elements, return the 2nd one\n    if len(unique_sorted) >= 2:\n        return unique_sorted[1]\n    else:\n        return None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \n    Args:\n    lst (list): A list of integers\n    \n    Returns:\n    int or None: The 2nd smallest element, or None if it doesn't exist\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(lst))\n    \n    # If there's only one unique element, return None\n    if len(unique_sorted) < 2:\n        return None\n    \n    # Return the second element (index 1) which is the 2nd smallest\n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    Returns None if there is no such element.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, num_string in enumerate(lst):\n        odd_count = sum(1 for digit in num_string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        template = \"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\"\n        result.append(template.format(odd_count))\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, num_string in enumerate(lst):\n        odd_count = sum(1 for digit in num_string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, num_string in enumerate(lst):\n        odd_count = sum(1 for digit in num_string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, num_string in enumerate(lst):\n        odd_count = sum(1 for digit in num_string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for index, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, num_string in enumerate(lst):\n        odd_count = sum(1 for digit in num_string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for idx, string in enumerate(lst):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 95.05813953488372, "dps_norm": 96.0, "pass@1": 87.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # Try both concatenation orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # Check if concatenating in order s1 + s2 is balanced\n    if is_balanced(lst[0] + lst[1]):\n        return 'Yes'\n    \n    # Check if concatenating in order s2 + s1 is balanced\n    if is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    # Concatenate strings in both orders\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n\n    # Check if either concatenation is balanced\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # Try both possible concatenations\n    concat1 = lst[0] + lst[1]\n    concat2 = lst[1] + lst[0]\n\n    if is_balanced(concat1) or is_balanced(concat2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n    \n    # Try concatenating s1 + s2\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    \n    # Try concatenating s2 + s1\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in order s1 + s2 is balanced\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    \n    # Check if concatenating in order s2 + s1 is balanced\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    \n    # If neither order results in a balanced string, return 'No'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n    \n    # Try concatenating s1 + s2\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    \n    # Try concatenating s2 + s1\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst[0], lst[1]\n    \n    # Try concatenating in both orders\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    # Try both concatenation orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    \n    # Try concatenating in both orders\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Count open and close parentheses in both strings\n    open_count = sum(s.count('(') for s in lst)\n    close_count = sum(s.count(')') for s in lst)\n    \n    # If the number of open and close parentheses is not equal, it's impossible to balance\n    if open_count != close_count:\n        return 'No'\n    \n    # Check if concatenating in either order results in a valid string\n    for order in [(0, 1), (1, 0)]:\n        stack = []\n        valid = True\n        for i in order:\n            for char in lst[i]:\n                if char == '(':\n                    stack.append(char)\n                else:  # char == ')'\n                    if not stack:\n                        valid = False\n                        break\n                    stack.pop()\n            if not valid:\n                break\n        if valid and not stack:\n            return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 0}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    # Try both concatenation orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            else:\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    s1, s2 = lst\n    combined1 = s1 + s2\n    combined2 = s2 + s1\n\n    if is_balanced(combined1) or is_balanced(combined2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements in ascending order\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements, sorted in ascending order\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements\n    return sorted(sorted_arr[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 78.02690582959642, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted by length and then alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    and returns the resulting list sorted by length and then alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, removes odd-length strings, and returns a sorted list.\n    \n    The list is sorted first by length (ascending), then alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of even-length strings.\n    \"\"\"\n    # Filter out odd-length strings\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes strings with odd lengths,\n    and returns the result sorted by length and alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    and returns the resulting list sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    and returns the result sorted by length and alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes strings with odd lengths,\n    and returns the resulting list sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    and returns the resulted list sorted by length and alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes strings with odd lengths,\n    and returns the resulted list sorted by length and alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length (ascending) and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \n    Args:\n    lst (list): A list of strings\n    \n    Returns:\n    list: A sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_list = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    sorts the remaining strings by length and alphabetically,\n    and returns the sorted list.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length and alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    then returns the resulting list sorted by length and alphabetically.\n    \n    Args:\n    lst (list): A list of strings.\n    \n    Returns:\n    list: A sorted list of strings with even lengths.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Deletes strings with odd lengths from the input list,\n    and returns the result sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the remaining strings by length, then alphabetically\n    sorted_strings = sorted(even_length_strings, key=lambda x: (len(x), x))\n    \n    return sorted_strings", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 55.50847457627118, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    Returns True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n < 2:\n        return True\n    \n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Handle special cases\n    if n <= 1:\n        return True  # Numbers less than or equal to 1 are not prime\n    if n == 2:\n        return False  # 2 is prime\n    if n % 2 == 0:\n        return True  # Even numbers greater than 2 are not prime\n    \n    # Check odd numbers up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True  # If n is divisible by any number, it's not prime\n    \n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    Returns True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    Returns True if the number is not prime, False otherwise.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    Returns True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    Returns True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 4}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Determines if a number is not prime.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Handle edge cases\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # If n is divisible by any number, it's not prime\n    \n    return False  # If no divisors found, the number is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    \n    # If no divisors found, the number is prime\n    return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest elements to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    largest.sort(reverse=True)\n    \n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest elements to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest elements to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    largest.sort(reverse=True)\n    \n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    largest.sort(reverse=True)\n    \n    return largest", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The number of largest integers to return\n    \n    Returns:\n    list: The n largest integers in descending order\n    \"\"\"\n    # Create a min heap of the n largest numbers\n    largest = heapq.nlargest(n, numbers)\n    \n    # Sort the result in descending order\n    return sorted(largest, reverse=True)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 71.4625850340136, "dps_norm": 54.5, "pass@1": 94.0, "profiled": [{"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    for i in range(1, length):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    \n    # Check all rotations from 1 to length-1\n    for i in range(1, length):\n        # Rotate the string\n        rotated = s[i:] + s[:i]\n        \n        # If rotated string is same as original, return number of rotations\n        if rotated == s:\n            return i\n    \n    # If no rotation results in the same string, return length\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required, or -1 if no rotation is possible\n    \"\"\"\n    if not s:\n        return -1\n    \n    n = len(s)\n    if n == 1:\n        return 1\n    \n    # Double the string to simulate rotation\n    doubled = s + s\n    \n    for i in range(1, n):\n        if doubled[i:i+n] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required, or 0 if no rotations are possible\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    for i in range(1, length):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required, or 0 if no rotation is possible\n    \"\"\"\n    if not s:\n        return 0\n    \n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    n = len(s)\n    \n    # Check all rotations from 1 to n-1\n    for i in range(1, n):\n        # Create the rotated string\n        rotated = s[i:] + s[:i]\n        \n        # If the rotated string is the same as the original, return the number of rotations\n        if rotated == s:\n            return i\n    \n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    n = len(s)\n    \n    # Check all rotations from 1 to n-1\n    for i in range(1, n):\n        # Create the rotated string\n        rotated = s[i:] + s[:i]\n        \n        # If the rotated string is the same as the original, return the number of rotations\n        if rotated == s:\n            return i\n    \n    # If no rotation produces the same string, return the length of the string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    \n    # Check all rotations from 1 to length-1\n    for i in range(1, length):\n        # Rotate the string\n        rotated = s[i:] + s[:i]\n        \n        # If rotated string is same as original, return the number of rotations\n        if rotated == s:\n            return i\n    \n    # If no rotation results in the same string, return the length of the string\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    # If no rotation found, return the length of the string\n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    \n    # Check all rotations from 1 to length-1\n    for i in range(1, length):\n        # Perform rotation\n        rotated = s[i:] + s[:i]\n        \n        # If rotated string is same as original, return number of rotations\n        if rotated == s:\n            return i\n    \n    # If no rotation produces the same string, return the length\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required, or -1 if no rotation is possible\n    \"\"\"\n    if not s:\n        return -1\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    for i in range(1, length):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required, or -1 if no rotation is possible\n    \"\"\"\n    if not s:\n        return -1\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Check all rotations from 1 to length-1\n    for i in range(1, length):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    # If no rotation found, return length (which is equivalent to no rotation)\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required\n    \"\"\"\n    if not s:\n        return 0\n    \n    length = len(s)\n    if length == 1:\n        return 1\n    \n    # Double the string to handle rotations\n    doubled = s + s\n    \n    for i in range(1, length):\n        if doubled[i:i+length] == s:\n            return i\n    \n    return length", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    int: The minimum number of rotations required, or -1 if no rotation is possible\n    \"\"\"\n    if not s or len(s) == 1:\n        return -1\n    \n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string\n    char (str): The character to be removed\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string\n    char (str): The character to be removed\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string\n    char (str): The character to be removed\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string\n    char (str): The character to be removed\n    \n    Returns:\n    str: The string with first and last occurrence of the given character removed\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it and return\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index + 1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index + 1:last_index] + string[last_index + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Args:\n    string (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The string with the first and last occurrence of the given character removed.\n    \"\"\"\n    # Find the index of the first occurrence\n    first_index = string.find(char)\n    \n    # If the character is not in the string, return the original string\n    if first_index == -1:\n        return string\n    \n    # Find the index of the last occurrence\n    last_index = string.rfind(char)\n    \n    # If there's only one occurrence, remove it\n    if first_index == last_index:\n        return string[:first_index] + string[first_index+1:]\n    \n    # Remove the first and last occurrence\n    return string[:first_index] + string[first_index+1:last_index] + string[last_index+1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (list of lists): The input matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (list of lists): The input matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (list of lists): The input matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (list of lists): The input matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (List[List[int]]): The input matrix to be sorted.\n    \n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    Args:\n    matrix (list of lists): The input matrix to be sorted.\n    \n    Returns:\n    list of lists: The sorted matrix.\n    \"\"\"\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Args:\n    text (str): The input string to check.\n    \n    Returns:\n    bool: True if the pattern is found, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match lowercase letters joined by underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Args:\n    text (str): The input string to check.\n    \n    Returns:\n    bool: True if the condition is met, False otherwise.\n    \"\"\"\n    # Regular expression pattern to match lowercase letters joined by underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \n    Args:\n    text (str): The input string to check\n    \n    Returns:\n    bool: True if the condition is met, False otherwise\n    \"\"\"\n    # Regular expression pattern to match lowercase letters joined by underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \n    Args:\n    text (str): The input string to check\n\n    Returns:\n    bool: True if the condition is met, False otherwise\n    \"\"\"\n    # Regular expression pattern to match lowercase letters joined by underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, and False otherwise.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters\n    joined with an underscore, False otherwise.\n    \n    :param text: Input string to check\n    :return: Boolean indicating if the condition is met\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 64.64646464646465, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicates in the list\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicates (as sets only store unique elements)\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains any duplicate element, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if an array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if duplicates are found, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicates in the list\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if an array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set\n    # If the length of the set is less than the length of the list,\n    # it means there were duplicate elements\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(unique_elements) < len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check if the given array contains any duplicate elements.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise\n    \"\"\"\n    # Convert the list to a set, which removes duplicates\n    # If the length of the set is less than the length of the original list,\n    # it means there were duplicates\n    return len(set(arr)) < len(arr)", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    The smallest number in the list\n    \"\"\"\n    if not numbers:\n        return None\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    The smallest number in the list\n    \"\"\"\n    if not numbers:\n        return None\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    The smallest number in the list\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        return None\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    if not numbers:\n        return None\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    The smallest number in the list\n    \"\"\"\n    if not numbers:\n        return None\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    The smallest number in the list\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    \"\"\"\n    Find the smallest number in a list of numbers.\n    \n    Args:\n    numbers (list): A list of numbers.\n    \n    Returns:\n    The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The list is empty\")\n    \n    return min(numbers)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuple_list: List of tuples to check\n    :param k: Number to check divisibility against\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuple_list: List of tuples to check\n    :param k: Divisor to check against\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples\n    k (int): The divisor\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers.\n    k (int): The divisor to check against.\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list): A list of tuples containing integers.\n    k (int): The divisor to check against.\n\n    Returns:\n    list: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuple_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n\n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [t for t in tuple_list if all(element % k == 0 for element in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n\n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list): A list of tuples containing integers.\n    k (int): The divisor to check against.\n\n    Returns:\n    list: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list): A list of tuples\n    k (int): The divisor\n\n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuple_list: List of tuples to check\n    :param k: Divisor to check against\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Args:\n    tuple_list (list): A list of tuples containing integers\n    k (int): The divisor to check against\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuple_list if all(num % k == 0 for num in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuple_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    Args:\n    tuple_list (list): A list of tuples containing integers.\n    k (int): The divisor to check against.\n\n    Returns:\n    list: A list of tuples where all elements in each tuple are divisible by k.\n    \"\"\"\n    return [tup for tup in tuple_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.91176470588235, "dps_norm": 87.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    Get the frequency of all elements in a list, returned as a dictionary.\n    \n    Args:\n    lst (list): The input list of elements.\n    \n    Returns:\n    dict: A dictionary where keys are unique elements from the input list,\n          and values are their frequencies.\n    \"\"\"\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    # Use a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of all elements in a list.\n    \n    Args:\n    lst (list): The input list of elements.\n    \n    Returns:\n    dict: A dictionary where keys are unique elements from the input list,\n          and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency counts\n    freq_dict = {}\n    \n    # Iterate through each element in the input list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency count\n    frequency = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the frequency dictionary\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Calculate the frequency of all elements in a list.\n    \n    Args:\n    lst (list): The input list of elements.\n    \n    Returns:\n    dict: A dictionary where keys are unique elements from the input list,\n          and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequencies\n    freq_dict = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    # Return the frequency dictionary\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(numbers):\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Use a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Create an empty dictionary to store the frequencies\n    frequency = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the frequency dictionary\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Returns a dictionary with the frequency of all elements in the input list.\n    \n    Args:\n    lst (list): The input list of elements.\n    \n    Returns:\n    dict: A dictionary where keys are unique elements from the input list,\n          and values are their frequencies.\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Use a dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through the list and count occurrences\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 33.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    Args:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n\n    Args:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the given list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:  # Check if the list is empty\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.46036585365853, "dps_norm": 61.0, "pass@1": 100.0, "profiled": [{"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n    \n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    # Initialize with the first tuple\n    min_tuple = tuple_list[0]\n\n    # Iterate through the list to find the tuple with the smallest second value\n    for current_tuple in tuple_list:\n        if current_tuple[1] < min_tuple[1]:\n            min_tuple = current_tuple\n\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 3}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n    \n    return min(tuple_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    if not tuple_list:\n        return None\n    \n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuple_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n    tuple_list (list): A list of tuples, where each tuple contains two elements.\n\n    Returns:\n    The first value of the tuple with the smallest second value.\n    \"\"\"\n    if not tuple_list:\n        return None\n\n    min_tuple = min(tuple_list, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 79.58333333333331, "dps_norm": 82.85714285714285, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n//i is also a divisor\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of the input integer\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n//i is also a divisor\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, n//i is also a divisor\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            \n            # If n/i is different from i, it's also a divisor\n            if n // i != i:\n                count += 1\n    \n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of the input integer\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is different from i, it's also a divisor\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n\n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is a different divisor, increment count\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer.\n    \n    Returns:\n    int: The number of divisors of the input integer.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of the input integer\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is different from i, it's also a divisor\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n//i is also a divisor\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is a different divisor, increment count again\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is a different divisor, increment count\n            if i != n // i:\n                count += 1\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer to find divisors for.\n    \n    Returns:\n    int: The number of divisors.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n\n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n//i is also a divisor\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The input integer\n    \n    Returns:\n    int: The number of divisors of n\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n/i is also a divisor\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count", "matching_cluster_idx": 5}]}, "Mbpp/97": {"dps": 99.67521367521368, "dps_norm": 88.125, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are unique elements and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(list_of_lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find frequency of each element in a flattened list of lists.\n\n    Args:\n    list_of_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in list_of_lists for item in sublist]\n    \n    # Use Counter to count occurrences of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n    \n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count occurrences of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are unique elements from the flattened list,\n                    and values are their frequencies.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n    \n    Args:\n    list_of_lists (list): A list containing lists of elements.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the list of lists using itertools.chain\n    flattened = list(chain(*list_of_lists))\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n\n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[int, int]: A dictionary where keys are unique elements from the flattened list,\n                    and values are their frequencies.\n    \"\"\"\n    # Flatten the list of lists\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Count the frequency of each element\n    frequency = Counter(flattened)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(nested_list: List[List[int]]) -> Dict[int, int]:\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists.\n    \n    Args:\n    nested_list (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    Dict[int, int]: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    # Flatten the nested list\n    flattened = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    return dict(Counter(flattened))", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 90.94155844155844, "dps_norm": 97.5, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the elements of the original tuple followed by the elements of the list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing elements from both the input tuple and list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple containing all elements from the input tuple followed by all elements from the input list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3: Input lists to be merged\n    \n    Returns:\n    A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists to be merged\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists to be merged\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3: Input lists to be merged\n    \n    Returns:\n    A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists to be merged\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into a single list\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1 (list): First input list\n    list2 (list): Second input list\n    list3 (list): Third input list\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3: Input lists to be merged\n    \n    Returns:\n    A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists to be merged\n    \n    Returns:\n    list: A single sorted list containing all elements from the input lists\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    return sorted(combined_list)", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 40.53846153846154, "dps_norm": 78.125, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_list (list): A list of lists containing integers\n    \n    Returns:\n    list: A list of common elements found in all nested lists\n    \"\"\"\n    if not nested_list:\n        return []\n    \n    # Convert the first sublist to a set\n    common_elements = set(nested_list[0])\n    \n    # Iterate through the remaining sublists\n    for sublist in nested_list[1:]:\n        # Update common_elements to keep only elements that are in both sets\n        common_elements = common_elements.intersection(set(sublist))\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert all sublists to sets\n    set_lists = [set(sublist) for sublist in nested_lists]\n    \n    # Use set intersection to find common elements\n    common_elements = set.intersection(*set_lists)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_lists (list): A list of lists containing elements\n    \n    Returns:\n    list: A list of common elements found in all nested lists\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists\n    for lst in nested_lists[1:]:\n        # Update common_elements to keep only elements present in both\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Intersect with each subsequent list\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    # Convert each inner list to a set\n    set_lists = [set(inner_list) for inner_list in nested_lists]\n    \n    # Use reduce with set intersection to find common elements\n    common_elements = reduce(set.intersection, set_lists)\n    \n    # Convert the result back to a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from functools import reduce\nfrom typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: A list of common elements found in all nested lists.\n    \"\"\"\n    # Convert each inner list to a set\n    set_lists = [set(lst) for lst in nested_lists]\n    \n    # Use reduce with set intersection to find common elements\n    common_elements = list(reduce(set.intersection, set_lists))\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert all sublists to sets\n    set_lists = [set(sublist) for sublist in nested_lists]\n    \n    # Use set intersection to find common elements\n    common_elements = set.intersection(*set_lists)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from typing import List, Set\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> Set[int]:\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Set[int]: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and keep only common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert all sublists to sets\n    set_lists = [set(sublist) for sublist in nested_lists]\n    \n    # Find the intersection of all sets\n    common_elements = set.intersection(*set_lists)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert all sublists to sets\n    set_lists = [set(sublist) for sublist in nested_lists]\n    \n    # Find the intersection of all sets\n    common_elements = set.intersection(*set_lists)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from functools import reduce\nfrom typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: A list of common elements found in all nested lists.\n    \"\"\"\n    # Convert each inner list to a set\n    set_lists = [set(lst) for lst in nested_lists]\n    \n    # Use reduce with set intersection to find common elements\n    common_elements = list(reduce(set.intersection, set_lists))\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom functools import reduce\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: A list of common elements found in all nested lists.\n    \"\"\"\n    # Convert each inner list to a set\n    set_list = [set(inner_list) for inner_list in nested_lists]\n    \n    # Use set intersection to find common elements\n    common_elements = reduce(lambda x, y: x.intersection(y), set_list)\n    \n    # Convert the result back to a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    # Convert all inner lists to sets\n    set_lists = [set(inner_list) for inner_list in nested_lists]\n    \n    # Use reduce with set intersection to find common elements\n    common_elements = reduce(lambda x, y: x.intersection(y), set_lists)\n    \n    # Convert the result back to a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from functools import reduce\nfrom typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: A list of common elements found in all nested lists.\n    \"\"\"\n    # Convert each inner list to a set\n    set_list = [set(inner_list) for inner_list in nested_lists]\n    \n    # Use reduce with set intersection to find common elements\n    common_elements = list(reduce(set.intersection, set_list))\n    \n    return common_elements", "matching_cluster_idx": 5}, {"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    # Convert all inner lists to sets\n    set_lists = [set(inner_list) for inner_list in nested_lists]\n    \n    # Use set intersection to find common elements\n    common_elements = reduce(lambda x, y: x.intersection(y), set_lists)\n    \n    # Convert the result back to a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from functools import reduce\nfrom typing import List\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> List[int]:\n    # Convert each inner list to a set\n    set_lists = [set(lst) for lst in nested_lists]\n    \n    # Use reduce and set intersection to find common elements\n    common_elements = reduce(set.intersection, set_lists)\n    \n    # Convert the result back to a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "from typing import List, Set\ndef common_in_nested_lists(nested_lists: List[List[int]]) -> Set[int]:\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n    nested_lists (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Set[int]: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate through the remaining lists and keep only the common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "from functools import reduce\ndef common_in_nested_lists(nested_lists):\n    # Convert each inner list to a set\n    set_lists = [set(inner_list) for inner_list in nested_lists]\n    \n    # Use reduce with set intersection to find common elements\n    common_elements = reduce(lambda x, y: x.intersection(y), set_lists)\n    \n    # Convert the result back to a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    Args:\n    nested_lists (list of lists): A list containing multiple lists of elements.\n    \n    Returns:\n    list: A list of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Convert the first list to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists\n    for lst in nested_lists[1:]:\n        # Update common_elements to keep only elements that are in both sets\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)\nnested_lists = [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    \n    # Convert all sublists to sets\n    set_lists = [set(sublist) for sublist in nested_lists]\n    \n    # Use set intersection to find common elements\n    common_elements = set.intersection(*set_lists)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}]}, "Mbpp/123": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n    \n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be returned\n    text (str): A string containing words separated by spaces\n    \n    Returns:\n    list: A list of words longer than n characters\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be returned\n    text (str): A string containing words separated by spaces\n    \n    Returns:\n    list: A list of words longer than n characters\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be returned\n    text (str): A string containing words separated by spaces\n    \n    Returns:\n    list: A list of words from the input text that are longer than n characters\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n\n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be included in the result.\n    text (str): A string containing words separated by spaces.\n    \n    Returns:\n    list: A list of words from the input text that are longer than n characters.\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n    \n    Args:\n    n (int): The minimum length of words to be included\n    text (str): A string containing words separated by spaces\n    \n    Returns:\n    list: A list of words longer than n characters\n    \"\"\"\n    # Split the text into a list of words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Calculate whether the given matrix is a magic square.\n    \n    A magic square is a square matrix where the sums of the numbers in each row, \n    each column, and both main diagonals are all equal.\n    \n    Args:\n    matrix (list of lists): The input matrix to be tested.\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Calculate whether the given matrix is a magic square.\n    A magic square is a square matrix where the sums of each row, column, and both diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and both diagonals are equal.\n    \n    Args:\n    matrix (list of lists): The input matrix to be tested\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column,\n    and both main diagonals are equal.\n\n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and both diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row as reference)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to calculate whether the matrix is a magic square.\n    A magic square is a square matrix where the sums of each row, column, and both main diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column,\n    and both main diagonals are equal.\n    \n    Args:\n    matrix (list of lists): The input matrix to be tested\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the sum of the first row as the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and both diagonals are equal.\n\n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, each column,\n    and both main diagonals are equal.\n\n    Args:\n    matrix (list of lists): The input matrix to be tested\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, each column,\n    and both main diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: Boolean, True if it's a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, each column,\n    and both main diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: Boolean, True if it's a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and both diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and both diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: Boolean indicating whether the matrix is a magic square\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column,\n    and both main diagonals are equal.\n\n    Args:\n    matrix (list of lists): The input matrix to be tested\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sums of each row, each column,\n    and both main diagonals are equal.\n\n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column, and both diagonals are equal.\n    \n    :param matrix: A 2D list representing the square matrix\n    :return: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to calculate whether the given matrix is a magic square.\n    \n    A magic square is a square matrix where the sum of each row, each column,\n    and both main diagonals are equal.\n    \n    Args:\n    matrix (list of lists): The input matrix to be tested\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the sum of the first row as the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Calculate whether the given matrix is a magic square.\n    A magic square is a square matrix where the sums of each row, column,\n    and both main diagonals are equal.\n    \n    Args:\n    matrix (List[List[int]]): A 2D list representing the square matrix\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check secondary diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, column,\n    and both main diagonals are equal.\n\n    :param matrix: A 2D list representing the square matrix\n    :return: Boolean, True if it's a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check other diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to test if a given matrix is a magic square.\n    A magic square is a square matrix where the sum of each row, each column,\n    and both main diagonals are equal.\n    \n    Args:\n    matrix (list of lists): The input matrix to test\n    \n    Returns:\n    bool: True if the matrix is a magic square, False otherwise\n    \"\"\"\n    n = len(matrix)\n    \n    # Calculate the expected sum (sum of first row)\n    expected_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != expected_sum:\n            return False\n    \n    # Check columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != expected_sum:\n            return False\n    \n    # Check main diagonal (top-left to bottom-right)\n    if sum(matrix[i][i] for i in range(n)) != expected_sum:\n        return False\n    \n    # Check other diagonal (top-right to bottom-left)\n    if sum(matrix[i][n-1-i] for i in range(n)) != expected_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 81.99551569506727, "dps_norm": 71.66666666666667, "pass@1": 99.0, "profiled": [{"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item with the maximum count\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(numbers):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Find the number with the maximum frequency\n    max_freq = 0\n    max_num = None\n    \n    for num, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_num = num\n    \n    return max_num", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Use a dictionary to count occurrences of each item\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    # Find the item with maximum frequency\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item with the maximum count\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(numbers):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Find the number with the maximum frequency\n    max_freq = 0\n    max_num = None\n    \n    for num, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_num = num\n    \n    return max_num", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item with maximum frequency\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Find the item with maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item with the maximum count\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(numbers):\n    # Create a dictionary to store the frequency of each number\n    frequency = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Find the number with the maximum frequency\n    max_freq = 0\n    max_num = None\n    \n    for num, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_num = num\n    \n    return max_num", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item with maximum frequency\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count occurrences of each item\n    count = Counter(lst)\n    \n    # Find the item with maximum frequency\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    \n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq = 0\n    max_item = None\n    for item, freq in frequency.items():\n        if freq > max_freq:\n            max_freq = freq\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 52.258064516129025, "dps_norm": 67.5, "pass@1": 93.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): An array of integers.\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): An array of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # Handle case where all elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0  # Return 0 for empty arrays to avoid division by zero\n\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n\n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0.0\n\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n\n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Args:\n    arr (list): A list of integers\n    \n    Returns:\n    float: The ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 4}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    \n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Find the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List of integers\n    :return: Float representing the ratio of zeroes to non-zeroes\n    \"\"\"\n    if not arr:\n        return 0\n\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n\n    if non_zero_count == 0:\n        return float('inf')  # All elements are zero\n\n    return zero_count / non_zero_count", "matching_cluster_idx": 5}]}, "Mbpp/140": {"dps": 62.59316770186335, "dps_norm": 69.375, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single list of unique numbers.\n    \n    Args:\n    list_of_lists (list): A list containing lists or tuples of numbers.\n    \n    Returns:\n    list: A flattened list of unique numbers.\n    \"\"\"\n    # Use a set comprehension to flatten the list and remove duplicates\n    flattened_set = {num for sublist in list_of_lists for num in sublist}\n    \n    # Convert the set back to a list\n    return list(flattened_set)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists (or tuples) into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing lists or tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {item for sublist in list_of_lists for item in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_lists):\n    # Use a set comprehension to flatten the list of lists and remove duplicates\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list containing tuples or lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the input list of lists.\n    \"\"\"\n    # Use a set comprehension to flatten the list and remove duplicates\n    return {num for sublist in list_of_lists for num in sublist}", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 98.41269841269842, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of elements to be sorted\n    :return: Sorted list\n    \"\"\"\n    def flip(arr, k):\n        return arr[:k][::-1] + arr[k:]\n\n    def find_max_index(arr, k):\n        return arr[:k].index(max(arr[:k]))\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverse the order of the first k elements in the array\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, k):\n    \"\"\"\n    Find the index of the maximum element in the first k elements\n    \"\"\"\n    return arr.index(max(arr[:k]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sort the array using the pancake sort algorithm\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # If the largest element is not at the end, flip it to the beginning\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Then flip it to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the order of the first k elements in the list.\n        \"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    def find_max_index(arr, k):\n        \"\"\"\n        Finds the index of the maximum element in the first k elements of the list.\n        \"\"\"\n        return arr[:k].index(max(arr[:k]))\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverse the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Find the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sort the array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # If the maximum element is not at the end, flip it to the beginning\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Then flip it to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    def flip(arr, k):\n        return arr[:k][::-1] + arr[k:]\n\n    def find_max_index(arr, n):\n        return arr.index(max(arr[:n]))\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the list.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, k):\n    \"\"\"Find the index of the maximum element in the first k elements.\"\"\"\n    return arr[:k].index(max(arr[:k]))\ndef pancake_sort(arr):\n    \"\"\"Sort the list using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # If the largest element is not at the end of the current sublist\n            if max_idx != 0:\n                # Flip the sublist to bring the largest element to the beginning\n                arr = flip(arr, max_idx + 1)\n            # Flip the entire sublist to bring the largest element to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Helper function to reverse the first k elements of the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Helper function to find the index of the maximum element in the first n elements.\"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Implements the pancake sort algorithm to sort the input list.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    n = len(arr)\n    \n    for curr_size in range(n, 1, -1):\n        # Find index of the maximum element in arr[0..curr_size-1]\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            # Move the maximum element to the end of the current subarray\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    :param arr: List of comparable elements\n    :return: Sorted list\n    \"\"\"\n    def flip(arr, k):\n        return arr[:k][::-1] + arr[k:]\n\n    def find_max_index(arr, n):\n        return arr.index(max(arr[:n]))\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Helper function to reverse the first k elements of the array.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n    \n    n = len(arr)\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:i]))\n        \n        if max_idx != i - 1:\n            # If the maximum element is not at the end of the unsorted portion\n            if max_idx != 0:\n                # Flip the subarray to bring the maximum element to the beginning\n                arr = flip(arr, max_idx + 1)\n            # Flip the subarray to bring the maximum element to its correct position\n            arr = flip(arr, i)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Finds the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            # Move the maximum element to the beginning\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            \n            # Move the maximum element to its correct position\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the order of the first k elements in the list.\n        \"\"\"\n        return arr[:k][::-1] + arr[k:]\n\n    def find_max_index(arr, k):\n        \"\"\"\n        Finds the index of the maximum element in the first k elements of the list.\n        \"\"\"\n        return arr[:k].index(max(arr[:k]))\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Finds the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # Flip the subarray to bring the maximum element to the beginning\n            if max_idx > 0:\n                arr = flip(arr, max_idx + 1)\n            # Flip the subarray to bring the maximum element to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Finds the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            # Move the maximum element to the beginning of the array\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            \n            # Move the maximum element to its correct position\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the order of the first k elements in the list.\n        \"\"\"\n        return arr[:k][::-1] + arr[k:]\n    \n    def find_max_index(arr, n):\n        \"\"\"\n        Finds the index of the maximum element in the first n elements.\n        \"\"\"\n        return arr[:n].index(max(arr[:n]))\n    \n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Finds the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # If the largest element is not at the end, flip it to the beginning\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Then flip it to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Finds the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # Flip the maximum element to the beginning of the array\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Flip the maximum element to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"\n    Finds the index of the maximum element in the first n elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            # Flip the subarray to bring the maximum element to the beginning\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Flip the subarray to bring the maximum element to its correct position\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"\n    Reverses the order of the first k elements in the array.\n    \"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, k):\n    \"\"\"\n    Finds the index of the maximum element in the first k elements of the array.\n    \"\"\"\n    return arr.index(max(arr[:k]))\ndef pancake_sort(arr):\n    \"\"\"\n    Sorts the input array using the pancake sort algorithm.\n    \"\"\"\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def flip(arr, k):\n    \"\"\"Reverse the order of the first k elements in the array.\"\"\"\n    return arr[:k][::-1] + arr[k:]\ndef find_max_index(arr, n):\n    \"\"\"Find the index of the maximum element in the first n elements.\"\"\"\n    return arr.index(max(arr[:n]))\ndef pancake_sort(arr):\n    \"\"\"Sort the array using the pancake sort algorithm.\"\"\"\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            # Move the maximum element to the beginning\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            \n            # Move the maximum element to its correct position\n            arr = flip(arr, curr_size)\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n    \n    Args:\n    arr (list): The input list to be sorted.\n    \n    Returns:\n    list: The sorted list in ascending order.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"Helper function to reverse the first k elements of the array.\"\"\"\n        return arr[:k][::-1] + arr[k:]\n    \n    def find_max_index(arr, k):\n        \"\"\"Helper function to find the index of the maximum element in the first k elements.\"\"\"\n        return arr[:k].index(max(arr[:k]))\n    \n    n = len(arr)\n    \n    for i in range(n, 1, -1):\n        max_idx = find_max_index(arr, i)\n        if max_idx != i - 1:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i)\n    \n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that XOR to an even number.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    int: The count of pairs that XOR to an even number.\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The count of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(numbers)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \n    Args:\n    nums (list): A list of integers\n    \n    Returns:\n    int: The count of pairs that xor to an even number\n    \"\"\"\n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 55.36231884057971, "dps_norm": 91.25, "pass@1": 56.0, "profiled": [{"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure the indices are within the list bounds\n    start_index = max(0, start_index)\n    end_index = min(len(numbers) - 1, end_index)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    :param numbers: List of numbers\n    :param start_index: Starting index of the range (inclusive)\n    :param end_index: Ending index of the range (inclusive)\n    :return: Sum of numbers within the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n    \n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not out of bounds\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    :param numbers: List of numbers\n    :param start_index: Starting index of the range (inclusive)\n    :param end_index: Ending index of the range (inclusive)\n    :return: Sum of numbers within the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative and end_index is not out of bounds\n    start_index = max(0, start_index)\n    end_index = min(end_index, len(numbers) - 1)\n\n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative and end_index is not out of bounds\n    start_index = max(0, start_index)\n    end_index = min(end_index, len(numbers) - 1)\n\n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): The input list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative and end_index is not out of bounds\n    start_index = max(0, start_index)\n    end_index = min(end_index, len(numbers) - 1)\n\n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    :param numbers: List of numbers\n    :param start_index: Starting index of the range (inclusive)\n    :param end_index: Ending index of the range (inclusive)\n    :return: Sum of numbers within the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    :param numbers: List of numbers\n    :param start_index: Starting index of the range (inclusive)\n    :param end_index: Ending index of the range (inclusive)\n    :return: Sum of numbers within the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative and end_index is not out of bounds\n    start_index = max(0, start_index)\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Return the sum of the numbers within the specified range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    Args:\n    numbers (list): A list of numbers\n    start_index (int): The starting index of the range (inclusive)\n    end_index (int): The ending index of the range (inclusive)\n    \n    Returns:\n    int: The sum of numbers within the specified range\n    \"\"\"\n    # Ensure start_index is not negative\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not out of bounds\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n    \n    :param numbers: List of numbers\n    :param start_index: Starting index of the range (inclusive)\n    :param end_index: Ending index of the range (inclusive)\n    :return: Sum of numbers within the specified range\n    \"\"\"\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n\n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative and end_index is not out of bounds\n    start_index = max(0, start_index)\n    end_index = min(end_index, len(numbers) - 1)\n\n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure the indices are within the list bounds\n    start_index = max(0, start_index)\n    end_index = min(len(numbers) - 1, end_index)\n\n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not out of bounds\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range of indices.\n    \n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not out of range\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not less than 0\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not greater than the last index of the list\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index + 1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    Args:\n    numbers (list): The list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n\n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not greater than the list length\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}, {"solution": "def sum_range_list(numbers, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n    \n    Args:\n    numbers (list): A list of numbers.\n    start_index (int): The starting index of the range (inclusive).\n    end_index (int): The ending index of the range (inclusive).\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \"\"\"\n    # Ensure start_index is not negative\n    start_index = max(0, start_index)\n    \n    # Ensure end_index is not out of range\n    end_index = min(end_index, len(numbers) - 1)\n    \n    # Calculate the sum of numbers within the range\n    return sum(numbers[start_index:end_index+1])", "matching_cluster_idx": 6}]}, "Mbpp/226": {"dps": 98.02325581395348, "dps_norm": 97.85714285714286, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters which have odd index values of a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str: A new string with characters at odd indices removed\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters at odd index values from the input string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters at odd index values from the given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at even indices (0-based) from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n\n    Args:\n    input_string (str): The input string to process.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at even indices (0-based) from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters which have odd index values of a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str: The string with characters at odd indices removed\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at even indices (0-based) from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from the input string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at even indices (0-based) from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters which have odd index values of a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at even indices from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Remove characters which have odd index values of a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str: The string with characters at odd indices removed\n    \"\"\"\n    return s[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters which have odd index values of a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 5}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from the given string.\n    \n    Args:\n    input_string (str): The input string to process.\n    \n    Returns:\n    str: A new string with characters at even indices from the input string.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}, {"solution": "def odd_values_string(input_string):\n    \"\"\"\n    Remove characters with odd index values from a given string.\n\n    Args:\n    input_string (str): The input string to process.\n\n    Returns:\n    str: A new string with characters at odd indices removed.\n    \"\"\"\n    return input_string[::2]", "matching_cluster_idx": 6}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the input string with the specified character.\n\n    Args:\n    string (str): The input string containing spaces to be replaced.\n    character (str): The character to replace the spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the string with the given character.\n    \n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n    \n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string containing spaces to be replaced.\n    character (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the given character.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string containing spaces to be replaced.\n    character (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the given character.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n    \n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n    \n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the input string with the given character.\n\n    Args:\n    string (str): The input string containing spaces to be replaced.\n    character (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the given character.\n    \"\"\"\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replace blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string containing spaces to be replaced.\n    character (str): The character to replace spaces with.\n\n    Returns:\n    str: The modified string with spaces replaced by the given character.\n    \"\"\"\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the given string with the specified character.\n    \n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n    \n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replaces blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Replace blank spaces in the given string with the specified character.\n\n    Args:\n    string (str): The input string.\n    character (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 39.6551724137931, "dps_norm": 53.0, "pass@1": 98.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(prev, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * prev), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n    \n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    :param m: The maximum value allowed in the sequence\n    :param n: The length of the sequence\n    :return: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining):\n        if remaining == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining - 1)\n        \n        return total\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(prev, remaining, memo):\n        if remaining == 0:\n            return 1\n        \n        if (prev, remaining) in memo:\n            return memo[(prev, remaining)]\n        \n        count = 0\n        for next_num in range(2 * prev, m + 1):\n            count += count_sequences(next_num, remaining - 1, memo)\n        \n        memo[(prev, remaining)] = count\n        return count\n    \n    return sum(count_sequences(i, n - 1, {}) for i in range(1, m // 2 + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    :param m: The maximum value allowed in the sequence\n    :param n: The length of the sequence\n    :return: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return sum(count_sequences(start, n - 1) for start in range(1, m // 2 + 1))", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The maximum value allowed in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The upper bound for the elements in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    def count_sequences(current, remaining_length, memo):\n        if remaining_length == 0:\n            return 1\n        if (current, remaining_length) in memo:\n            return memo[(current, remaining_length)]\n        \n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += count_sequences(next_num, remaining_length - 1, memo)\n        \n        memo[(current, remaining_length)] = total\n        return total\n\n    return sum(count_sequences(i, n - 1, {}) for i in range(1, m // 2 + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The maximum value allowed in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return sum(count_sequences(i, n - 1) for i in range(1, m // 2 + 1))", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, remaining, max_value):\n        if remaining == 0:\n            return 1\n        \n        total = 0\n        for next_value in range(max(current * 2, 1), max_value + 1):\n            total += count_sequences(next_value, remaining - 1, max_value)\n        \n        return total\n\n    return count_sequences(0, n, m)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    :param m: The upper limit for each element in the sequence\n    :param n: The length of the sequence\n    :return: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    :param m: The maximum value allowed in the sequence\n    :param n: The length of the sequence\n    :return: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining):\n        if remaining == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining - 1)\n        \n        return total\n    \n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n    \n    :param m: The maximum value allowed in the sequence\n    :param n: The length of the sequence\n    :return: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, remaining_length, memo):\n        if remaining_length == 0:\n            return 1\n        if (current, remaining_length) in memo:\n            return memo[(current, remaining_length)]\n        \n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += count_sequences(next_num, remaining_length - 1, memo)\n        \n        memo[(current, remaining_length)] = total\n        return total\n\n    total_sequences = 0\n    memo = {}\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1, memo)\n    \n    return total_sequences", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(prev, remaining):\n        if remaining == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * prev), m + 1):\n            total += count_sequences(next_num, remaining - 1)\n        \n        return total\n    \n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(prev, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(2 * prev, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n    \n    return sum(count_sequences(i, n - 1) for i in range(1, m // 2 + 1))", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The upper bound for the elements in the sequence\n    n (int): The length of the sequence\n\n    Returns:\n    int: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(2 * current, m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return sum(count_sequences(i, n - 1) for i in range(1, m // (2 ** (n - 1)) + 1))", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the number of possible sequences of length n, where each element\n    is a positive integer and is greater than or equal to twice the previous\n    element but less than or equal to m.\n\n    Args:\n    m (int): The upper bound for the elements in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    def count_sequences(prev, length):\n        if length == 0:\n            return 1\n        \n        count = 0\n        start = max(prev * 2, 1)\n        for num in range(start, m + 1):\n            count += count_sequences(num, length - 1)\n        \n        return count\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, remaining, max_val):\n        if remaining == 0:\n            return 1\n        \n        total = 0\n        for next_val in range(max(current * 2, 1), max_val + 1):\n            total += count_sequences(next_val, remaining - 1, max_val)\n        \n        return total\n\n    return count_sequences(0, n, m)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Finds the number of possible sequences of length n, where each element is a positive integer\n    and is greater than or equal to twice the previous element but less than or equal to m.\n\n    :param m: The maximum value allowed in the sequence\n    :param n: The length of the sequence\n    :return: The total number of possible sequences\n    \"\"\"\n    def count_sequences(current, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for next_num in range(max(1, 2 * current), m + 1):\n            total += count_sequences(next_num, remaining_length - 1)\n        \n        return total\n\n    return count_sequences(0, n)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(prev, remaining_length):\n        if remaining_length == 0:\n            return 1\n        \n        total = 0\n        for num in range(2 * prev, m + 1):\n            total += count_sequences(num, remaining_length - 1)\n        \n        return total\n\n    return sum(count_sequences(i, n - 1) for i in range(1, m // 2 + 1))", "matching_cluster_idx": 5}]}, "Mbpp/240": {"dps": 50.0, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by all elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The first input list.\n    list2 (list): The second input list.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list\n    list2 (list): The second list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will be added to the end of the first list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will be added to the end of the first list.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The first list\n    list2 (list): The second list\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list\n    list2 (list): The second list\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of the first list.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n    \n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n\n    Args:\n    list1 (list): The first list whose last element will be replaced.\n    list2 (list): The second list whose elements will replace the last element of list1.\n\n    Returns:\n    list: A new list with the last element of list1 replaced by the elements of list2.\n    \"\"\"\n    return list1[:-1] + list2", "matching_cluster_idx": 5}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n    \n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n    \n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ninput_list = ['Red', 'Green', 'Black']\ninsert_char = 'c'\nresult = insert_element(input_list, insert_char)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ntest_list = ['Red', 'Green', 'Black']\ntest_element = 'c'\nresult = insert_element(test_list, test_element)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n    \n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n    \n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ninput_list = ['Red', 'Green', 'Black']\ninsert_char = 'c'\nresult = insert_element(input_list, insert_char)", "matching_cluster_idx": 6}, {"solution": "def insert_element(input_list, element):\n    result = []\n    for item in input_list:\n        result.extend([element, item])\n    return result\ntest_list = ['Red', 'Green', 'Black']\ntest_element = 'c'\nresult = insert_element(test_list, test_element)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\noriginal_list = ['Red', 'Green', 'Black']\nelement_to_insert = 'c'\nresult = insert_element(original_list, element_to_insert)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n\n    Args:\n    lst (list): The original list.\n    element: The element to be inserted.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\noriginal_list = ['Red', 'Green', 'Black']\nelement_to_insert = 'c'\nresult = insert_element(original_list, element_to_insert)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n\n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    Args:\n    lst (list): The input list\n    element: The element to be inserted\n    \n    Returns:\n    list: The resulting list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n    \n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n    \n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ninput_list = ['Red', 'Green', 'Black']\ninsert_char = 'c'\nresult = insert_element(input_list, insert_char)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n    lst (list): The input list.\n    element: The element to insert.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    Args:\n    lst (list): The input list\n    element: The element to be inserted\n    \n    Returns:\n    list: A new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ninput_list = ['Red', 'Green', 'Black']\ninsert_char = 'c'\nresult = insert_element(input_list, insert_char)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n    \n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n    \n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ntest_list = ['Red', 'Green', 'Black']\ntest_element = 'c'\nresult = insert_element(test_list, test_element)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n    \n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ninput_list = ['Red', 'Green', 'Black']\ninsert_char = 'c'\nresult = insert_element(input_list, insert_char)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list.\n\n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    Args:\n    lst (list): The original list\n    element: The element to be inserted\n    \n    Returns:\n    list: A new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\noriginal_list = ['Red', 'Green', 'Black']\nelement_to_insert = 'c'\nresult = insert_element(original_list, element_to_insert)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the input list.\n\n    Args:\n    lst (list): The input list.\n    element: The element to be inserted.\n\n    Returns:\n    list: A new list with the element inserted before each original element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\ninput_list = ['Red', 'Green', 'Black']\ninsert_char = 'c'\nresult = insert_element(input_list, insert_char)", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    Args:\n    lst (list): The original list\n    element: The element to be inserted\n    \n    Returns:\n    list: A new list with the element inserted before each original element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result\noriginal_list = ['Red', 'Green', 'Black']\nelement_to_insert = 'c'\nresult = insert_element(original_list, element_to_insert)", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 97.71689497716895, "dps_norm": 88.23529411764706, "pass@1": 100.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n (int): A non-negative integer\n\n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n\n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Counts the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n\n    Args:\n    n (int): A non-negative integer\n\n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a boolean array \"is_prime[i]\" to True for all numbers from 2 to n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    # Use the Sieve of Eratosthenes algorithm to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n\n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and mark all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use the Sieve of Eratosthenes algorithm\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Update all multiples of i\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Create a boolean array \"is_prime[0..n]\" and initialize\n    # all entries it as true. A value in is_prime[i] will\n    # finally be false if i is Not a prime, else true.\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Update all multiples of i\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and mark all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and mark all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and mark all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use the Sieve of Eratosthenes algorithm\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Update all multiples of i\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer.\n    \n    Returns:\n    int: The count of prime numbers less than n.\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[i]\" as true for all numbers from 2 to n-1\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes algorithm\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark all multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of primes\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[i]\" as true for all numbers from 2 to n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and set all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Update all multiples of i\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and mark all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and set all entries to true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Update all multiples of i\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Count the number of prime numbers less than the given non-negative number.\n    \n    Args:\n    n (int): A non-negative integer\n    \n    Returns:\n    int: The count of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n    \n    # Initialize all numbers as prime\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    \n    # Initialize a boolean array \"is_prime[0..n]\" and mark all entries as true\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    # Use Sieve of Eratosthenes to mark non-prime numbers\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            # Mark multiples of i as non-prime\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Count the number of prime numbers\n    return sum(is_prime)", "matching_cluster_idx": 14}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    result = [[] for _ in range(n)]\n    for i, item in enumerate(input_list):\n        result[i % n].append(item)\n    return result\ntest_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']\ntest_n = 3\nresult = list_split(test_list, test_n)", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains elements at every nth position.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains elements at every nth position.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    lst (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the original list.\n    \"\"\"\n    return [lst[i::n] for i in range(n)]\nn = 3", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n    \n    Returns:\n    list: A list of lists, where each sublist contains elements at every nth position.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n    \n    :param lst: The input list to be split\n    :param n: The interval at which to split the list\n    :return: A list of lists, where each sublist contains every nth element\n    \"\"\"\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(input_list, n):\n    \"\"\"\n    Splits a list for every nth element, returning a list of the resulting lists.\n\n    Args:\n    input_list (list): The input list to be split.\n    n (int): The interval at which to split the list.\n\n    Returns:\n    list: A list of lists, where each sublist contains every nth element from the input list.\n    \"\"\"\n    return [input_list[i::n] for i in range(n)]", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The input list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The input list to check for uniqueness.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    \n    Args:\n    lst (list): The input list to check for uniqueness\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 96.41025641025641, "dps_norm": 98.33333333333333, "pass@1": 78.0, "profiled": [{"solution": "def merge_and_count(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inv_count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_inv = merge_sort_and_count(arr[:mid])\n    right, right_inv = merge_sort_and_count(arr[mid:])\n    merged, merge_inv = merge_and_count(left, right)\n    \n    return merged, left_inv + right_inv + merge_inv\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in an array.\n    An inversion occurs when a[i] > a[j] and i < j.\n    \n    Args:\n    arr (list): The input array of integers\n    \n    Returns:\n    int: The number of inversions in the array\n    \"\"\"\n    inv_count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    \n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def merge_and_count(left, right):\n    merged = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count the number of inversions in an array.\n    An inversion occurs when a[i] > a[j] and i < j.\n    \n    Args:\n    arr (list): The input array of integers\n    \n    Returns:\n    int: The number of inversions in the array\n    \"\"\"\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort(arr[:mid])\n        right, inv_right = merge_sort(arr[mid:])\n        merged, inv_merge = merge(left, right)\n        \n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge(left, right):\n        merged = []\n        inv_count = 0\n        i, j = 0, 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n    \n    _, inv_count = merge_sort(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    merged, inv_merge = merge_and_count(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge_and_count(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Write a python function to count inversions in an array.\n    \"\"\"\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    merged, inv_merge = merge_and_count(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge_and_count(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Counts the number of inversions in an array.\n    An inversion occurs when i < j and arr[i] > arr[j].\n    \"\"\"\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    merged, inv_merge = merge_and_count(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge_and_count(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Count inversions in an array.\n    \n    An inversion occurs when for indices i and j, i < j but arr[i] > arr[j].\n    \n    Args:\n    arr (list): Input array\n    \n    Returns:\n    int: Number of inversions in the array\n    \"\"\"\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    left_len, right_len = len(left), len(right)\n    \n    while i < left_len and j < right_len:\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += left_len - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    merged, inv_merge = merge_and_count(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge_and_count(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inv_count\ndef get_Inv_Count(arr):\n    \"\"\"\n    Count inversions in an array.\n    An inversion occurs when i < j and arr[i] > arr[j].\n    \"\"\"\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count inversions in an array.\n    \n    An inversion occurs when for indices i and j, i < j and arr[i] > arr[j].\n    \n    Args:\n    arr (list): Input array of integers\n    \n    Returns:\n    int: Number of inversions in the array\n    \"\"\"\n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_and_count(arr[:mid])\n        right, inv_right = merge_sort_and_count(arr[mid:])\n        merged, inv_merge = merge_and_count(left, right)\n        \n        return merged, inv_left + inv_right + inv_merge\n    \n    def merge_and_count(left, right):\n        merged = []\n        inv_count = 0\n        i, j = 0, 0\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_count += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inv_count\n    \n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    merged = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    merged = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(left, right):\n    result = []\n    count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            count += len(left) - i\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result, count\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_count = merge_sort_and_count(arr[:mid])\n    right, right_count = merge_sort_and_count(arr[mid:])\n    merged, merge_count = merge_and_count(left, right)\n    \n    return merged, left_count + right_count + merge_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}, {"solution": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    merged, inv_merge = merge_and_count(left, right)\n    \n    return merged, inv_left + inv_right + inv_merge\ndef merge_and_count(left, right):\n    merged = []\n    inv_count = 0\n    i, j = 0, 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    merged.extend(left[i:])\n    merged.extend(right[j:])\n    \n    return merged, inv_count\ndef get_Inv_Count(arr):\n    _, inv_count = merge_sort_and_count(arr)\n    return inv_count", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 97.58620689655173, "dps_norm": 66.66666666666667, "pass@1": 97.0, "profiled": [{"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n    list1 (list): First list of integers\n    list2 (list): Second list of integers\n    n (int): Number of largest products to return\n    \n    Returns:\n    list: List of n largest products in descending order\n    \"\"\"\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Generate all possible products\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    sorted_list1 = sorted(list1, reverse=True)\n    sorted_list2 = sorted(list2, reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in sorted_list1:\n        for num2 in sorted_list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all possible products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n    list1 (list): First list of integers\n    list2 (list): Second list of integers\n    n (int): Number of largest products to return\n    \n    Returns:\n    list: List of n largest products in descending order\n    \"\"\"\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Generate all possible products\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n    \n    # Sort products in descending order and return the n largest\n    return sorted(products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n    list1 (list): First list of integers\n    list2 (list): Second list of integers\n    n (int): Number of largest products to return\n    \n    Returns:\n    list: List of n largest products in descending order\n    \"\"\"\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    all_products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            all_products.append(num1 * num2)\n    \n    # Sort the products in descending order and return the top n\n    return sorted(all_products, reverse=True)[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    sorted_list1 = sorted(list1, reverse=True)\n    sorted_list2 = sorted(list2, reverse=True)\n    \n    # Create a list to store all products\n    all_products = []\n    \n    # Calculate all possible products\n    for num1 in sorted_list1:\n        for num2 in sorted_list2:\n            all_products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    all_products.sort(reverse=True)\n    \n    # Return the n largest products\n    return all_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n    list1 (list): First list of integers\n    list2 (list): Second list of integers\n    n (int): Number of largest products to return\n    \n    Returns:\n    list: List of n largest products in descending order\n    \"\"\"\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    sorted_list1 = sorted(list1, reverse=True)\n    sorted_list2 = sorted(list2, reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in sorted_list1:\n        for num2 in sorted_list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Return the n largest products\n    return sorted_products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    sorted_list1 = sorted(list1, reverse=True)\n    sorted_list2 = sorted(list2, reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in sorted_list1:\n        for num2 in sorted_list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all possible products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all possible products\n    products = []\n    \n    # Calculate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param n: Number of largest products to return\n    :return: List of n largest products\n    \"\"\"\n    # Create all possible products\n    products = [a * b for a in list1 for b in list2]\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists,\n    selecting one factor from each list.\n    \n    Args:\n    list1 (list): First list of integers\n    list2 (list): Second list of integers\n    n (int): Number of largest products to return\n    \n    Returns:\n    list: List of n largest products in descending order\n    \"\"\"\n    # Sort both lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Create a list to store all products\n    products = []\n    \n    # Calculate all possible products\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            products.append(list1[i] * list2[j])\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 58.0, "profiled": [{"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between sum_parts and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between sum_parts and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # If the result for n is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n        \n        # Store the result in the memoization dictionary\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of recursive calls\n        sum_recursive = (f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n\n        # Calculate the maximum between n and the sum of recursive calls\n        result = max(sum_recursive, n)\n\n        # Memoize the result for n\n        memo[n] = result\n\n        return result\n\n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of recursive calls\n        sum_parts = (\n            f(n // 2) +\n            f(n // 3) +\n            f(n // 4) +\n            f(n // 5)\n        )\n\n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n\n        # Memoize the result\n        memo[n] = result\n\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result for n is already computed, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n\n        # Calculate the maximum between sum_parts and n\n        result = max(sum_parts, n)\n\n        # Store the result in the memoization dictionary\n        memo[n] = result\n\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result for n\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the value is already computed\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n        \n        # Store the result in the memoization dictionary\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n\n        # Calculate the maximum between sum_parts and n\n        result = max(sum_parts, n)\n\n        # Memoize the result for n\n        memo[n] = result\n\n        return result\n\n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n\n        # Take the maximum of the sum and n\n        result = max(sum_parts, n)\n\n        # Memoize the result for n\n        memo[n] = result\n\n        return result\n\n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Take the maximum of sum_parts and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n\n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n\n        # Memoize the result\n        memo[n] = result\n\n        return result\n\n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed values\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # If the value is already computed, return it from the memo\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n        \n        # Store the result in the memo\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between sum_parts and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function f with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store calculated results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # If the result for n is already memoized, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between sum_parts and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result for n\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result is already memoized, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n\n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n\n        # Memoize the result\n        memo[n] = result\n\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n\n        # If the result for n is already computed, return it\n        if n in memo:\n            return memo[n]\n\n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n\n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n\n        # Store the result in the memoization dictionary\n        memo[n] = result\n\n        return result\n\n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store computed results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of recursive calls\n        sum_parts = (f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n        \n        # Calculate the maximum between n and sum_parts\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function with the given n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Create a memoization dictionary to store calculated results\n    memo = {}\n    \n    def f(n):\n        # Base case: if n is 0 or 1, return n\n        if n <= 1:\n            return n\n        \n        # Check if the result for n is already memoized\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n        sum_parts = f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5)\n        \n        # Calculate the maximum between the sum and n\n        result = max(sum_parts, n)\n        \n        # Memoize the result\n        memo[n] = result\n        \n        return result\n    \n    # Call the inner function and return the result\n    return f(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    string (str): The input string to search for non-repeated characters.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if all characters repeat\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    string (str): The input string to search for non-repeated characters.\n    \n    Returns:\n    str or None: The first non-repeated character if found, None otherwise.\n    \"\"\"\n    # Create a dictionary to store character frequencies\n    char_freq = {}\n    \n    # Count the frequency of each character\n    for char in string:\n        char_freq[char] = char_freq.get(char, 0) + 1\n    \n    # Find the first character with frequency 1\n    for char in string:\n        if char_freq[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeated character, or None if all characters repeat\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If all characters repeat, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequencies\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store character frequencies\n    char_freq = {}\n    \n    # Count the frequency of each character\n    for char in s:\n        char_freq[char] = char_freq.get(char, 0) + 1\n    \n    # Find the first character with frequency 1\n    for char in s:\n        if char_freq[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    string (str): The input string to search.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    string (str): The input string to search for non-repeated characters.\n    \n    Returns:\n    str or None: The first non-repeated character, or None if all characters repeat.\n    \"\"\"\n    char_count = {}\n    \n    # Count occurrences of each character\n    for char in string:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str or None: The first non-repeating character, or None if no such character exists\n    \"\"\"\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Find the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in\n    element: The element to search for\n    \n    Returns:\n    bool: True if the element is found, False otherwise\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in\n    element: The element to search for\n    \n    Returns:\n    bool: True if the element is found, False otherwise\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check if an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to search in\n    element: The element to search for\n    \n    Returns:\n    bool: True if the element is found, False otherwise\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to search in\n    element: The element to search for\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tup (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Args:\n    tuplex (tuple): The tuple to search in.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 88.60248447204968, "dps_norm": 87.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check\n    seq2 (sequence): The second sequence to check against\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in one sequence exists in another sequence.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    set1 = set(seq1)\n    set2 = set(seq2)\n    return bool(set1.intersection(set2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any common element, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in a sequence exists in another sequence.\n    \n    Args:\n    seq1 (iterable): The first sequence to check.\n    seq2 (iterable): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's any overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (sequence): The first sequence to check.\n    seq2 (sequence): The second sequence to check against.\n    \n    Returns:\n    bool: True if there's an overlap, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 94.23868312757202, "dps_norm": 96.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the given tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_input, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple by the delimiter.\n    \n    Args:\n    tuple_input (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tuple_input))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple by the given delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Default is '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_input, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tuple_input (tuple): The input tuple to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all tuple elements concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tuple_input))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple using the specified delimiter.\n\n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n\n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tuple_input, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tuple_input (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tuple_input))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple by the delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the given tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to concatenate.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenate each element of a tuple by the delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n\n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n\n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to '-'.\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    # Convert all elements to strings and join them with the delimiter\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    Concatenates each element of a tuple using the specified delimiter.\n    \n    Args:\n    tup (tuple): The input tuple containing elements to be concatenated.\n    delimiter (str, optional): The delimiter to use between elements. Defaults to \"-\".\n    \n    Returns:\n    str: A string with all elements of the tuple concatenated, separated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}]}, "Mbpp/424": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tuple_input):\n    return [s[-1] for s in tuple_input]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_input):\n    return [s[-1] for s in tuple_input]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_input):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_input (tuple): A tuple containing strings\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple\n    \"\"\"\n    return [s[-1] for s in tuple_input]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n\n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the last character of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extract only the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_of_strings (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_of_strings):\n    return [s[-1] for s in tuple_of_strings]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tuple_input):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tuple_input (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list containing the last character of each string in the input tuple.\n    \"\"\"\n    return [s[-1] for s in tuple_input]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    nested_list (list): A list containing sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The number of sublists that contain the specified element\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    \n    Args:\n    nested_list (list): A list containing sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    nested_list (list): A list of lists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in nested_list)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The count of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The count of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    nested_list (list): A list of lists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The count of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The count of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n    \n    Args:\n    lst (list): A list of sublists\n    element: The element to search for in the sublists\n    \n    Returns:\n    int: The number of sublists containing the element\n    \"\"\"\n    return sum(element in sublist for sublist in lst)", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 46.15702479338843, "dps_norm": 48.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 63.82978723404255, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare against the array elements\n    \n    Returns:\n    bool: True if the number is greater than all elements, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare against the array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare against the array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers.\n    num (int or float): The number to compare against the array elements.\n    \n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Args:\n    arr (list): The input array of numbers.\n    num (int or float): The number to compare with array elements.\n\n    Returns:\n    bool: True if the number is greater than all elements, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare against the array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > element for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    :param arr: List of integers\n    :param num: Number to compare against the array elements\n    :return: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare against the array elements\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare against the array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int or float): The number to compare with array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the given number is greater than all elements in the array.\n    \n    Args:\n    arr (list): The input array of numbers\n    num (int): The number to compare against the array elements\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd-indexed characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string\n    \n    Returns:\n    str: The string with odd characters removed\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd-indexed characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes odd characters in a string.\n    \n    Args:\n    s (str): The input string\n    \n    Returns:\n    str: A new string with odd characters removed\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: A new string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(string):\n    \"\"\"\n    Remove odd characters in a string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: The string with odd characters removed.\n    \"\"\"\n    return string[1::2]", "matching_cluster_idx": 4}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in\n    list_input (list): The list containing elements to search for\n    \n    Returns:\n    int: The total count of occurrences\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_elements):\n    \"\"\"\n    Count the occurrence of all elements from the list in the given tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_elements (list): The list of elements to count.\n    \n    Returns:\n    int: The total count of occurrences of all list elements in the tuple.\n    \"\"\"\n    count = 0\n    for element in list_elements:\n        count += tuple_input.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Counts the occurrence of all elements from the list in the given tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in\n    list_input (list): The list of elements to search for\n    \n    Returns:\n    int: The total count of occurrences\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list of elements to search for.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The input tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_elements):\n    \"\"\"\n    Count the occurrence of all elements from the list in the given tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_elements (list): The list of elements to count.\n    \n    Returns:\n    int: The total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for element in list_elements:\n        count += tuple_input.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list containing elements to count.\n\n    Returns:\n    int: The total count of occurrences of list elements in the tuple.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in\n    list_input (list): The list of elements to search for\n    \n    Returns:\n    int: The total count of occurrences\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    return sum(tuple_input.count(element) for element in list_input)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_elements):\n    \"\"\"\n    Count the occurrence of all elements from the list in the given tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in\n    list_elements (list): The list of elements to count\n    \n    Returns:\n    int: The total count of occurrences\n    \"\"\"\n    count = 0\n    for element in list_elements:\n        count += tuple_input.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The input tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences of all elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_input, list_input):\n    \"\"\"\n    Count the occurrence of all elements from the list in the tuple.\n    \n    Args:\n    tuple_input (tuple): The tuple to search in.\n    list_input (list): The list of elements to search for.\n    \n    Returns:\n    int: The total count of occurrences.\n    \"\"\"\n    count = 0\n    for item in list_input:\n        count += tuple_input.count(item)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    string_list (list): A list of strings to be reversed.\n    \n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list with each string reversed.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 48.07692307692307, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist in the input list.\n    \n    Args:\n    lst (list): A list of sublists\n    \n    Returns:\n    list: A list containing the first element of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"\n    Get the first element of each sublist in a nested list.\n    \n    Args:\n    nested_list (list): A list containing sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in nested_list if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist.\n    \n    Args:\n    lst (list): A list of sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist.\n\n    Args:\n    lst (list): A list of sublists\n\n    Returns:\n    list: A list containing the first element of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist.\n    \n    Args:\n    lst (list): A list of sublists\n    \n    Returns:\n    list: A list containing the first element of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist in the input list.\n\n    Args:\n    lst (list): A list of sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(nested_list):\n    \"\"\"\n    Get the first element of each sublist in a nested list.\n    \n    Args:\n    nested_list (list): A list containing sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in nested_list if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist in the input list.\n    \n    Args:\n    lst (list): A list of sublists\n    \n    Returns:\n    list: A list containing the first element of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist in the input list.\n    \n    Args:\n    lst (list): A list of sublists\n\n    Returns:\n    list: A list containing the first element of each sublist\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    Get the first element of each sublist in the input list.\n\n    Args:\n    lst (list): A list of sublists.\n\n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst if sublist]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n    \n    Returns:\n    str: The modified string with characters replaced\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n    \n    Returns:\n    str: The string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace a specific character in a string with another character.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with the character replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n    \n    Returns:\n    str: The modified string with characters replaced\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace characters in a string.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n    \n    Returns:\n    str: The modified string with characters replaced\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace characters in a string.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n    \n    Returns:\n    str: The modified string with characters replaced\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replaces all occurrences of char_to_replace with replacement_char in the given string.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace characters in a string.\n    \n    Args:\n    string (str): The original string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n    \n    Returns:\n    str: The string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string with characters replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n    \n    Returns:\n    str: The string with characters replaced\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n    \n    Returns:\n    str: The string with characters replaced\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of char_to_replace with replacement_char in the given string.\n    \n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n    \n    Returns:\n    str: The string with replaced characters.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace all occurrences of a character in a string with another character.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The string with replaced characters.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace a specific character in a string with another character.\n\n    Args:\n    string (str): The input string.\n    char_to_replace (str): The character to be replaced.\n    replacement_char (str): The character to replace with.\n\n    Returns:\n    str: The modified string with the character replaced.\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        return 0\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        return 0\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest value in the array\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        return 0\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers.\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array.\n    \n    Raises:\n    ValueError: If the input array is empty.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array cannot be empty.\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest value in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        return 0\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    :param arr: A list of numbers\n    :return: The sum of the largest and smallest values in the array\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest values in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array is empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest value in the array\n    \n    Raises:\n    ValueError: If the input array is empty\n    \"\"\"\n    if not arr:\n        raise ValueError(\"Input array cannot be empty\")\n    \n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of numbers\n    \n    Returns:\n    int or float: The sum of the largest and smallest value in the array\n    \"\"\"\n    if not arr:\n        return None\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Args:\n    input_string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Args:\n    input_string (str): The string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n    \n    Args:\n    input_string (str): The string to be converted to lower case.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n    string (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Args:\n    string (str): The input string to be converted.\n    \n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regex to find all strings enclosed in quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regex to find all matches between quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regular expression to find all matches\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regular expression to find all strings between quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regex to find all strings enclosed in quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regular expression to find all matches\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regex to find all matches between quotation marks\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regular expression to find all matches\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regular expression to find all matches\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regex to find all matches\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotes.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    # Use regex to find all matches of text within quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of extracted values without quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.06172839506173, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Return the numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    num_counts = {}\n    for num in numbers:\n        num_counts[num] = num_counts.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num in numbers if num_count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers\n    that appear only once.\n\n    Args:\n    numbers (list): A list of integers\n\n    Returns:\n    list: A list containing numbers that appear only once in the input list\n    \"\"\"\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Create a list of numbers that appear only once\n    unique_nums = [num for num, count in num_count.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n\n    Args:\n    numbers (list): A list of integers\n\n    Returns:\n    list: A list containing numbers that appear only once in the input list\n    \"\"\"\n    # Count the occurrences of each number\n    num_counts = {}\n    for num in numbers:\n        num_counts[num] = num_counts.get(num, 0) + 1\n    \n    # Return numbers that appear only once\n    return [num for num, count in num_counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n    \n    :param numbers: A list of integers\n    :return: A list of integers that appear only once in the input list\n    \"\"\"\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return only the numbers that appear once.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    list: A list containing only the numbers that appear once in the input list\n    \"\"\"\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return only the numbers that appear once\n    return [num for num in numbers if num_count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Create a dictionary to store the count of each number\n    num_count = {}\n    \n    # Count the occurrences of each number\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n\n    Args:\n    numbers (list): A list of integers\n\n    Returns:\n    list: A list containing numbers that appear only once in the input list\n\n    Example:\n    >>> two_unique_nums([1,2,3,2,3,4,5])\n    [1, 4, 5]\n    \"\"\"\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n\n    # Return a list of numbers that appear only once\n    return [num for num in numbers if num_count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n\n    Args:\n    numbers (list): A list of integers\n\n    Returns:\n    list: A list containing numbers that appear only once in the input list\n\n    Example:\n    >>> two_unique_nums([1,2,3,2,3,4,5])\n    [1, 4, 5]\n    \"\"\"\n    # Count the occurrences of each number\n    num_counts = {}\n    for num in numbers:\n        num_counts[num] = num_counts.get(num, 0) + 1\n\n    # Return numbers that appear only once\n    return [num for num, count in num_counts.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Return the numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    list: A list containing numbers that appear only once in the input list\n    \"\"\"\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return numbers that appear only once\n    return [num for num in numbers if num_count[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in num_count.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    # Count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num, count in count_dict.items() if count == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n\n    Args:\n    numbers (list): A list of integers\n\n    Returns:\n    list: A list containing numbers that appear only once in the input list\n    \"\"\"\n    # Count the occurrences of each number\n    num_counts = {}\n    for num in numbers:\n        num_counts[num] = num_counts.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num in numbers if num_counts[num] == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(numbers):\n    \"\"\"\n    Remove duplicate numbers from a given list and return a list of numbers that appear only once.\n\n    Args:\n    numbers (list): A list of integers.\n\n    Returns:\n    list: A list containing numbers that appear only once in the input list.\n\n    Example:\n    >>> two_unique_nums([1,2,3,2,3,4,5])\n    [1, 4, 5]\n    \"\"\"\n    # Count the occurrences of each number\n    num_count = {}\n    for num in numbers:\n        num_count[num] = num_count.get(num, 0) + 1\n    \n    # Return a list of numbers that appear only once\n    return [num for num in numbers if num_count[num] == 1]", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 70.03174603174602, "dps_norm": 66.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Three lists of equal length to be interleaved.\n    \n    Returns:\n    A single list containing elements from the input lists interleaved.\n    \"\"\"\n    return [item for tuple in zip(list1, list2, list3) for item in tuple]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    list3 (list): The third input list\n    \n    Returns:\n    list: A single flat list with elements from the input lists interleaved\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Three input lists of the same length.\n    \n    Returns:\n    list: A single flat list containing elements from the input lists interleaved.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]\nresult = interleave_lists(list1, list2, list3)", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Three input lists of equal length\n    \n    Returns:\n    list: A single list containing elements from the input lists interleaved\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Three lists of equal length to be interleaved.\n    \n    Returns:\n    A single list containing elements from the input lists interleaved.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]\nresult = interleave_lists(list1, list2, list3)", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Three input lists of equal length.\n    \n    Returns:\n    list: A single list containing elements from the input lists interleaved.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must have the same length.\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    list3 (list): The third input list\n    \n    Returns:\n    list: A single flat list with elements interleaved from the input lists\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Three lists of equal length to be interleaved.\n    \n    Returns:\n    A single list containing elements from the input lists interleaved.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists of the same length\n    \n    Returns:\n    list: A single flat list with elements interleaved from the input lists\n    \"\"\"\n    return [elem for group in zip(list1, list2, list3) for elem in group]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    list3 (list): The third input list\n    \n    Returns:\n    list: A single list containing interleaved elements from the input lists\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must have the same length\")\n    \n    return [elem for triple in zip(list1, list2, list3) for elem in triple]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists of equal length\n    \n    Returns:\n    list: A single list with elements from the input lists interleaved\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must have the same length\")\n    \n    result = []\n    for items in zip(list1, list2, list3):\n        result.extend(items)\n    return result", "matching_cluster_idx": 8}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists to be interleaved\n    \n    Returns:\n    list: A single flat list containing interleaved elements from input lists\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must have the same length\")\n    \n    return [elem for group in zip(list1, list2, list3) for elem in group]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Three input lists of equal length\n    \n    Returns:\n    list: A single list containing elements from the input lists interleaved\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]\nresult = interleave_lists(list1, list2, list3)", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Three input lists of the same length\n    \n    Returns:\n    list: A single flat list containing elements from the input lists interleaved\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists of equal length\n    \n    Returns:\n    list: A single list containing elements from the input lists interleaved\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Three lists of equal length to be interleaved.\n    \n    Returns:\n    A single list containing elements from the input lists interleaved.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]\nresult = interleave_lists(list1, list2, list3)", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first input list\n    list2 (list): The second input list\n    list3 (list): The third input list\n    \n    Returns:\n    list: A single flat list with elements interleaved from the input lists\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3 (list): Input lists of equal length\n    \n    Returns:\n    list: A single list containing elements from the input lists interleaved\n    \"\"\"\n    return [item for group in zip(list1, list2, list3) for item in group]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Three lists of equal length to be interleaved.\n    \n    Returns:\n    A single list containing elements from the input lists interleaved.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1, list2, list3: Three lists of equal length to be interleaved.\n    \n    Returns:\n    A single list containing elements from the input lists interleaved.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All input lists must have the same length\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    \n    return result\nlist1 = [1, 2, 3, 4, 5, 6, 7]\nlist2 = [10, 20, 30, 40, 50, 60, 70]\nlist3 = [100, 200, 300, 400, 500, 600, 700]\nresult = interleave_lists(list1, list2, list3)", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The rearranged list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The resulting list after splitting and rearranging.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: A new list with the first n elements moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split and rearranged.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The rearranged list.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \n    :param arr: The input list to be split\n    :param n: The index at which to split the list\n    :return: The modified list\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: A new list with the first n elements moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list with the first part added to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n    \n    :param arr: The input list to be split\n    :param n: The index at which to split the list\n    :return: The modified list\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    \n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    Args:\n    arr (list): The input list to be split.\n    n (int): The index at which to split the list.\n    \n    Returns:\n    list: The modified list with the first part moved to the end.\n    \"\"\"\n    if n <= 0 or n >= len(arr):\n        return arr\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 12.162162162162161, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the elements from the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    lst (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the elements from the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    lst (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Args:\n    input_list (list): The input list to be converted.\n    \n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Args:\n    input_list (list): The input list to be converted.\n\n    Returns:\n    tuple: A tuple containing the same elements as the input list.\n    \"\"\"\n    return tuple(input_list)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    int: The difference between the largest and smallest value\n    \n    Raises:\n    ValueError: If the input list is empty\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    numbers (list): A list of numbers\n    \n    Returns:\n    int: The difference between the largest and smallest value\n    \n    Raises:\n    ValueError: If the input list is empty\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list cannot be empty\")\n    \n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}, {"solution": "def big_diff(numbers):\n    if not numbers:\n        return 0\n    return max(numbers) - min(numbers)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed words back into a string\n    return \" \".join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    string (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into words\n    words = string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Reverses the order of words in a given string.\n    Words are assumed to be separated by spaces.\n    \n    Args:\n    string (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words\n    words = string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    string (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into words\n    words = string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverse words separated by spaces in a given string.\n    \n    Args:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    words.reverse()\n    \n    # Join the reversed words back into a string\n    return \" \".join(words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Reverses the order of words in a given string.\n    Words are assumed to be separated by spaces.\n    \"\"\"\n    # Split the string into a list of words\n    words = string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Reverses words separated by spaces in a given string.\n    \n    Args:\n    string (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words reversed.\n    \"\"\"\n    # Split the string into words\n    words = string.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    reversed_string = \" \".join(reversed_words)\n    \n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"\n    Reverses the order of words in a given string.\n    Words are assumed to be separated by spaces.\n    \n    Args:\n    s (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words in reverse order.\n    \n    Example:\n    >>> reverse_words(\"python program\")\n    'program python'\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    \"\"\"\n    Reverses the order of words in a given string.\n    \n    Args:\n    sentence (str): The input string containing words separated by spaces.\n    \n    Returns:\n    str: A new string with the words in reverse order.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a sentence\n    reversed_sentence = \" \".join(reversed_words)\n    \n    return reversed_sentence", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed words back into a string\n    return \" \".join(reversed_words)", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Takes a list and returns a new list with the same elements, but the k'th element removed.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to be removed (1-based index)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The position of the element to be removed (1-indexed).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based indexing).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the input list and return the modified list.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to be removed (1-based index)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns a new list.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to be removed (1-based index)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Takes a list and returns a new list with the same elements, but the k'th element removed.\n    \n    :param lst: The input list\n    :param k: The index of the element to be removed (1-based)\n    :return: A new list with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Takes a list and returns a new list with the same elements, but the k'th element removed.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to be removed (1-based index)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list and returns a new list.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to be removed (1-based indexing)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The position of the element to be removed (1-indexed).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Takes a list and returns a new list with the same elements, but the k'th element removed.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to be removed (1-based index)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of bounds\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Takes a list and returns a new list with the same elements,\n    but the k'th element removed.\n    \n    :param lst: Input list\n    :param k: Index of the element to be removed (1-based index)\n    :return: New list with k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]\nk = 3", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the given list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]\nk = 3", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the input list and returns a new list.\n    \n    Args:\n    lst (list): The input list.\n    k (int): The index of the element to be removed (1-based index).\n    \n    Returns:\n    list: A new list with the k'th element removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is out of range\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the given list.\n    \n    Args:\n    lst (list): The input list\n    k (int): The index of the element to remove (1-based)\n    \n    Returns:\n    list: A new list with the k'th element removed\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst.copy()  # Return a copy of the original list if k is invalid\n    \n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/631": {"dps": 55.55555555555554, "dps_norm": 75.0, "pass@1": 19.0, "profiled": [{"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to be processed.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n\n    Args:\n    text (str): The input string\n\n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    text (str): The input string to be processed.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: The processed string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in a given string.\n    \n    Args:\n    text (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    text (str): The input string to be processed.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to process.\n    \n    Returns:\n    str: The processed string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    text (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(text):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    text (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return text.replace(' ', '_').replace('_', ' ', text.count('_'))", "matching_cluster_idx": 5}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    \n    Args:\n    string (str): The input string to process.\n    \n    Returns:\n    str: The processed string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    return string.replace(' ', '_').replace('_', ' ', string.count('_'))", "matching_cluster_idx": 5}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end, preserving the order of non-zero elements.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    \n    # Count the number of zeroes\n    zero_count = len(nums) - len(non_zero)\n    \n    # Append zeroes to the end\n    result = non_zero + [0] * zero_count\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end, maintaining the order of non-zero elements.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end, preserving the order of non-zero elements.\n    \"\"\"\n    # Separate non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    \n    # Count the number of zeroes\n    zero_count = lst.count(0)\n    \n    # Append zeroes to the end\n    result = non_zero + [0] * zero_count\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(numbers):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n    numbers (list): A list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in numbers if num != 0]\n    zeroes = [0] * (len(numbers) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(numbers):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n    numbers (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in numbers if num != 0]\n    zeroes = [num for num in numbers if num == 0]\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(numbers):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n    numbers (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in numbers if num != 0]\n    zeroes = [0] * (len(numbers) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize two pointers\n    non_zero = 0\n    current = 0\n\n    # Traverse the list\n    while current < len(lst):\n        if lst[current] != 0:\n            # Swap non-zero element with the element at non_zero index\n            lst[non_zero], lst[current] = lst[current], lst[non_zero]\n            non_zero += 1\n        current += 1\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    lst (list): The input list containing integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeroes = [x for x in lst if x == 0]\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    Args:\n    nums (list): The input list of integers.\n    \n    Returns:\n    list: A new list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 34.0, "profiled": [{"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The length of the list (not strictly necessary, but included as per the problem statement)\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers in the list\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    :param nums: List of integers\n    :param n: Length of the list\n    :return: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    :param nums: List of integers\n    :param n: Length of the list\n    :return: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): A list of integers\n    n (int): The number of elements in the list (can be omitted as we can use len(nums))\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): A list of integers\n    n (int): The length of the list\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The length of the list (not strictly necessary, but included to match the given function signature)\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): A list of integers\n    n (int): The length of the list\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    :param arr: List of integers\n    :param n: Length of the list\n    :return: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The length of the list\n    \n    Returns:\n    int: The sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The length of the list\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum\nnumbers = [5, 9, 7, 6]\nn = len(numbers)", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    n (int): The length of the list\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): List of integers\n    n (int): Length of the list\n    \n    Returns:\n    int: Sum of XOR of all pairs\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums, n):\n    \"\"\"\n    Calculates the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    nums (list): A list of integers\n    n (int): The length of the list\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers in the list\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(numbers, n):\n    \"\"\"\n    Calculate the sum of XOR of all pairs of numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers.\n    n (int): The number of elements in the list.\n    \n    Returns:\n    int: The sum of XOR of all pairs of numbers.\n    \"\"\"\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += numbers[i] ^ numbers[j]\n    return xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 20.71808510638298, "dps_norm": 50.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the given array.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n    \n    :param arr: The input array\n    :param k: The position up to which the array should be reversed\n    :return: The modified array\n    \"\"\"\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k > len(arr):\n        k = len(arr)\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    left = 0\n    right = k - 1\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the given array.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the given array.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The partially reversed array.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n    \n    :param arr: The input array\n    :param k: The position up to which the array should be reversed\n    :return: The modified array\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    :param arr: The input array\n    :param k: The position up to which the array should be reversed\n    :return: The modified array with elements reversed up to position k\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    left = 0\n    right = k - 1\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    # Check if k is valid\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n    \n    :param arr: The input array to be partially reversed.\n    :param k: The position up to which the array should be reversed.\n    :return: The modified array with elements reversed up to position k.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    left = 0\n    right = k - 1\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n    \n    :param arr: The input array\n    :param k: The position up to which the array should be reversed\n    :return: The modified array\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    left = 0\n    right = k - 1\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position K.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with elements reversed up to position K.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first K elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array up to a given position.\n    \n    :param arr: The input array\n    :param k: The position up to which the array should be reversed\n    :return: The modified array\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    left = 0\n    right = k - 1\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the array.\n    \n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 7}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position.\n\n    Args:\n    arr (list): The input array to be partially reversed.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with elements reversed up to position k.\n    \"\"\"\n    if k <= 0 or k > len(arr):\n        return arr\n    \n    # Reverse the first k elements\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr", "matching_cluster_idx": 6}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple and the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the tuple. The output is a tuple.\n    \n    Args:\n    tup (tuple): The input tuple\n    dictionary (dict): The dictionary to be added to the tuple\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple and the dictionary\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dic):\n    \"\"\"\n    Add a dictionary to the end of a tuple.\n\n    Args:\n    tup (tuple): The input tuple.\n    dic (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary added at the end.\n    \"\"\"\n    return tup + (dic,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The original tuple\n    dictionary (dict): The dictionary to be added\n    \n    Returns:\n    tuple: A new tuple containing all elements of the original tuple and the dictionary\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the tuple.\n    \n    Args:\n    tup (tuple): The input tuple\n    dictionary (dict): The dictionary to be added\n    \n    Returns:\n    tuple: A new tuple with the dictionary added as the last element\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    \n    Args:\n    tup (tuple): The input tuple\n    dictionary (dict): The dictionary to be added to the tuple\n    \n    Returns:\n    tuple: A new tuple with the dictionary added at the end\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the dictionary added as the last element.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to a tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to the tuple. The output is a tuple.\n    \n    Args:\n    tup (tuple): The input tuple\n    dictionary (dict): The dictionary to be added\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple and the dictionary\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, d):\n    \"\"\"\n    Add a dictionary to the tuple. The output is a tuple.\n    \n    Args:\n    tup (tuple): The input tuple\n    d (dict): The dictionary to be added\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple and the dictionary\n    \"\"\"\n    return tup + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    \n    Args:\n    tup (tuple): The input tuple\n    dictionary (dict): The dictionary to be added to the tuple\n    \n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Add a dictionary to a tuple.\n\n    Args:\n    tup (tuple): The input tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple containing all elements of the input tuple followed by the dictionary.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 79.78142076502732, "dps_norm": 78.125, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings containing the extracted values.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    # Use regular expression to find all matches\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    \n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string containing quoted values.\n    \n    Returns:\n    list: A list of strings extracted from between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    Extracts values between quotation marks \" \" of the given string.\n    \n    Args:\n    string (str): The input string to extract values from.\n    \n    Returns:\n    list: A list of strings found between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 5.813953488372094, "dps_norm": 40.0, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef replace_specialchar(text):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    text (str): The input string to process.\n\n    Returns:\n    str: The processed string with spaces, commas, and dots replaced by colons.\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(string):\n    return re.sub(r'[ ,.]', ':', string)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(input_string):\n    return re.sub(r'[ ,.]', ':', input_string)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}]}, "Mbpp/740": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where odd-indexed elements are keys and even-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts a tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple.\n    \n    Returns:\n    dict: A dictionary where odd-indexed elements are keys and even-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where keys are even-indexed elements and values are odd-indexed elements.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where odd-indexed elements are keys and even-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with even number of elements\n    \n    Returns:\n    dict: Dictionary with adjacent elements as key-value pairs\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where keys are odd-indexed elements and values are even-indexed elements.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple\n    \n    Returns:\n    dict: A dictionary with keys and values from adjacent elements in the tuple\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where keys are odd-indexed elements and values are even-indexed elements.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements\n    \n    Returns:\n    dict: A dictionary where odd-indexed elements are keys and even-indexed elements are values\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements\n    \n    Returns:\n    dict: Dictionary with key-value pairs from adjacent elements in the tuple\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where odd-indexed elements are keys and even-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where odd-indexed elements are keys and even-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with even number of elements\n    \n    Returns:\n    dict: Dictionary with keys and values from adjacent elements in the tuple\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): Input tuple with an even number of elements.\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple\n    \n    Returns:\n    dict: A dictionary where even-indexed elements are keys and odd-indexed elements are values\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))", "matching_cluster_idx": 8}]}, "Mbpp/744": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The input tuple to check\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains a None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains a None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains a None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tup (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_none(tuple_input):\n    \"\"\"\n    Check if the given tuple has any None value.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tuple_input", "matching_cluster_idx": 5}]}, "Mbpp/750": {"dps": 52.38095238095238, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the input list and tuple combined.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The input list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements appended\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the tuple added to the end.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the tuple appended.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The original list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements added\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The original list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the tuple elements appended.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The original list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements added\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The input list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the elements of the tuple appended to the original list\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The original list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the tuple added to the end.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The input list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements added\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The original list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements added\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The original list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the tuple added to the end.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The original list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the tuple appended.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the tuple added to the end.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the input list followed by the elements of the input tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The input tuple.\n    \n    Returns:\n    list: A new list with the elements of the input tuple added to the end.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the input list followed by the elements of the input tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The original list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements added to the end\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n    \n    Args:\n    lst (list): The input list.\n    tup (tuple): The tuple to be added to the list.\n    \n    Returns:\n    list: A new list with the elements of the input list followed by the elements of the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Args:\n    lst (list): The original list\n    tup (tuple): The tuple to be added to the list\n    \n    Returns:\n    list: A new list with the tuple elements added to the end\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element (the number)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a list of tuples based on the second element.\n    \n    Args:\n    records (list): A list of tuples where each tuple contains a string and an integer.\n    k (int): The number of minimum records to return.\n    \n    Returns:\n    list: A list of k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the records based on the second element (index 1) of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of each tuple (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k records from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element (the number)\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element (index 1) in ascending order\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 86.81034482758622, "dps_norm": 86.25, "pass@1": 78.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list containing common elements that appear at the same index in all three input lists\n    \"\"\"\n    result = []\n    \n    # Determine the length of the shortest list\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Use enumerate to keep track of the index\n    common_elements = [\n        element for index, element in enumerate(l1)\n        if index < len(l2) and index < len(l3) and element == l2[index] == l3[index]\n    ]\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    return [x for i, (x, y, z) in enumerate(zip(l1, l2, l3)) if x == y == z]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Use enumerate to keep track of the index\n    common_elements = [\n        element\n        for index, (element, elem2, elem3) in enumerate(zip(l1, l2, l3))\n        if element == elem2 == elem3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Use enumerate to keep track of the index\n    common_elements = [\n        elem for index, (elem, elem2, elem3) in enumerate(zip(l1, l2, l3))\n        if elem == elem2 == elem3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3: Input lists\n    \n    Returns:\n    A list containing common elements that appear at the same index in all three lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    return [x for i, (x, y, z) in enumerate(zip(l1, l2, l3)) if x == y == z]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Use enumerate to keep track of the index\n    common_elements = [\n        elem for index, (elem, elem2, elem3) in enumerate(zip(l1, l2, l3))\n        if elem == elem2 == elem3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over the lists simultaneously\n    # Use enumerate to keep track of the index\n    common_elements = [\n        element\n        for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    return [x for i, (x, y, z) in enumerate(zip(l1, l2, l3)) if x == y == z]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list containing common elements at the same index\n    \"\"\"\n    result = []\n    \n    # Iterate through the shortest list to avoid index out of range errors\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list containing common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3: Input lists\n    \n    Returns:\n    A list containing common elements that appear at the same index in all three lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    # List comprehension to create the result list\n    return [elem for idx, (elem, elem2, elem3) in enumerate(zip(l1, l2, l3)) if elem == elem2 == elem3]", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element\n        for index, (element, elem2, elem3) in enumerate(zip(l1, l2, l3))\n        if element == elem2 == elem3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Use enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements that appear at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    common_elements = [\n        element for index, (element, e2, e3) in enumerate(zip(l1, l2, l3))\n        if element == e2 == e3\n    ]\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Find common elements from three lists that appear at the same index.\n    \n    Args:\n    l1, l2, l3 (list): Input lists to compare\n    \n    Returns:\n    list: A list of common elements appearing at the same index in all three input lists\n    \"\"\"\n    # Use zip to iterate over all three lists simultaneously\n    # Enumerate to keep track of the index\n    return [elem for index, (elem, elem2, elem3) in enumerate(zip(l1, l2, l3)) \n            if elem == elem2 == elem3]", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 5.0, "profiled": []}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/758": {"dps": 98.34942084942084, "dps_norm": 88.125, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Dict, Tuple\nfrom collections import Counter\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count the occurrences of sublists within a list.\n\n    Args:\n    lst (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples (converted from sublists)\n                                and values are the number of occurrences.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples (converted from lists) and values are their occurrences.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences using Counter\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 7}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count the occurrences of sublists within a list.\n\n    Args:\n    lst (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where each key is a tuple \n    representation of a sublist, and the value is the count of its occurrences.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n    \n    Args:\n    lst (list): A list containing sublists.\n    \n    Returns:\n    dict: A dictionary where keys are tuples (converted from sublists) and values are their occurrences.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n    \n    Args:\n    lst (list): A list containing sublists.\n    \n    Returns:\n    dict: A dictionary where keys are tuples (converted from sublists) and values are their occurrences.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counts = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counts)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where each sublist is converted to a tuple (key)\n                                and the value is the number of occurrences in the original list.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n    \n    Args:\n    lst (list): A list containing sublists.\n    \n    Returns:\n    dict: A dictionary where keys are tuples (converted from sublists) and values are their occurrences.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Tuple\nfrom collections import Counter\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples (converted from sublists)\n                                and values are the number of occurrences.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Tuple\nfrom collections import Counter\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys\n    and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where each key is a tuple\n    representing a sublist, and the value is the number of occurrences\n    of that sublist in the original list.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Return the counter as a dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where each key is a tuple representation of a sublist,\n                                and the value is the number of occurrences of that sublist.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        count_dict[sublist_tuple] = count_dict.get(sublist_tuple, 0) + 1\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples (converted from lists) and values are their occurrences.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Tuple\nfrom collections import Counter\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys\n    and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples created from\n    sublists and values are the number of occurrences of each sublist.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n    \n    Args:\n    lst (list): A list containing sublists\n    \n    Returns:\n    dict: A dictionary where keys are tuples (converted from sublists) and values are their occurrences\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counts = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counts)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n    \n    :param lst: A list containing sublists\n    :return: A dictionary with tuples as keys and their occurrences as values\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counts = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counts)", "matching_cluster_idx": 6}, {"solution": "from typing import List, Dict, Tuple\nfrom collections import Counter\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys and their occurrences as values.\n\n    Args:\n    lst (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples (converted from sublists)\n                                and values are the number of occurrences.\n\n    Example:\n    >>> unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]])\n    {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count lists within a list and return a dictionary where each sublist is\n    converted to a tuple and the value is the number of its occurrences.\n\n    Args:\n    lst (List[List[int]]): A list of lists containing integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary with tuples as keys and their counts as values.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counts = Counter(tuple(sublist) for sublist in lst)\n    \n    # Return the resulting dictionary\n    return dict(tuple_counts)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    Count lists within a list and return a dictionary with tuples as keys\n    and their occurrences as values.\n    \n    :param lst: A list containing sublists\n    :return: A dictionary with tuples as keys and their counts as values\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    tuple_counter = Counter(tuple(sublist) for sublist in lst)\n    \n    # Convert the Counter object to a regular dictionary\n    return dict(tuple_counter)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int, ...], int]:\n    \"\"\"\n    Count the occurrences of sublists within a list.\n\n    Args:\n    lst (List[List[int]]): A list containing sublists of integers.\n\n    Returns:\n    Dict[Tuple[int, ...], int]: A dictionary where keys are tuples (converted from sublists)\n                                and values are the number of occurrences of each sublist.\n    \"\"\"\n    # Convert each sublist to a tuple and count occurrences\n    return dict(Counter(tuple(sublist) for sublist in lst))", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to get unique elements\n    unique_elements = set(numbers)\n    \n    # If the set has only one element, return True; otherwise, return False\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty, return False\n    if not numbers:\n        return False\n    \n    # Use set() to get unique elements\n    # If the length of the set is 1, there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, it means there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check if a list of numbers contains only one distinct element.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty, return False\n    if not numbers:\n        return False\n    \n    # Use set() to get unique elements, if length is 1, there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty, return False\n    if not numbers:\n        return False\n    \n    # Use set() to get unique elements, if length is 1, there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise\n    \"\"\"\n    # Convert the list to a set to get unique elements\n    unique_set = set(numbers)\n    \n    # If the set has only one element, return True\n    # Otherwise, return False\n    return len(unique_set) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to get unique elements\n    unique_set = set(numbers)\n    \n    # If the set has only one element, return True; otherwise, return False\n    return len(unique_set) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, it means there's only one distinct element\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n    numbers (list): A list of numbers to check.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Use set() to get unique elements, then check if its length is 1\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_set = set(numbers)\n    \n    # If the set has only one element, return True; otherwise, return False\n    return len(unique_set) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    # If the list is empty, return False\n    if not numbers:\n        return False\n    \n    # Use set() to get unique elements. If there's only one, return True\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    numbers (list): A list of numbers to check.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to be analyzed.\n    \n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to count digits from.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n    string (str): The input string to be analyzed.\n\n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to count digits from.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to be analyzed.\n    \n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to count digits in.\n\n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n\n    Args:\n    string (str): The input string to check for digits.\n\n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    string (str): The input string to check for digits.\n    \n    Returns:\n    int: The count of digits in the input string.\n    \"\"\"\n    return sum(1 for char in string if char.isdigit())", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains consecutive items from the input list\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains consecutive items from the input list\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples containing consecutive pairs\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n    \n    Args:\n    lst (list): The input list\n    \n    Returns:\n    list: A list of tuples, where each tuple contains a pair of consecutive items\n    \"\"\"\n    return list(zip(lst[:-1], lst[1:]))", "matching_cluster_idx": 5}]}, "Mbpp/775": {"dps": 72.44, "dps_norm": 53.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers in a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(num % 2 == 1 for i, num in enumerate(lst) if i % 2 == 1)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(numbers[i] % 2 == 1 for i in range(1, len(numbers), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check whether every odd index contains odd numbers in the given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(numbers[i] % 2 == 1 for i in range(1, len(numbers), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(num % 2 == 1 for num in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(numbers[i] % 2 == 1 for i in range(1, len(numbers), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Args:\n    lst (list): The input list of integers\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    return all(lst[i] % 2 == 1 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}]}, "Mbpp/777": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    # Return the sum of the unique numbers\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to store unique elements\n    unique_elements = set(numbers)\n    \n    # Calculate the sum of unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    :param numbers: A list of integers\n    :return: The sum of non-repeated elements\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to store unique elements\n    unique_elements = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to store unique elements\n    unique_elements = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to store unique elements\n    unique_elements = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to store unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Calculate the sum of unique numbers\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Calculate the sum of unique numbers\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to store unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    \"\"\"\n    Find the sum of non-repeated elements in a given list.\n    \n    Args:\n    numbers (list): A list of integers\n    \n    Returns:\n    int: The sum of non-repeated elements in the list\n    \"\"\"\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Calculate the sum of unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to store unique elements\n    unique_elements = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to store unique elements\n    unique_elements = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(numbers):\n    # Use a set to keep only unique elements\n    unique_numbers = set(numbers)\n    \n    # Sum up the unique elements\n    return sum(unique_numbers)", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 60.0, "dps_norm": 56.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(num):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even,\n    False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors is even.\n    \n    Args:\n    n (int): The number to check for divisors\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise\n    \"\"\"\n    # Count the divisors\n    divisor_count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_count += 1\n    \n    # Check if the count is even\n    return divisor_count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even,\n    False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors is even.\n    \n    Args:\n    n (int): The number to check for divisors\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i divides n without a remainder, it's a divisor\n        if n % i == 0:\n            count += 1\n    \n    # Return True if the count is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even,\n    False otherwise.\n    \n    :param n: The number to check for divisors\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is a different divisor, increment count again\n            if i != n // i:\n                count += 1\n    \n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \n    :param n: The number to check for divisors\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \n    :param n: The number to check for divisors\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors for a given number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    \n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \n    :param n: The number to check for divisors\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is a different divisor, increment count\n            if i != n // i:\n                count += 1\n    \n    # Return True if count is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \n    :param n: The number to check for divisors\n    :return: True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Check whether the count of divisors for a given number is even.\n    \n    Args:\n    n (int): The number to check for divisors\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, increment count\n            count += 1\n            # If n/i is a different divisor, increment count again\n            if i != n // i:\n                count += 1\n    \n    # Return True if count is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Counts the number of divisors for a given number and returns True if the count is even,\n    False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors for a given number and return True if the count is even,\n    False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}]}, "Mbpp/800": {"dps": 58.88059701492537, "dps_norm": 81.0, "pass@1": 64.0, "profiled": [{"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    \"\"\"\n    Removes all whitespaces from a given string.\n    \n    Args:\n    string (str): The input string from which to remove whitespaces.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}, {"solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 3}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (List[List[int]]): A list of lists containing integers.\n    \n    Returns:\n    List[int]: The list with the highest sum of elements.\n    \n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return []\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return None\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The list with the highest sum of elements.\n    \n    Example:\n    >>> max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])\n    [10, 11, 12]\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (List[List[int]]): A list containing lists of integers.\n    \n    Returns:\n    List[int]: The list with the highest sum of elements.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (List[List[int]]): A list containing lists of integers.\n\n    Returns:\n    List[int]: The list with the highest sum of elements.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n\n    Returns:\n    list: The list with the highest sum of elements.\n\n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \n    Raises:\n    ValueError: If the input list is empty.\n    \"\"\"\n    if not list_of_lists:\n        raise ValueError(\"Input list cannot be empty\")\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n\n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n\n    Returns:\n    list: The list with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \n    Args:\n    list_of_lists (list): A list containing lists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list with the highest sum of elements from a list of lists.\n    \n    Args:\n    list_of_lists (list): A list containing sublists of numbers.\n    \n    Returns:\n    list: The sublist with the highest sum of elements.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    \n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tup (tuple): The tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check\n    k: The value to search for in the tuple\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tuple_input, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tuple_input (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in tuple_input", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n    \n    Args:\n    tup (tuple): The tuple to check.\n    k: The value to search for in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Args:\n    tup (tuple): The input tuple to check.\n    k: The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
