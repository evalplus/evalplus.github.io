{"date": "2024-11-08 20:59", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 81.65576442357961, "dps_norm": 77.46557596992379, "pass@1": 76.9322033898305}, "eval": {"HumanEval/9": {"dps": 71.07255520504732, "dps_norm": 74.44444444444444, "pass@1": 54.0, "profiled": [{"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if len(numbers) == 0:\n        return []\n\n    result = []\n    current_max = numbers[0]\n    for n in numbers:\n        if n > current_max:\n            current_max = n\n        result.append(current_max)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum\n    element found until given moment in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n\n    \"\"\"\n    max_list = []\n    current_max = numbers[0] if numbers else None\n\n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    for number in numbers:\n        if not result:\n            result.append(number)\n        else:\n            result.append(max(number, result[-1]))\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_so_far = None\n    for num in numbers:\n        if max_so_far is None or num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_num = numbers[0] if numbers else None\n\n    for num in numbers:\n        if num > max_num:\n            max_num = num\n        result.append(max_num)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    result = []\n    max_so_far = numbers[0]\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_val = None\n    for num in numbers:\n        if max_val is None or num > max_val:\n            max_val = num\n        result.append(max_val)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_num = None\n    for num in numbers:\n        if max_num is None or num > max_num:\n            max_num = num\n        result.append(max_num)\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_so_far = float('-inf')\n    \n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    running_max = [numbers[0]]\n    for i in range(1, len(numbers)):\n        running_max.append(max(numbers[i], running_max[-1]))\n    return running_max", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    for number in numbers:\n        if result:\n            result.append(max(result[-1], number))\n        else:\n            result.append(number)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_so_far = float('-inf')\n    for n in numbers:\n        max_so_far = max(max_so_far, n)\n        result.append(max_so_far)\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    return [max(numbers[:i+1]) for i in range(len(numbers))]", "matching_cluster_idx": 2}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    for num in numbers:\n        if len(result) == 0 or num > result[-1]:\n            result.append(num)\n        else:\n            result.append(result[-1])\n    return result", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    result = []\n    max_value = None\n\n    for num in numbers:\n        if max_value is None or num > max_value:\n            max_value = num\n        result.append(max_value)\n\n    return result", "matching_cluster_idx": 7}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n\n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n        \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    # Initialize empty list to store the results\n    max_list = []\n    # Initialize max_num with the smallest possible integer\n    max_num = float('-inf')\n    \n    # Iterate over numbers\n    for num in numbers:\n        # Update max_num if current number is greater\n        max_num = max(max_num, num)\n        # Append the current max_num to the result list\n        max_list.append(max_num)\n\n    # Return the result list\n    return max_list", "matching_cluster_idx": 4}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if len(numbers) == 0:    # handling edge case\n        return []\n    max_list = [numbers[0]]    # initializing output with first element of the input list\n    for num in numbers[1:]:\n        if num > max_list[-1]:    # comparing current number with previous max\n            max_list.append(num)    # if current number is greater, then append it to max_list\n        else:\n            max_list.append(max_list[-1])    # if not, then append the previous max\n    return max_list", "matching_cluster_idx": 6}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers: return []\n\n    max_so_far = numbers[0]\n    result = []\n\n    for number in numbers:\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 4}]}, "HumanEval/0": {"dps": 58.604651162790695, "dps_norm": 65.0, "pass@1": 94.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    numbers.sort()\n    for i in range(len(numbers)-1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort() # We sort the numbers to make comparisons easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i + 1] - numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for idx, num in enumerate(numbers):\n        if idx + 1 == len(numbers):\n            break\n        if abs(numbers[idx+1] - num) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if abs(numbers[i] - numbers[i-1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i+1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport itertools\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Check if input list is not too short\n    if len(numbers) < 2:\n        return False\n    \n    # Loop over all combinations of two numbers in the list\n    for num1, num2 in itertools.combinations(numbers, 2):\n        # If the difference between the two numbers is smaller than the threshold,\n        # return True\n        if abs(num1 - num2) < threshold:\n            return True\n            \n    # If no pairs of numbers in the list are closer to each other than the threshold,\n    # return False\n    return False", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()  # Sort the numbers\n\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)-1):\n        if numbers[i+1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i + 1] - numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    numbers.sort()\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)-1):\n        if abs(numbers[i+1] - numbers[i]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i-1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, num1 in enumerate(numbers[:-1]):\n        for num2 in numbers[i + 1:]:\n            if abs(num1 - num2) < threshold:\n                return True\n    return False", "matching_cluster_idx": 4}, {"solution": "from typing import List\nfrom itertools import combinations\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for x, y in combinations(numbers, 2):\n        if abs(x - y) < threshold:\n            return True\n    return False", "matching_cluster_idx": 5}]}, "HumanEval/4": {"dps": 46.424050632911396, "dps_norm": 76.66666666666667, "pass@1": 95.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return float('nan')  # Return NaN for empty lists\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviation_sum = sum(abs(num - mean) for num in numbers)\n\n    return absolute_deviation_sum / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(number - mean) for number in numbers]\n    return sum(absolute_differences) / len(absolute_differences)", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_diffs = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_diffs) / len(absolute_diffs)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\"\n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    differences = [abs(x - mean) for x in numbers]\n    return sum(differences) / n", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    abs_diffs = [abs(n - mean) for n in numbers]\n    mad = sum(abs_diffs) / len(abs_diffs)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" \n    For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    n = len(numbers)\n    mean = sum(numbers) / n\n    absolute_deviation = sum(abs(x - mean) for x in numbers)\n\n    return absolute_deviation / n", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if len(numbers) == 0:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n\n    return sum(absolute_deviations) / len(absolute_deviations)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(num - mean) for num in numbers) / len(numbers)", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(n - mean) for n in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    mad = sum(abs(num - mean) for num in numbers) / n\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    return sum(absolute_differences) / len(absolute_differences)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_deviation = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviation) / len(absolute_deviation)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    n = len(numbers)\n    mean = sum(numbers) / n\n    absolute_differences = [abs(number - mean) for number in numbers]\n    mad = sum(absolute_differences) / n\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport statistics\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    return statistics.mean(abs(x - statistics.mean(numbers)) for x in numbers)", "matching_cluster_idx": -1}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    deviation = sum(abs(num - mean) for num in numbers) / len(numbers)\n    return deviation", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0\n    numbers_mean = sum(numbers) / len(numbers)\n    differences = [abs(number - numbers_mean) for number in numbers]\n    return sum(differences) / len(numbers)", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport math\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n\n    if len(numbers) == 0:\n        return 0.0\n\n    n = len(numbers)\n    x_mean = sum(numbers) / n\n    mad = sum(math.fabs(x - x_mean) for x in numbers) / n\n\n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    absolute_deviation = [abs(x - mean) for x in numbers]\n\n    return sum(absolute_deviation) / len(numbers)", "matching_cluster_idx": 3}]}, "HumanEval/16": {"dps": 96.74418604651163, "dps_norm": 97.22222222222223, "pass@1": 99.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set()\n    for char in string.lower():\n        distinct_chars.add(char)\n    return len(distinct_chars)", "matching_cluster_idx": 3}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    # set() function is used to remove duplicates from the list\n    distinct_characters = set(string.lower())\n    \n    # return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Using set to get unique characters regardless of case\n    unique_chars = set(string.lower())\n    # Returning the count of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Lowercase the string to ignore case\n    lowercase_string = string.lower()\n\n    # Use a set to automatically remove duplicates and count the distinct characters\n    distinct_characters = set(lowercase_string)\n\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # convert the string to lower case to ignore case distinctions\n    lower_case_string = string.lower()\n    # convert the string to a set to remove duplicate characters\n    distinct_characters_set = set(lower_case_string)\n    # return the number of distinct characters\n    return len(distinct_characters_set)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert string to lowercase\n    lower_string = string.lower()\n    \n    # Convert string to set to remove duplicate characters\n    distinct_chars = set(lower_string)\n    \n    # Return the count of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    lower_string = string.lower()\n    distinct_characters = set(lower_string)\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    unique_chars = set(string.lower())\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    lower_string = string.lower()\n    distinct_characters = set(lower_string)\n    return len(distinct_characters)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 88.15980629539952, "dps_norm": 91.66666666666667, "pass@1": 92.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Initialize min_diff to a large value\n    min_diff = float('inf')\n    closest_elements = (0, 0)\n    \n    # Sort the numbers\n    numbers.sort()\n\n    # Iterate through the sorted list, comparing each pair of elements\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n\n        # If the difference is smaller than the current min_diff, update min_diff and closest_elements\n        if diff < min_diff:\n            min_diff = diff\n            closest_elements = (numbers[i-1], numbers[i])\n\n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest = (0.0, 0.0)\n\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest = (numbers[i], numbers[i+1])\n\n    return closest", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Sort the list\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the minimum difference and closest elements\n    min_diff = float(\"inf\")\n    closest = (0.0, 0.0)\n\n    # Iterate over the sorted list and check for the minimum difference\n    for i in range(1, len(sorted_numbers)):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i - 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest = (sorted_numbers[i - 1], sorted_numbers[i])\n            \n    return closest", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    sorted_numbers = sorted(numbers)\n\n    min_difference = float(\"inf\")\n    result = (None, None)\n\n    for i in range(len(sorted_numbers) - 1):\n        difference = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n\n        if difference < min_difference:\n            min_difference = difference\n            result = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    result = (0, 0)\n    \n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float('inf')\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = float(\"inf\")\n    closest_pair = (None, None)\n    for i in range(len(numbers)-1):\n        diff = abs(numbers[i+1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport math\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers.\")\n        \n    min_diff = math.inf\n    closest_pair = (None, None)\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n                \n    return closest_pair", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    min_diff = float('inf')\n    result = (0, 0)\n\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < min_diff:\n                min_diff = abs(numbers[i] - numbers[j])\n                if numbers[i] < numbers[j]:\n                    result = (numbers[i], numbers[j])\n                else:\n                    result = (numbers[j], numbers[i])\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()  # Sort the list of numbers to easily find the closest pair\n    smallest_diff = float('inf')  # Initialize the smallest difference to a large value\n    closest_pair = (0.0, 0.0)  # Initialize the closest pair to zeros\n\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]  # Calculate the difference between consecutive numbers\n\n        if diff < smallest_diff:\n            smallest_diff = diff  # Update the smallest difference\n            closest_pair = (numbers[i], numbers[i+1])  # Update the closest pair\n\n    return closest_pair  # Return the closest pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    # Check if list contains at least two numbers\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers\")\n\n    # Sort the list of numbers\n    sorted_numbers = sorted(numbers)\n\n    # Initialize variables to track the smallest difference found and the closest pair of numbers\n    min_diff = float('inf')\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n\n    # Compare each pair of adjacent numbers in the sorted list\n    for i in range(1, len(sorted_numbers)):\n        diff = abs(sorted_numbers[i-1] - sorted_numbers[i])\n\n        # If the difference is smaller than the smallest difference found so far,\n        # update the smallest difference and the closest pair of numbers\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i-1], sorted_numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n\n    smallest_difference = float(\"inf\")\n    result = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n\n        if diff < smallest_difference:\n            smallest_difference = diff\n            result = (numbers[i], numbers[i + 1])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    numbers.sort()\n    closest_diff = sys.float_info.max\n    result = None\n    \n    for i in range(1, len(numbers)):\n        diff = abs(numbers[i] - numbers[i-1])\n        if diff < closest_diff:\n            closest_diff = diff\n            result = (numbers[i-1], numbers[i])\n            \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list in ascending order\n    numbers.sort()\n\n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n\n    # Initialize the closest pair\n    closest_pair = (numbers[0], numbers[1])\n\n    # Loop through the list to find the pair with the smallest difference\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    \n    numbers.sort()  # Sort the numbers\n    closest_pair = (numbers[0], numbers[1])  # Initialize with the first two numbers\n    smallest_difference = abs(numbers[1] - numbers[0])  # Calculate the initial difference\n\n    # Iterate over the list to find the pair of closest numbers\n    for i in range(1, len(numbers) - 1):\n        difference = abs(numbers[i+1] - numbers[i])\n        if difference < smallest_difference:\n            smallest_difference = difference\n            closest_pair = (numbers[i], numbers[i+1])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()  # Sort the numbers list in ascending order.\n    min_diff = float('inf')  # Initialize the minimum difference to a large number.\n    res = (0.0, 0.0)  # Initialize the result to (0, 0).\n    \n    # Compare each pair of adjacent numbers to find the pair with the smallest difference.\n    for i in range(len(numbers)-1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            res = (numbers[i], numbers[i+1])\n            \n    return res", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List should contain at least two elements.\")\n    numbers.sort()  # Sort the numbers list in ascending order\n\n    # Initialize the smallest difference and the closest pair\n    smallest_diff = sys.float_info.max\n    closest_pair = (0, 0)\n\n    # Iterate over the list and find the closest pair\n    for i in range(1, len(numbers)):\n        diff = abs(numbers[i] - numbers[i-1])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (numbers[i-1], numbers[i])\n\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    numbers.sort()\n    min_diff = sys.float_info.max\n    result = (None, None)\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i-1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i-1], numbers[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n\n    min_diff = float('inf')\n    res = (None, None)\n\n    for i in range(len(numbers) - 1):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                if numbers[i] < numbers[j]:\n                    res = (numbers[i], numbers[j])\n                else:\n                    res = (numbers[j], numbers[i])\n\n    return res", "matching_cluster_idx": 3}]}, "HumanEval/24": {"dps": 81.66666666666667, "dps_norm": 50.625, "pass@1": 99.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"Input must be greater than 1\")\n        \n    # Start from the largest possible divisor which is n//2 and go down to 1\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    largest = 1\n    for i in range(2, n):\n        if n % i == 0:\n            largest = i\n    return largest", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start from the largest number which is n//2 and going down\n    for i in range(n // 2, 0, -1):\n        # If n is divisible by i, return i as the largest divisor\n        if n % i == 0:\n            return i\n    # If no divisor is found, return 1\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"For a given number n, find the largest number that divides n evenly, smaller than n\n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for divisor in range(n//2, 0, -1):\n        if n % divisor == 0:\n            return divisor", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 2: return None\n\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(21)\n    7\n    >>> largest_divisor(29)\n    1\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(17)\n    1\n    >>> largest_divisor(100)\n    50\n    >>> largest_divisor(49)\n    7\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    i = n // 2\n    while i > 0:\n        if n % i == 0:\n            return i\n        i -= 1", "matching_cluster_idx": 2}, {"solution": "def largest_divisor(n: int) -> int:\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for divisor in range(n // 2, 0, -1):\n        if n % divisor == 0:\n            return divisor", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "matching_cluster_idx": 3}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Examples:\n    >>> largest_divisor(15)\n    5\n    \n    >>> largest_divisor(25)\n    5\n    \"\"\"\n    for divisor in range(n//2, 0, -1):\n        if n % divisor == 0:\n            return divisor\n    return 1", "matching_cluster_idx": 3}]}, "HumanEval/26": {"dps": 63.333333333333336, "dps_norm": 78.75, "pass@1": 59.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    no_duplicates = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            no_duplicates.append(num)\n    return no_duplicates", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counter_dict = {}\n    output_list = []\n    for num in numbers:\n        if num not in counter_dict:\n            counter_dict[num] = 0\n            output_list.append(num)\n        counter_dict[num] += 1\n        if counter_dict[num] > 1 and num in output_list:\n            output_list.remove(num)\n    return output_list", "matching_cluster_idx": 1}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    unique_numbers = []\n    counts = dict()\n    for num in numbers:\n        if num in counts:\n            counts[num] += 1\n        else:\n            counts[num] = 1\n    for num in numbers:\n        if counts[num] == 1:\n            unique_numbers.append(num)\n    return unique_numbers", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    no_duplicates = []\n\n    for number in numbers:\n        if number not in seen:\n            no_duplicates.append(number)\n            seen.add(number)\n        else:\n            # remove from no_duplicates if it already exists\n            no_duplicates = [x for x in no_duplicates if x != number]\n\n    return no_duplicates", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        if number in counts:\n            counts[number] += 1\n        else:\n            counts[number] = 1\n    return [number for number in numbers if counts[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    frequency = {}\n    result = []\n    \n    for num in numbers:\n        if num not in frequency:\n            frequency[num] = 1\n            result.append(num)\n        elif frequency[num] == 1:\n            frequency[num] += 1\n            result.remove(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 1\n            result.append(num)\n        else:\n            counts[num] += 1\n            if counts[num] == 2:\n                result.remove(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\nfrom collections import OrderedDict\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use OrderedDict to keep the original order and count duplicates\n    unique_numbers = OrderedDict()\n\n    for num in numbers:\n        if num in unique_numbers:\n            unique_numbers[num] += 1\n        else:\n            unique_numbers[num] = 1\n\n    # Return only those numbers that appear once\n    return [k for k, v in unique_numbers.items() if v == 1]", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 1\n        else:\n            counts[number] += 1\n    result = []\n    for number in numbers:\n        if counts[number] == 1:\n            result.append(number)\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    return [num for num in numbers if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_map = {}\n    result = []\n    for num in numbers:\n        if num not in count_map:\n            count_map[num] = 1\n            result.append(num)\n        else:\n            count_map[num] += 1\n            if count_map[num] > 1 and num in result:\n                result.remove(num)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \n    >>> remove_duplicates([1, 2, 2, 3, 3, 3])\n    []\n    \"\"\"\n    from collections import Counter\n    counts = Counter(numbers)\n    return [num for num in numbers if counts[num] <= 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n    for number in numbers:\n        if number not in counts:\n            counts[number] = 1\n            result.append(number)\n        else:\n            counts[number] += 1\n            if counts[number] == 2:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary where keys are the numbers in the list and values are their counts\n    counts = {}\n    for number in numbers:\n        if number in counts:\n            counts[number] += 1\n        else:\n            counts[number] = 1\n    \n    # Return a list of numbers that only occurred once, maintaining the original order\n    return [number for number in numbers if counts[number] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    count_dict = {}\n    for i in numbers:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    res = []\n    for i in numbers:\n        if count_dict[i] == 1:\n            res.append(i)\n    return res", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    result = []\n\n    for num in numbers:\n        if num not in counts:\n            counts[num] = 0\n            result.append(num)\n        counts[num] += 1\n\n    return [num for num in result if counts[num] == 1]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n\n    counts = {}\n    result = []\n\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n        if counts[num] == 1:\n            result.append(num)\n        elif counts[num] == 2:\n            result.remove(num)\n\n    return result", "matching_cluster_idx": 2}]}, "HumanEval/31": {"dps": 79.62025316455696, "dps_norm": 81.25, "pass@1": 98.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n == 2:\n        return True\n    elif n % 2 == 0:\n        return False\n    else:\n        for current in range(3, int(n ** 0.5) + 1, 2):\n            if n % current == 0:\n                return False\n        return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return True if a given number is prime, and False otherwise.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"\n    Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n%2 == 0 or n%3 == 0:\n        return False\n    i = 5\n    while i*i <= n:\n        if n%i == 0 or n%(i+2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return False\n    return all(n % i for i in range(3, int(n**0.5) + 1, 2))", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return False\n    return all(n % i for i in range(3, int(n**0.5) + 1, 2))", "matching_cluster_idx": 5}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n\n    if n <= 3:\n        return True\n\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 74.24768518518519, "dps_norm": 79.54545454545455, "pass@1": 82.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Separate the values at the indices divisible by three\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_elements.sort()\n\n    # Replace the elements at the indices divisible by three in original list\n    result = l[:]\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = third_elements.pop(0)\n\n    return result", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    div_by_three = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    div_by_three_iter = iter(div_by_three)\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(next(div_by_three_iter))\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Get elements at indices divisible by 3\n    third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Place sorted elements back into the list at appropriate positions\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = third_elements[third_index]\n            third_index += 1\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    indices_divisible_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    vals_at_indices = [l[i] for i in indices_divisible_by_three]\n    vals_at_indices.sort()\n\n    for i, val in zip(indices_divisible_by_three, vals_at_indices):\n        l[i] = val\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three\n    third_values = sorted(l[i] for i in range(0, len(l), 3))\n    \n    # Replace elements at indices divisible by three with sorted elements\n    for i, j in enumerate(range(0, len(l), 3)):\n        l[j] = third_values[i]\n        \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract values at indices divisible by three\n    third_vals = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted values\n    third_vals.sort()\n\n    # Replace original list at indices divisible by three with sorted values\n    l_prime = l.copy()\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime[i] = third_vals[j]\n            j += 1\n\n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract values at positions divisible by three\n    thirds = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted values\n    thirds.sort()\n    # Replace the corresponding positions in the list with the sorted values\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = thirds.pop(0)\n    return l", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    sorted_vals = sorted([l[i] for i in range(0, len(l), 3)])\n    result = []\n    sorted_index = 0\n    for index in range(len(l)):\n        if index % 3 == 0:\n            result.append(sorted_vals[sorted_index])\n            sorted_index += 1\n        else:\n            result.append(l[index])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract values at indices divisible by three and sort them\n    third_elements = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Create the output list\n    output_list = l.copy()\n    \n    # Update the output list with sorted values at indices divisible by three\n    index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            output_list[i] = third_elements[index]\n            index += 1\n    \n    return output_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extracting elements at positions divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sorting the extracted elements\n    third_elements.sort()\n\n    # Replacing the elements at positions divisible by 3 with sorted elements\n    result = []\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(third_elements[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract elements at the indices divisible by 3\n    thirds = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    thirds.sort()\n    \n    # Update the list by replacing elements at the indices divisible by 3 with sorted elements\n    third_count = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = thirds[third_count]\n            third_count += 1\n            \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_vals = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    result = []\n    third_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(third_vals[third_index])\n            third_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    # Extract elements at indices divisible by 3\n    third_elements = sorted(l[i] for i in range(len(l)) if i % 3 == 0)\n    \n    # Reconstruct the list with sorted third elements\n    l_prime = []\n    index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(third_elements[index])\n            index += 1\n        else:\n            l_prime.append(l[i])\n            \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n    # Identify the elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the identified elements\n    third_elements.sort()\n\n    # Replace the elements at indices divisible by 3 in the original list\n    for i, value in zip(range(0, len(l), 3), third_elements):\n        l[i] = value\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    third_list = [l[i] for i in range(len(l)) if i % 3 == 0]\n    third_list.sort()\n    return [third_list.pop(0) if i % 3 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    # Extract the numbers at indices divisible by 3\n    indices_divisible_by_three = [i for i in range(len(l)) if i % 3 == 0]\n    values_at_indices = [l[i] for i in indices_divisible_by_three]\n\n    # Sort the extracted values\n    values_at_indices.sort()\n\n    # Put the sorted values back into the list\n    for i, value in zip(indices_divisible_by_three, values_at_indices):\n        l[i] = value\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    \n    # Extract the values at the indices divisible by 3\n    divisible_by_3 = [l[i] for i in range(len(l)) if i % 3 == 0]\n    # Sort the extracted values\n    sorted_values = sorted(divisible_by_3)\n    # Replace the values at the indices divisible by 3 in the original list with the sorted values\n    sorted_list = l[:]\n    for i in range(len(sorted_values)):\n        sorted_list[i * 3] = sorted_values[i]\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n\n    # Find the elements at indices divisible by 3\n    third_elements = [l[i] for i in range(len(l)) if i % 3 == 0]\n\n    # Sort the elements at indices divisible by 3\n    third_elements.sort()\n\n    # Replace the elements at indices divisible by 3 in list l\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = third_elements.pop(0)\n\n    return l", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are\n    equal to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    thirds = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    return [val if i % 3 != 0 else thirds.pop(0) for i, val in enumerate(l)]", "matching_cluster_idx": 7}, {"solution": "def sort_third(l: list):\n    # Extract elements at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort the extracted elements\n    third_elements.sort()\n    \n    # Replace elements at indices divisible by 3 with sorted ones\n    sorted_l = [third_elements.pop(0) if idx%3 == 0 else l[idx] for idx in range(len(l))]\n    \n    return sorted_l", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 95.47169811320755, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(list(set(l)))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list) -> list:\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # convert list to set to remove duplicates\n    unique_set = set(l)\n    # convert set to list and sort\n    unique_list = sorted(list(unique_set))\n    return unique_list", "matching_cluster_idx": 3}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    unique_elements = list(set(l))\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_list = list(set(l))\n    unique_list.sort()\n    return unique_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    unique_elements = list(set(l))\n    unique_elements.sort()\n    return unique_elements", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 92.74193548387096, "dps_norm": 70.71428571428572, "pass@1": 91.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for num in range(1, n):\n        if num % 11 == 0 or num % 13 == 0:\n            count += str(num).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n \n    which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def count_sevens(num: int):\n        return str(num).count('7')\n\n    sevens_counter = 0\n    for num in range(n):\n        if num % 11 == 0 or num % 13 == 0:\n            sevens_counter += count_sevens(num)\n    return sevens_counter", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    # Initialize a counter for the number of occurrences of the digit 7\n    count = 0\n\n    # Iterate through all integers less than n\n    for i in range(1, n):\n        # Check if the current number is divisible by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Count the number of times the digit 7 appears in the current number\n            count += str(i).count('7')\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def count_sevens(num: int) -> int:\n        \"\"\"Helper function to count occurrences of digit 7 in a given number.\"\"\"\n        return str(num).count('7')\n\n    # Initialize the count to 0\n    count = 0\n    # Iterate over the range from 1 to n\n    for i in range(1, n):\n        # Check divisibility by 11 or 13\n        if i % 11 == 0 or i % 13 == 0:\n            # Count the occurrences of digit 7\n            count += count_sevens(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count(\"7\")\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\n    Examples:\n\n        >>> fizz_buzz(50)\n        0\n\n        >>> fizz_buzz(78)\n        2\n\n        >>> fizz_buzz(79)\n        3\n    \"\"\"\n\n    def count_sevens(num):\n        \"\"\"Helper function to count the number of times the digit 7 appears in a given integer.\"\"\"\n        count = 0\n        while num > 0:\n            if num % 10 == 7:\n                count += 1\n            num //= 10\n        return count\n\n    total_sevens = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            total_sevens += count_sevens(i)\n\n    return total_sevens", "matching_cluster_idx": 3}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    Example:\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 90.67103109656301, "dps_norm": 90.0, "pass@1": 96.0, "profiled": [{"solution": "def sort_even(l: list):\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    even_indices.sort()\n    \n    sorted_l = l[:]\n    for i, val in enumerate(even_indices):\n        sorted_l[2*i] = val\n        \n    return sorted_l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    even_indices = sorted([l[i] for i in range(0, len(l), 2)])\n    return_list = []\n    even_index = 0\n\n    for i in range(len(l)):\n        if i % 2 == 0:\n            return_list.append(even_indices[even_index])\n            even_index += 1\n        else:\n            return_list.append(l[i])\n    return return_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # create a new list with only the even indexed elements of the original list\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    even_elements.sort()\n\n    # replace the even indexed elements of the original list with the sorted list\n    for i, value in enumerate(even_elements):\n        l[2 * i] = value\n\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    l[::2] = sorted(l[::2])\n    return l", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = sorted(l[::2])\n    result = []\n    even_index = 0\n\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(evens[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even indices from the list and sort them.\n    even_values = sorted(l[::2])\n\n    # Create a new list with the same length as the original one.\n    sorted_list = [even_values.pop(0) if index % 2 == 0 else l[index] for index in range(len(l))]\n\n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_vals = sorted(l[i] for i in range(0, len(l), 2))\n    for i in range(0, len(l), 2):\n        l[i] = even_vals.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_indices = sorted([l[i] for i in range(0, len(l), 2)])\n    for i, value in enumerate(even_indices):\n        l[2*i] = value\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = sorted([l[i] for i in range(0, len(l), 2)])\n    return [evens.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract elements at even indices and sort them\n    even_elements = sorted(l[::2])\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Initialize a counter for the sorted even elements\n    even_index = 0\n\n    # Iterate through the original list\n    for i in range(len(l)):\n        # If the index is even, take the next sorted element\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        # If the index is odd, take the original element\n        else:\n            result.append(l[i])\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    evens = sorted(l[i] for i in range(len(l)) if i % 2 == 0)\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l[i] = evens.pop(0)\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract even-indexed elements and sort them\n    even_indices_sorted = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Generate a list with sorted even-indexed elements and original odd-indexed elements\n    return [even_indices_sorted.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    even_indices.sort()\n    \n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    even_indices.sort()\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    # Extract the even-indexed elements from the list and sort them\n    even_indexed = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Reconstruct the list with sorted even-indexed elements and original odd-indexed elements\n    for i in range(0, len(l), 2):\n        l[i] = even_indexed.pop(0)\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    even_vals = sorted([v for i, v in enumerate(l) if i % 2 == 0])\n    return [even_vals.pop(0) if i % 2 == 0 else v for i, v in enumerate(l)]", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Store the even indices in a separate list\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n\n    # Sort the list of elements at even indices\n    even_indices.sort()\n\n    # Replace the elements at even indices with the sorted values\n    for i, val in zip(range(0, len(l), 2), even_indices):\n        l[i] = val\n\n    # Return the modified list\n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l):\n    \"\"\" This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices\n    are equal to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extracting the even indices' elements from the list\n    even_indices_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Replacing the even indices in the original list with the sorted elements\n    for i in range(0, len(l), 2):\n        l[i] = even_indices_elements.pop(0)\n        \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Initialize an empty list to hold the sorted even-indexed elements\n    sorted_even = []\n\n    # Iterate over the even indices of the input list\n    for i in range(0, len(l), 2):\n        # Append the element at the current even index to the sorted_even list\n        sorted_even.append(l[i])\n\n    # Sort the sorted_even list\n    sorted_even.sort()\n\n    # Create an output list initialized with the sorted_even list\n    output = sorted_even.copy()\n\n    # Iterate over the odd indices of the input list\n    for i in range(1, len(l), 2):\n        # Append the element at the current odd index to the output list\n        output.insert(i, l[i])\n\n    return output", "matching_cluster_idx": 7}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    even_indicies = sorted(l[::2])  # getting values at the even indices and sorting them\n    res = [even_indicies.pop(0) if i%2==0 else l[i] for i in range(len(l))]\n    return res", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 90.82352941176471, "dps_norm": 97.0, "pass@1": 40.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    mod_pow_cache = {0: 1}\n    def mod_pow(n: int) -> int:\n        if n in mod_pow_cache:\n            return mod_pow_cache[n]\n        else:\n            half_pow = mod_pow(n // 2)\n            if n % 2 == 0:\n                mod_pow_cache[n] = (half_pow * half_pow) % p\n            else:\n                mod_pow_cache[n] = (half_pow * half_pow * 2) % p\n            return mod_pow_cache[n]\n    return mod_pow(n) % p", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (2**n) % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n == 0:\n        return 1 % p\n\n    # Calculate 2 to the power of n modulo p\n    mod_result = pow(2, n, p)\n    return mod_result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Calculate 2 to the power of n\n    power_of_2 = 2 ** n\n\n    # Calculate the remainder of the division by p\n    result = power_of_2 % p\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Limit n to avoid overflow\n    n %= 2**32\n    \n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \"\"\"\n    x = 2**n\n    return x % p", "matching_cluster_idx": 3}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p, handling numeric issues.\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    res = pow(2, n, p)\n    return res", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 92.41545893719807, "dps_norm": 73.125, "pass@1": 99.0, "profiled": [{"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    no_vowels_text = \"\"\n    \n    for char in text:\n        if char not in vowels:\n            no_vowels_text += char\n            \n    return no_vowels_text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    text_without_vowels = ''\n    lines = text.split('\\n')\n    for line in lines:\n        new_line = ''\n        for char in line:\n            if char not in vowels:\n                new_line += char\n        text_without_vowels += new_line + '\\n'\n    return text_without_vowels[:-1] if text_without_vowels else ''", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    result = ''\n    for letter in text:\n        if letter not in vowels:\n            result += letter\n    return result", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    text_without_vowels = \"\"\n    for character in text:\n        if character not in vowels:\n            text_without_vowels += character\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    new_text = ''\n    for char in text:\n        if char not in vowels:\n            new_text += char\n    return new_text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    return ''.join([char for char in text if char.lower() not in 'aeiou'])", "matching_cluster_idx": 2}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([i for i in text if i not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    no_vowels_text = \"\".join([char for char in text if char not in vowels])\n    return no_vowels_text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    no_vowels_text = ''.join([c for c in text if c not in vowels])\n    return no_vowels_text", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    text_without_vowels = \"\"\n    for char in text:\n        if char not in vowels:\n            text_without_vowels += char\n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    text_without_vowels = \"\"\n    \n    for char in text:\n        if char not in vowels:\n            text_without_vowels += char\n    \n    return text_without_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    no_vowels = ''\n    for char in text:\n        if char not in vowels:\n            no_vowels += char\n    return no_vowels", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    vowels = 'aeiouAEIOU'\n    result = ''\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 62.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create sets of characters for both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    # Return True if the sets are equal, otherwise False\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(set(s0)) == sorted(set(s1))", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    s0_set = set(s0)\n    s1_set = set(s1)\n    return s0_set == s1_set", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert the strings to sorted sets of characters\n    set0 = sorted(set(s0))\n    set1 = sorted(set(s1))\n\n    # Compare the sets\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    set_0 = set(s0)\n    set_1 = set(s1)\n    return set_0.issubset(set_1) and set_1.issubset(set_0)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    set0 = set(s0)\n    set1 = set(s1)\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 93.64173228346456, "dps_norm": 85.83333333333333, "pass@1": 99.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = list(set(l1) & set(l2))  # Finds the common elements between two lists\n    common_elements.sort()  # Sort the common elements\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    common_list = sorted(set(l1).intersection(l2))\n    return common_list", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    return sorted(set1 & set2)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1).intersection(l2))", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common_elements = list(set(l1) & set(l2))\n    common_elements.sort()\n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    common_elements = set(l1) & set(l2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n\n    # Use set operations to find the common elements\n    common_set = set(l1) & set(l2)\n\n    # Convert the set back to a list and sort it\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Find common elements\n    common_list = list(set(l1) & set(l2))\n    \n    # Sort the common elements\n    sorted_common_list = sorted(common_list)\n    \n    return sorted_common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n\n    return sorted(set1.intersection(set2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    common_set = set(l1).intersection(l2)  # Find the common elements in two lists.\n    return sorted(common_set)  # Sort the common elements.", "matching_cluster_idx": 5}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # converting lists to sets for efficient lookup\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # finding intersection of the two sets\n    common_elements = list(set1 & set2)\n    \n    # sorting the common elements\n    common_elements.sort()\n    \n    return common_elements", "matching_cluster_idx": 4}, {"solution": "def common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Find the common elements\n    common_elements = set(l1).intersection(set(l2))\n\n    # Return the sorted list of unique common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common_list = sorted(set(l1) & set(l2))  # Find the common elements\n    return common_list", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Compute common items and remove duplicates\n    common_set = set(l1).intersection(set(l2))\n\n    # Sort the common items and convert to list\n    return sorted(list(common_set))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Using set intersection to find common elements, then convert to list and sort\n    return sorted(list(set(l1) & set(l2)))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 90.79861111111111, "dps_norm": 95.0, "pass@1": 83.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    \n    # While the factor is less than or equal to the square root of n\n    while n > 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start from the smallest prime number\n    i = 2\n    \n    # While i * i <= n\n    while i * i <= n:\n        # If n is not divisible by i, increment i\n        if n % i:\n            i += 1\n        # If n is divisible by i, divide n by i\n        else:\n            n //= i\n    # Return the largest prime factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Initialize the largest_prime variable to None\n    largest_prime = None\n\n    # Divide n by 2 until n is odd\n    while n % 2 == 0:\n        largest_prime = 2\n        n = n / 2\n\n    # n must be odd now, so find an odd factor\n    for i in range(3, int(n**0.5)+1, 2):\n        while n % i == 0:\n            largest_prime = i\n            n = n / i\n\n    # If n is still a prime number and larger than 2\n    if n > 2:\n        largest_prime = n\n\n    return int(largest_prime)", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start from the smallest prime number\n    i = 2\n    # While the square of i is less than or equal to n\n    while i * i <= n:\n        # If n is divisible by i\n        if n % i:\n            # Increment i\n            i += 1\n        else:\n            # Otherwise, divide n by i\n            n //= i\n    # Return the largest prime factor\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start from the smallest prime number\n    i = 2\n    # Iterate until the square of the current number is less than or equal to n\n    while i * i <= n:\n        if n % i:  # if i is not a factor of n\n            i += 1  # increment by 1\n        else:\n            n //= i  # divide n by i until it's no longer possible\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    >>> largest_prime_factor(13195)\n    29\n    \n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n if n > 1 else i", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(n):\n        \"\"\"Yield the prime factors of n.\"\"\"\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0 and is_prime(i):\n                yield i\n            if n % i == 0 and is_prime(n // i):\n                yield n // i\n\n    return max(prime_factors(n))", "matching_cluster_idx": 6}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Using trial division algorithm\n    largest_factor = -1\n    for i in range(2, n+1):\n        while n % i == 0:\n            largest_factor = i\n            n /= i\n    return largest_factor", "matching_cluster_idx": 1}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start from the smallest prime number\n    i = 2\n    while i * i <= n:\n        # If n is divisible by i, it means i is a factor of n\n        if n % i:\n            # increment the number if not a factor\n            i += 1\n        else:\n            # update n to be the quotient of n divided by i\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n.\n    Assume n > 1 and is not a prime.\n\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n\n    Complexity: O(sqrt(n)) due to the loop that goes up to the square root of n.\n    The loop checks divisibility only up to the square root of n, because a larger\n    factor of n would be a multiple of smaller factor that has already been checked.\n\n    :param n: number to find the largest prime factor for\n    :return: largest prime factor\n    \"\"\"\n    largest_factor = 2\n    while n % 2 == 0:\n        n //= 2\n\n    factor = 3\n    max_factor = int(n**0.5)\n    while factor <= max_factor:\n        if n % factor:\n            factor += 2\n        else:\n            n //= factor\n            largest_factor = factor\n            max_factor = int(n**0.5)\n    if n > 1:\n        largest_factor = n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    def factor(n, start):\n        for i in range(start, int(n**0.5) + 1):\n            if n % i == 0:\n                return n // i, False\n        return n, True\n\n    largest_prime = None\n    while not largest_prime:\n        n, is_prime = factor(n, start=2 if largest_prime is None else largest_prime)\n        if is_prime:\n            largest_prime = n\n\n    return largest_prime", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Start from the smallest prime number\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 69.61038961038962, "dps_norm": 56.25, "pass@1": 32.0, "profiled": [{"solution": "def vowels_count(s):\n    count = 0\n    s = s.lower()\n    \n    for char in s:\n        if char in 'aeiou':\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        elif s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def vowels_count(s):\n    s = s.lower() # Make the string case-insensitive\n    vowels = \"aeiou\"\n    count = sum(1 for char in s if char in vowels)\n    \n    if s.endswith('y'): # Check if the string ends with 'y'\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    count = 0\n    for i, char in enumerate(s):\n        if char.lower() in 'aeiou':\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = \"aeiou\"\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    for char in s.lower():\n        if char in vowels:\n            count += 1\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = sum(s.lower().count(v) for v in vowels)\n    \n    # Check if 'y' is at the end of the word and add 1 to the count if true\n    if s.lower().endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = \"aeiou\"\n    count = sum(1 for char in s if char in vowels)\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        if s[i].lower() == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def vowels_count(s):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = sum(1 for char in s.lower() if char in vowels)\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i].lower() == 'y':\n            count += 1\n    return count", "matching_cluster_idx": 0}, {"solution": "def vowels_count(s):\n    vowel_count = 0\n    for i in range(len(s)):\n        if s[i].lower() in ['a', 'e', 'i', 'o', 'u']:\n            vowel_count += 1\n        elif s[i].lower() == 'y' and i == len(s)-1:\n            vowel_count += 1\n    return vowel_count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in 'aeiou':\n            count += 1\n        elif s[i] == 'y' and i == len(s) - 1:\n            count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = sum(s.lower().count(v) for v in vowels)\n    if s.lower().endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n\n    vowels = 'aeiou'\n\n    count = sum(s.lower().count(v) for v in vowels)\n    if s.lower().endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    s = s.lower()\n    vowels = \"aeiou\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"\n    Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum([s.count(v) for v in vowels])\n    \n    if s.endswith(\"y\"):\n        count += 1\n    \n    return count", "matching_cluster_idx": 6}, {"solution": "def vowels_count(s):\n    count = 0\n    vowels = 'aeiou'\n    s = s.lower()\n    \n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if s[i] == 'y' and i == len(s) - 1:\n            count += 1\n            \n    return count", "matching_cluster_idx": 2}, {"solution": "def vowels_count(s):\n    vowels = set(\"aeiou\")\n    count = sum(1 for letter in s.lower() if letter in vowels)\n    if s.lower().endswith(\"y\"):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    vowels = \"aeiou\"\n    count = sum(1 for char in s.lower() if char in vowels)\n    \n    if s.lower().endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 93.5, "dps_norm": 88.33333333333333, "pass@1": 84.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Count the total number of characters in each list\n    count1 = sum(len(s) for s in lst1)\n    count2 = sum(len(s) for s in lst2)\n\n    # Return the list with the lesser total character count\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum1 = sum(len(s) for s in lst1)\n    sum2 = sum(len(s) for s in lst2)\n    return lst1 if sum1 <= sum2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    len1, len2 = sum(len(x) for x in lst1), sum(len(x) for x in lst2)\n    return lst1 if len1 <= len2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    count1 = sum(len(word) for word in lst1)\n    count2 = sum(len(word) for word in lst2)\n\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    if sum(len(s) for s in lst1) <= sum(len(s) for s in lst2):\n        return lst1\n    return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # calculate total chars for each list\n    lst1_chars = sum(len(word) for word in lst1)\n    lst2_chars = sum(len(word) for word in lst2)\n    \n    # return the list with less total characters\n    if lst1_chars <= lst2_chars:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    len_lst1 = sum(len(x) for x in lst1)\n    len_lst2 = sum(len(x) for x in lst2)\n    if len_lst1 <= len_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    sum1 = sum(len(word) for word in lst1)\n    sum2 = sum(len(word) for word in lst2)\n    return lst1 if sum1 <= sum2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    sum_lst1 = sum(len(s) for s in lst1)\n    sum_lst2 = sum(len(s) for s in lst2)\n    return lst2 if sum_lst2 < sum_lst1 else lst1", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        total_chars = 0\n        for string in lst:\n            total_chars += len(string)\n        return total_chars\n\n    total_chars_lst1 = count_chars(lst1)\n    total_chars_lst2 = count_chars(lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 6}, {"solution": "def total_match(lst1, lst2):\n    def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1, count2 = count_chars(lst1), count_chars(lst2)\n\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Count total number of characters in lst1\n    lst1_count = sum(len(word) for word in lst1)\n    # Count total number of characters in lst2\n    lst2_count = sum(len(word) for word in lst2)\n\n    # Return lst1 if it has less or equal number of chars, else return lst2\n    return lst1 if lst1_count <= lst2_count else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Get the total number of characters in each list\n    total_chars_lst1 = sum(len(word) for word in lst1)\n    total_chars_lst2 = sum(len(word) for word in lst2)\n    \n    # Return the list with fewer total characters, or lst1 if they are equal\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate total number of characters in both lists\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or the first list if they are equal\n    return lst1 if total_chars_lst1 <= total_chars_lst2 else lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 84.33168316831683, "dps_norm": 50.833333333333336, "pass@1": 95.0, "profiled": [{"solution": "def add(lst):\n    sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to zero\n    total = 0\n\n    # Iterate over the list, with indices\n    for i in range(len(lst)):\n        # If the index is odd and the number is even, add it to the total\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(el for i, el in enumerate(lst) if i % 2 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(el for i, el in enumerate(lst) if i % 2 != 0 and el % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # start from index 1 and step by 2\n        if lst[i] % 2 == 0:  # check if the number is even\n            total += lst[i]\n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(num for idx, num in enumerate(lst) if idx % 2 != 0 and num % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, this function adds the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize sum as 0\n    total = 0\n    \n    # Loop through the list, skipping every second element starting from the second one\n    for i in range(1, len(lst), 2):\n        # Check if the element is even\n        if lst[i] % 2 == 0:\n            total += lst[i]\n            \n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(i for idx, i in enumerate(lst) if idx % 2 != 0 and i % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(lst[i] for i in range(len(lst)) if i%2 != 0 and lst[i]%2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 90.64625850340136, "dps_norm": 94.0, "pass@1": 58.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    The function takes a string and returns an ordered version of it.\n    The ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    The order of words and blank spaces in the sentence are preserved.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def anti_shuffle_word(w):\n        \"\"\"\n        Inner function to anti-shuffle single words.\n        \"\"\"\n        return ''.join(sorted(w))\n\n    words = s.split(' ')\n    ordered_words = [anti_shuffle_word(word) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    for i in range(len(words)):\n        words[i] = sort_word(words[i])\n    return ' '.join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    def order_chars(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    ordered_words = [order_chars(word) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    if isinstance(s, str):\n        words = s.split(' ')\n        new_words = [''.join(sorted(word)) for word in words]\n        anti_shuffled = ' '.join(new_words)\n        return anti_shuffled\n    else:\n        raise TypeError(\"Input must be a string\")", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_chars(word):\n        \"\"\"\n        Return a string with the characters sorted based on ASCII value.\n        \"\"\"\n        return \"\".join(sorted(word))\n\n    words = s.split(\" \")\n    for i in range(len(words)):\n        words[i] = sort_chars(words[i])\n    return \" \".join(words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it. \n    The ordered version of a string is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in \n    ascending order based on their ASCII value. \n    The words and blank spaces in the sentence are kept in their original order.\n    \"\"\"\n    \n    words = s.split(' ')\n    result = []\n    for word in words:\n        result.append(''.join(sorted(word)))\n    return ' '.join(result)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    words = s.split(' ')\n    ordered_words = [''.join(sorted(word)) for word in words]\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def ordered_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    ordered_words = [ordered_word(word) for word in words]\n\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join(''.join(sorted(word.replace(' ', ''))) for word in s.split(' '))", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n\n    # Split the string into words\n    words = s.split(' ')\n\n    # Initialize an empty list to store the ordered words\n    ordered_words = []\n\n    for word in words:\n        # Convert each word into a list of characters\n        chars = list(word)\n        # Sort the characters in ascending order based on ascii value\n        chars.sort()\n        # Join the sorted characters back into a string\n        ordered_word = ''.join(chars)\n        ordered_words.append(ordered_word)\n\n    # Join the ordered words back into a string with spaces\n    result = ' '.join(ordered_words)\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    This function takes a string as an input and returns the ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    if not s:\n        return s\n    \n    # Splitting the sentence into words\n    words = s.split(' ')\n    \n    # Ordering the characters in each word\n    ordered_words = [\"\".join(sorted(word)) for word in words]\n    \n    # Joining the ordered words into a sentence\n    ordered_sentence = \" \".join(ordered_words)\n    \n    return ordered_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n\n    # Process each word in the list\n    ordered_words = []\n    for word in words:\n        # Sort the characters in each word\n        sorted_word = ''.join(sorted(word))\n\n        # Preserve the original non-ascii characters in their original position\n        ascii_chars = sorted([char for char in sorted_word if ord(char) < 128])\n        original_word = []\n        ascii_index = 0\n        for char in sorted_word:\n            if ord(char) < 128:\n                original_word.append(ascii_chars[ascii_index])\n                ascii_index += 1\n            else:\n                original_word.append(char)\n\n        # Join the characters to form the ordered word\n        ordered_word = ''.join(original_word)\n        ordered_words.append(ordered_word)\n\n    # Join the ordered words back into a string\n    ordered_s = ' '.join(ordered_words)\n\n    return ordered_s", "matching_cluster_idx": 0}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    if s == \"\":\n        return \"\"\n\n    words = s.split(\" \")\n\n    ordered_words = []\n    for word in words:\n        if word == \"\" or word == \" \":\n            ordered_words.append(word)\n        else:\n            ordered_words.append(\"\".join(sorted(word)))\n\n    return \" \".join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def ascii_sort(word):\n        return \"\".join(sorted(word, key=ord))\n    \n    words = s.split(' ')\n    shuffled_words = [ascii_sort(word) for word in words]\n    return ' '.join(shuffled_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def alphabetize(word):\n        return \"\".join(sorted(word))\n\n    words = s.split(\" \")\n    anti_shuffled_words = [alphabetize(word) for word in words]\n    anti_shuffled_sentence = \" \".join(anti_shuffled_words)\n    return anti_shuffled_sentence", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(\" \")\n\n    # Process each word and sort the letters\n    processed_words = [''.join(sorted(word)) for word in words]\n\n    # Join the processed words back into a sentence\n    return \" \".join(processed_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return \"\".join(sorted(word, key=ord))\n    \n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    \n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join([''.join(sorted(word, key=lambda x: ord(x))) for word in s.split(' ')])", "matching_cluster_idx": 2}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ' '.join([''.join(sorted(word)) for word in s.split(' ')])", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    # Splitting string into words\n    words = s.split(' ')\n    ordered_words = []\n    \n    # For each word, sort characters and combine them back into a string\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n\n    # Join words back into a string with spaces\n    ordered_s = ' '.join(ordered_words)\n    \n    return ordered_s", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 79.19308357348703, "dps_norm": 54.285714285714285, "pass@1": 91.0, "profiled": [{"solution": "def get_row(lst, x):\n    coordinates = []\n\n    # Populate coordinates with matching elements\n    for row_index, row in enumerate(lst):\n        for col_index in [i for i, el in enumerate(row) if el == x]:\n            coordinates.append((row_index, col_index))\n\n    # Sort coordinates first by row index and then by column index\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for row_number, row in enumerate(lst):\n        for column_number, element in enumerate(row):\n            if element == x:\n                result.append((row_number, column_number))\n    result.sort(key=lambda coordinate: (coordinate[0], -coordinate[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    res = []\n    for i, row in enumerate(lst):\n        for j, item in enumerate(row):\n            if item == x:\n                res.append((i, j))\n    res.sort(key=lambda a: (a[0], -a[1]))\n    return res", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, num in enumerate(row):\n            if num == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda tup: (tup[0], -tup[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row, elements in enumerate(lst):\n        for column, value in enumerate(elements):\n            if value == x:\n                coordinates.append((row, column))\n    coordinates.sort(key=lambda item: (item[0], -item[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                coordinates.append((i, j))\n\n    coordinates.sort(key=lambda tup: (tup[0], -tup[1]))\n\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, elem in enumerate(row):\n            if elem == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, col in enumerate(row):\n            if col == x:\n                coordinates.append((row_idx, col_idx))\n    coordinates.sort(key=lambda tup: (tup[0], -tup[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"Function to get coordinates of the integer x in the 2 dimensional list\"\"\"\n    coordinates = []\n    for row in range(len(lst)):\n        for col in range(len(lst[row])):\n            if lst[row][col] == x:\n                coordinates.append((row, col))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort(key=lambda x: (x[0], -x[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for i, row in enumerate(lst):\n        for j, col in enumerate(row):\n            if col == x:\n                result.append((i, j))\n    result.sort(key=lambda tup: (tup[0], -tup[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    ans = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] == x:\n                ans.append((i, j))\n    return sorted(ans, key=lambda tup: (tup[0], -tup[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, elem in enumerate(row):\n            if elem == x:\n                coordinates.append((row_idx, col_idx))\n    \n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for row_index, row in enumerate(lst):\n        for col_index, item in enumerate(row):\n            if item == x:\n                coordinates.append((row_index, col_index))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, sublist in enumerate(lst):\n        for j, elem in enumerate(sublist):\n            if elem == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    result = []\n    for idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((idx, col_idx))\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    return sorted([(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x], key=lambda tup: (tup[0], -tup[1]))", "matching_cluster_idx": 2}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 91.82989690721651, "dps_norm": 27.857142857142858, "pass@1": 62.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_text = \"\"\n    for char in s:\n        ascii_val = ord(char)\n        if 65 <= ascii_val <= 90: \n            encrypted_text += chr(((ascii_val - 65 + 2*2) % 26) + 65)\n        elif 97 <= ascii_val <= 122:\n            encrypted_text += chr(((ascii_val - 97 + 2*2) % 26) + 97)\n        else:\n            encrypted_text += char\n    return encrypted_text", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2  # This will shift the letters by 4 places in the alphabet\n            if char.islower():\n                encrypted += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encrypted += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            encrypted += char  # If the character is not a letter, it's added as is\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            start = 'a' if char.islower() else 'A'\n            offset = (ord(char) - ord(start) + 2*2) % 26\n            result += chr(ord(start) + offset)\n        else:\n            result += char\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    def rotate(ch):\n        if 'a' <= ch <= 'z':\n            return chr((ord(ch) - ord('a') + 4) % 26 + ord('a'))\n        elif 'A' <= ch <= 'Z':\n            return chr((ord(ch) - ord('A') + 4) % 26 + ord('A'))\n        return ch\n\n    return ''.join(map(rotate, s))", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                encrypted += chr((ord(char) - 97 + shift) % 26 + 97)\n            else:\n                encrypted += chr((ord(char) - 65 + shift) % 26 + 65)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            offset = (ord(char) - start + 4) % 26\n            result += chr(start + offset)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = ''\n    for c in s:\n        ascii_val = ord(c)\n        if 65 <= ascii_val <= 90:\n            result += chr((ascii_val - 65 + 2*2) % 26 + 65) # For uppercase letters\n        elif 97 <= ascii_val <= 122:\n            result += chr((ascii_val - 97 + 2*2) % 26 + 97) # For lowercase letters\n        else:\n            result += c # For non-alphabet characters\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_string = \"\"\n    for character in s:\n        if character.isalpha():\n            shift = 2 * 2  # as the problem statement suggests to shift down by two multiplied to two places\n            char_code = ord(character.lower())\n            if char_code >= ord('a') and char_code <= ord('z'):\n                new_char_code = (char_code - ord('a') + shift) % 26 + ord('a')\n                new_char = chr(new_char_code) if character.islower() else chr(new_char_code).upper()\n                encrypted_string += new_char\n            else:\n                encrypted_string += character\n        else:\n            encrypted_string += character\n    return encrypted_string", "matching_cluster_idx": 0}, {"solution": "def encrypt(s):\n    \"\"\"\n    This function takes a string, s, and returns the encrypted string\n    with letters in s shifted down by two multiplied by two places in the\n    alphabet.\n    \"\"\"\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            start = 'a' if c.islower() else 'A'\n            result += chr((ord(c) - ord(start) + 4) % 26 + ord(start))\n        else:\n            result += c\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = ''\n    for char in s:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            result += chr((ord(char) - start + 4) % 26 + start)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for i in s:\n        if i.isalpha():\n            ascii_offset = 65 if i.isupper() else 97\n            encrypted += chr((ord(i) - ascii_offset + 2*2) % 26 + ascii_offset)\n        else:\n            encrypted += i\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A'))\n            encrypted += new_char\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted_str = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            encrypted_char = chr((ord(char) - ascii_offset + 4) % 26 + ascii_offset)\n            encrypted_str += encrypted_char\n        else:\n            encrypted_str += char\n    return encrypted_str", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt a string by shifting characters two places to the right.\"\"\"\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            ascii_offset = 65 if char.isupper() else 97\n            encrypted += chr((ord(char) - ascii_offset + 2 * 2) % 26 + ascii_offset)\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = ''\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2  # Rotate down by 4 places\n            if char.islower():\n                # Wrap around if needed\n                encrypted += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encrypted += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            encrypted += char  # Non-alphabet characters are not encrypted\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2\n            if char.islower():\n                result += chr((ord(char) - 97 + shift) % 26 + 97)\n            else:\n                result += chr((ord(char) - 65 + shift) % 26 + 65)\n        else:\n            result += char\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for c in s:\n        if c.isalpha():\n            shift = 2 * 2\n            start = ord('a') if c.islower() else ord('A')\n            encrypted += chr((ord(c) - start + shift) % 26 + start)\n        else:\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = \"\"\n    for c in s:\n        if c.isalpha():\n            shift = 2 * 2 # as per the problem statement\n            if c.islower():\n                encrypted += chr((ord(c) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encrypted += chr((ord(c) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            encrypted += c\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    result = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            shift = 4 # two places multiplied by two\n            ascii_offset = ord('a') if char.islower() else ord('A')\n            \n            # Encrypt the character\n            encrypted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n            result += encrypted_char\n        else:\n            # If the character is not a letter, don't encrypt it\n            result += char\n            \n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shift = 2 * 2  # multiplied by 2\n            if char.islower():\n                encrypted += chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                encrypted += chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            encrypted += char\n    return encrypted", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 78.59922178988327, "dps_norm": 56.25, "pass@1": 89.0, "profiled": [{"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    return unique_lst[1] if len(unique_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    unique_sorted_lst = sorted(set(lst))\n    return unique_sorted_lst[1] if len(unique_sorted_lst) > 1 else None", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = set(lst)\n    if len(unique_lst) < 2:\n        return None\n\n    min1 = min(unique_lst)\n    unique_lst.remove(min1)\n    min2 = min(unique_lst)\n\n    return min2", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_lst = set(lst)\n    if len(unique_lst) < 2:\n        return None\n    unique_lst.remove(min(unique_lst))\n    return min(unique_lst)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates from list\n    lst = list(set(lst))\n\n    # If list has less than 2 elements return None\n    if len(lst) < 2:\n        return None\n\n    # Sort the list\n    lst.sort()\n\n    # Return the 2nd smallest element\n    return lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Remove duplicates\n    unique_lst = list(set(lst))\n    # If less than 2 elements, return None\n    if len(unique_lst) < 2:\n        return None\n    # Sort the list\n    unique_lst.sort()\n    # Return the second smallest\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if not lst or len(lst) < 2: return None\n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2: return None\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    if len(unique_lst) < 2:\n        return None\n    else:\n        return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if not lst or len(set(lst)) < 2:\n        return None\n    \n    # Get unique elements\n    unique_lst = list(set(lst))\n    \n    # Sort the unique elements in ascending order\n    unique_lst.sort()\n    \n    # Return the second smallest element\n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Remove duplicates from the list\n    unique_lst = list(set(lst))\n    \n    # Sort the list in ascending order\n    unique_lst.sort()\n    \n    # Return None if the list has less than 2 elements\n    if len(unique_lst) < 2:\n        return None\n    \n    # Return the 2nd smallest element\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    unique_lst = list(set(lst))  # Remove duplicates\n    \n    if len(unique_lst) < 2:\n        return None  # Less than 2 elements means there is no 2nd smallest\n\n    unique_lst.sort()\n    return unique_lst[1]  # Second element in the sorted list is the second smallest", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # Check if list has at least two elements\n    if len(lst) < 2:\n        return None\n    # Initialize smallest and second smallest\n    smallest = second_smallest = float('inf')\n    for num in lst:\n        # Update smallest and second smallest\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    # Check if second smallest was updated\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    This function returns the 2nd smallest element of the given list.\n    It returns None if there is no such element.\n\n    Examples:\n    >>> next_smallest([1, 2, 3, 4, 5])\n    2\n    >>> next_smallest([5, 1, 4, 3, 2])\n    2\n    >>> next_smallest([])\n    None\n    >>> next_smallest([1, 1])\n    None\n    \"\"\"\n    unique_lst = list(set(lst))\n    unique_lst.sort()\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    # First, we remove duplicates from the list.\n    unique_list = list(set(lst))\n    \n    # If the list has less than 2 elements, there's no \"second smallest\" element.\n    if len(unique_list) < 2:\n        return None\n    \n    # Sort the list in ascending order.\n    unique_list.sort()\n    \n    # The second smallest number is now at index 1.\n    return unique_list[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    unique_list = list(set(lst))\n    unique_list.sort()\n    if len(unique_list) < 2:\n        return None\n    else:\n        return unique_list[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if not lst or len(lst) < 2:\n        return None\n    unique_lst = sorted(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    if len(lst) < 2:\n        return None\n    unique_lst = sorted(set(lst)) # sort and remove duplicate\n    if len(unique_lst) < 2:\n        return None\n    return unique_lst[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 94.32048681541582, "dps_norm": 64.16666666666667, "pass@1": 89.0, "profiled": [{"solution": "def odd_count(lst):\n    result = []\n    for i, string in enumerate(lst, 1):\n        count = sum(int(char) % 2 for char in string)\n        sentence = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            count, count, count, count\n        )\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        odd_digits = sum(1 for digit in string if int(digit) % 2 != 0)\n        sentence = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(\n            odd_digits, odd_digits, odd_digits, odd_digits)\n        result.append(sentence)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    results = []\n    for i, s in enumerate(lst):\n        count = count_odd_digits(s)\n        string = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        results.append(string)\n    \n    return results", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(int(c) % 2 for c in s)\n\n    return [\n        f\"the number of odd elements {count_odds(i)}n the str{count_odds(i)}ng {count_odds(i)} of the {count_odds(i)}nput.\"\n        for i in lst\n    ]", "matching_cluster_idx": 0}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    # Initialize the result list\n    result = []\n    # Iterate through each string in the list\n    for i, string in enumerate(lst):\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        # Format the output string\n        output = \"the number of odd elements {0}n the str{0}ng {0} of the {0}nput.\".format(odd_count)\n        # Add the output string to the result list\n        result.append(output)\n    # Return the result list\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    Examples:\n\n    odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n\n    odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        count = count_odds(s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        odd_count = sum([1 for digit in string if int(digit) % 2 != 0])\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst, start=1):\n        odd_count_in_s = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count_in_s}n the str{odd_count_in_s}ng {odd_count_in_s} of the {odd_count_in_s}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, string in enumerate(lst, 1):\n        odd_count = sum(int(char) % 2 for char in string)\n        output.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for i, string in enumerate(lst, start=1):\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        # Count the number of odd digits in the string\n        return sum(1 for c in s if int(c) % 2 != 0)\n\n    # Map the count_odd_digits function to each string in the list\n    counts = map(count_odd_digits, lst)\n\n    # Format the output string for each number of odd digits\n    return [f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n             for count in counts]", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output_list = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        output_list.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output_list = []\n    for string in lst:\n        # Count number of odd digits in the string\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        output = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count)\n        output_list.append(output)\n    return output_list", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    output = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(1 for c in s if int(c) % 2)\n        output.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(string):\n        return sum(1 for digit in string if int(digit) % 2 != 0)\n\n    result = []\n    for index, string in enumerate(lst):\n        count = count_odd_digits(string)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    \n    result = []\n    \n    for string in lst:\n        count = sum(1 for digit in string if int(digit) % 2 == 1)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "import doctest\ndef odd_count(lst):\n    output = []\n    for s in lst:\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        sentence = \"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_digits, odd_digits, odd_digits, odd_digits)\n        output.append(sentence)\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for i, s in enumerate(lst):\n        odd_count = sum([int(c) % 2 for c in s])\n        output.append(\n            f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        )\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(int(c) % 2 for c in s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    result = []\n    for string in lst:\n        odd_count = sum(1 for digit in string if int(digit) % 2 != 0)\n        result.append(\"the number of odd elements {}n the str{}ng {} of the {}nput.\".format(odd_count, odd_count, odd_count, odd_count))\n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 12.0, "profiled": [{"solution": "def match_parens(lst):\n    def check_balance(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n                if balance < 0:\n                    return False\n        return balance == 0\n\n    first, second = lst\n    return 'Yes' if check_balance(first + second) or check_balance(second + first) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    s1, s2 = lst[0] + lst[1], lst[1] + lst[0]\n    \n    def check(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if check(s1) or check(s2):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    This function checks if we can concatenate the two given strings in some order, that the resulting string will be good. \n    A string is considered to be good if and only if all parentheses in it are balanced. For example: \n    the string '(())()' is good, while the string '())' is not.\n    The function returns 'Yes' if it's possible to make a good string, and returns 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        '''\n        Helper function to check if a string has balanced parentheses.\n        Returns True if balanced, False otherwise.\n        '''\n        count = 0\n        for c in s:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    # Concatenate the two strings in both possible orders.\n    str1, str2 = lst\n    good1 = is_balanced(str1 + str2)\n    good2 = is_balanced(str2 + str1)\n\n    # If either concatenation is good, then we can make a good string.\n    if good1 or good2:\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(s):\n        count = 0\n        for char in s:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n            if count < 0:\n                return False\n        return count == 0\n\n    first, second = lst\n    if check_balance(first + second) or check_balance(second + first):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def balance_check(s):\n        open_parentheses = 0\n        for char in s:\n            if char == '(':\n                open_parentheses += 1\n            else:\n                open_parentheses -= 1\n            if open_parentheses < 0:\n                return False\n        return open_parentheses == 0\n    \n    str1, str2 = lst\n    return 'Yes' if balance_check(str1 + str2) or balance_check(str2 + str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def check(string):\n        open_count = 0\n        for char in string:\n            if char == '(':\n                open_count += 1\n            else:\n                if open_count == 0:\n                    return False\n                open_count -= 1\n        return open_count == 0\n\n    str1, str2 = lst\n    return 'Yes' if check(str1 + str2) or check(str2 + str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(s):\n        counter = 0\n        for char in s:\n            if char == '(':\n                counter += 1\n            elif char == ')':\n                counter -= 1\n                if counter < 0:\n                    return False\n        return counter == 0\n\n    def reverse_string(s):\n        return s[::-1]\n\n    def concatenate_strings(s1, s2):\n        return s1 + s2\n\n    string1, string2 = lst\n    if check_balance(concatenate_strings(string1, string2)) or check_balance(concatenate_strings(string2, string1)):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def check_balance(s):\n        count = 0\n        for ch in s:\n            if ch == '(':\n                count += 1\n            elif ch == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n\n    return 'Yes' if check_balance(lst[0] + lst[1]) or check_balance(lst[1] + lst[0]) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def count_parentheses(string):\n        count = 0\n        for char in string:\n            if char == '(':\n                count += 1\n            elif char == ')':\n                count -= 1\n                if count < 0:\n                    return False\n        return count == 0\n    \n    def check_order(str1, str2):\n        return count_parentheses(str1 + str2) or count_parentheses(str2 + str1)\n    \n    return 'Yes' if check_order(*lst) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def count_parens(s):\n        balance = 0\n        for ch in s:\n            if ch == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if count_parens(s1 + s2) or count_parens(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def check_balance(string):\n        # Initial number of open and close parentheses\n        open_count = 0\n        close_count = 0\n\n        for char in string:\n            if char == '(':\n                open_count += 1\n            elif char == ')':\n                close_count += 1\n                if close_count > open_count:\n                    return False\n\n        # Check if all parentheses are balanced\n        return open_count == close_count\n\n    def concatenate_strings(string1, string2):\n        # Concatenates strings in different orders and checks if any of them are balanced\n        return check_balance(string1 + string2) or check_balance(string2 + string1)\n\n    return 'Yes' if concatenate_strings(*lst) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def count_parens(s):\n        open_count = 0\n        for char in s:\n            if char == '(':\n                open_count += 1\n            elif char == ')':\n                if open_count == 0:\n                    return False\n                else:\n                    open_count -= 1\n        return open_count == 0\n\n    s1, s2 = lst[0], lst[1]\n    return 'Yes' if count_parens(s1+s2) or count_parens(s2+s1) else 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 61.206896551724135, "dps_norm": 75.71428571428571, "pass@1": 10.0, "profiled": [{"solution": "def maximum(arr, k):\n    arr.sort()\n    return arr[::-1][:k][::-1]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    # Check the condition to ensure k is not more than the length of the array\n    if k > len(arr):\n        raise ValueError(\"k cannot be greater than the length of the array\")\n    \n    # Use a heap data structure to keep track of the k largest numbers\n    import heapq\n    heap = heapq.nlargest(k, arr)\n    \n    # Return the sorted list of the k largest numbers\n    return sorted(heap)", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    maxheap = []\n    for num in arr:\n        heapq.heappush(maxheap, -num)\n    \n    result = []\n    for _ in range(k):\n        result.append(-heapq.heappop(maxheap))\n    return sorted(result)", "matching_cluster_idx": 2}, {"solution": "from heapq import nlargest\ndef maximum(arr, k):\n    return sorted(nlargest(k, arr))", "matching_cluster_idx": 3}, {"solution": "from heapq import heappush, heappop\ndef maximum(arr, k):\n    if k == 0:\n        return []\n\n    maxHeap = []\n    for num in arr:\n        heappush(maxHeap, -num)\n\n    result = []\n    for _ in range(k):\n        result.append(-heappop(maxHeap))\n\n    return sorted(result)", "matching_cluster_idx": 3}, {"solution": "def maximum(arr, k):\n    # Sort the array in reverse order (highest to lowest)\n    arr.sort(reverse=True)\n\n    # Slice the first k elements from the sorted array\n    max_k = arr[:k]\n\n    # Return the list sorted in ascending order\n    max_k.sort()\n    return max_k", "matching_cluster_idx": 6}, {"solution": "import heapq\ndef maximum(arr, k):\n    if k == 0:\n        return []\n    max_heap = []\n    for num in arr:\n        heapq.heappush(max_heap, -num)\n    result = []\n    for _ in range(k):\n        result.append(-heapq.heappop(max_heap))\n    return sorted(result)", "matching_cluster_idx": 2}, {"solution": "def maximum(arr, k):\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    arr.sort(reverse=True)\n    \n    # Get the first k elements\n    max_k_numbers = arr[:k]\n    \n    # Sort the k numbers in ascending order\n    max_k_numbers.sort()\n    \n    return max_k_numbers", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if k <= 0:\n        return []\n    arr.sort()\n    return arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    # Sort the list in descending order\n    arr.sort(reverse=True)\n    \n    # Slice the first 'k' elements\n    output = arr[:k]\n    \n    # Sort the output list in ascending order\n    output.sort()\n    \n    return output", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 82.60089686098655, "dps_norm": 61.42857142857143, "pass@1": 98.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    \n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements\n    that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(number for index, number in enumerate(lst) if index % 2 == 0 and number % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    # Initialize the sum at 0\n    sum = 0\n    # Start from 0 index and step by 2 to get even positions\n    for i in range(0, len(lst), 2):\n        # Check if the element is odd\n        if lst[i] % 2 != 0:\n            # Add the odd number to the sum\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(item for index, item in enumerate(lst) if index % 2 == 0 and item % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(i for idx, i in enumerate(lst) if idx % 2 == 0 and i % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            total += lst[i]\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 == 0 and x % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum = 0\n    for i in range(len(lst)):\n        # Check if element is odd and its position is even\n        if lst[i] % 2 == 1 and i % 2 == 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum_odd_elements_in_even_positions = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum_odd_elements_in_even_positions += lst[i]\n    return sum_odd_elements_in_even_positions", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    return sum(el for i, el in enumerate(lst) if i % 2 == 0 and el % 2 != 0)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 2):  # Iterating over even positions\n        if lst[i] % 2 != 0:  # Check if the number is odd\n            total += lst[i]  # Add to total if odd\n    return total", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 1)", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 97.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # filter out strings with odd lengths\n    lst = [x for x in lst if len(x) % 2 == 0]\n    \n    # sort by length, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function filters out strings with odd length and returns them sorted by length and alphabetically.\n    \"\"\"\n    # Filter out strings with odd length\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter the list to remove strings of odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    # Sort the filtered list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda s: (len(s), s))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths from the list\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by the length of each word and alphabetically if the lengths are equal\n    lst = sorted(lst, key=lambda x: (len(x), x))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length and alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    # Return the sorted list\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Function that sorts a list by word length and removes words with odd lengths.\"\"\"\n    \n    # Deleting the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # Sorting the list ascending by word length and alphabetically\n    lst = sorted(lst, key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Given a list of strings, delete strings of odd lengths and return \n    the resulted list sorted by length (ascending) and then alphabetically if \n    two words have the same length.\"\"\"\n    \n    # Removing odd length strings\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sorting the list by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter out strings with odd lengths\n    filtered = [s for s in lst if len(s) % 2 == 0]\n    # sort strings by length and alphabetically\n    sorted_list = sorted(filtered, key=lambda x: (len(x), x))\n    # return the sorted list\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings of odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list based on word length and alphabetically\n    lst = sorted(lst, key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"This function accepts a list of strings as a parameter, deletes\n    the strings that have odd lengths from it, and returns the resulted\n    list with a sorted order.\"\"\"\n    # Filter out strings with odd length\n    filtered_list = [x for x in lst if len(x) % 2 == 0]\n    # Sort the list by string length and alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    lst = [i for i in lst if len(i) % 2 == 0]\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings of odd length\n    lst = [i for i in lst if len(i) % 2 == 0]\n    # Sort the list by length of each word, then alphabetically\n    return sorted(lst, key=lambda x: (len(x), x))", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter the list to only keep words with even length\n    even_len_words = [word for word in lst if len(word) % 2 == 0]\n    \n    # sort the list first by length, then alphabetically\n    even_len_words.sort(key=lambda word: (len(word), word))\n    \n    return even_len_words", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Accepts a list of strings as a parameter, deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order, The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates. The order of the list should be ascending by length of each word, \n    and you should return the list sorted by that rule. If two words have the same length, \n    sort the list alphabetically. The function should return a list of strings in sorted order. \n    You may assume that all words will have the same length.\n    \"\"\"\n    # filter out strings with odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n\n    # sort the list by word length and alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Delete the strings that have odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter out strings of odd length\n    lst = [s for s in lst if len(s) % 2 == 0]\n    # sort by length and then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"Function that filters strings of even lengths from a list, sorts them by length, and returns the sorted list.\"\"\"\n    \n    # Filter strings of even lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n\n    # Sort strings by length, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter the list to remove strings of odd lengths\n    lst = [word for word in lst if len(word) % 2 == 0]\n    # Sort the list by length of each word, then alphabetically\n    lst.sort(key=lambda word: (len(word), word))\n    return lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # filter the strings with even length\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    # sort the list by length and then alphabetically\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"The function accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    \"\"\"\n    lst = [word for word in lst if len(word) % 2 == 0]\n    lst.sort(key=lambda x: (len(x), x))\n    return lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 74.66101694915254, "dps_norm": 82.5, "pass@1": 88.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    This function checks if a number is not prime.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    if num < 2:\n        return True\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return True\n    for current in range(3, int(n ** 0.5) + 1, 2):\n        if n % current == 0: \n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    elif n <= 3:\n        return False\n    elif n%2 == 0 or n%3 == 0:\n        return True\n    i = 5\n    while (i * i <= n):\n        if (n%i == 0 or n%(i+2) == 0):\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime\n    :param n: integer number\n    :return: boolean value, True if number is not prime, False otherwise\n    \"\"\"\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i = i + 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"\n    Check if a number is prime\n    \"\"\"\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    \"\"\"\n    Check if a number is not prime\n    \"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, n):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 0}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    elif n <= 3:\n        return True\n    elif n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef is_not_prime(n):\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1 or (n % 2 == 0 and n > 2): \n        return True\n    for current in range(3, int(n ** 0.5) + 1, 2):\n        if n % current == 0: \n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(num):\n    if num <= 1:\n        return True\n    for i in range(2, num):\n        if num % i == 0:\n            return True\n    return False", "matching_cluster_idx": 0}, {"solution": "def is_not_prime(n):\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 98.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a list of numbers, returned in descending order.\n\n    :param nums: List of numbers.\n    :param n: An integer representing the count of largest numbers to find.\n    :return: A list of n largest numbers in descending order.\n    \"\"\"\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param num_list: list of numbers\n    :param n: number of largest elements to return\n    :return: list of n largest elements in descending order\n    \"\"\"\n    largest_nums = heapq.nlargest(n, num_list)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Finds the n largest integers from a given list of numbers, returned in descending order.\n    \n    Args:\n    nums (list of int): List of numbers\n    n (int): The number of largest elements to be returned\n    \n    Returns:\n    list of int: List of n largest numbers in descending order.\n    \n    Example:\n    >>> heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)\n    [85, 75, 65]\n    \"\"\"\n    \n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use the nlargest method from heapq to find the n largest numbers in nums\n    largest_nums = heapq.nlargest(n, nums)\n    \n    # Return the list of the n largest numbers in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums,n):\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(num_list, n):\n    return heapq.nlargest(n, num_list)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    largest_nums = hq.nlargest(n, nums)\n    largest_nums.sort(reverse=True)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param nums: List of numbers.\n    :param n: Number of largest elements to find.\n    :return: A list of n largest numbers in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Function to find the n largest integers from a given list of numbers, returned in descending order.\n    :param nums: a list of numbers\n    :param n: the number of largest elements to be returned\n    :return: a list of n largest numbers in descending order\n    \"\"\"\n    largest_nums = hq.nlargest(n, nums)\n    largest_nums.sort(reverse=True)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums,n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    :param nums: List of integers.\n    :param n: Number of top elements to extract.\n    :return: List of n largest elements in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n  largest_nums = heapq.nlargest(n, nums)\n  return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq as hq\ndef heap_queue_largest(nums, n):\n    largest_nums = hq.nlargest(n, nums)\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums,n):\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 50.34013605442177, "dps_norm": 50.0, "pass@1": 88.0, "profiled": [{"solution": "def find_Rotations(string: str) -> int:\n    n = len(string)\n    for i in range(1, n):\n        rotated = string[i:] + string[:i]\n        if rotated == string:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    length = len(s)\n    for i in range(1, length):\n        if s == s[i:] + s[:i]:\n            return i\n    return length", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n == 1:\n        return 1\n\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Function to find the minimum number of rotations required to get the same string.\n    \"\"\"\n    if len(s) == 1:\n        return 1\n    \n    rotations = len(s)\n    for i in range(1, len(s)):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            rotations = i\n            break\n    return rotations", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: Minimum number of rotations required to get the same string.\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n == 1:\n        return 1\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n    :param s: Input string.\n    :return: Minimum number of rotations required.\n    \"\"\"\n    if len(s) <= 1:\n        return 1\n    \n    rotations = 1\n    temp = s[1:] + s[0]\n    \n    while temp != s and rotations < len(s):\n        temp = temp[1:] + temp[0]\n        rotations += 1\n        \n    return rotations if temp == s else -1", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations required to get the same string.\n    If no rotation is needed, it returns 1; otherwise, returns the number of rotations required.\n    \"\"\"\n    n = len(string)\n    if n == 1:\n        return 1\n    for i in range(1, n):\n        if string == string[i:] + string[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(string):\n    n = len(string)\n    for i in range(1, n):\n        rotated_string = string[i:] + string[:i]\n        if rotated_string == string:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \"\"\"\n    if len(set(s)) == 1:\n        return 1\n    \n    n = len(s)\n    for i in range(2, n):\n        if s == s[i:] + s[:i]:\n            return i\n    \n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n == 1: return 1\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    if n == 1:\n        return 1\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    This function finds the minimum number of rotations (greater than 0) required to get the same string.\n    :param s: input string\n    :return: minimum number of rotations required\n    \"\"\"\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    if len(set(s)) == 1:  # If all characters are the same\n        return 1\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return i\n    return n  # If no rotation can make the string equal to itself", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    if not s:\n        return 0\n    n = len(s)\n    for i in range(1, n):\n        if s[i:] + s[:i] == s:\n            return gcd(i, n)\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    return n", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 49.92831541218638, "dps_norm": 73.88888888888889, "pass@1": 30.0, "profiled": [{"solution": "def remove_Occ(string, char):\n    # Remove first occurrence\n    string = string.replace(char, \"\", 1)\n    \n    # Remove last occurrence\n    string = string[::-1].replace(char, \"\", 1)[::-1]\n    \n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    This function removes the first and last occurrence of a given character from a string.\n    :param s: Input string\n    :param char: Character to be removed\n    :return: New string after removing first and last occurrence of the character\n    \"\"\"\n    # Find the first and last occurrence of the character\n    first_occ = s.find(char)\n    last_occ = s.rfind(char)\n\n    # If the character does not exist in the string, return the string as it is\n    if first_occ == -1 or last_occ == -1:\n        return s\n    # If the character is only present once, remove the first occurrence\n    elif first_occ == last_occ:\n        return s[:first_occ] + s[first_occ + 1:]\n    else:\n        # If the character is present more than once, remove the first and last occurrence\n        return s[:first_occ] + s[first_occ + 1:last_occ] + s[last_occ + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occ = s.find(ch)\n    last_occ = s.rfind(ch)\n    if first_occ == -1:\n        return s\n    elif first_occ == last_occ:\n        return s[:first_occ] + s[first_occ+1:]\n    else:\n        return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    first_occurrence = s.find(char)\n    last_occurrence = s.rfind(char)\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Remove the first occurrence\n    string = string.replace(char, '', 1)\n    # Remove the last occurrence\n    string = string[::-1].replace(char, '', 1)[::-1]\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    # Count the occurrences of the character\n    count = s.count(char)\n    if count == 0:\n        return s\n    # Remove the first occurrence\n    s = s.replace(char, \"\", 1)\n    # If there's more than one occurrence, remove the last occurrence\n    if count > 1:\n        s = s[::-1].replace(char, \"\", 1)[::-1]\n    return s", "matching_cluster_idx": 3}, {"solution": "def remove_Occ(string, char):\n    # Remove first occurrence\n    string = string.replace(char, '', 1)\n    # Reverse the string to remove the last occurrence\n    reverse_string = string[::-1]\n    reverse_string = reverse_string.replace(char, '', 1)\n    # Return the processed string\n    return reverse_string[::-1]", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    This function removes the first and last occurrence of a specific character in a given string.\n\n    Parameters:\n    s (str): The input string.\n    char (str): The character to be removed.\n\n    Returns:\n    str: The resulting string after removal.\n    \"\"\"\n    # Find the first and last occurrence index of the character\n    first_occ = s.find(char)\n    last_occ = s.rfind(char)\n\n    # If the character is found, remove the first and last occurrence\n    if first_occ != -1 and last_occ != -1:\n        result = s[:first_occ] + s[first_occ + 1 : last_occ] + s[last_occ + 1 :]\n    else:\n        result = s\n\n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    first_occurrence = s.find(ch)\n    last_occurrence = s.rfind(ch)\n    \n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    else:\n        return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Function to remove first and last occurrence of a given character from the string.\n    \n    Parameters:\n    s (str): input string\n    char (str): character to be removed\n\n    Returns:\n    str: string after removal\n    \"\"\"\n    \n    # Removing first occurrence\n    s = s.replace(char, '', 1)\n    # Removing last occurrence\n    s = s[::-1].replace(char, '', 1)[::-1]\n    \n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Function to remove first and last occurrence of a given character from the string.\n    \"\"\"\n    # Remove first occurrence of char\n    string = string.replace(char, '', 1)\n\n    # Find last occurrence of char and remove it\n    string = string[::-1]  # Reverse the string\n    string = string.replace(char, '', 1)  # Remove first occurrence of char in reversed string\n    string = string[::-1]  # Reverse the string back\n\n    return string", "matching_cluster_idx": 3}, {"solution": "def remove_Occ(s, char):\n    first_occ = s.find(char)\n    last_occ = s.rfind(char)\n    if first_occ == -1 or last_occ == -1:\n        return s\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ+1:]\n    else:\n        return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    first_occ = s.find(char)\n    last_occ = s.rfind(char)\n    if first_occ == last_occ:\n        return s.replace(char, '', 1)\n    else:\n        return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    \"\"\"\n    Function to remove first and last occurrence of a given character from the string.\n    :param string: input string\n    :param char: character to remove\n    :return: updated string\n    \"\"\"\n    # Removing last occurrence\n    string = string[::-1].replace(char, '', 1)[::-1]\n    # Removing first occurrence\n    string = string.replace(char, '', 1)\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    Remove the first and last occurrence of a given character from the string.\n    \n    Parameters:\n    s (str): The input string.\n    char (str): The character to be removed.\n    \n    Returns:\n    str: The modified string after removing first and last occurrence of the character.\n    \"\"\"\n    # Removing the first occurrence\n    s = s.replace(char, '', 1)\n    # Removing the last occurrence\n    s = s[::-1].replace(char, '', 1)[::-1]\n    return s", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s, char):\n    \"\"\"\n    This function takes a string and a character as input and removes the first and last occurrence of the character from the string.\n    \"\"\"\n    # Find the first and last occurrence of the character in the string\n    first_occ = s.find(char)\n    last_occ = s.rfind(char)\n\n    # If the character is not present in the string, return the string as it is\n    if first_occ == -1:\n        return s\n\n    # If the first and last occurrence are the same, remove only one occurrence\n    if first_occ == last_occ:\n        return s[:first_occ] + s[first_occ+1:]\n\n    # If the first and last occurrence are different, remove both occurrences\n    return s[:first_occ] + s[first_occ+1:last_occ] + s[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, char):\n    # First occurrence\n    s = s.replace(char, '', 1)\n    # Last occurrence\n    s = s[::-1]\n    s = s.replace(char, '', 1)\n    s = s[::-1]\n    return s", "matching_cluster_idx": 3}, {"solution": "def remove_Occ(str1, char):\n    first_occ = str1.find(char)\n    last_occ = str1.rfind(char)\n    if first_occ == -1:\n        return str1\n    elif first_occ == last_occ:\n        return str1[:first_occ] + str1[first_occ+1:]\n    else:\n        return str1[:first_occ] + str1[first_occ+1:last_occ] + str1[last_occ+1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(string, char):\n    # Remove first occurrence of char\n    string = string.replace(char, \"\", 1)\n    # Remove last occurrence of char\n    string = string[::-1].replace(char, \"\", 1)[::-1]\n    return string", "matching_cluster_idx": 4}, {"solution": "def remove_Occ(s: str, char: str) -> str:\n    # Remove first occurrence of char\n    s = s.replace(char, '', 1)\n    # Remove last occurrence of char\n    s = s[::-1].replace(char, '', 1)[::-1]\n    return s", "matching_cluster_idx": 4}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 97.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: A list of lists where each inner list represents a row in the matrix.\n    :return: The sorted matrix.\n    \n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    This function sorts a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    matrix.sort(key=lambda x: sum(x))\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Args:\n    matrix (list of list of int): The input matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n\n    # Define a custom sorting function to sort by the sum of the rows\n    def sort_key(row):\n        return sum(row)\n\n    # Sort the matrix by the sum of each row\n    sorted_matrix = sorted(matrix, key=sort_key)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    This function takes a matrix (a list of lists) as an argument and returns\n    a new matrix where the rows are sorted in ascending order by the sum of their elements.\n    \"\"\"\n    return [row for _, row in sorted([(sum(row), row) for row in matrix])]", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(mat):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n\n    Parameters:\n    mat (List[List[int]]): The matrix to be sorted.\n\n    Returns:\n    List[List[int]]: The sorted matrix.\n    \"\"\"\n    mat.sort(key=sum)\n    return mat", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n\n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n\n    \"\"\"\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: A list of lists containing numerical values.\n    :return: A sorted list of lists according to the sum of its rows.\n    \"\"\"\n    # Sort the matrix based on the sum of its rows\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a matrix in ascending order according to the sum of its rows.\n    \n    Parameters:\n    matrix (list of list of int): A matrix represented as a list of lists where each inner list represents a row.\n    \n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # First, let's calculate the sum of each row and store it along with the row in a list of tuples.\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples in ascending order of sums.\n    row_sums.sort()\n    \n    # Extract the sorted rows (second element in each tuple) to form the sorted matrix.\n    sorted_matrix = [row for _, row in row_sums]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: A 2D list representing the matrix\n    :return: A 2D list representing the sorted matrix\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List[List[int]]\n    :return: List[List[int]]\n    \"\"\"\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    This function takes a matrix as input and sorts it based on the sum of its rows in ascending order.\n    \n    Example:\n    >>> sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])\n    [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n    \"\"\"\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Pair each row with its sum and sort based on sums\n    sorted_rows = sorted(zip(row_sums, matrix), key=lambda x: x[0])\n    \n    # Extract the sorted matrix\n    sorted_matrix = [row for _, row in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Check for empty matrix\n    if not matrix:\n        return []\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sorts a given matrix in ascending order according to the sum of its rows.\n    \n    :param matrix: List[List[int]]\n    :return: List[List[int]]\n    \"\"\"\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    This function sorts a given matrix in ascending order according to the sum of its rows.\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    \"\"\"\n    Sort a given matrix in ascending order according to the sum of its rows.\n    \n    Parameters:\n    matrix (list of list of int): The input matrix to be sorted.\n\n    Returns:\n    list of list of int: The sorted matrix.\n    \"\"\"\n    return sorted(matrix, key=sum)", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 70.39634146341463, "dps_norm": 85.625, "pass@1": 44.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters \n    joined with an underscore, and False otherwise.\n    \"\"\"\n    # Use regex to match the pattern\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    if re.match(pattern, text):\n        return True\n    return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r\"^[a-z]+(_[a-z]+)*$\"\n    return bool(re.match(pattern, s))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    import re\n\n    # Match the string pattern of lowercase letters joined by underscore.\n    # The underscore is optional and the lowercase letters can appear one or more times.\n    pattern = re.compile(r'[a-z]+(_[a-z]+)*')\n\n    # Match the entire string with the pattern.\n    match = pattern.fullmatch(s)\n\n    # Return True if the entire string matches the pattern.\n    # Return False otherwise.\n    return match is not None", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    pattern = '^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Function to check if the input string contains sequences of lowercase letters joined with an underscore.\n    :param text: str\n    :return: bool\n    \"\"\"\n    return bool(re.search(r\"^[a-z]+(_[a-z]+)*$\", text))", "matching_cluster_idx": 3}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function checks if the input string contains sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    text_parts = text.split('_')\n    for part in text_parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 5}, {"solution": "def text_lowercase_underscore(s):\n    import re\n    if re.search(r'^[a-z]+(_[a-z]+)*$', s):\n        return True\n    else:\n        return False", "matching_cluster_idx": 3}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    This function checks whether the input string contains sequences of lowercase letters \n    joined with an underscore. If the input string follows this pattern, it returns True. \n    Otherwise, it returns False.\n    \"\"\"\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    import re\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    if re.match(pattern, s):\n        return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(input_string):\n    parts = input_string.split('_')\n    for part in parts:\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(string):\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    return re.match(pattern, string) is not None", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(text):\n    # Split the string by underscore and check each part\n    parts = text.split('_')\n    for part in parts:\n        # Check if all characters in the part are lowercase\n        if not part.islower():\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def text_lowercase_underscore(text):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    :param text: str -- input text to be analyzed.\n    :return: bool -- True if text contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    # Split text into tokens based on underscore character\n    tokens = text.split('_')\n    \n    # Check if each token is a sequence of lowercase letters\n    for token in tokens:\n        if not token.islower():\n            return False\n    \n    # If all tokens pass the lowercase check, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Check if the input string contains sequences of lowercase letters joined with an underscore.\n    :param text: The input string to check.\n    :return: True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    pattern = re.compile(r'^[a-z]+(_[a-z]+)*$')\n    return bool(pattern.match(text))", "matching_cluster_idx": 7}, {"solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    This function returns true if the input string contains sequences of lowercase letters joined with an underscore.\n    \"\"\"\n    if s == '':\n        return False\n    lower_case_underscored_strings = s.split('_')\n    for string in lower_case_underscored_strings:\n        if not string.islower():\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "import re\ndef text_lowercase_underscore(s):\n    # Check if the input string contains sequences of lowercase letters joined by an underscore\n    return bool(re.match(r'^[a-z]+(_[a-z]+)*$', s))", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 77.02020202020202, "dps_norm": 87.0, "pass@1": 96.0, "profiled": [{"solution": "def test_duplicate(arr):\n    arr_set = set(arr)\n    return len(arr_set) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    Write a function to find whether a given array of integers contains any duplicate element.\n    \"\"\"\n    # Create an empty dictionary to store the counts of each integer\n    counts = {}\n\n    # Iterate over the list and update counts for each integer\n    for num in nums:\n        if num in counts:\n            return True\n        counts[num] = 1\n\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check whether a given array of integers contains any duplicate elements.\n\n    Parameters:\n    arr (list of int): The input list of integers.\n\n    Returns:\n    bool: True if the list contains any duplicate elements, False otherwise.\n    \"\"\"\n    seen = set() # Used to record the elements seen so far\n    for num in arr:\n        if num in seen: # If the element has been seen before, return True\n            return True\n        seen.add(num) # Record the element\n    return False # If no duplicate is found, return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check for duplicate numbers in an array.\n    \"\"\"\n    # Convert the list to a set for faster search\n    arr_set = set(arr)\n    \n    # Compare the lengths of list and set\n    return len(arr) != len(arr_set)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    This function checks if a given list of integers contains any duplicate elements.\n\n    :param nums: List of integers\n    :return: A boolean, True if the list contains duplicates, False otherwise\n    \"\"\"\n    # Using Python set to check for duplicates\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    \"\"\"\n    This function takes an input list of integers and checks for duplicate elements.\n    If any duplicate elements are found, the function returns True. Otherwise, it returns False.\n    \"\"\"\n    # convert the list to a set and compare the lengths\n    if len(set(lst)) < len(lst):\n        return True\n    else:\n        return False", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers and checks whether it contains any duplicate elements.\n    :param arr: List[int]\n    :return: Bool\n    \"\"\"\n    seen = set() # Initialize set to store unique elements\n\n    for num in arr:\n        if num in seen: # Check if the number is already in the set\n            return True # If yes, return True\n        seen.add(num) # If not, add the number to the set\n    return False # If no duplicate is found, return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    return len(nums) != len(set(nums))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    This function checks if the input list contains any duplicate element.\n\n    Args:\n    arr (list): a list of integers.\n\n    Returns:\n    bool: True if there is a duplicate, False otherwise.\n\n    Examples:\n    >>> test_duplicate([1,2,3,4,5])\n    False\n    >>> test_duplicate([1,2,2,3,4])\n    True\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(lst) != len(set(lst))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(lst):\n    return len(set(lst)) != len(lst)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to find whether a given array of integers contains any duplicate element.\n    :param arr: List of integers.\n    :return: True if there is any duplicate element, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(nums):\n    \"\"\"\n    This function checks for duplicate elements in a given array.\n    :param nums: List of integers.\n    :return: True if duplicate is found, else False.\n    \"\"\"\n    # Use set to track unique elements\n    unique_nums = set()\n\n    # Iterate over elements in the array\n    for num in nums:\n        # If the number is already in the set, it is a duplicate\n        if num in unique_nums:\n            return True\n        # Otherwise, add it to the set\n        unique_nums.add(num)\n\n    # If no duplicates found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Check whether a given array of integers contains any duplicate element.\n    :param arr: list[int]\n    :return: bool\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check for duplicate integers in an array\n    arr : List[int]\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 97.0, "dps_norm": 98.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(xs):\n    return min(xs)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(xs):\n    return min(xs)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(nums):\n    smallest = nums[0]\n    for num in nums:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(list):\n    return min(list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list):\n  return min(list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    This function takes a list of numbers and returns the smallest number in the list.\n\n    Parameters:\n    lst (list): a list of numbers.\n\n    Returns:\n    int or float: the smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(xs):\n    return min(xs)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list_nums):\n    \"\"\"\n    This function finds and returns the smallest number in the given list.\n    :param list_nums: List of integers\n    :return: Smallest integer in the list\n    \"\"\"\n    return min(list_nums)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(list):\n    return min(list)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    smallest = lst[0]\n    for i in lst:\n        if i < smallest:\n            smallest = i\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Return the smallest number from a list.\n    Args:\n        lst (list): List of numbers.\n    Returns:\n        int: Smallest number in the list.\n    \"\"\"\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 89.03571428571429, "dps_norm": 67.77777777777779, "pass@1": 94.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples from the given list of tuples which have all elements divisible by k.\n    \n    :param tuples_list: List of tuples to be searched.\n    :param k: Divisor for checking divisibility.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    result = [t for t in tuples_list if all(el % k == 0 for el in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Return list of tuples which have all elements divisible by k.\n\n    :param tuples_list: a list of tuples\n    :param k: an integer\n    :return: a list of tuples\n    \"\"\"\n    result = [t for t in tuples_list if all(x % k == 0 for x in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k as input.\n    It returns a list of tuples where all elements are divisible by k.\n\n    :param tup_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples with all elements divisible by k\n    \"\"\"\n    return [t for t in tup_list if all(x % k == 0 for x in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k as input. \n    It returns a list containing only the tuples from the original list \n    for which all elements are divisible by k.\n    \"\"\"\n    result = [t for t in tuples if all(element % k == 0 for element in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    result = [t for t in tuples_list if all(i % k == 0 for i in t)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    result = [tuple for tuple in lst if all(element % k == 0 for element in tuple)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    result = [tup for tup in tup_list if all(num % k == 0 for num in tup)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tup_list, k):\n    \"\"\"\n    Function to find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tup_list: List of tuples.\n    :param k: Divisor.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    # List to hold tuples divisible by k\n    divisible_tuples = []\n\n    # Loop through all tuples in the given list\n    for tup in tup_list:\n        # Assume the tuple is divisible by k\n        divisible = True\n        # Loop through each element in the tuple\n        for elem in tup:\n            # If any element is not divisible by k, set divisible to False and break the loop\n            if elem % k != 0:\n                divisible = False\n                break\n        # If the tuple was divisible by k, add it to the list\n        if divisible:\n            divisible_tuples.append(tup)\n    return divisible_tuples", "matching_cluster_idx": 8}, {"solution": "def find_tuples(test_list, k):\n    result = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = []\n    for tup in test_list:\n        if all(elem % k == 0 for elem in tup):\n            res.append(tup)\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return (res)", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = [ele for ele in test_list if all(ele[i] % k == 0 for i in range(len(ele)))]\n    return res", "matching_cluster_idx": 4}, {"solution": "def find_tuples(tuples_list, k):\n    return [t for t in tuples_list if all(el % k == 0 for el in t)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    result = []\n    for tup in test_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(lst, k):\n    return [tup for tup in lst if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    \"\"\"\n    Function to find tuples which have all elements divisible by k from the given list of tuples.\n    \n    Parameters:\n    test_list (list): A list of tuples to be checked.\n    k (int): Divisor\n    \n    Returns:\n    list: A list of tuples where all elements are divisible by k\n    \"\"\"\n\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 97.25490196078431, "dps_norm": 88.57142857142857, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    \"\"\"\n    Get the frequency of all elements in a list, returned as a dictionary.\n    \n    Parameters:\n    lst (list): The list of elements to count the frequency of.\n    \n    Returns:\n    dict: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    This function gets the frequency of all the elements in a list, returned as a dictionary.\n    \n    :param lst: List of elements\n    :return: Dictionary with element as key and frequency as value\n    \"\"\"\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    A function that takes a list as input and returns a dictionary with frequency of each element.\n\n    Parameters:\n    lst (list): The list of elements to count frequency for.\n\n    Returns:\n    dict: A dictionary with elements as keys and their corresponding frequency as values.\n    \"\"\"\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Function to get the frequency of all the elements in a list.\n\n    :param lst: List of elements\n    :return: Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    freq_dict = {}\n    for element in lst:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    A function to count frequency of elements in a list\n    \n    Arguments:\n    lst -- list of elements\n    \n    Returns:\n    A dictionary of elements as keys and their frequency as values\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if item in freq:\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list and returns a dictionary with frequency of each element in the list.\n\n    Parameters:\n    lst (list): The list to be counted.\n\n    Returns:\n    dict: A dictionary with element frequencies.\n    \"\"\"\n    freq = {}\n    for item in lst:\n        if (item in freq):\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"Return the frequency count of all elements in the list.\n\n    :param lst: List of elements to count\n    :return: Dictionary where keys are the unique elements and values are their respective frequencies.\n    \"\"\"\n    count_dict = {}\n    for i in lst:\n        if i in count_dict:\n            count_dict[i] += 1\n        else:\n            count_dict[i] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if (item in frequency):\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(arr):\n    result = {}\n    for num in arr:\n        if num in result:\n            result[num] += 1\n        else:\n            result[num] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function takes a list as an input and returns the frequency count of each element in the list, \n    returned as a dictionary.\n    \"\"\"\n    freq = {}\n    for i in lst:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Write a function to get the frequency of all the elements in a list, returned as a dictionary.\n    \"\"\"\n    result = {}\n    for item in lst:\n        if item in result:\n            result[item] += 1\n        else:\n            result[item] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    Count the frequency of each item in a list.\n\n    :param lst: list of items\n    :return: dictionary with items as keys and their counts as values\n    \"\"\"\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"Return the frequency of all the elements in a list, returned as a dictionary.\"\"\"\n    freq = {}\n    for i in lst:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    result = {}\n    for num in lst:\n        if num not in result:\n            result[num] = 1\n        else:\n            result[num] += 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    \"\"\"\n    This function returns a dictionary showing frequency of all elements in the given list\n    \"\"\"\n    freq = {}\n    for i in lst:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    return freq", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))", "matching_cluster_idx": 6}, {"solution": "def freq_count(lst):\n    \"\"\"\n    Get the frequency of all the elements in a list, returned as a dictionary.\n\n    Parameters:\n    lst (list): The list of elements to count.\n\n    Returns:\n    dict: A dictionary containing elements as keys and their corresponding frequencies as values.\n    \"\"\"\n    frequency_dict = {}\n    for element in lst:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef freq_count(lst):\n    \"\"\"\n    This function calculates the frequency of all elements in a given list and returns\n    a dictionary where the keys are the unique elements in the list and the values are \n    the frequencies of these elements.\n    \n    Input: A list of elements.\n    Output: A dictionary with elements as keys and their frequencies as values.\n    \"\"\"\n    return dict(Counter(lst))", "matching_cluster_idx": 6}]}, "Mbpp/90": {"dps": 80.53658536585367, "dps_norm": 86.42857142857142, "pass@1": 100.0, "profiled": [{"solution": "def len_log(list1):\n    return max(len(word) for word in list1)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(list1):\n    # Finding the maximum length of string in the list\n    max_length = max(len(word) for word in list1)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    max_length = 0\n    for word in lst:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(list_of_words):\n  max_length = 0\n  for word in list_of_words:\n    if len(word) > max_length:\n      max_length = len(word)\n  return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    max_length = len(lst[0])\n    for word in lst:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(list1):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n\n    :param list1: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in list1)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(list_input):\n    return max(len(word) for word in list_input)", "matching_cluster_idx": 5}, {"solution": "def len_log(list1):\n    # Initialize max_length to the length of the first element in the list\n    max_length = len(list1[0])\n    \n    for element in list1:\n        # Compare the length of the current element with max_length\n        if len(element) > max_length:\n            max_length = len(element)\n            \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(list):\n    max_length = 0\n    for word in list:\n        word_length = len(word)\n        if word_length > max_length:\n            max_length = word_length\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n  # Initialize max_len to 0\n  max_len = 0\n  # Loop through the list\n  for word in lst:\n    # Update max_len if current word's length is greater than max_len\n    if len(word) > max_len:\n      max_len = len(word)\n  # Return the length of the longest word\n  return max_len", "matching_cluster_idx": 5}, {"solution": "def len_log(list1):\n    return max(len(word) for word in list1)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    \"\"\"\n    This function takes a list of strings as an input, \n    and returns the length of the longest string in the list.\n    \"\"\"\n    return max(len(x) for x in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(lst):\n    return max(len(word) for word in lst)", "matching_cluster_idx": 5}, {"solution": "def len_log(list_of_words):\n    return max(len(word) for word in list_of_words)", "matching_cluster_idx": 5}, {"solution": "def len_log(list):\n    max_length = 0\n    for word in list:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(list):\n    return len(max(list, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(list1):\n    max_len = 0\n    for word in list1:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 74.14634146341463, "dps_norm": 57.0, "pass@1": 98.0, "profiled": [{"solution": "def index_minimum(lst):\n    if not lst:\n        return None\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    This function takes a list of tuples as input and returns the first value of the tuple\n    with the smallest second value. \n\n    :param lst: list of tuples\n    :return: first value of the tuple with the smallest second value\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    Args:\n    lst (list of tuples): A list of tuples where each tuple contains a string and an integer.\n\n    Returns:\n    str: The first value of the tuple with the smallest second value.\n    \n    Examples:\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    :param tuples: list of tuples\n    :return: first value of the tuple with smallest second value\n    \"\"\"\n    # Filter out tuples where the second value is the smallest in the list\n    filtered_tuples = [t for t in tuples if t[1] == min(t[1] for t in tuples)]\n    # Return the first value of the first tuple in the filtered list\n    return filtered_tuples[0][0]", "matching_cluster_idx": -1}, {"solution": "def index_minimum(lst):\n    \"\"\"Return the first value of the tuple with the smallest second value.\"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(list_of_tuples):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(list_of_tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Check if the list is not empty to prevent errors\n    if tuples_list:\n        # Using min() function with lambda to find tuple with the smallest second value\n        min_tuple = min(tuples_list, key=lambda x: x[1])\n        return min_tuple[0]  # Returning the first value of the tuple\n    else:\n        return None", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n    \n    Parameters:\n    lst (list of tuples): A list of tuples where each tuple contains a string and an integer.\n    \n    Returns:\n    str: The first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n\n    :param tuples: list of tuples with two elements each\n    :return: first value of the tuple with the smallest second value\n\n    >>> index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)])\n    'Varsha'\n    \"\"\"\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, return the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    \"\"\"\n    Given a list of tuples, this function returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    # Using min function with key parameter set to second element of tuple to find tuple with smallest second element\n    return min(tuples, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Return the first value of the tuple with the smallest second value in the list.\n    \n    :param lst: A list of tuples\n    :type lst: list\n    \n    :returns: The first value of the tuple with the smallest second value\n    :rtype: str\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples):\n    # Using the 'key' parameter of the 'min' function to sort based on the second element of each tuple\n    min_tuple = min(tuples, key=lambda x: x[1])\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(lst):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \n    :param lst: List of tuples\n    :return: First value of the tuple with the smallest second value\n    \"\"\"\n    return min(lst, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(l):\n    return min(l, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 82.49999999999999, "dps_norm": 56.42857142857142, "pass@1": 99.0, "profiled": [{"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    if num == 1:\n        return 1\n    ans = 0\n    for x in range(1, int(num ** 0.5) + 1):\n        if num % x == 0:\n            if x == num // x:\n                ans += 1\n            else:\n                ans += 2\n    return ans", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    \"\"\"\n    This function finds the number of divisors of a given integer n.\n    :param n: int\n    :return: int\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    '''\n    This function takes an integer as an input and returns the number of divisors of that number.\n\n    Arguments:\n    n -- integer\n\n    Returns:\n    count -- integer\n\n    Example:\n    >>> divisor(15)\n    4\n    '''\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n: int) -> int:\n    \"\"\"\n    Given an integer, returns the number of divisors of that integer.\n    \n    Args:\n    n: An integer\n    \n    Returns:\n    An integer, the number of divisors of n\n    \n    Examples:\n    >>> divisor(15)\n    4\n    >>> divisor(10)\n    4\n    \"\"\"\n    i = 1\n    result = 0\n    while i * i <= n:\n        if n % i == 0:\n            if n // i == i:\n                result += 1\n            else:\n                result += 2\n        i += 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to count the number of divisors of a given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n/i == i:\n                count = count + 1\n            else:\n                count = count + 2\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    if n == 1:\n        return 1\n\n    cnt = 0\n    for i in range(1, int(n**(1/2)) + 1):\n        if n % i == 0:\n            cnt += 1\n            if n // i != i:\n                cnt += 1\n\n    return cnt", "matching_cluster_idx": 6}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count", "matching_cluster_idx": 6}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    cnt = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            cnt += 1\n    return cnt", "matching_cluster_idx": 2}]}, "Mbpp/97": {"dps": 81.67521367521368, "dps_norm": 77.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(nested_list):\n    flattened_list = [item for sublist in nested_list for item in sublist]\n    frequency_dict = {}\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n\n    # Count frequency of each item using Counter from collections\n    frequency_dict = dict(Counter(flattened_list))\n\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Initialize an empty dictionary\n    frequency_dict = {}\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Calculate the frequency of each item in the flattened list\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    :param lists: list of lists\n    :return: dictionary with each unique element from the list as keys and its frequencies as values\n    \"\"\"\n    flat_list = [item for sublist in lists for item in sublist]\n    return {i: flat_list.count(i) for i in set(flat_list)}", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return {item: flat_list.count(item) for item in set(flat_list)}", "matching_cluster_idx": 2}, {"solution": "from collections import defaultdict\ndef frequency_lists(lst_of_lists):\n    # Initialize the result dictionary using defaultdict\n    freq_dict = defaultdict(int)\n    \n    # Flatten the list of lists and update the dictionary\n    for sublist in lst_of_lists:\n        for item in sublist:\n            freq_dict[item] += 1\n            \n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(l):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    :param l: A list of lists\n    :return: A dictionary with elements as keys and their frequency as values\n    \"\"\"\n    flat_list = [item for sublist in l for item in sublist]\n    return {item: flat_list.count(item) for item in set(flat_list)}", "matching_cluster_idx": 2}, {"solution": "from collections import Counter\ndef frequency_lists(lsts):\n    flat_list = [item for sublist in lsts for item in sublist]\n    return dict(Counter(flat_list))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sub_list in list_of_lists:\n        for item in sub_list:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(lists):\n    frequencies = defaultdict(int)\n    for lst in lists:\n        for item in lst:\n            frequencies[item] += 1\n    return dict(frequencies)", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef frequency_lists(list_of_lists):\n    \"\"\"\n    Finds the frequency of each element in a list of lists.\n\n    Parameters:\n    list_of_lists (list of lists): A list of lists containing integers.\n\n    Returns:\n    dict: A dictionary where the keys are the unique integers in the lists and the values are the frequencies of those integers.\n    \"\"\"\n    frequency_dict = defaultdict(int)\n\n    for sublist in list_of_lists:\n        for item in sublist:\n            frequency_dict[item] += 1\n\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element.\n    frequency = {}\n    \n    # Iterate over each sublist in the main list.\n    for sublist in lists:\n        # Iterate over each element in the sublist.\n        for element in sublist:\n            # If the element is already a key in the dictionary, increment its value by 1.\n            # Otherwise, add the element as a new key with an initial value of 1.\n            if element in frequency:\n                frequency[element] += 1\n            else:\n                frequency[element] = 1\n    \n    # Return the final dictionary of frequencies.\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Given a list of lists, returns a dictionary mapping items to their total count from all lists.\n    \"\"\"\n    freq_dict = {}\n    for lst in list_of_lists:\n        for item in lst:\n            if item in freq_dict:\n                freq_dict[item] += 1\n            else:\n                freq_dict[item] = 1\n    return freq_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Create a function that takes a list of lists of integers and returns a dictionary \n    where each key is an integer and each value is the number of times the integer \n    appears in the entire list of lists.\n    \n    :param lists: A list of lists of integers\n    :return: A dictionary mapping each integer to its frequency\n    \"\"\"\n    # Initialize an empty dictionary\n    frequency = {}\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each integer\n    for item in flattened_list:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    This function takes a list of lists, flattens it into one list,\n    and returns a dictionary with the frequency of each unique element in the list.\n    \n    :param lists: A list of lists\n    :return: A dictionary with element frequencies\n    \"\"\"\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Count frequency of each element\n    frequency_dict = {item: flattened_list.count(item) for item in set(flattened_list)}\n    \n    return frequency_dict", "matching_cluster_idx": 2}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Calculate the frequency of each element in a list of lists.\n    \n    :param list_of_lists: A list of lists\n    :type list_of_lists: list of list of int\n    :return: A dictionary with elements as keys and their frequency as values\n    :rtype: dict of int to int\n    \n    >>> frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])\n    {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n    \"\"\"\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            frequency_dict[element] = frequency_dict.get(element, 0) + 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency:\n                frequency[item] += 1\n            else:\n                frequency[item] = 1\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lst):\n    flattened_list = [item for sublist in lst for item in sublist]\n    return dict(Counter(flattened_list))", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 53.27922077922078, "dps_norm": 86.66666666666666, "pass@1": 95.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function takes a list and a tuple as inputs. It returns a tuple containing\n    all elements of the tuple followed by all elements of the list.\n\n    Parameters:\n    lst (list): The list to be appended to the tuple.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple containing all elements of the tuple and the list.\n\n    Examples:\n    >>> add_lists([5, 6, 7], (9, 10))\n    (9, 10, 5, 6, 7)\n\n    >>> add_lists(['hello', 'world'], (True, False))\n    (True, False, 'hello', 'world')\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list_to_append, tuple_to_append):\n    '''\n    This function takes a list and a tuple, and returns a new tuple \n    with the original tuple plus the elements of the input list at the end.\n    '''\n    return tuple_to_append + tuple(list_to_append)", "matching_cluster_idx": 5}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    This function receives two parameters - a list and a tuple, and returns a tuple\n    which is the result of concatenating the list to the tuple.\n\n    :param lst: a list to be appended to the tuple\n    :param tup: a tuple to which the list should be appended\n    :return: a new tuple containing the elements of the original tuple and the elements of the list in the same order as they appear in the list\n    \"\"\"\n    # Convert tuple to list because Python does not allow direct concatenation of a list to a tuple\n    tup_as_list = list(tup)\n    # Concatenate the list to the list of tuple elements\n    result_list = tup_as_list + lst\n    # Convert the result list back to a tuple before returning it\n    return tuple(result_list)", "matching_cluster_idx": 3}, {"solution": "def add_lists(list1, tuple1):\n    return tuple1 + tuple(list1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, t):\n    \"\"\"\n    This function appends a list of elements to an existing tuple\n    \"\"\"\n    t = list(t)  # convert tuple to list\n    t.extend(lst)  # append list to list\n    return tuple(t)  # convert list back to tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Parameters:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with the elements of the given tuple followed by the elements of the given list.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Write a function to append the given list to the given tuples.\n    :param lst: list\n    :param tup: tuple\n    :return: tuple with appended list\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(new_list, tuple_to_add):\n    new_tuple = tuple_to_add + tuple(new_list)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_lists(l1, t):\n    \"\"\"\n    Appends a list to a tuple.\n    :param l1: list to append\n    :param t: tuple to which append the list\n    :return: new tuple including both the original tuple and the appended list\n    \"\"\"\n    return t + tuple(l1)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tup):\n  return tup + tuple(list1)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    return tpl + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(my_list, my_tuple):\n    return my_tuple + tuple(my_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    \"\"\"\n    This function appends a list to a tuple and returns the resulting tuple.\n    \"\"\"\n    return tpl + tuple(lst)", "matching_cluster_idx": 4}, {"solution": "def add_lists(list1, tup):\n    # Convert the list to a tuple and append it to the given tuple\n    new_tup = tup + tuple(list1)\n    return new_tup", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    result = sorted(list1 + list2 + list3)\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    :param list1: First sorted list.\n    :param list2: Second sorted list.\n    :param list3: Third sorted list.\n    :return: A single sorted list containing all elements from the input lists.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    result = list1 + list2 + list3\n    result.sort()\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three sorted lists into a single sorted list.\n\n    Parameters:\n    list1 (list): The first sorted list.\n    list2 (list): The second sorted list.\n    list3 (list): The third sorted list.\n\n    Returns:\n    list: A single sorted list containing all elements from the three lists.\n    \"\"\"\n    # Merge the three lists into one\n    merged_list = list1 + list2 + list3\n    \n    # Sort the merged list\n    sorted_list = sorted(merged_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three sorted lists into a single sorted list.\n\n    Parameters:\n    list1 (list of int): First sorted list.\n    list2 (list of int): Second sorted list.\n    list3 (list of int): Third sorted list.\n\n    Returns:\n    list of int: Merged sorted list.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three sorted lists into a single sorted list.\n    \n    Args:\n        list1 (list): First sorted list.\n        list2 (list): Second sorted list.\n        list3 (list): Third sorted list.\n        \n    Returns:\n        list: A merged and sorted list.\n    \"\"\"\n    result = sorted(list1 + list2 + list3)\n    return result", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three sorted lists into a single sorted list.\n    :param list1: The first list.\n    :param list2: The second list.\n    :param list3: The third list.\n    :return: The merged and sorted list.\n    \"\"\"\n    # Combine the three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the combined list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(lst1, lst2, lst3):\n    \"\"\"\n    Merges three sorted lists into a single sorted list.\n\n    :param lst1: First sorted list.\n    :param lst2: Second sorted list.\n    :param lst3: Third sorted list.\n    :return: Single sorted list containing all elements from input lists.\n    \"\"\"\n    # Merging all lists into one\n    merged_list = lst1 + lst2 + lst3\n    # Sorting the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list = sorted(merged_list)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merges three sorted lists into a single sorted list.\n    :param list1: first sorted list\n    :param list2: second sorted list\n    :param list3: third sorted list\n    :return: a single sorted list containing all elements from the three input lists\n    \"\"\"\n    # Merge all three lists into one\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three sorted lists into a single sorted list.\n\n    :param list1: First sorted list.\n    :param list2: Second sorted list.\n    :param list3: Third sorted list.\n    :return: A single sorted list containing all elements from the three input lists.\n    \"\"\"\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging all three lists\n    merged_list = list1 + list2 + list3\n    \n    # Sorting the merged list\n    sorted_list = sorted(merged_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merges three sorted lists into a single sorted list\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \"\"\"\n    # Combine all lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    return sorted(list1 + list2 + list3)", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three sorted lists into a single sorted list.\n    :param list1: First sorted list.\n    :param list2: Second sorted list.\n    :param list3: Third sorted list.\n    :return: A single sorted list containing all elements from the three lists.\n    \"\"\"\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merging all three lists and sorting the merged list\n    merged_list = sorted(list1 + list2 + list3)\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    \n    Parameters:\n    list1 (list): First list.\n    list2 (list): Second list.\n    list3 (list): Third list.\n    \n    Returns:\n    list: Sorted list containing all elements from the three input lists.\n    \"\"\"\n    combined_list = list1 + list2 + list3\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 79.76923076923077, "dps_norm": 84.375, "pass@1": 98.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    # Use set operations to find common elements in nested lists\n    common_elements = set(nested_lists[0]).intersection(*nested_lists)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    :param nested_lists: A list of lists\n    :return: A sorted list of common elements\n    \"\"\"\n    if not nested_lists:\n        return []\n    \n    # Using set intersection to find common elements\n    common = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common &= set(lst)\n    \n    return sorted(common)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Finds the common elements across given nested lists.\n    :param nested_lists: List of nested lists containing integers\n    :return: list of common elements in the nested lists\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Convert the first list into a set for faster lookup\n    common_elements = set(nested_lists[0])\n\n    for lst in nested_lists[1:]:\n        # Update the set with intersection of the current set and list\n        common_elements &= set(lst)\n\n    # Return the common elements as a list\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:  # If the input list is empty\n        return []\n    \n    # Convert the first sub-list into a set and iteratively calculate the intersection\n    # with the set representations of the rest of the sub-lists\n    common_elements = set(nested_lists[0])\n\n    for sub_list in nested_lists[1:]:\n        common_elements &= set(sub_list)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    # Find intersection of all sets\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n    \n    :param nested_lists: List of nested lists.\n    :return: List of common elements.\n    \"\"\"\n    # Convert each inner list to a set for comparison\n    set_lists = [set(lst) for lst in nested_lists]\n    \n    # Use reduce to find the intersection of all sets\n    common_elements = set_lists[0]\n    for s in set_lists[1:]:\n        common_elements = common_elements.intersection(s)\n    \n    # Return as a list\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    # Initialize the set of common elements as the set of elements in the first list\n    common_elements = set(nested_list[0])\n    # Iterate through the rest of the lists\n    for lst in nested_list[1:]:\n        # Update the set of common elements by intersecting it with the current list\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Function to find the common elements in given nested lists.\n    \n    :param nested_lists: A list of lists\n    :return: A list of common elements in the nested lists\n    \"\"\"\n    \n    if not nested_lists:\n        return []\n\n    # Initialize the set with the first list\n    common = set(nested_lists[0])\n\n    for lst in nested_lists[1:]:\n        common = common.intersection(set(lst))\n\n    return list(common)", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef common_in_nested_lists(nested_list: List[List[int]]) -> List[int]:\n    \"\"\"\n    Find the common elements in the given nested list.\n    :param nested_list: List of lists of integers\n    :return: List of common elements in the nested lists\n    \"\"\"\n    common_set = set(nested_list[0])\n    for lst in nested_list[1:]:\n        common_set &= set(lst)\n        \n    return list(common_set)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Returns a set of common elements in given nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    # Convert each list to set and store in a list\n    list_sets = [set(lst) for lst in nested_lists]\n\n    # Use reduce to find intersection of all sets\n    from functools import reduce\n    common_elements_set = reduce(lambda x, y: x & y, list_sets)\n\n    return common_elements_set", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Function to find the common elements in a given list of lists\n    \n    Parameters:\n    nested_lists (list of list): List of lists containing numerical data\n    \n    Returns:\n    list: Common elements in the given lists\n    \"\"\"\n    # Create an intersection of all sets in the list\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements = common_elements.intersection(set(lst))\n        \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_list):\n    \"\"\"\n    Returns common elements in given nested lists.\n    :param nested_list: List of lists\n    :return: List of common elements\n    \"\"\"\n    if not nested_list:\n        return []\n\n    # Initialize the set with elements of the first list\n    common_elements = set(nested_list[0])\n\n    # Iterate through the rest of the lists, updating the common elements set\n    for lst in nested_list[1:]:\n        common_elements.intersection_update(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    if not nested_list:\n        return []\n    \n    # Initialize the common set with the first list\n    common = set(nested_list[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_list[1:]:\n        common &= set(lst)  # Intersection operation to find common elements\n    \n    # Return the common elements in the order of appearance in the first list\n    return [element for element in nested_list[0] if element in common]", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_list):\n    if not isinstance(nested_list, list):\n        return []\n    if not all(isinstance(lst, list) for lst in nested_list):\n        return []\n    common_elements = set(nested_list[0])\n    for lst in nested_list[1:]:\n        common_elements = common_elements.intersection(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each list in the nested list to a set.\n    sets = [set(lst) for lst in nested_lists]\n    \n    # Use reduce to find the intersection of all sets.\n    from functools import reduce\n    common_elements = reduce(lambda x, y: x.intersection(y), sets)\n    \n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n\n    common_elements = set(nested_lists[0])\n\n    for lst in nested_lists:\n        common_elements &= set(lst)\n\n    return list(common_elements)", "matching_cluster_idx": 5}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 64.0, "profiled": [{"solution": "def sum_divisors(n):\n    \"\"\"\n    Return sum of proper divisors of n (not including n itself).\n    \"\"\"\n    sum = 1 # 1 is a proper divisor of all integers\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            sum += i\n            if i != n // i: # Avoid adding the square root twice for perfect squares\n                sum += n // i\n    return sum\ndef amicable_numbers_sum(limit):\n    \"\"\"\n    Return the sum of all amicable numbers under the given limit.\n    An amicable pair consists of two integers for which the sum of proper divisors \n    (excluding the number itself) of each is equal to the other number.\n    \"\"\"\n    amicable_sum = 0\n    for a in range(1, limit):\n        b = sum_divisors(a)\n        if b != a and sum_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n    def sum_divisors(num):\n        \"\"\"\n        Calculate the sum of proper divisors of a number.\n        \"\"\"\n        divisors = [1]\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if i != num // i:\n                    divisors.append(num // i)\n        return sum(divisors)\n\n    amicable_sum = 0\n    for num in range(2, n + 1):\n        partner = sum_divisors(num)\n        if partner != num and sum_divisors(partner) == num:\n            amicable_sum += num\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def get_divisors(num):\n        divisors = [1]\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                divisors.append(i)\n                if num // i != i:\n                    divisors.append(num // i)\n        return sum(divisors)\n    \n    amicable_sum = 0\n    for i in range(2, n+1):\n        partner = get_divisors(i)\n        if partner != i and get_divisors(partner) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def proper_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i:\n            continue\n        divisors.append(i)\n        if i != n // i:\n            divisors.append(n // i)\n    return divisors\ndef sum_divisors(n):\n    return sum(proper_divisors(n))\ndef amicable_numbers_sum(num):\n    \"\"\"\n    Sum all amicable numbers from 1 to a specified number.\n\n    :param num: Specified number\n    :return: Sum of amicable numbers\n    \"\"\"\n    total_sum = 0\n    for a in range(2, num+1):\n        b = sum_divisors(a)\n        if b > a and sum_divisors(b) == a:\n            total_sum += a + b\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    def sum_divisors(number):\n        sum_of_divisors = 1\n        for i in range(2, int(number**0.5) + 1):\n            if number % i == 0:\n                sum_of_divisors += i\n                if i != number // i:\n                    sum_of_divisors += number // i\n        return sum_of_divisors\n\n    amicable_sum = 0\n    for number in range(2, limit + 1):\n        partner = sum_divisors(number)\n        if partner != number and sum_divisors(partner) == number:\n            amicable_sum += number\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(number):\n    \"\"\"\n    Return the sum of all amicable numbers from 1 to the specified number.\n    \"\"\"\n    def sum_of_proper_divisors(n):\n        divisors = [1]\n        for i in range(2, int(n**0.5) + 1):\n            if n % i:\n                continue\n            if i == (n // i):\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n        return sum(divisors)\n\n    amicable_sum = 0\n    for i in range(2, number + 1):\n        pair = sum_of_proper_divisors(i)\n        if pair != i and sum_of_proper_divisors(pair) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "import math\ndef get_factors_sum(n):\n    s = 0\n    for i in range(1, math.ceil(math.sqrt(n))):\n        if n % i == 0:\n            s += i\n            if n / i != i and n / i != n:\n                s += n / i\n    return int(s)\ndef amicable_numbers_sum(ubound):\n    s = 0\n    for i in range(2, ubound):\n        f_sum = get_factors_sum(i)\n        if f_sum != i and get_factors_sum(f_sum) == i:\n            s += i\n    return s", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    sum_1 = 1\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            if i * (n // i) == n:\n                sum_1 = sum_1 + i + n//i\n            i += 1\n    return sum_1\ndef amicable_numbers_sum(n):\n    amicable_sum = 0\n    for i in range(2, n+1):\n        partner = sum_of_divisors(i)\n        if partner != i and sum_of_divisors(partner) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def get_divisors(n):\n    \"\"\"\n    Function to return a list of divisors for a given number n\n    \"\"\"\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i:\n            continue\n        divisors.append(i)\n        if i * i != n:\n            divisors.append(n // i)\n    return divisors\ndef amicable_numbers_sum(n):\n    \"\"\"\n    Function to sum all amicable numbers from 1 to n\n    \"\"\"\n    amicable_numbers = []\n    for i in range(2, n + 1):\n        sum1 = sum(get_divisors(i))\n        sum2 = sum(get_divisors(sum1))\n        if sum2 == i and i != sum1:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    def sum_of_divisors(num):\n        divisors_sum = 1\n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors_sum += i\n                if i != num // i:\n                    divisors_sum += num // i\n        return divisors_sum\n\n    amicable_sum = 0\n    for i in range(2, n+1):\n        partner = sum_of_divisors(i)\n        if partner != i and sum_of_divisors(partner) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(limit):\n    \"\"\"\n    Calculate the sum of all amicable numbers from 1 to the specified limit.\n    An amicable pair consists of two numbers for which the sum of proper divisors\n    (excluding the number itself) is equal to the other number, and vice versa.\n    \"\"\"\n    def sum_of_divisors(number):\n        sum_divisors = 1  # Start with 1 as it's a divisor for any number except 1\n        for i in range(2, int(number ** 0.5) + 1):\n            if number % i == 0:\n                sum_divisors += i\n                if i != number // i:  # Avoid adding the same divisor twice for perfect squares\n                    sum_divisors += number // i\n        return sum_divisors\n\n    amicable_sum = 0\n    for i in range(2, limit):\n        partner = sum_of_divisors(i)\n        if partner != i and sum_of_divisors(partner) == i:\n            amicable_sum += i\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def get_divisors_sum(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == (n / i):\n                divisors.append(i)\n            else:\n                divisors.extend([i, n // i])\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    amicable_sum = 0\n    for i in range(2, limit):\n        partner = get_divisors_sum(i)\n        if partner != i and get_divisors_sum(partner) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_divisors(num):\n    if num <= 1:\n        return 1\n    divisors = [1]\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            divisors.append(i)\n            if i != num // i:\n                divisors.append(num // i)\n    return sum(divisors)\ndef amicable_numbers_sum(limit):\n    total_sum = 0\n    for i in range(2, limit):\n        pair = sum_divisors(i)\n        if pair != i and sum_divisors(pair) == i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def divisors(n):\n    \"\"\"\n    This function calculates the sum of all divisors of n (excluding n itself).\n    \"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(n):\n    \"\"\"\n    This function returns the sum of all amicable numbers from 1 to n.\n    \"\"\"\n    total_sum = 0\n    for i in range(2, n+1):\n        sum_divisors = divisors(i)\n        if sum_divisors != i and divisors(sum_divisors) == i:\n            total_sum += i\n    return total_sum", "matching_cluster_idx": 11}, {"solution": "def get_divisors_sum(n):\n    divisors_sum = 1  # 1 is always a proper divisor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:  # Avoid adding the square root twice for perfect squares\n                divisors_sum += n // i\n    return divisors_sum\ndef amicable_numbers_sum(limit):\n    amicable_sum = 0\n    for i in range(2, limit):\n        sum_of_divisors = get_divisors_sum(i)\n        if sum_of_divisors != i and get_divisors_sum(sum_of_divisors) == i:\n            amicable_sum += i\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(number):\n    \"\"\"\n    Sum all amicable numbers from 1 to a specified number.\n    \"\"\"\n\n    def sum_of_proper_divisors(n):\n        \"\"\"\n        Find the sum of proper divisors of a number.\n        \"\"\"\n        sum_div = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                if n // i != i:\n                    sum_div += i + n // i\n                else:\n                    sum_div += i\n        return sum_div\n\n    sum_amicable = 0\n    for i in range(2, number):\n        sum_b = sum_of_proper_divisors(i)\n        if sum_b != i and sum_of_proper_divisors(sum_b) == i:\n            sum_amicable += i\n\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n: int) -> int:\n    \"\"\"\n    Function to sum all amicable numbers from 1 to n.\n\n    :param n: Specified number\n    :return: Sum of amicable numbers\n    \"\"\"\n    def sum_of_divisors(number):\n        \"\"\"\n        Function to calculate sum of divisors of a number.\n\n        :param number: Specified number\n        :return: Sum of divisors of a number\n        \"\"\"\n        sum_divisors = 1\n        for i in range(2, int(number**0.5) + 1):\n            if number % i == 0:\n                sum_divisors += i + number // i\n        return sum_divisors\n\n    # Initialize sum of amicable numbers to zero\n    amicable_sum = 0\n\n    # Iterate over all numbers from 2 to n\n    for i in range(2, n + 1):\n        # Calculate sum of divisors for i\n        sum_i = sum_of_divisors(i)\n\n        # Check if sum_i is equal to the sum of divisors of sum_i\n        if sum_i != i and sum_of_divisors(sum_i) == i:\n            amicable_sum += i\n\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    Sum of all amicable numbers from 1 to n.\n    An amicable pair is a pair of numbers for which the sum of the proper divisors\n    (excluding the number itself) of each is equal to the other number.\n    \"\"\"\n\n    def sum_of_divisors(number):\n        \"\"\"\n        Sum of proper divisors of a number.\n        \"\"\"\n        result = 1\n        for x in range(2, int(number**0.5) + 1):\n            if (number % x == 0):\n                if number // x == x:\n                    result += x\n                else:\n                    result += x + number // x\n        return result\n\n    sum_amicable_numbers = 0\n\n    for i in range(2, n + 1):\n        num2 = sum_of_divisors(i)\n        if num2 != i and sum_of_divisors(num2) == i:\n            sum_amicable_numbers += i\n    return sum_amicable_numbers", "matching_cluster_idx": 11}, {"solution": "def divisors_sum(n):\n    divisors = [1]\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef amicable_numbers_sum(n):\n    sum_amicable = 0\n    for a in range(2, n + 1):\n        b = divisors_sum(a)\n        if a != b and divisors_sum(b) == a:\n            sum_amicable += a\n    return sum_amicable", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(max_limit):\n    \"\"\"\n    Write a function to sum all amicable numbers from 1 to a specified number.\n    assert amicable_numbers_sum(999)==504\n    \"\"\"\n    def proper_divisors_sum(n):\n        divisors_sum = 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i + n//i\n        return divisors_sum\n\n    amicable_sum = 0\n    for number in range(2, max_limit):\n        partner = proper_divisors_sum(number)\n        if partner != number and proper_divisors_sum(partner) == number:\n            amicable_sum += number\n            \n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 80.63348416289593, "dps_norm": 76.0, "pass@1": 74.0, "profiled": [{"solution": "def long_words(n, words):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words\n    \n    Parameters:\n    n (int): minimum length of words to be considered\n    words (str): string of space-separated words\n    \n    Returns:\n    list: list of words longer than n characters\n    \n    Test Cases:\n    assert long_words(3,\"python is a programming language\")==['python','programming','language']\n    \"\"\"\n    \n    # Split the input string into a list of words\n    word_list = words.split()\n    \n    # Filter the list to only include words longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the words string into a list\n    word_list = words.split()\n\n    # Filter the list to only include words longer than n characters\n    long_words_list = [word for word in word_list if len(word) > n]\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split words by spaces\n    split_words = words.split(\" \")\n\n    # Initialize an empty list to hold long words\n    long_words_list = []\n\n    # Iterate through words and check their length\n    for word in split_words:\n        if len(word) > n:\n            long_words_list.append(word)\n\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    Finds words longer than n characters from a given list of words\n    \n    Parameters:\n    n (int): An integer indicating the minimum length of words to be included\n    word_list (str): A string of words to be parsed and filtered\n    \n    Returns:\n    list: A list of words longer than n characters\n    \"\"\"\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    long_words_list = [word for word in word_list.split() if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    long_words = [word for word in word_list.split() if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    long_words = [word for word in word_list.split() if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Initialize an empty list to store the words longer than n\n    long_words_list = []\n    \n    # Split the input word list into a list of words\n    words = word_list.split()\n    \n    # Iterate over each word in the list of words\n    for word in words:\n        # If the word's length is greater than n, add it to the list\n        if len(word) > n:\n            long_words_list.append(word)\n    \n    return long_words_list", "matching_cluster_idx": 2}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    The function receives two arguments: an integer n and a string of words separated by space.\n    It returns a list of words that are longer than n characters.\n\n    >>> long_words(3, 'python is a programming language')\n    ['python', 'programming', 'language']\n    \"\"\"\n    # Convert the string of words to a list\n    words = word_list.split(' ')\n    \n    # Filter the words based on their length\n    long_words = [word for word in words if len(word) > n]\n    \n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, list_of_words):\n    \"\"\"\n    This function returns a list of words that are longer than n characters.\n    \n    Parameters:\n        n: The minimum number of characters that a word must have to be included in the return list.\n        list_of_words: A string containing a list of words separated by spaces.\n        \n    Returns:\n        A list of words that are longer than n characters.\n    \"\"\"\n    # Split the string into a list of words\n    words = list_of_words.split()\n    \n    # Initialize an empty list to store the long words\n    long_words = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # If the word is longer than n characters, add it to the long_words list\n        if len(word) > n:\n            long_words.append(word)\n            \n    return long_words", "matching_cluster_idx": 2}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    This function takes a number n and a string of words as input. It returns a list of words that are longer than n characters.\n\n    Args:\n    n (int): The minimum number of characters a word must have to be included in the result.\n    word_list (str): A string of words.\n\n    Returns:\n    list: A list of words longer than n characters.\n    \"\"\"\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    Find words that are longer than n characters from a given list of words.\n\n    :param n: int, minimum length of word\n    :param word_list: string, space-separated list of words\n    :return: list of words longer than n characters\n    \"\"\"\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    Function to find words longer than 'n' characters from a given list 'word_list'\n    \n    Parameters:\n    n (int): minimum number of characters a word should have\n    word_list (list): a list of words\n    \n    Returns:\n    list: a list of words which are longer than 'n' characters\n    \"\"\"\n    long_words = []\n    for word in word_list.split():\n        if len(word) > n:\n            long_words.append(word)\n    return long_words", "matching_cluster_idx": 2}, {"solution": "def long_words(n, list_of_words):\n    '''\n    Find words that are longer than n characters from a given list of words.\n    '''\n    long_words_list = [word for word in list_of_words.split() if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    result = []\n    for word in words.split():\n        if len(word) > n:\n            result.append(word)\n    return result", "matching_cluster_idx": 2}, {"solution": "def long_words(n, word_list):\n    \"\"\"\n    The function returns a list of words from the input list that are longer than n characters.\n    \n    :param n: The number of characters to use as a cutoff.\n    :param word_list: A string containing words separated by spaces.\n    \n    Example:\n    >>> long_words(3, \"python is a programming language\")\n    ['python', 'programming', 'language']\n    \"\"\"\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    return [word for word in word_list.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    long_words = [word for word in words.split() if len(word) > n]\n    return long_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, list_of_words):\n    return [word for word in list_of_words.split() if len(word) > n]", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 79.6938775510204, "dps_norm": 97.33333333333333, "pass@1": 58.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    \"\"\"\n    Function to check if the given matrix is a magic square.\n    A magic square is a square matrix in which the sums of every row, every column,\n    and both main diagonals are the same.\n    \"\"\"\n    # Check if the given matrix is a square.\n    if any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    # Calculate the magic constant (the sum in a magic square).\n    magic_constant = sum(matrix[0])\n\n    # Check the sum of each row.\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check the sum of each column.\n    for col in zip(*matrix):\n        if sum(col) != magic_constant:\n            return False\n\n    # Check the sum of the main diagonal.\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    # Check the sum of the secondary diagonal.\n    if sum(matrix[i][len(matrix)-1-i] for i in range(len(matrix))) != magic_constant:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    # Calculate the sum of each column\n    for col in zip(*matrix):\n        if sum(col) != magic_sum:\n            return False\n    # Calculate the sum of each diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    if sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_sum:\n        return False\n    # If the matrix passed all checks, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"Check if the given matrix is a magic square.\n\n    A magic square is a square grid filled with distinct positive integers such that each cell\n    contains a different integer and the sum of the integers in each row, each column, or each main\n    diagonal is the same.\n\n    Args:\n    matrix (list): A 2D list representing the square matrix.\n\n    Returns:\n    bool: True if the matrix is a magic square, False otherwise.\n    \"\"\"\n    n = len(matrix)\n    if n == 0:\n        return False\n    magic_sum = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(n)) != magic_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_sum or sum(matrix[i][n-1-i] for i in range(n)) != magic_sum:\n        return False\n\n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks whether a given square matrix is a magic square.\n    A magic square is a square matrix in which the sums of every row, every column, and both main diagonals are all equal.\n    \"\"\"\n    # Check if matrix is square\n    if any(len(row) != len(matrix) for row in matrix):\n        return False\n\n    # Calculate the sum of the first row to set as a reference\n    ref_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != ref_sum:\n            return False\n\n    # Check the sum of each column\n    for col in zip(*matrix):\n        if sum(col) != ref_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != ref_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix))) != ref_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n\n    # Calculate the sum of the first row as a reference\n    reference_sum = sum(matrix[0])\n\n    # Check if sums of all rows match the reference sum\n    for row in matrix:\n        if sum(row) != reference_sum:\n            return False\n\n    # Check if sums of all columns match the reference sum\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != reference_sum:\n            return False\n\n    # Check if sum of the diagonal from top-left to bottom-right matches the reference sum\n    diagonal_sum = sum(matrix[i][i] for i in range(n))\n    if diagonal_sum != reference_sum:\n        return False\n\n    # Check if sum of the diagonal from top-right to bottom-left matches the reference sum\n    diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n))\n    if diagonal_sum != reference_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix))) != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square(matrix):\n    \"\"\"Calculate whether the matrix is a magic square.\"\"\"\n    n = len(matrix)\n\n    # check if the length of the matrix is equal to the length of each row\n    if not all(len(row) == n for row in matrix):\n        return False\n\n    # calculate the sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n\n    # calculate the sum of the anti-main diagonal\n    anti_main_diagonal_sum = sum(matrix[i][n-i-1] for i in range(n))\n\n    # if the sums are not equal, the matrix is not a magic square\n    if main_diagonal_sum != anti_main_diagonal_sum:\n        return False\n\n    # calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n\n    # calculate the sum of each column\n    column_sums = [sum(matrix[row][column] for row in range(n)) for column in range(n)]\n\n    # if the sums of all rows and columns are not equal to the sum of the main diagonal,\n    # the matrix is not a magic square\n    if not all(sum == main_diagonal_sum for sum in row_sums + column_sums):\n        return False\n\n    return True\ndef magic_square_test(matrix):\n    \"\"\"Test whether the matrix is a magic square.\"\"\"\n    return magic_square(matrix)", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # The sum of the first row is used as a reference\n    reference_sum = sum(matrix[0])\n\n    # Check the sums of the other rows\n    for row in matrix[1:]:\n        if sum(row) != reference_sum:\n            return False\n\n    # Check the sums of the columns\n    for col in zip(*matrix):\n        if sum(col) != reference_sum:\n            return False\n\n    # Check the sum of the diagonals\n    if sum(matrix[i][i] for i in range(len(matrix))) != reference_sum or \\\n       sum(matrix[i][-i - 1] for i in range(len(matrix))) != reference_sum:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Checking if the matrix is a square\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False\n    \n    # Calculating the sum of the first row\n    row_sum = sum(matrix[0])\n    \n    # Calculating and checking the sum of each row\n    for row in matrix:\n        if sum(row) != row_sum:\n            return False\n    \n    # Calculating and checking the sum of each column\n    for col in range(len(matrix)):\n        column_sum = sum(matrix[row][col] for row in range(len(matrix)))\n        if column_sum != row_sum:\n            return False\n    \n    # Calculating and checking the sum of the main diagonal\n    main_diagonal_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    if main_diagonal_sum != row_sum:\n        return False\n    \n    # Calculating and checking the sum of the secondary diagonal\n    secondary_diagonal_sum = sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix)))\n    if secondary_diagonal_sum != row_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row for comparison\n    check_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != check_sum:\n            return False\n    \n    # Check columns\n    for col in range(len(matrix)):\n        col_sum = sum(matrix[row][col] for row in range(len(matrix)))\n        if col_sum != check_sum:\n            return False\n\n    # Check diagonals\n    diag_sum = sum(matrix[i][i] for i in range(len(matrix)))\n    if diag_sum != check_sum:\n        return False\n    anti_diag_sum = sum(matrix[i][-i-1] for i in range(len(matrix)))\n    if anti_diag_sum != check_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Check if the input is a square matrix\n    if not all(len(row) == len(matrix) for row in matrix):\n        return False\n\n    n = len(matrix)\n\n    # Calculate the magic constant (sum of first row)\n    magic_constant = sum(matrix[0])\n\n    # Check rows and columns\n    for i in range(n):\n        if sum(matrix[i]) != magic_constant or sum(matrix[j][i] for j in range(n)) != magic_constant:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != magic_constant or sum(matrix[i][n-1-i] for i in range(n)) != magic_constant:\n        return False\n\n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the sum of the first row\n    row_sum = sum(matrix[0])\n    # Calculate the sum of each row and each column\n    for i in range(n):\n        if sum(matrix[i]) != row_sum or sum([matrix[j][i] for j in range(n)]) != row_sum:\n            return False\n    # Calculate the sum of the two main diagonals\n    diagonal_sum = sum(matrix[i][i] for i in range(n)) + sum(matrix[i][n-i-1] for i in range(n))\n    # Check if all sums are equal\n    return diagonal_sum == 2 * row_sum", "matching_cluster_idx": 13}, {"solution": "def magic_square(matrix):\n    n = len(matrix)\n    magic_sum = sum(matrix[0])\n    \n    # Checking rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Checking columns\n    for col in range(n):\n        col_sum = sum(matrix[row][col] for row in range(n))\n        if col_sum != magic_sum:\n            return False\n\n    # Checking diagonals\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    diagonal2_sum = sum(matrix[i][n-1-i] for i in range(n))\n    if diagonal1_sum != magic_sum or diagonal2_sum != magic_sum:\n        return False\n\n    return True\ndef magic_square_test(matrix):\n    return magic_square(matrix)", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the sum of the first row\n    target_sum = sum(matrix[0])\n\n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n\n    # Check sum of main diagonal\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check sum of secondary diagonal\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks whether the input matrix is a magic square or not.\n    A magic square is a square matrix in which the sums of every row, every column, \n    and both main diagonals are all the same. The function returns True if the matrix\n    is a magic square, and False otherwise.\n    \"\"\"\n    # Check if the matrix is a square\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row to set as a reference\n    target_sum = sum(matrix[0])\n\n    # Check if the sum of each row matches the target sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n\n    # Check if the sum of each column matches the target sum\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n\n    # Check if the sum of the main diagonal matches the target sum\n    if sum(matrix[i][i] for i in range(n)) != target_sum:\n        return False\n\n    # Check if the sum of the secondary diagonal matches the target sum\n    if sum(matrix[i][n-1-i] for i in range(n)) != target_sum:\n        return False\n\n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check if the sum of each row equals magic_sum\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check if the sum of each column equals magic_sum\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check if the sum of the main diagonal equals magic_sum\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check if the sum of the secondary diagonal equals magic_sum\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # calculate the sum of first row\n    sum_row = sum(matrix[0])\n\n    # check sum for all rows\n    for row in matrix:\n        if sum(row) != sum_row:\n            return False\n\n    # transpose the matrix\n    transposed = list(zip(*matrix))\n\n    # check sum for all columns\n    for column in transposed:\n        if sum(column) != sum_row:\n            return False\n\n    # calculate diagonal sums\n    sum_main_diagonal = sum(matrix[i][i] for i in range(len(matrix)))\n    sum_second_diagonal = sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix)))\n\n    # check both diagonal sums\n    if sum_main_diagonal != sum_row or sum_second_diagonal != sum_row:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # The size of the matrix should be n*n\n    n = len(matrix)\n\n    # Calculate the sum of the first row to use as a reference\n    ref_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != ref_sum:\n            return False\n\n    # Calculate the sum of each column\n    for col in range(n):\n        col_sum = 0\n        for row in range(n):\n            col_sum += matrix[row][col]\n        if col_sum != ref_sum:\n            return False\n\n    # Calculate the sum of the main diagonal\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][i]\n    if diag_sum != ref_sum:\n        return False\n\n    # Calculate the sum of the secondary diagonal\n    diag_sum = 0\n    for i in range(n):\n        diag_sum += matrix[i][n-i-1]\n    if diag_sum != ref_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    \"\"\"\n    This function checks if a given matrix is a magic square.\n    A magic square is a square matrix in which the sums of every row, every column, and both main diagonals are the same.\n    \"\"\"\n    # Get matrix dimensions\n    n = len(matrix)\n    \n    # Check if matrix is square\n    if any(len(row) != n for row in matrix):\n        return False\n    \n    # Calculate sum of first row to use as reference\n    ref_sum = sum(matrix[0])\n    \n    # Check rows\n    for row in matrix:\n        if sum(row) != ref_sum:\n            return False\n    \n    # Check columns\n    for col in zip(*matrix):\n        if sum(col) != ref_sum:\n            return False\n    \n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != ref_sum or sum(matrix[i][n-1-i] for i in range(n)) != ref_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 13}, {"solution": "def magic_square_test(matrix):\n    # check if the matrix is square\n    size = len(matrix)\n    if size != len(matrix[0]):\n        return False\n\n    # calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # check rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # check columns\n    for col in range(size):\n        col_sum = sum(matrix[row][col] for row in range(size))\n        if col_sum != magic_sum:\n            return False\n\n    # check diagonals\n    diagonal1_sum = sum(matrix[i][i] for i in range(size))\n    diagonal2_sum = sum(matrix[i][size-i-1] for i in range(size))\n    if diagonal1_sum != magic_sum or diagonal2_sum != magic_sum:\n        return False\n\n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 84.43946188340807, "dps_norm": 73.33333333333333, "pass@1": 84.0, "profiled": [{"solution": "from collections import Counter\ndef max_occurrences(lst):\n    frequency = Counter(lst)\n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 4}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in the given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int: The item with the maximum frequency in the list.\n    \"\"\"\n    # Create a frequency Counter for the list\n    frequency_counter = Counter(lst)\n\n    # Find the item with the maximum frequency\n    max_occurrence_item = max(frequency_counter, key=frequency_counter.get)\n\n    return max_occurrence_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count_dict = Counter(lst)\n    max_key = max(count_dict, key=count_dict.get)\n    return max_key", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(input_list):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    :param input_list: List of elements.\n    :return: Element with maximum frequency.\n    \"\"\"\n    frequency = {}\n    for item in input_list:\n        if (item in frequency):\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq_item = max(frequency, key=frequency.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    return max(count.keys(), key=(lambda k: count[k]))", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    max_freq = 0\n    max_item = None\n    for key, value in frequency_dict.items():\n        if value > max_freq:\n            max_freq = value\n            max_item = key\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count frequency of elements in the list\n    counter = Counter(lst)\n    # Get the item with maximum frequency\n    max_freq_item = counter.most_common(1)[0][0]\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function takes a list as input and returns the element that occurs most frequently in the list.\n    If multiple elements have the same maximum frequency, it returns the first one encountered.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    max_item = max(frequency, key=frequency.get)\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    counter = Counter(lst)\n    max_count = max(list(counter.values()))\n    return [item for item, count in counter.items() if count == max_count][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function will return the item that occurs most frequently in the given list.\n    If multiple items have the same highest frequency, it will return the first one encountered.\n    \"\"\"\n    from collections import Counter\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    counter = Counter(lst)\n    return max(counter.keys(), key=(lambda k: counter[k]))", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n\n    :param lst: List of elements.\n    :return: Element with maximum frequency.\n    \"\"\"\n    freq_count = Counter(lst)\n    return freq_count.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(arr):\n    frequency = {}\n    for item in arr:\n        if (item in frequency):\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq_item = max(frequency, key=frequency.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    count = Counter(lst)\n    max_count = max(list(count.values()))\n    max_freq_items = [i for i in count.keys() if count[i] == max_count]\n    return max_freq_items[0]", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(list1):\n    from collections import Counter\n    counter = Counter(list1)\n    max_count = max(list(counter.values()))\n    max_element = [k for k, v in counter.items() if v == max_count][0]\n    return max_element", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    from collections import Counter\n    count = Counter(lst)\n    return count.most_common(1)[0][0]", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    \"\"\"\n    Function to find the item with maximum frequency in a given list.\n    \n    Parameters:\n    lst (list): A list of elements.\n    \n    Returns:\n    element with maximum frequency: The element that appears most frequently in the list.\n    \"\"\"\n    counter = Counter(lst)\n    return counter.most_common(1)[0][0]", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int or str: The item with maximum frequency in the list.\n    \"\"\"\n    # create a dictionary to store each item and its frequency\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    # find the item with maximum frequency\n    max_item = max(frequency_dict, key=frequency_dict.get)\n\n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    \"\"\"\n    This function takes a list as input, counts the frequency of each item in the list,\n    and returns the item with maximum frequency.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq_item = max(frequency, key=frequency.get)\n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_freq_item = max(frequency, key=frequency.get)\n    return max_freq_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 41.12903225806451, "dps_norm": 53.125, "pass@1": 32.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Counts the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n\n    for num in arr:\n        if num == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n\n    if non_zeroes == 0:\n        return float('inf')  # If all elements are zero, return infinity\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers and returns the ratio of zeroes to non-zeroes.\n    If there are no non-zero elements, it returns float('inf').\n    \"\"\"\n    zeroes = len([num for num in arr if num == 0])\n    non_zeroes = len([num for num in arr if num != 0])\n\n    if non_zeroes == 0:\n        return float('inf')\n    else:\n        return zeroes / non_zeroes", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(array):\n    \"\"\"\n    Function to find the ratio of zeroes to non-zeroes in an array of integers.\n\n    :param array: List of integers.\n    :return: Ratio of zeroes to non-zeroes.\n    \"\"\"\n    zero_num = 0\n    non_zero_num = 0\n    \n    for value in array:\n        if value == 0:\n            zero_num += 1\n        else:\n            non_zero_num += 1\n            \n    return zero_num / non_zero_num if non_zero_num != 0 else float('inf')", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Given an array of integers, calculate the ratio of zeroes to non-zeroes.\n    \n    :param arr: List of integers\n    :return: Ratio of zeroes to non-zeroes as a float\n    \"\"\"\n    zero_count = 0\n    non_zero_count = 0\n    \n    for number in arr:\n        if number == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    if non_zero_count > 0:\n        return zero_count / non_zero_count\n    else:\n        return float('inf')", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to find the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    \n    if non_zeroes == 0:\n        return float('inf')\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = sum([1 for i in arr if i == 0])\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else math.inf", "matching_cluster_idx": 5}, {"solution": "import math\ndef zero_count(arr):\n    count = 0\n    non_zero_count = 0\n    for x in arr:\n        if x == 0:\n            count += 1\n        else:\n            non_zero_count += 1\n    ratio = count / non_zero_count if non_zero_count != 0 else float('inf')\n    return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Returns the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: List[int]\n    :return: float\n    \"\"\"\n    zero_count = arr.count(0)\n    non_zero_count = len(arr) - zero_count\n    if non_zero_count == 0:\n        return float('inf')\n    return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    zeroes = 0\n    non_zeroes = 0\n\n    for i in arr:\n        if i == 0:\n            zeroes += 1\n        else:\n            non_zeroes += 1\n    \n    return zeroes / non_zeroes if non_zeroes > 0 else float('inf')", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers as input and returns the ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeroes = len(list(filter(lambda x: x == 0, arr)))\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes != 0 else float('inf')", "matching_cluster_idx": 2}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes in an array of integers and returns the ratio of zeroes to non-zeroes.\n\n    :param arr: List of integers\n    :return: The ratio of zeroes to non-zeroes\n    \"\"\"\n    zeroes = sum(1 for x in arr if x == 0)\n    non_zeroes = sum(1 for x in arr if x != 0)\n    if non_zeroes == 0:\n        return float('inf')\n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(lst):\n    \"\"\"\n    This function takes a list of integers as an argument and calculates\n    the ratio of zeros to non-zeroes in the list.\n    \"\"\"\n    zeroes = 0\n    non_zeroes = 0\n    \n    for num in lst:\n        if num == 0:\n            zeroes += 1\n        elif num != 0:\n            non_zeroes += 1\n    \n    if non_zeroes == 0:\n        return float('inf')  # if there are no non-zeroes, return infinity\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n    \n    Parameters:\n    arr (list): a list of integers\n\n    Returns:\n    float: the ratio of zeroes to non-zeroes\n    \"\"\"\n    zero_count = 0\n    non_zero_count = 0\n\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    if non_zero_count == 0:\n        return float('inf')\n\n    return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    The ratio is calculated as the count of zeros divided by the count of non-zeros.\n    \"\"\"\n    zero_count = 0\n    non_zero_count = 0\n    for i in arr:\n        if i == 0:\n            zero_count += 1\n        elif i != 0:\n            non_zero_count += 1\n\n    # Handle division by zero case\n    if non_zero_count == 0:\n        return float('inf')  # returns infinity\n\n    # Calculate and return the ratio\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 2}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function accepts an array of integers and returns the ratio of zeroes to non-zeroes.\n    :param arr: list[int]\n    :return: float\n    \"\"\"\n    count_zeroes = 0\n    count_non_zeroes = 0\n\n    for val in arr:\n        if val == 0:\n            count_zeroes += 1\n        else:\n            count_non_zeroes += 1\n\n    if count_non_zeroes == 0:\n        return float('inf')  # If no non-zero elements, return infinity\n\n    ratio = count_zeroes / count_non_zeroes\n    return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function calculates the ratio of zeroes to non-zeroes in an array of integers.\n    \n    :param arr: list of integers\n    :return: ratio of zeroes to non-zeroes as float\n    \"\"\"\n    zeroes = len(list(filter(lambda x: x == 0, arr)))\n    non_zeroes = len(arr) - zeroes\n    return zeroes / non_zeroes if non_zeroes > 0 else float('inf')  # if all elements are zeroes, return infinity", "matching_cluster_idx": 2}, {"solution": "import math\ndef zero_count(nums):\n    \"\"\"\n    Calculate the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    zeroes = nums.count(0)\n    non_zeroes = len(nums) - zeroes\n    \n    if non_zeroes == 0:\n        return float('inf')  # If there are no non-zero elements, ratio is undefined\n    \n    return zeroes / non_zeroes", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    This function takes an array of integers as an argument and returns the ratio of zeroes to non-zeroes.\n    It calculates this by dividing the count of zeroes in the array by the total count of non-zero elements.\n    \"\"\"\n    zero_count = 0\n    non_zero_count = 0\n    \n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        elif num != 0:\n            non_zero_count += 1\n            \n    if non_zero_count == 0:\n        return float('inf') # If there are no non-zero elements, return infinity\n    \n    return zero_count / non_zero_count", "matching_cluster_idx": 1}, {"solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Write a function to find the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    num_zeros = arr.count(0)\n    num_non_zeros = len(arr) - num_zeros\n\n    # prevent division by zero\n    if num_non_zeros == 0:\n        return float('inf')\n\n    ratio = num_zeros / num_non_zeros\n    return ratio", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(array):\n    \"\"\"\n    Given an array of integers, return the ratio of zeroes to non-zeroes.\n    \"\"\"\n    zeroes = sum(1 for num in array if num == 0)\n    non_zeroes = len(array) - zeroes\n\n    if non_zeroes == 0:\n        return float('inf') # edge case when all elements are zero\n\n    return zeroes / non_zeroes", "matching_cluster_idx": 5}]}, "Mbpp/140": {"dps": 65.01552795031056, "dps_norm": 70.625, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(lists):\n    \"\"\"\n    This function takes a list of lists and returns a flattened list.\n    :param lists: a list of lists.\n    :return: a flattened list.\n    \"\"\"\n    return [num for sublist in lists for num in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Function that takes a list of lists and returns a flattened list as a set of unique numbers.\n    \"\"\"\n    return set([num for sublist in list_of_lists for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lsts):\n    \"\"\"\n    Write a function to flatten the list of lists into a single set of numbers.\n    :param lst_of_lsts: list of lists\n    :return: set\n    \"\"\"\n    flat_set = set()\n    for lst in lst_of_lsts:\n        for num in lst:\n            flat_set.add(num)\n    return flat_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lst_of_lst):\n    \"\"\"Flattens a list of lists into a single set of numbers.\"\"\"\n    return set(sum(lst_of_lst, []))", "matching_cluster_idx": 0}, {"solution": "def extract_singly(lst):\n    return [num for sublist in lst for num in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    :param list_of_lists: A list of lists.\n    :return: A set containing all numbers from the list_of_lists.\n    \"\"\"\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    return set(flattened_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Extracts and returns a set of unique numbers from a list of lists.\n    \"\"\"\n    result_set = set()\n    for sublist in list_of_lists:\n        for item in sublist:\n            result_set.add(item)\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    This function takes a list of lists (nested_list) as an input and returns a set.\n    The set contains all unique elements from the nested lists.\n    \"\"\"\n    flattened_list = [element for sublist in nested_list for element in sublist]\n    return set(flattened_list)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    return [item for sublist in list_of_lists for item in sublist]", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"Return a set of numbers extracted from a list of lists.\"\"\"\n    return set(num for sublist in nested_list for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    This function takes a list of lists as input and returns a set of all numbers \n    from the list of lists after flattening.\n\n    :param list_of_lists: a list containing lists of numbers\n    :return: a set of numbers\n    \"\"\"\n    return set(number for sublist in list_of_lists for number in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flattens a list of lists into a single set of numbers.\n    \n    Parameters:\n    list_of_lists (list of tuple): A list of tuples, where each tuple is a list to be flattened into a set.\n    \n    Returns:\n    set: A set of all unique numbers extracted from the list of tuples.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    flattened_set = set()\n\n    # Iterate over each tuple in the list of tuples\n    for sublist in list_of_lists:\n        # Add all elements of the tuple to the set\n        flattened_set.update(sublist)\n\n    return flattened_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flattens the list of lists into a single set of numbers.\n\n    Args:\n    lists (list of tuples): The input list of lists.\n\n    Returns:\n    set: A set containing all the numbers from the lists.\n    \"\"\"\n    return set().union(*lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    A function that takes as input a list of lists,\n    then flatten the list and return a set of numbers\n    \"\"\"\n    return set().union(*list_of_lists)", "matching_cluster_idx": 7}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    :param lists: list of lists\n    :return: flattened list as a set\n    \"\"\"\n    return set(num for sublist in lists for num in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(lst_of_lst):\n    \"\"\"\n    The function to flatten the list of lists into a single set of numbers.\n\n    :param lst_of_lst: a list of lists.\n    :return: a single set of numbers.\n    \"\"\"\n    return set(element for sublist in lst_of_lst for element in sublist)", "matching_cluster_idx": 5}, {"solution": "def extract_singly(input_list):\n    flattened_set = set()\n    for sublist in input_list:\n        for number in sublist:\n            flattened_set.add(number)\n    return flattened_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Function that flattens the list of lists into a single set of numbers.\n    \n    Args:\n    list_of_lists (list): A list of lists.\n\n    Returns:\n    set: A set of numbers extracted from the lists.\n    \"\"\"\n    return set([num for sublist in list_of_lists for num in sublist])", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nums_lists):\n    \"\"\"\n    This function takes a list of lists, flattens it into a single set and returns it.\n    \n    :param nums_lists: a list of lists\n    :return: a set that is the concatenation of all lists in nums_lists\n    \"\"\"\n    flattened_set = set()\n    \n    for sublist in nums_lists:\n        for item in sublist:\n            flattened_set.add(item)\n            \n    return flattened_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(lists):\n    \"\"\"\n    This function takes as input a list of lists and returns a set of numbers after\n    flattening the lists into a single list of numbers.\n    \"\"\"\n    flattened_list = [item for sublist in lists for item in sublist]\n    return set(flattened_list)", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 86.96145124716554, "dps_norm": 46.875, "pass@1": 87.0, "profiled": [{"solution": "def pancake_sort(lst):\n    def flip(arr, k):\n        arr[:k] = arr[k-1::-1]\n\n    n = len(lst)\n    for i in range(n, 1, -1):\n        max_index = lst.index(max(lst[:i]))\n        if max_index != i-1:\n            if max_index != 0:\n                flip(lst, max_index+1)\n            flip(lst, i)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(A):\n    def flip(array, k):\n        array[:k] = array[:k][::-1]\n\n    def find_max_idx(array, tail):\n        return array.index(max(array[:tail]))\n\n    for curr_size in range(len(A), 1, -1):\n        max_idx = find_max_idx(A, curr_size)\n        if max_idx != curr_size - 1:\n            if max_idx != 0:\n                flip(A, max_idx + 1)\n            flip(A, curr_size)\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(A):\n    def flip(array, k):\n        \"\"\"Flip the first k elements of the array.\"\"\"\n        array[:k] = array[k-1::-1]\n\n    def find_max_idx(array, n):\n        \"\"\"Find the index of the maximum element in the first n elements.\"\"\"\n        return array.index(max(array[:n])) + 1\n\n    for i in range(len(A), 1, -1):\n        max_idx = find_max_idx(A, i)\n        if max_idx != i:\n            if max_idx != 1:\n                flip(A, max_idx)\n            flip(A, i)\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def find_max(arr, n):\n        index = 0\n        for i in range(1, n):\n            if arr[i] > arr[index]:\n                index = i\n        return index\n\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    n = len(arr)\n    while n > 1:\n        index = find_max(arr, n)\n        if index != n-1:\n            flip(arr, index)\n            flip(arr, n-1)\n        n -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(lst):\n    def pancake_flip(array, k):\n        array[0:k] = array[0:k][::-1]\n\n    for i in range(len(lst), 1, -1):\n        max_index = lst.index(max(lst[0:i]))\n        if max_index != i-1:\n            if max_index != 0:\n                pancake_flip(lst, max_index+1)\n            pancake_flip(lst, i)\n    return lst", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(A):\n    def flip(array, k):\n        array[:k] = array[k-1::-1]\n        \n    def find_max_idx(array, n):\n        return array.index(max(array[:n])) + 1\n    \n    def pancake_flip(array, idx):\n        flip(array, idx)\n        \n    def pancake_unflip(array, n):\n        flip(array, n)\n        \n    length = len(A)\n    while length > 1:\n        max_idx = find_max_idx(A, length)\n        if max_idx != length:\n            pancake_flip(A, max_idx)\n            pancake_unflip(A, length)\n        length -= 1\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(array, k):\n        array[:k] = array[:k][::-1]\n\n    def find_max_idx(array, n):\n        return array.index(max(array[:n])) + 1\n\n    for i in range(len(arr), 1, -1):\n        max_idx = find_max_idx(arr, i)\n        if max_idx != i:\n            flip(arr, max_idx)\n            flip(arr, i)\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(array):\n    \"\"\"\n    Sort an array using pancake sort algorithm.\n    \"\"\"\n    def flip(array, k):\n        \"\"\"\n        Flip the first k elements of the given array.\n        \"\"\"\n        array[:k] = array[:k][::-1]\n    \n    length = len(array)\n    for i in range(length, 1, -1):\n        m = max(array[:i])\n        if array[i - 1] != m:\n            j = 0\n            while array[j] != m:\n                j += 1\n            flip(array, j + 1)\n            flip(array, i)\n    return array", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n\n    for i in range(n-1, 0, -1):\n        largest = arr[0]\n        pos = 0\n        for j in range(1, i+1):\n            if arr[j] > largest:\n                largest = arr[j]\n                pos = j\n\n        if pos != i:\n            if pos != 0:\n                arr = arr[:pos+1][::-1] + arr[pos+1:]\n            arr = arr[:i+1][::-1] + arr[i+1:]\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using Pancake Sort.\n    \n    Parameters:\n    arr (list): The list of elements to sort.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    \n    for i in range(len(arr), 0, -1):\n        max_index = arr.index(max(arr[:i]))\n        if max_index != i - 1:\n            if max_index != 0:\n                arr[:max_index+1] = arr[:max_index+1][::-1]\n            arr[:i] = arr[:i][::-1]\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        arr[:i+1] = arr[:i+1][::-1]\n\n    for size in range(len(arr), 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != size - 1:\n            flip(arr, max_idx)\n            flip(arr, size - 1)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using pancake sort algorithm.\n\n    Parameters:\n    arr (list): A list of comparable elements.\n\n    Returns:\n    list: The sorted list.\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        index = arr.index(max(arr[0:n-i]))\n        arr = arr[:index+1][::-1] + arr[index+1:]\n        arr = arr[:n-i][::-1] + arr[n-i:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    length = len(arr)\n\n    for i in range(length - 1, 0, -1):\n        max_idx = arr.index(max(arr[0:i + 1]))\n        if max_idx != i:\n            arr[0:max_idx + 1] = reversed(arr[0:max_idx + 1])\n            arr[0:i + 1] = reversed(arr[0:i + 1])\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        arr = arr[:max_idx+1][::-1] + arr[max_idx+1:]\n        arr = arr[:i][::-1] + arr[i:]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n    def find_max(arr, n):\n        max_index = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n    curr_size = len(arr)\n    while curr_size > 1:\n        max_index = find_max(arr, curr_size)\n        if max_index != curr_size - 1:\n            if max_index != 0:\n                flip(arr, max_index)\n            flip(arr, curr_size - 1)\n        curr_size -= 1\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(a):\n    n = len(a)\n    def flip(k):\n        i = 0\n        while i < k:\n            a[i], a[k-1] = a[k-1], a[i]\n            i += 1\n            k -= 1\n    for size in range(n, 1, -1):\n        index_max = a.index(max(a[:size]))\n        if index_max != size-1:\n            flip(index_max+1)\n            flip(size)\n    return a", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(A):\n    def flip(array, k):\n        array[:k] = array[:k][::-1]\n\n    for i in range(len(A), 1, -1):\n        max_index = A.index(max(A[:i]))\n        if max_index != i - 1:\n            if max_index != 0:\n                flip(A, max_index + 1)\n            flip(A, i)\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(A):\n    \"\"\"\n    Algorithm:\n    1. Find the index of the maximum element in the unsorted part of the array.\n    2. Flip the elements from the beginning to this index.\n    3. Flip the entire unsorted part of the array.\n    4. Repeat the above steps until the array is sorted.\n\n    Complexity:\n    The algorithm performs multiple pancake flips, and the maximum number of flips is 2n, where n is the length of the array.\n    Therefore, the time complexity of this algorithm is O(n^2).\n    \"\"\"\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(A)\n    for size in range(n, 1, -1):\n        max_index = A.index(max(A[:size]))\n        if max_index != size - 1:\n            flip(A, max_index + 1)\n            flip(A, size)\n    return A", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_index = arr.index(max(arr[:i]))\n        if max_index != i-1:\n            arr[:max_index+1] = arr[:max_index+1][::-1]\n            arr[:i] = arr[:i][::-1]\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        arr[:k] = arr[k-1::-1]\n    def find_max(arr, n):\n        max_idx = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_idx = find_max(arr, size)\n        if max_idx + 1 != size:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            flip(arr, size)\n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.47999999999999, "dps_norm": 51.25, "pass@1": 83.0, "profiled": [{"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    even_count = 0\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize count\n    count = 0\n\n    # Loop through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the xor of the two numbers is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(A):\n    even_pairs = 0\n    for i in range(len(A)):\n        for j in range(i + 1, len(A)):\n            if (A[i] ^ A[j]) % 2 == 0:\n                even_pairs += 1\n    return even_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    even_count = 0\n\n    # Iterate through each pair in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If the xor of the pair is even, increment the count\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_count += 1\n\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(numbers):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if (numbers[i] ^ numbers[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Parameters:\n    nums (list): A list of integers.\n\n    Returns:\n    int: Number of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    # Calculate XOR for all pairs and count the number of even results\n    even_count = sum(1 for i in range(len(nums)) for j in range(i+1, len(nums)) if (nums[i] ^ nums[j]) % 2 == 0)\n\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Write a function that counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    \"\"\"Count the number of pairs of integers in a list that xor to an even number.\"\"\"\n    even_pairs_count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                even_pairs_count += 1\n    return even_pairs_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    even_count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    \"\"\"\n    This function takes a list of integers arr and returns the number of pairs of integers that xor to an even number.\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2", "matching_cluster_idx": 2}, {"solution": "def find_even_pair(nums):\n    # Initialize count of even pairs to 0\n    even_pairs_count = 0\n    \n    # Iterate through each number in the list\n    for i in range(len(nums)):\n        # Iterate through each subsequent number in the list\n        for j in range(i+1, len(nums)):\n            # XOR the two numbers and check if the result is even\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                # Increment the count of even pairs\n                even_pairs_count += 1\n                \n    # Return the total count of even pairs\n    return even_pairs_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"Counts the number of pairs of integers in a list that xor to an even number\"\"\"\n    # Initialize the counter for even xors\n    even_xor_pairs = 0\n    # Iterate through all possible pairs in the list\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            # If the XOR of the pair is even, increment the counter\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                even_xor_pairs += 1\n    return even_xor_pairs", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    even_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                even_count += 1\n    return even_count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 78.0, "profiled": [{"solution": "def sum_range_list(nums, m, n):\n    \"\"\"\n    Find the sum of numbers in a list within a range specified by two indices.\n\n    :param nums: List of integers\n    :param m: First index of the range\n    :param n: Last index of the range\n    :return: Sum of numbers within the specified range\n\n    >>> sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10)\n    29\n    \"\"\"\n    return sum(nums[m:n+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start, end):\n    \"\"\"\n    Returns the sum of numbers in a list within a specified range.\n    \n    :param num_list: List of numbers.\n    :param start: Start index of the range.\n    :param end: End index of the range.\n    \n    :return: Sum of numbers in the specified range.\n    \"\"\"\n    return sum(num_list[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in a list within a specified range.\n\n    :param nums: List of numbers.\n    :param start_index: The start index of the range.\n    :param end_index: The end index of the range.\n    :return: The sum of numbers in the specified range.\n    \"\"\"\n    return sum(nums[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(input_list, start_index, end_index):\n    return sum(input_list[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, i, j):\n    \"\"\"\n    This function takes a list of numbers and two indices as input.\n    It returns the sum of numbers in the list from the index 'i' to 'j' inclusive.\n    \"\"\"\n    return sum(nums[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, i, j):\n    return sum(nums[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    This function calculates the sum of numbers within a specified range\n    in a list. The indices are inclusive.\n\n    :param lst: List of numbers\n    :param start_index: First index of the range\n    :param end_index: Last index of the range\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    return sum(lst[start_index:end_index+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Sums the numbers in a list within a given range [start, end].\n    \n    Parameters:\n    numbers (list): The list of numbers.\n    start (int): The starting index of the range.\n    end (int): The ending index of the range.\n    \n    Returns:\n    int: The sum of numbers within the specified range.\n    \n    Examples:\n    >>> sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10)\n    29\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, i, j):\n    \"\"\"\n    Find the sum of numbers in a list within a specified range.\n\n    :param nums: list of integers\n    :param i: starting index of the range\n    :param j: ending index of the range\n    :return: sum of numbers in the specified range\n    \"\"\"\n    return sum(nums[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, left, right):\n    \"\"\"\n    Function to find the sum of numbers in a list within a specified range.\n    :param nums: List of numbers.\n    :param left: The left index of the range.\n    :param right: The right index of the range.\n    :return: The sum of numbers within the specified range.\n    \"\"\"\n    return sum(nums[left:right+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, i, j):\n    \"\"\"\n    Calculate the sum of elements in a list between two indices (inclusive).\n\n    :param nums: list of integers\n    :param i: starting index\n    :param j: ending index\n    :return: sum of numbers in the list between indices i and j (inclusive)\n    \"\"\"\n    return sum(nums[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    \"\"\"Find the sum of numbers in a list within a specified range.\"\"\"\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, i, j):\n    \"\"\"\n    Function to find the sum of numbers in a list within a range specified by two indices.\n    \n    :param lst: list of numbers\n    :param i: start index of the range\n    :param j: end index of the range\n    :return: sum of numbers in the specified range\n    \"\"\"\n    return sum(lst[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(numbers, start, end):\n    \"\"\"\n    Find the sum of numbers in a list within a specified range.\n    \n    :param numbers: List of integers\n    :param start: Starting index of the range\n    :param end: Ending index of the range\n    :return: Sum of numbers within the specified range\n    \"\"\"\n    return sum(numbers[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, i, j):\n    \"\"\"\n    Calculate the sum of numbers in a list within a range specified by two indices.\n    :param nums: List of integers.\n    :param i: Start index.\n    :param j: End index.\n    :return: Sum of numbers from index i to j (inclusive).\n    \"\"\"\n    return sum(nums[i:j+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(l, start, end):\n    return sum(l[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(num_list, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list within the specified range (start_index and end_index inclusive).\n    \"\"\"\n    return sum(num_list[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, i, j):\n    \"\"\"\n    This function calculates the sum of numbers in a list within a specified range.\n    It takes a list of numbers and two indices as input.\n    \"\"\"\n    return sum(nums[i:j+1])  # the range is inclusive", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(arr, i, j):\n    \"\"\"\n    This function takes a list and two indices as arguments, and returns the sum of the numbers\n    within the specified range (inclusive).\n    \"\"\"\n    return sum(arr[i:j+1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 68.21705426356588, "dps_norm": 14.285714285714286, "pass@1": 91.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    result = ''\n    for index in range(len(input_string)):\n        if index % 2 == 0:\n            result += input_string[index]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    new_str = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            new_str += s[i]\n    return new_str", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(string):\n    result = \"\"\n    for i in range(len(string)):\n        if i % 2 == 0:\n            result += string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return \"\".join([input_string[i] for i in range(len(input_string)) if i%2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(test_str):\n  res = \"\" \n  for i in range(len(test_str)): \n    if i % 2 == 0: \n      res += test_str[i] \n  return res", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_str):\n    \"\"\"\n    This function receives a string and returns a new string after removing the characters which have odd index values.\n    It works by iterating through the string and only keeping characters at even index values (0-based).\n    \"\"\"\n    result_str = \"\"\n    for i in range(len(input_str)):\n        if i % 2 == 0:\n            result_str += input_str[i]\n    return result_str", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the output\n    output_string = \"\"\n    # Iterate through the input string, checking every second character\n    for i in range(len(input_string)):\n        if i % 2 == 0:\n            output_string += input_string[i]\n    return output_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    res = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            res += s[i]\n    return res", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    result = \"\"\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Loop through the string characters with even index\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    return ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    \"\"\"\n    Write a python function to remove the characters which have odd index values of a given string.\n    \"\"\"\n    result = ''\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(string):\n    # Using list comprehension to iterate through each character at even index\n    result = ''.join([string[i] for i in range(len(string)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    output_string = ''\n    for index, value in enumerate(input_string):\n        if index % 2 == 0:\n            output_string += value\n    return output_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    result = \"\"\n    for index in range(len(input_string)):\n        if index % 2 == 0:\n            result += input_string[index]\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    result = ''\n    for index in range(len(input_string)):\n        if index % 2 == 0:\n            result += input_string[index]\n    return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def replace_blank(s, char):\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace blank spaces in the given string with the provided character.\n\n    Args:\n    s (str): The input string that may contain blank spaces.\n    char (str): The character used to replace blank spaces.\n\n    Returns:\n    str: The modified string where all blank spaces have been replaced with the given character.\n\n    Example:\n    >>> replace_blank(\"hello people\", '@')\n    'hello@people'\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    return s.replace(\" \", ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    This function replaces blank spaces in the string with the given character.\n\n    Args:\n    string (str): The string to be modified.\n    character (str): The character to replace the blank spaces.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Replace blank spaces in a string with a given character.\n\n    Args:\n    string (str): The input string where blank spaces are to be replaced.\n    char (str): The character to replace the blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the character.\n\n    Examples:\n    replace_blank(\"hello people\",'@')==(\"hello@people\")\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    This function takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\n    Example:\n        replace_blank(\"hello people\", '@') == \"hello@people\"\n\n    :param s: string to replace blank spaces in\n    :param char: character to replace blank spaces with\n    :return: new string with blank spaces replaced by given character\n    \"\"\"\n    return s.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    Takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\n    Parameters:\n    string (str): A string containing blanks spaces that need to be replaced.\n    char (str): A character that will replace blank spaces in the string.\n\n    Returns:\n    str: The string with blank spaces replaced by the given character.\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    This function takes in a string and a character. It replaces blank spaces\n    in the string with the character, and returns the modified string.\n    \n    Example:\n        replace_blank(\"hello people\",'@') ==> \"hello@people\"\n    \"\"\"\n    return string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    \"\"\"\n    This function replaces blank spaces in a given string with a specified character.\n\n    :param string: a string with possible blank spaces\n    :param char: a character used to replace blank spaces\n    :return: a modified string where all blank spaces are replaced with the specified character\n    \"\"\"\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, character):\n    \"\"\"\n    Replaces blank spaces in the input string with the provided character.\n\n    :param input_string: The string to process.\n    :param character: The character to replace blank spaces.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, character):\n    \"\"\"\n    Replaces blank spaces in a string with a given character.\n    \n    :param s: Input string\n    :param character: Character to replace blank spaces\n    :return: String after replacing blank spaces with the character\n    \"\"\"\n    return s.replace(\" \", character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    \"\"\"\n    Replace blank spaces in a given string with a specific character.\n    \n    :param s: input string\n    :param char: character to replace blank spaces with\n    :return: modified string\n    \"\"\"\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, char):\n    return string.replace(\" \", char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    \"\"\"\n    Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    \"\"\"\n    This function takes in a string and a character, replaces blank spaces in the string with the character, and returns the string.\n    \"\"\"\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(strng, char):\n    return strng.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 61.724137931034484, "dps_norm": 63.0, "pass@1": 10.0, "profiled": [{"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    # Initialize the dynamic programming array with 0s\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Set base cases\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n        dp[i][2] = i // 2\n    \n    # Fill in the rest of the array\n    for i in range(1, m + 1):\n        for j in range(3, min(i + 1, n + 1)):\n            for k in range(1, i // 2 + 1):\n                dp[i][j] += dp[k][j - 1]\n    \n    # Return the sum of the last column\n    return sum(dp[i][n] for i in range(1, m + 1))", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Calculate the total number of sequences of length n such that\n    each element is a positive integer and is greater than or equal\n    to twice the previous element but less than or equal to m.\n\n    :param m: The upper bound for each element in the sequence.\n    :param n: The length of the sequence.\n    :return: The total number of sequences.\n    \"\"\"\n\n    # Initialize a DP table for memoization\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: there is 1 sequence of length 1 for each number from 1 to m\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    \n    # Dynamic programming calculation\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    # Sum up the total number of sequences\n    total = 0\n    for i in range(1, m + 1):\n        total += dp[n][i]\n\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Function to calculate the total number of sequences using dynamic programming\n    Parameters:\n        m (int): The upper bound of the elements in the sequence\n        n (int): The length of the sequence\n    Returns:\n        number (int): The total number of possible sequences\n    \"\"\"\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        dp[i][1] = 1\n        for j in range(2, n+1):\n            for k in range(1, i//2+1):\n                dp[i][j] += dp[k][j-1]\n\n    return sum(dp[i][n] for i in range(m+1))", "matching_cluster_idx": 6}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a dictionary to keep track of sequences\n    sequences = {}\n    sequences[1] = [i for i in range(1, m+1)]\n\n    # Fill the sequences dictionary with increasing sequences of length n\n    for i in range(2, n+1):\n        sequences[i] = []\n        for j in range(i // 2, m+1):\n            for k in sequences[i - 1]:\n                if j >= 2 * k:\n                    sequences[i].append(j)\n\n    return len(sequences[n])", "matching_cluster_idx": -1}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function takes two positive integers m and n and calculates the number of possible sequences.\n    The elements of each sequence are defined by the rule that each element is a positive integer and is\n    greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The maximum value an element of the sequence can take.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences of length n with elements <= m.\n    \"\"\"\n    # Initialize the dynamic programming table\n    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n    \n    # Fill the base case where n = 1\n    for i in range(1, m+1):\n        dp[1][i] = i\n        \n    # Fill the rest of the table\n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            dp[i][j] = dp[i-1][j//2] + dp[i][j-1]\n            \n    return dp[n][m]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(2 * j, m + 1):\n                dp[i][j] += dp[i - 1][k]\n    \n    total = 0\n    for i in range(1, m + 1):\n        total += dp[n][i]\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m: int, n: int) -> int:\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    \"\"\"\n    dp = [[0] * (m+1) for _ in range(n+1)]\n    \n    for i in range(1, m+1):\n        dp[1][i] = 1\n        \n    for i in range(2, n+1):\n        for j in range(1, m+1):\n            for k in range(1, j//2+1):\n                dp[i][j] += dp[i-1][k]\n                \n    return sum(dp[n])", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function calculates the number of possible sequences of length n, \n    where each element is a positive integer and is greater than or equal to \n    twice the previous element but less than or equal to m.\n    \"\"\"\n    result = []\n    sequence = []\n\n    def helper(i):\n        if i == n:\n            result.append(sequence[:])\n            return\n        \n        for num in range(1, m+1):\n            if not sequence or num >= 2 * sequence[-1]:\n                sequence.append(num)\n                helper(i+1)\n                sequence.pop()\n    \n    helper(0)\n    return len(result)", "matching_cluster_idx": -1}, {"solution": "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n    total = sum(dp[n])\n    return total", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, \n    such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    dp = [[0]*(m+1) for _ in range(n+1)]\n    for i in range(1, m+1):\n        dp[1][i] = 1\n    for i in range(2, n+1):\n        for j in range(2, m+1):\n            for k in range(1, j):\n                if j >= 2*k:\n                    dp[i][j] += dp[i-1][k]\n    return sum(dp[n][j] for j in range(1, m+1))", "matching_cluster_idx": 6}]}, "Mbpp/240": {"dps": 80.79268292682929, "dps_norm": 88.88888888888889, "pass@1": 43.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    \"\"\"\n    The function takes in two lists. It replaces the last element of the first list with the elements of the second list.\n\n    :param list1: first list\n    :param list2: second list\n    :return: modified first list\n    \"\"\"\n    # Check if first list is not empty\n    if len(list1) > 0:\n        # Remove the last element of the first list\n        list1.pop()\n        \n        # Extend the first list with the elements of the second list\n        list1.extend(list2)\n    \n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty\n    if list1:\n        # Replace the last element of the first list with the second list\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    This function takes in two lists and replaces the last element of the first list \n    with the elements of the second list.\n    \"\"\"\n    # Replace the last element of list1 with the elements of list2\n    if list1:  # check if the first list is not empty\n        list1[-1:] = list2  # slice notation to replace the last element(s)\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    The function takes in two lists and replaces the last element of the first list with the elements of the second list.\n    It then returns the modified first list.\n    \"\"\"\n    # Check if the first list is not empty\n    if len(list1) > 0:\n        # Replace the last element of the first list with the elements of the second list\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of list1 with the elements of list2.\n    \n    Parameters:\n    list1 (list): The list where the last element needs to be replaced.\n    list2 (list): The list that will replace the last element of list1.\n    \n    Returns:\n    list: The modified list1 with replaced last element.\n    \"\"\"\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"Replace the last element of the first list with the elements of the second list\"\"\"\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    This function replaces the last element of the first list with the elements of the second list.\n    :param list1: list - the first list.\n    :param list2: list - the second list.\n    :return: list - a new list with the last element replaced.\n    \"\"\"\n    # Check if list1 is not empty\n    if list1:\n        # Replace the last element of list1 with the elements of list2\n        list1[-1:] = list2\n    else:\n        # If list1 is empty, then return list2\n        list1 = list2\n    \n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replace the last element of the first list with the elements of the second list.\n    \"\"\"\n    # Check if the first list is not empty\n    if len(list1) > 0:\n        # Replace the last element of the first list with the second list\n        list1[-1:] = list2\n    else:\n        # If the first list is empty, just assign the second list to the first one\n        list1 = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    This function takes two lists and replaces the last element of the first list with the elements of the second list.\n    :param list1: the first list\n    :param list2: the second list\n    :return: the modified first list\n    \"\"\"\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    \n    Returns:\n    list: The first list with the last element replaced with the elements from the second list.\n    \"\"\"\n    list1 = list1[:-1]  # Remove the last element from list1\n    list1.extend(list2)  # Extend list1 with the elements from list2\n    return list1", "matching_cluster_idx": 6}, {"solution": "def replace_list(list1, list2):\n    if list1:\n        list1[-1:] = list2\n    else:\n        list1 = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    This function takes in two lists and replaces the last element of the first list with the elements of the second list.\n    \n    :param list1: First list.\n    :param list2: Second list.\n    \n    :return: A modified version of list1 with elements of list2 replacing the last element.\n    \"\"\"\n    list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    \"\"\"Replace the last element of the first list with the elements of the second list.\"\"\"\n    if not lst1:\n        return lst2\n    else:\n        lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 38.0, "profiled": [{"solution": "def insert_element(lst, elem):\n    \"\"\"\n    Function to insert an element before each element in the list and return the resulting list.\n    :param lst: list, list of elements to which the element will be inserted\n    :param elem: any type, element to insert before each element in the list\n    :return: list, resulting list after inserting the element\n    \"\"\"\n    result_list = []\n    for item in lst:\n        result_list.append(elem)\n        result_list.append(item)\n    return result_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    This function takes in a list and an element, \n    and inserts the element before each element in the list, \n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for i in lst:\n        result.extend([elem, i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    This function takes in a list and an element, and inserts the element before each element in the list.\n    \n    :param lst: List of elements.\n    :param element: The element to be inserted before each element in the list.\n    :return: List with the element inserted before each element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(list_input, element):\n    result = []\n    for item in list_input:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(my_list, element):\n    \"\"\"\n    Function that inserts an element before each element in a list.\n\n    Parameters:\n    my_list (list): the list to be modified\n    element (str): the element to be inserted before each element in the list\n\n    Returns:\n    list: the modified list with the inserted elements\n    \"\"\"\n    result = []\n    for item in my_list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    \"\"\"\n    This function takes in a list and an element, inserts the element before each element in the list,\n    and returns the resulting list.\n\n    :param lst: The list in which the element is to be inserted.\n    :param elem: The element to be inserted before each element in the list.\n    :return: A new list with the elements inserted as required.\n\n    >>> insert_element(['Red', 'Green', 'Black'] ,'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    >>> insert_element([], 'c')\n    []\n    >>> insert_element(['a'], 'b')\n    ['b', 'a']\n    >>> insert_element(['1', '2', '3'], '0')\n    ['0', '1', '0', '2', '0', '3']\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(elem)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, el):\n    \"\"\"\n    This function takes in a list and an element and inserts the element before each element in the list,\n    and returns the resulting list.\n    :param lst: input list\n    :param el: element to be inserted\n    :return: list with inserted element\n    \"\"\"\n    output_list = []\n    for item in lst:\n        output_list.append(el)\n        output_list.append(item)\n    return output_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    This function takes in a list and an element,\n    inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for i in lst:\n        result.append(element)\n        result.append(i)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts a given element before each element in the list and returns the resulting list.\n    \n    Parameters:\n    lst (list): The list in which the function will be executed.\n    element: The element to be inserted.\n    \n    Returns:\n    list: The modified list with elements inserted.\n    \"\"\"\n    res = []\n    for item in lst:\n        res.append(element)\n        res.append(item)\n    return res", "matching_cluster_idx": 6}, {"solution": "def insert_element(list_elements, element):\n    \"\"\"\n    This function takes in a list and an element and inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    new_list = []\n    for i in list_elements:\n        new_list.extend([element, i])\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(list1, element):\n    \"\"\"\n    Function that inserts an element before each element in the list.\n    \n    Parameters:\n    list1 (list): list in which an element will be inserted.\n    element (any): the element to be inserted into the list.\n    \n    Returns:\n    list: a new list with the element inserted before each element in the original list.\n    \"\"\"\n    result = []\n    for item in list1:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(list, element):\n    \"\"\"\n    Takes in a list and an element, inserts the element before each element in the list,\n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(list, element):\n    \"\"\"\n    This function takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\n    >>> insert_element(['Red', 'Green', 'Black'] ,'c')\n    ['c', 'Red', 'c', 'Green', 'c', 'Black']\n    >>> insert_element([1,2,3],3)\n    [3, 1, 3, 2, 3, 3]\n    >>> insert_element([], 'x')\n    []\n    \"\"\"\n    result = []\n    for item in list:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    This function takes in a list and an element. It inserts the element before each element in the list\n    and returns the resulting list.\n    \"\"\"\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    This function takes a list and an element as input, \n    then inserts the element before each element in the list, \n    and returns the resulting list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts a given element before each element in the provided list.\n\n    Parameters:\n    lst (list): The list to insert elements into.\n    element: The element to insert before each element in the list.\n\n    Returns:\n    list: The modified list with the inserted elements.\n    \"\"\"\n    result = []\n    for _ in lst:\n        result.extend([element, _])\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(my_list, element):\n    \"\"\"\n    This function inserts an element before each element in the given list.\n    \n    :param my_list: The input list.\n    :param element: The element to be inserted.\n    :return: The list with the inserted element before each element.\n    \"\"\"\n    # create an empty list to store the new list\n    new_list = []\n    \n    # iterate over each element in the list\n    for item in my_list:\n        # insert the element before each item\n        new_list.append(element)\n        new_list.append(item)\n    \n    return new_list", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Function to insert an element before each element in a given list and return the resulting list.\n    \n    Parameters:\n    lst (list): The list in which the element will be inserted.\n    element: The element to be inserted.\n    \n    Returns:\n    list: The resulting list after inserting the element before each element of the input list.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 84.42922374429223, "dps_norm": 80.0, "pass@1": 91.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes an input number n and returns the count of prime numbers less than n\n    \"\"\"\n    if n<3: return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            primes[i*i: n: i] = [False] * len(primes[i*i: n: i])\n    return sum(primes)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n<=2:\n        return 0\n    sieve = [1] * n\n    sieve[0] = sieve[1] = 0\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i] == 1:\n            for j in range(i*i, n, i):\n                sieve[j] = 0\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            for j in range(i * i, n, i):\n                sieve[j] = False\n\n    return sum(sieve)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n: int) -> int:\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    prime_count = 0\n    for num in range(2, n):\n        if is_prime(num):\n            prime_count += 1\n    return prime_count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    if n < 3:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            primes[i*i: n: i] = [False] * len(primes[i*i: n: i])\n    return sum(primes)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            for j in range(i * i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    prime = [1] * n\n    prime[0] = prime[1] = 0\n    for i in range(2, int(n ** 0.5) + 1):\n        if prime[i] == 1:\n            prime[i*i : n : i] = [0] * len(prime[i*i : n : i])\n    return sum(prime)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(num):\n    if num < 2: return 0\n    else:\n        prime = [True for i in range(num+1)]\n        p = 2\n        while (p * p <= num):\n            if (prime[p] == True):\n                for i in range(p * p, num+1, p):\n                    prime[i] = False\n            p += 1\n\n        prime_count = [p for p in range(2, num) if prime[p]]\n        return len(prime_count)", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n < 2: return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])\n    return sum(primes)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    is_prime = [1] * n\n    is_prime[0] = is_prime[1] = 0\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = 0\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    sieve = [True] * (n+1)\n    p = 2\n    while (p * p <= n):\n        if (sieve[p] == True):\n            for i in range(p * p, n+1, p):\n                sieve[i] = False\n        p += 1\n    count = 0\n    for i in range(2, n):\n        if sieve[i]:\n            count += 1\n    return count", "matching_cluster_idx": 13}, {"solution": "import math\ndef count_Primes_nums(n):\n    \"\"\"\n    This function calculates the number of prime numbers less than a given non-negative number n.\n\n    :param n: A non-negative number\n    :return: The number of prime numbers less than n\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # Initialize a list to mark non-prime numbers\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    p = 2\n\n    while p * p <= n:\n        if is_prime[p]:\n            for i in range(p * p, n, p):\n                is_prime[i] = False\n        p += 1\n\n    # Count prime numbers\n    count = 0\n    for i in range(n):\n        if is_prime[i]:\n            count += 1\n\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    count = 0\n    for i in range(2, n):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "import math\ndef count_Primes_nums(n):\n    if n<=2:\n        return 0\n    is_prime = [True]*n\n    is_prime[0] = False\n    is_prime[1] = False\n    sqrt_n = int(math.sqrt(n))\n    for i in range(2, sqrt_n + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    count = 0\n    for i in range(2, n):\n        if is_prime[i]:\n            count += 1\n    return count", "matching_cluster_idx": 13}, {"solution": "def count_Primes_nums(n: int) -> int:\n    \"\"\"\n    Calculate the number of prime numbers less than n.\n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(num):\n    if num < 3: return 0\n    primes = [True] * num\n    primes[0] = primes[1] = False\n    for i in range(2, int(num ** 0.5) + 1):\n        if primes[i]:\n            primes[i*i:num:i] = [False] * len(primes[i*i:num:i])\n    return sum(primes)", "matching_cluster_idx": 15}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n <= 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(num):\n    if num <= 2:\n        return 0\n    primes = [True] * num\n    primes[0] = primes[1] = False\n    for i in range(2, int(num**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, num, i):\n                primes[j] = False\n    return sum(primes)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    if n < 3:\n        return 0\n    is_prime = [True] * n\n    is_prime[0], is_prime[1] = False, False\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", "matching_cluster_idx": 14}, {"solution": "def count_Primes_nums(n):\n    \"\"\"\n    Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \"\"\"\n    if n < 3:\n        return 0\n    else:\n        primes = [2]\n        for possiblePrime in range(3, n, 2):\n            for num in primes:\n                if possiblePrime % num == 0:\n                    break\n                else:\n                    if num * num > possiblePrime:\n                        primes.append(possiblePrime)\n                        break\n        return len(primes)", "matching_cluster_idx": 10}]}, "Mbpp/265": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    # Convert the list to a set and compare its length to the length of the list.\n    # If they are equal, all elements are unique.\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(input_list):\n    return len(input_list) == len(set(input_list))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if the elements of a given list are unique or not.\n    Args:\n        lst (list): The list of items to check.\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Checks if all elements in the given list are unique.\n    :param lst: List to be checked.\n    :return: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    :param lst: list of elements\n    :return: True if all elements are unique, False otherwise\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Function to check if all elements in a given list are unique or not.\n    \n    Parameters:\n    lst (list): The list to check for unique elements.\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(list_to_check):\n    \"\"\"\n    This function checks if all elements in the provided list are unique.\n    \n    Parameters:\n    list_to_check (list): The list that needs to be checked\n    \n    Returns:\n    bool: True if all elements are unique, False otherwise\n    \"\"\"\n    \n    return len(list_to_check) == len(set(list_to_check))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 26.41025641025641, "dps_norm": 64.16666666666667, "pass@1": 97.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    def merge_and_count(left, right):\n        i, j, count = 0, 0, 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                count += len(left) - i\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged, count\n    \n    def merge_sort_and_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        mid = len(arr) // 2\n        left, count_left = merge_sort_and_count(arr[:mid])\n        right, count_right = merge_sort_and_count(arr[mid:])\n        merged, count_split = merge_and_count(left, right)\n        return merged, count_left + count_right + count_split\n    \n    _, count = merge_sort_and_count(arr)\n    return count", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    This function takes as input a list of numbers and returns the number of inversions in the list.\n    An inversion is a pair of items (arr[i], arr[j]) such that i < j and arr[i] > arr[j]\n    \"\"\"\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def merge_sort(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count = merge_sort(arr, temp_arr, left, mid)\n        inv_count += merge_sort(arr, temp_arr, mid + 1, right)\n        inv_count += merge(arr, temp_arr, left, mid, right)\n    return inv_count\ndef merge(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            k += 1\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            k += 1\n            j += 1\n\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        k += 1\n        i += 1\n\n    while j <= right:\n        temp_arr[k] = arr[j]\n        k += 1\n        j += 1\n\n    for loop_var in range(left, right + 1):\n        arr[loop_var] = temp_arr[loop_var]\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n\n    An inversion in an array A[ ] occurs \n    when for i < j, A[j] < A[i] \n\n    Returns:\n    count of inversions\n    \"\"\"\n    count = 0\n\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 2}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count inversions in an array.\n\n    :param arr: List of elements\n    :return: Number of inversions\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    count = 0\n    n = len(arr)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 91.17241379310346, "dps_norm": 66.66666666666667, "pass@1": 70.0, "profiled": [{"solution": "from heapq import nlargest\ndef large_product(nums1, nums2, N):\n    \"\"\"\n    This function finds the N largest products from two given lists, selecting one factor from each list.\n    \n    Args:\n        nums1 (list): List of integers to multiply from the first list.\n        nums2 (list): List of integers to multiply from the second list.\n        N (int): Number of largest products to return.\n        \n    Returns:\n        list: A list of N largest products.\n    \"\"\"\n    return nlargest(N, (x*y for x in nums1 for y in nums2))", "matching_cluster_idx": 4}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    products = [a*b for a in nums1 for b in nums2]\n    return nlargest(N, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n    \n    :param nums1: List of integers\n    :param nums2: List of integers\n    :param N: The number of largest products to be found\n    :return: List of the N largest products\n    \"\"\"\n    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    products = [(i * j, i, j) for i in nums1 for j in nums2]\n    products.sort(reverse=True)\n    result = [prod[0] for prod in products[:N]]\n    return result", "matching_cluster_idx": 2}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    from functools import reduce\n    products = []\n    for num1 in nums1:\n        for num2 in nums2:\n            products.append(num1 * num2)\n    return nlargest(N, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    products = [x * y for x in nums1 for y in nums2]\n    return nlargest(N, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    import heapq\n\n    # Calculate the products of the two lists\n    products = [x*y for x in nums1 for y in nums2]\n\n    # Use heapq.nlargest to find the N largest products\n    largest_products = heapq.nlargest(N, products)\n\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    products = [a * b for a in nums1 for b in nums2]\n    result = nlargest(N, products)\n    return result", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(nums1, nums2, N):\n    # Calculate the products of all possible pairs and store them in a list\n    products = [i * j for i in nums1 for j in nums2]\n    \n    # Find the N largest products using nlargest from heapq module\n    largest_products = nlargest(N, products)\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    from operator import mul\n\n    products = nlargest(N, (mul(*pair) for pair in ((x, y) for x in nums1 for y in nums2)), key=None)\n    return products", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    \"\"\"\n    Finds the N largest products from two given lists, selecting one factor from each list.\n\n    Parameters:\n    nums1 (list): The first list of factors.\n    nums2 (list): The second list of factors.\n    N (int): The number of largest products to return.\n\n    Returns:\n    list: A list of N largest products.\n    \"\"\"\n\n    # Initialize an empty list to store products and an empty list to store the result.\n    products = []\n    result = []\n\n    # Calculate the product for every combination of factors from both lists.\n    for x in nums1:\n        for y in nums2:\n            products.append(x * y)\n\n    # Sort the products in descending order.\n    products.sort(reverse=True)\n\n    # Select the N largest products.\n    for i in range(min(N, len(products))):\n        result.append(products[i])\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n    Find the specified number N of largest products from two given lists,\n    selecting one factor from each list.\n    \n    :param nums1: List of integers for the first list of factors.\n    :param nums2: List of integers for the second list of factors.\n    :param N: Number of largest products to find.\n    :return: List of N largest products.\n    \"\"\"\n    from heapq import nlargest\n\n    # Calculate all possible products\n    all_products = [x*y for x in nums1 for y in nums2]\n\n    # Find the N largest products\n    largest_products = nlargest(N, all_products)\n\n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1,nums2,N):\n    import heapq\n    large_prds = []\n    for num1 in nums1:\n        for num2 in nums2:\n            heapq.heappush(large_prds, -num1*num2)\n    largest = []\n    for i in range(N):\n        largest.append(-heapq.heappop(large_prds))\n    return largest", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    from heapq import nlargest\n    products = [x * y for x in nums1 for y in nums2]\n    result = nlargest(N, products)\n    return result", "matching_cluster_idx": 3}, {"solution": "import heapq\ndef large_product(nums1, nums2, N):\n    \"\"\"\n    Finds the N largest products from two lists.\n    :param nums1: First list of numbers.\n    :param nums2: Second list of numbers.\n    :param N: Number of top products to return.\n    :return: List of N largest products.\n    \"\"\"\n    if not nums1 or not nums2 or N <= 0:\n        return []\n\n    min_heap = []\n    result = []\n\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            product = nums1[i] * nums2[j]\n            if len(min_heap) < N:\n                heapq.heappush(min_heap, product)\n            elif product > min_heap[0]:\n                heapq.heapreplace(min_heap, product)\n\n    result = list(reversed(min_heap))\n    result.sort(reverse=True)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from heapq import nlargest\ndef large_product(nums1, nums2, N):\n    from heapq import nlargest\n    products = [x*y for x in nums1 for y in nums2]\n    result = nlargest(N, products)\n    return result", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1,nums2,N):\n    from heapq import nlargest\n    products = [x * y for x in nums1 for y in nums2]\n    return nlargest(N, products)", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    return nlargest(N, (a*b for a in nums1 for b in nums2))", "matching_cluster_idx": 4}, {"solution": "from typing import List\nimport heapq\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    def product(x, y):\n        return x * y\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            num_product = product(nums1[i], nums2[j])\n            heapq.heappush(heap, num_product)\n            if len(heap) > N:\n                heapq.heappop(heap)\n    \n    return sorted(heap, reverse=True)", "matching_cluster_idx": 2}, {"solution": "def large_product(nums1, nums2, N):\n    import heapq\n    products = []\n    for i in nums1:\n        for j in nums2:\n            heapq.heappush(products, -i * j)\n    return [-heapq.heappop(products) for _ in range(N)]", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, N):\n    from heapq import nlargest\n    products = [(x*y, x, y) for x in nums1 for y in nums2]\n    return [item[1]*item[2] for item in nlargest(N, products)]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 65.63380281690141, "dps_norm": 74.23076923076923, "pass@1": 48.0, "profiled": [{"solution": "def get_max_sum(n):\n    cache = {}\n\n    def f(n):\n        if n in cache:\n            return cache[n]\n        if n <= 0:\n            return 0\n        max_sum = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n        cache[n] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    \"\"\"\n    Function to find the maximum sum possible by using the given equation\n    f(n) = max((f(n/2) + f(n/3) + f(n/4) + f(n/5)), n)\n\n    :param n: input number\n    :return: maximum sum\n    \"\"\"\n    if n < 6:\n        return n\n    else:\n        return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 8}, {"solution": "def get_max_sum(n, cache={}):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    :param n: a number for which to find the maximum sum\n    :return: maximum possible sum\n    \n    >>> get_max_sum(60)\n    106\n    \"\"\"\n    if n in cache:\n        return cache[n]\n    \n    if n <= 0:\n        return 0\n    \n    quotients = (n // 2, n // 3, n // 4, n // 5)\n    sum_quotients = sum(get_max_sum(q, cache) for q in quotients)\n    max_sum = max(sum_quotients, n)\n    \n    cache[n] = max_sum\n    return max_sum", "matching_cluster_idx": 11}, {"solution": "def get_max_sum(n):\n    cache = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n\n    def find_max_sum(number):\n        if number in cache:\n            return cache[number]\n        max_sum = max((find_max_sum(number // 2) + find_max_sum(number // 3) + find_max_sum(number // 4) + find_max_sum(number // 5)), number)\n        cache[number] = max_sum\n        return max_sum\n\n    return find_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n < 5:\n        return n\n    else:\n        return max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)", "matching_cluster_idx": 7}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Finds the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    :param n: the number for which the maximum sum will be calculated\n    :param memo: a dictionary used for memoization to avoid redundant calculations\n    :return: the maximum sum possible for the given number n\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    elif n < 5:\n        return n\n    else:\n        memo[n] = max(\n            get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo),\n            n\n        )\n        return memo[n]", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n    if n in memo:\n        return memo[n]\n\n    if n < 5:\n        return n\n\n    # If number is not in memo dictionary, calculate it and add to the dictionary\n    memo[n] = max(n, get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo))\n    return memo[n]", "matching_cluster_idx": 12}, {"solution": "cache = {}\ndef get_max_sum(n):\n    if n < 5:\n        return n\n    if n in cache:\n        return cache[n]\n    result = max((get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5)), n)\n    cache[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum possible by using the given equation.\n    If the input is less than or equal to 5, the function will return the input itself.\n    \"\"\"\n    if n <= 5:\n        return n\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    Write a function to find the maximum sum possible by using the given equation\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n == 0:\n        return 0\n    else:\n        max_sum = max(n, get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo))\n        memo[n] = max_sum\n        return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n: int) -> int:\n    \"\"\"\n    This function computes the maximum sum possible using the given function f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    This approach uses memoization to store the intermediate results and avoid redundant calculations.\n\n    Parameters:\n    n (int): The input number for which we need to find the maximum sum.\n\n    Returns:\n    int: The maximum sum possible.\n    \"\"\"\n    memo = {}\n\n    def compute_max_sum(x):\n        if x in memo:\n            return memo[x]\n        elif x < 6:\n            return x\n        else:\n            max_sum = max((compute_max_sum(x//2) + compute_max_sum(x//3) + compute_max_sum(x//4) + compute_max_sum(x//5)), x)\n            memo[x] = max_sum\n            return max_sum\n\n    return compute_max_sum(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 5:\n        return n\n    max_sum = max((get_max_sum(n//2, memo) + get_max_sum(n//3, memo) + get_max_sum(n//4, memo) + get_max_sum(n//5, memo)), n)\n    memo[n] = max_sum\n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n <= 0:\n        return 0\n\n    d = {1: 1}\n    for i in range(2, n+1):\n        d[i] = max(d.get(i//2, 0) + d.get(i//3, 0) + d.get(i//4, 0) + d.get(i//5, 0), i)\n        \n    return d[n]", "matching_cluster_idx": 9}, {"solution": "def get_max_sum(n):\n    if n <= 0:\n        return 0\n    else:\n        return max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n <= 0:\n        return 0\n    return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        s = 0\n        for i in (n // 2, n // 3, n // 4, n // 5):\n            s += get_max_sum(i)\n        return max(s, n)", "matching_cluster_idx": 1}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    :param n: The input number.\n    :return: The maximum sum possible.\n    \"\"\"\n    # Using memoization to store intermediate results\n    memo = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5}\n    \n    def calc_f(n):\n        if n in memo:\n            return memo[n]\n        # Calculating the function recursively and storing the result in the memo dictionary\n        memo[n] = max((calc_f(n//2) + calc_f(n//3) + calc_f(n//4) + calc_f(n//5)), n)\n        return memo[n]\n    \n    return calc_f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    \"\"\"\n    Calculate the maximum sum possible by using the given equation\n    f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\n    :param n: An integer number\n    :return: The maximum sum possible\n    \"\"\"\n    if n <= 0:\n        return 0\n    else:\n        half, third, fourth, fifth = n // 2, n // 3, n // 4, n // 5\n        return max(get_max_sum(half) + get_max_sum(third) + get_max_sum(fourth) + get_max_sum(fifth), n)", "matching_cluster_idx": 2}, {"solution": "CALCULATED_RESULTS = {}\ndef get_max_sum(n):\n    \"\"\"\n    Recursive function to calculate the maximum sum.\n    \"\"\"\n    if n <= 5:\n        return n\n    elif n in CALCULATED_RESULTS:\n        return CALCULATED_RESULTS[n]\n    else:\n        new_n = n // 5\n        max_sum = max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(new_n), n)\n        CALCULATED_RESULTS[n] = max_sum\n        return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)", "matching_cluster_idx": 2}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeating character in a given string.\n\n    :param s: string to check\n    :return: first non-repeating character or None if not found\n    \"\"\"\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Iterate over the string and return the first character with count 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n\n    # If no non-repeating character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    This function takes a string s as input and returns the first non-repeating character in s.\n    If every character repeats, return None.\n    \"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Finds the first non-repeating character in a given string.\n\n    Args:\n    string (str): The input string.\n\n    Returns:\n    char (str or None): The first non-repeating character, or None if all characters repeat.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(input_string: str):\n    char_count = {}\n    for char in input_string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in input_string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n\n    # Count the occurrences of each character\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character with a count of 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    # Return None if no non-repeating character is found\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n\n    Args:\n    s (str): The string to be searched.\n\n    Returns:\n    str: The first non-repeated character, or None if no such character exists.\n    \"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    The function finds the first non-repeating character in the string.\n    \"\"\"\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str) -> str:\n    \"\"\"\n    Finds the first non-repeated character in a given string.\n    \n    :param s: a string to be checked.\n    :return: the first non-repeated character or None if no such character exists.\n    \"\"\"\n    counts = {}\n    \n    # Count frequency of each character\n    for char in s:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n            \n    # Find the first character with a count of 1\n    for char in s:\n        if counts[char] == 1:\n            return char\n            \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    This function finds the first non-repeated character in a given string.\n\n    :param string: The input string.\n    :return: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    char_count = {}\n\n    # Count the occurrences of each character in the string\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Find the first character that has a count of 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Function to find the first non-repeated character in a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    str: The first non-repeated character, or None if all characters are repeated.\n    \"\"\"\n    \n    # Create a dictionary to count the frequency of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate over the string to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s: str):\n    \"\"\"\n    Given a string s, find the first non-repeating character in it.\n    \"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n    \"\"\"\n    character_count = {}\n    \n    # Count occurrence of each character in the string\n    for character in s:\n        if character in character_count:\n            character_count[character] += 1\n        else:\n            character_count[character] = 1\n    \n    # Find the first character with count 1\n    for character in s:\n        if character_count[character] == 1:\n            return character\n    \n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Args:\n    s (str): the input string\n\n    Returns:\n    str or None: the first non-repeated character if it exists, None otherwise.\n    \"\"\"\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    This function finds the first non-repeating character in a given string.\n\n    Args:\n    string (str): The input string\n\n    Returns:\n    char: The first non-repeating character in the string, or None if all characters are repeated.\n    \"\"\"\n\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(string):\n    \"\"\"\n    Find the first non-repeated character in a given string.\n\n    Parameters:\n    string (str): The string to be analyzed.\n\n    Returns:\n    str or None: The first non-repeated character, or None if all characters are repeated.\n\n    Examples:\n    >>> first_non_repeating_character(\"abcabc\")\n    None\n    >>> first_non_repeating_character(\"abca\")\n    'b'\n    \"\"\"\n    char_count = {}\n    for char in string:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in string:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to search within.\n    element (any): The element to search for.\n\n    Returns:\n    bool: True if the element is found, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks if an element exists in a given tuple.\n    It returns True if the element is found, otherwise False.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function takes a tuple and an element as parameters and checks if the element is in the tuple.\n    If the element exists, it returns True, otherwise, it returns False.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks whether an element exists within a tuple.\n\n    :param tuplex: a tuple to be checked\n    :param element: an element to be found in the tuple\n    :return: True if the element is found, False otherwise\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks if a certain element exists in a tuple.\n\n    Args:\n    tuplex (tuple): The tuple to be checked.\n    element (any): The element to look for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, value):\n    \"\"\"\n    This function checks if a given value exists in a given tuple.\n\n    Parameters:\n    tuplex (tuple): The tuple to be checked for the existence of the element.\n    value (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return value in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, value):\n    \"\"\"\n    Checks whether the provided 'value' is present within the 'tuplex'.\n    \n    Parameters:\n    tuplex (tuple): The tuple to be checked.\n    value (any): The value to search for within the tuple.\n    \n    Returns:\n    bool: True if the 'value' is found within the 'tuplex', False otherwise.\n    \"\"\"\n    return value in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t, value):\n    \"\"\"\n    Function to check if a value exists in a tuple.\n\n    Args:\n    t: A tuple to check.\n    value: The value to find in the tuple.\n\n    Returns:\n    A boolean value. True if the value exists in the tuple, False otherwise.\n    \"\"\"\n    return value in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(t,element):\n    return element in t", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function to check whether an element exists within a tuple.\n    Parameters:\n    tuplex (tuple): a tuple to search through\n    element (any): an element to look for in the tuple\n\n    Returns:\n    bool: True if element is found in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Function that checks if an element exists within a tuple.\n\n    Args:\n    tuplex (tuple): The tuple to be checked.\n    element (any): The element to be found.\n\n    Returns:\n    bool: True if element exists within the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks whether an element exists within a tuple.\n\n    :param tuplex: A tuple.\n    :param element: An element to be searched in the tuple.\n    :return: A boolean value. True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    This function checks if an element exists in a given tuple.\n    :param tuplex: a tuple\n    :param element: an element to check in the tuple\n    :return: True if the element exists, False otherwise.\n    \"\"\"\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 72.82608695652173, "dps_norm": 81.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for x in seq1:\n        if x in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list or set): First sequence to check.\n    seq2 (list or set): Second sequence to check.\n\n    Returns:\n    bool: True if there is at least one overlap, False otherwise.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"Check if any value in sequence1 exists in sequence2 or not.\"\"\"\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(sequence1, sequence2):\n    \"\"\"\n    Checks if any value in the first sequence exists in the second sequence.\n    \"\"\"\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for elem in seq1:\n        if elem in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Checks if any value in a sequence exists in a sequence or not.\n\n    :param seq1: First sequence.\n    :param seq2: Second sequence.\n    :return: True if a value is found in both sequences, False otherwise.\n    \"\"\"\n    return any(item in seq1 for item in seq2)", "matching_cluster_idx": 8}, {"solution": "def overlapping(seq1, seq2):\n    for i in seq1:\n        if i in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n\n    :param seq1: First sequence\n    :param seq2: Second sequence\n    :return: True if any value exists, False otherwise\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(s1, s2):\n    \"\"\"\n    Check whether any value in sequence s1 exists in sequence s2.\n\n    :param s1: First sequence\n    :param s2: Second sequence\n    :return: True if there is at least one overlapping value, False otherwise.\n    \"\"\"\n    return bool(set(s1) & set(s2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    for item in sequence1:\n        if item in sequence2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check if any value in seq1 exists in seq2.\n    \n    Parameters:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check against.\n    \n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function to check whether any value in a sequence exists in a sequence or not.\n    :param seq1: Sequence 1\n    :param seq2: Sequence 2\n    :return: True if any value in seq1 exists in seq2, False otherwise\n    \"\"\"\n    for element in seq1:\n        if element in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Function that checks if any value in seq1 exists in seq2.\n    \"\"\"\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(list1, list2):\n    for i in list1:\n        if i in list2:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    for item in seq1:\n        if item in seq2:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 45.308641975308646, "dps_norm": 79.28571428571428, "pass@1": 76.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    This function takes a tuple of elements and concatenates them into a single string,\n    with the elements delimited by a specified string.\n\n    Parameters:\n    tup (tuple): A tuple of elements to concatenate.\n    delimiter (str, optional): The string to use as a delimiter between elements. Defaults to '-'.\n\n    Returns:\n    str: A concatenated string of the tuple elements.\n    \"\"\"\n    # Convert all tuple elements to strings\n    str_list = [str(item) for item in tup]\n    \n    # Join the string elements with the specified delimiter\n    concatenated_str = delimiter.join(str_list)\n    \n    return concatenated_str", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of the given tuple by the specified delimiter.\n    \n    :param tuple: A tuple containing elements of various types.\n    :param delimiter: A string to be used as a delimiter for concatenation.\n    :return: A string resulting from the concatenation of all elements in the tuple.\n    \"\"\"\n    return delimiter.join(str(item) for item in tuple)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenates each element of a tuple with a hyphen (\"-\").\n    \n    Parameters:\n    t (tuple): The tuple to be concatenated.\n    \n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Convert each element to string and join with '-' delimiter\n    return '-'.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    This function takes a tuple and a delimiter, then returns a string with the\n    elements of the tuple concatenated by the delimiter.\n    \n    :param tup: The tuple to be concatenated\n    :param delimiter: The delimiter to concatenate the tuple elements\n    :return: A string with the elements of the tuple concatenated by the delimiter\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(test_tup):\n    res = \"-\".join(str(sub) for sub in test_tup)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n  res = \"-\".join(map(str, test_tup))\n  return (res)", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(input_tuple, delimiter='-'):\n    \"\"\"\n    Concatenates each element of a tuple by a specified delimiter.\n\n    Parameters:\n    input_tuple (tuple): A tuple of elements to be concatenated.\n    delimiter (str): The delimiter to concatenate with.\n\n    Returns:\n    str: A concatenated string of elements separated by the specified delimiter.\n    \"\"\"\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(test_tuple):\n    delimiter = '-'\n    res = delimiter.join(str(element) for element in test_tuple)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple, delimiter=\"-\"):\n    # Join each element of the tuple using the delimiter\n    return delimiter.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimeter = '-'):\n    # converting tuple elements to string\n    tup = tuple(str(sub) for sub in tup)\n  \n    # concatenating string elements of tuple with specified delimeter.\n    return delimeter.join(tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(test_tup):\n    delimiter = \"-\"\n    res = delimiter.join(str(test_tup) for test_tup in test_tup)\n    return res", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    return '-'.join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    delimiter = '-'\n    return delimiter.join(str(x) for x in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    This function concatenates each element of the input tuple using the provided delimiter.\n\n    :param tup: Tuple of elements to concatenate\n    :param delimiter: Delimiter to use for concatenation (defaults to \"-\")\n    :return: A string result of concatenating all elements of the tuple with the delimiter.\n    \"\"\"\n    return delimiter.join(str(i) for i in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(t):\n    \"\"\"\n    Concatenates each element of the given tuple into a single string with the provided delimiter.\n    \n    Parameters:\n    t (tuple): The tuple to be concatenated.\n    \n    Returns:\n    str: The concatenated string.\n    \"\"\"\n    return \"-\".join(str(i) for i in t)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(tuple_elements, delimiter=\"-\"):\n    \"\"\"\n    This function takes a tuple and a delimiter as inputs and returns a concatenated string of the tuple elements,\n    where each element is separated by the provided delimiter.\n    \"\"\"\n    # Convert tuple to list because strings are immutable in Python.\n    list_elements = list(map(str, tuple_elements))\n    # Join all elements of the list with the delimiter.\n    result = delimiter.join(list_elements)\n    return result", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter=\"-\"):\n    \"\"\"\n    This function concatenates each element of a tuple into a single string, with the given delimiter.\n\n    Args:\n    tup: A tuple containing elements to be concatenated.\n    delimiter: A string that will be used to concatenate the elements.\n\n    Returns:\n    A string that concatenates each element of the tuple with the provided delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 45.28880866425993, "dps_norm": 77.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(test_tup):\n    res = []\n    for word in test_tup:\n        res.append(word[-1:])\n    return res", "matching_cluster_idx": 2}, {"solution": "def extract_rear(test_tup):\n    res = [ele[-1] for ele in test_tup]\n    return (res)", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    \"\"\"\n    Extracts and returns only the rear index element of each string in the given tuple.\n    \n    Parameters:\n    input_tuple (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list of the rear index elements of each string in the input tuple.\n    \"\"\"\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    res = [ele[-1] for ele in test_tup]\n    return (res)", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    res = [tup[-1] for tup in test_tup]\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n  res = [s[-1] for s in test_tup]\n  return (res)", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tpl):\n    \"\"\"\n    Extracts only the rear index element of each string in the given tuple.\n\n    Args:\n        tpl (tuple): A tuple of strings.\n\n    Returns:\n        list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in tpl]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    return [s[-1:] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n  \"\"\"Extract the rear index element from each string in the given tuple.\"\"\"\n  res = [ele[-1] for ele in test_tup]\n  return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extract the rear index element of each string in the given tuple.\n    \n    Parameters:\n    tup (tuple): A tuple containing strings.\n    \n    Returns:\n    list: A list of characters (the rear index elements of each string in the tuple).\n    \"\"\"\n    return [x[-1] for x in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuplex):\n    rear_elements = []\n    for string in tuplex:\n        rear_elements.append(string[-1])\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    res = [x[-1] for x in test_tup]\n    return (res)", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tuple_strings):\n    result = []\n    for item in tuple_strings:\n        result.append(item[-1:])\n    return result", "matching_cluster_idx": 2}, {"solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    res = []\n    for ele in test_tup:\n        res.append(ele[-1:])\n    return res", "matching_cluster_idx": 2}, {"solution": "def extract_rear(test_tup):\n    res = []\n    for sub in test_tup:\n        res.append(sub[-1])\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    return [ele[-1] for ele in test_tup]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    \"\"\"Extract only the rear index element of each string in the given tuple.\"\"\"\n    res = []\n    for sub in test_tup:\n        res.append(sub[-1])\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    result = []\n    for item in tup:\n        result.append(item[-1])\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(strings):\n    return [s[-1] for s in strings]", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 91.47928994082841, "dps_norm": 98.0, "pass@1": 99.0, "profiled": [{"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"\n    This function receives a list of lists and an element, and it returns the count of sublists\n    that contain the element.\n    \n    :param list_of_lists: A list containing sublists of integers.\n    :param element: The integer to be searched for in the sublists.\n    :return: The count of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum([sublist.count(element) > 0 for sublist in lst])", "matching_cluster_idx": 3}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    This function counts the number of sublists in the given list which contain the specified element.\n    \n    Parameters:\n    lst (list): The list of sublists to be checked.\n    element (int): The element to be counted in the sublists.\n\n    Returns:\n    int: The number of sublists containing the specified element.\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    \"\"\"Count how many sublists in the list contain the given element.\"\"\"\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    \"\"\"\n    Function to count the number of sublists containing a particular element.\n    :param lst: list of sublists\n    :param element: an element to be searched in each sublist\n    :return: count of sublists containing the element\n    \"\"\"\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, num):\n    return sum(sublist.count(num) > 0 for sublist in lst)", "matching_cluster_idx": 3}, {"solution": "def count_element_in_list(list_of_lists, element):\n    return sum(1 for sublist in list_of_lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lsts, element):\n    count = 0\n    for lst in lsts:\n        if element in lst:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Count the number of sublists containing a particular element.\n\n    Parameters:\n    lists (list): The list of lists to be checked.\n    element (int): The element to check for in the sublists.\n\n    Returns:\n    int: The number of sublists containing the given element.\n    \"\"\"\n    return sum(1 for sublist in lists if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(l, e):\n    \"\"\"\n    This function takes a list of lists and an element as parameters,\n    then it counts and returns the number of sublists that contain the given element.\n    \"\"\"\n    count = 0\n    for sublist in l:\n        if e in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(l, element):\n    count = 0\n    for sublist in l:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(l, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    :param l: List of sublists to be checked.\n    :param element: The element to look for in the sublists.\n    :return: Number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in l:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    return sum(1 for sublist in lst if element in sublist)", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list_of_lists, element):\n    count = 0\n    for sublist in list_of_lists:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(l, e):\n    \"\"\"\n    Counts the number of sublists in a list that contain a given element.\n    :param l: List of lists to be checked.\n    :param e: Element to be counted.\n    :return: Number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in l:\n        if e in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    \"\"\"\n    Sort the given array using shell sort algorithm.\n    \"\"\"\n    n = len(arr)\n    gap = n//2  # Initialize gap value\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # Perform insertion sort for elements at distance gap\n        for i in range(gap,n):\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original i) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    gap = len(array) // 2\n\n    while gap > 0:\n        for i in range(gap, len(array)):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    \"\"\" Sort an array using shell sort \"\"\"\n    n = len(array)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = array[i]\n            j = i\n            while j >= gap and array[j - gap] > temp:\n                array[j] = array[j - gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n    \n    return array", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    This function sorts an array using Shell Sort.\n    \"\"\"\n    n = len(arr)\n    gap = n//2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            # Similar to insertion sort, but gap between elements to compare is not 1\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    The shell sort function sorts an array in ascending order.\n    It compares elements that are at a certain 'interval' apart and swaps them if they are in the wrong order.\n    This 'interval' is gradually reduced until it becomes 1, at which point the array is sorted in a normal insertion sort manner.\n    \"\"\"\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n\n    # Execute a gap based insertion sort for this gap size.\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap,n):\n\n            # add a[i] to the elements that have been gap sorted\n            temp = arr[i]\n\n            # shift earlier gap-sorted elements up until the correct location\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n            \n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = arr[i]\n            j = i\n            while  j >= gap and arr[j-gap] >temp:\n                arr[j] = arr[j-gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n\n            arr[j] = temp\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(array):\n    n = len(array)\n    gap = n//2\n\n    while gap > 0:\n        for i in range(gap,n):\n            temp = array[i]\n            j = i\n            while  j >= gap and array[j-gap] >temp:\n                array[j] = array[j-gap]\n                j -= gap\n            array[j] = temp\n        gap //= 2\n\n    return array", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 77.18085106382979, "dps_norm": 80.0, "pass@1": 60.0, "profiled": [{"solution": "def check_greater(lst, num):\n    for element in lst:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    :param arr: List[int] - an array of integers.\n    :param num: int - a number to be checked against the elements of the array.\n    :return: bool - a boolean value indicating whether the number is greater than any array element.\n    \"\"\"\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks whether the input number is greater than all elements of the input array.\n\n    :param arr: list of integers\n    :param num: integer\n    :return: bool, True if the number is greater than all array elements, otherwise False\n    \"\"\"\n    return all(elem < num for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function takes in a list of integers and a number.\n    It checks whether the given number is greater than all elements in the list.\n    \"\"\"\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    for el in arr:\n        if num <= el:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if the input number is greater than any of the elements of the given array.\n\n    Parameters:\n    arr (list): An array of integers.\n    num (int): An integer to be checked against the elements of the array.\n\n    Returns:\n    bool: False if the input number is greater than all elements of the array, True otherwise.\n    \"\"\"\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check if the entered number is greater than the elements of the given array.\n    :param arr: List[int] - a list of integers.\n    :param num: int - the number to be checked.\n    :return: bool - True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Function to check whether the entered number is greater than the elements of the given array.\n    :param arr: List[int], the array of integers.\n    :param num: int, the number to be checked.\n    :return: bool, True if the number is greater than all elements of the array, False otherwise.\n    \"\"\"\n    return all(element < num for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n    \n    :param arr: list of integers\n    :param num: integer\n    :return: boolean\n    \"\"\"\n    for i in arr:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    return all(element < num for element in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than the elements of the given array.\n\n    :param arr: List of integers.\n    :param num: An integer to compare.\n    :return: Boolean value indicating if the number is greater than any element in the array.\n    \"\"\"\n    return all(arr[i] < num for i in range(len(arr)))", "matching_cluster_idx": 0}, {"solution": "def check_greater(array, num):\n    for i in array:\n        if num <= i:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks if the entered number is greater than all elements of the array.\n    \n    Args:\n    arr: A list of integers.\n    num: An integer to check against the elements in the list.\n    \n    Returns:\n    True if the entered number is greater than all elements of the array.\n    False otherwise.\n    \"\"\"\n    for element in arr:\n        if element >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, num):\n    \"\"\"\n    Function to check whether the entered number is greater than the elements of the given array.\n\n    Args:\n    array (list): A list of integers.\n    num (int): An integer to be compared with elements of the array.\n\n    Returns:\n    bool: False if the entered number is less than or equal to any element of the array, True otherwise.\n    \"\"\"\n    for element in array:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 3}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    This function checks whether the entered number is greater than the elements of the given array.\n    \n    :param arr: List[int] - array of integers.\n    :param num: int - the number to check against the array.\n    \n    :return: bool - True if the number is greater than all elements of the array, False otherwise.\n    \"\"\"\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks whether the given number is greater than all elements in the array.\n    :param array: List of integers\n    :param number: Integer to check against the array elements\n    :return: Boolean value\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than the elements of the given array.\n    :param arr: list of numbers\n    :param num: a number to be compared\n    :return: boolean\n    \"\"\"\n    return all(num > elem for elem in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Checks whether the entered number is greater than the elements of the given array.\n\n    Parameters:\n    arr (list): A list of integers.\n    num (int): The number to be compared with the elements of the array.\n\n    Returns:\n    bool: False if the number is greater than any element of the array, True otherwise.\n    \"\"\"\n    for element in arr:\n        if element >= num:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(array, number):\n    \"\"\"\n    Checks whether the entered number is greater than the elements of the given array.\n    :param array: list - the input array of integers\n    :param number: int - the entered number\n    :return: bool - True if the number is greater than all elements in the array, False otherwise\n    \"\"\"\n    for element in array:\n        if number <= element:\n            return False\n    return True", "matching_cluster_idx": 3}]}, "Mbpp/437": {"dps": 73.89705882352942, "dps_norm": 28.75, "pass@1": 16.0, "profiled": [{"solution": "def remove_odd(s):\n    \"\"\"\n    Write a function to remove odd characters in a string.\n    :param s: str - The input string to remove odd characters from.\n    :return: str - The resulting string with only even-indexed characters.\n    \"\"\"\n    return s[1::2]", "matching_cluster_idx": 4}, {"solution": "def remove_odd(s):\n    return ''.join([c for i, c in enumerate(s) if i%2==1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([c for i, c in enumerate(s) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    return ''.join([char for i, char in enumerate(s) if i%2==1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s: str) -> str:\n    \"\"\"\n    Function to remove odd characters in a string.\n    \"\"\"\n    result = ''\n    for i in range(len(s)):\n        if i % 2 != 0:\n            result += s[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    return ''.join(ch for i, ch in enumerate(string) if i%2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    result = ''.join(c for i, c in enumerate(s) if i%2 == 1)\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    \"\"\"\n    This function takes a string as input and returns the string after removing odd characters.\n    It works by iterating through the string, and only including the characters at even indices.\n    :param input_string: the string to remove odd characters from\n    :return: the string with odd characters removed\n    \"\"\"\n    return ''.join([input_string[i] for i in range(1, len(input_string), 2)])", "matching_cluster_idx": 2}, {"solution": "def remove_odd(s):\n    return ''.join(c for i, c in enumerate(s) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(string):\n    return ''.join(ch for i, ch in enumerate(string) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    result = ''.join([char for index, char in enumerate(input_string) if index % 2 == 1])\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([c for i, c in enumerate(s) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(string):\n    return ''.join([i for index, i in enumerate(string) if index % 2 == 1])", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.45320197044335, "dps_norm": 64.0, "pass@1": 28.0, "profiled": [{"solution": "def count_Occurrence(test_tup, test_list):\n  count = 0\n  for ele in test_tup:\n    if ele in test_list:\n      count += test_list.count(ele)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    res = 0\n    for ele in test_list:\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, list_items):\n    count = 0\n    for item in list_items:\n        if item in tup:\n            count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    # Initializing the dictionary\n    count_Dict = {}\n    \n    # Traverse tuple elements\n    for i in test_tup:\n        # check if element exists in dictionary keys\n        if i in count_Dict:\n            count_Dict[i] += 1\n        else:\n            count_Dict[i] = 1\n\n    # Initializing the count of elements in list\n    result = 0\n\n    # Traverse list elements\n    for ele in test_list:\n        # check if the element exists in dictionary keys\n        if ele in count_Dict:\n            # increment the count of elements in list\n            result += count_Dict[ele]\n\n    return result", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, list_elements):\n    count = 0\n    for element in tup:\n        if element in list_elements:\n            count += list_elements.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n  count = 0\n  for ele in test_list:\n    count += test_tup.count(ele)\n  return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tuple_elements, list_elements):\n    count = 0\n    for element in list_elements:\n        if element in tuple_elements:\n            count += tuple_elements.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    count_dict = {}\n    for i in test_tup:\n        count_dict[i] = test_tup.count(i)\n    return sum(count_dict[i] for i in test_list if i in count_dict)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    res = 0\n    for ele in test_list:\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    res = 0\n    for ele in test_list:\n        res += test_tup.count(ele)\n    return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, list_elements):\n    count = 0\n    for i in list_elements:\n        count += tup.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n  res = sum([test_tup.count(i) for i in test_list])\n  return (res)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, lst):\n    count = 0\n    for elem in lst:\n        count += t.count(elem)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(t, li):\n    count = 0\n    for i in t:\n        if i in li:\n            count += li.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n  res = 0\n  for item in test_list:\n    res += test_tup.count(item)\n  return res", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    count = 0\n    for i in test_list:\n        count += test_tup.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    count = 0\n    for i in test_list:\n        count += test_tup.count(i)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n  res = 0\n  for ele in test_list:\n    res += test_tup.count(ele)\n  return (res)", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(test_tup, test_list):\n    count_dict = {}\n    for item in test_tup:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    count = sum(count_dict[key] for key in test_list if key in count_dict)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_Occurrence(tup, lst):\n    return sum(tup.count(x) for x in lst)", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    :param s: input string\n    :type s: str\n    :return: string without whitespaces\n    :rtype: str\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(text):\n    \"\"\"Remove all whitespaces from the given string.\"\"\"\n    return text.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function takes a string as input and removes all whitespaces from it.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(test_str):\n    return test_str.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    :param input_string: A string that may contain whitespaces.\n    :return: A string without any whitespaces.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Parameters:\n    input_string (str): The string from which whitespaces should be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \n    Examples:\n    remove_whitespaces(' Google    Flutter ') returns 'GoogleFlutter'\n    remove_whitespaces('   Hello  World   ') returns 'HelloWorld'\n    remove_whitespaces(' Python   ') returns 'Python'\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"Return input_string without whitespaces.\"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    This function will take a string as input and return the string with all the whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Remove whitespaces from the string\n    result = input_string.replace(\" \", \"\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(test_str):\n    return test_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Remove all whitespaces from the given string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(test_str):\n    return test_str.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    \"\"\"\n    This function takes a string as input and returns the same string without any whitespaces.\n    \n    Args:\n    string (str): the string from which you want to remove all whitespaces.\n    \n    Returns:\n    str: the string without whitespaces.\n    \"\"\"\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    \"\"\"\n    Write a function to remove all whitespaces from the given string.\n    :param s: input string\n    :type s: str\n    :return: string without whitespaces\n    :rtype: str\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(string):\n    return string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \n    Args:\n    lst: List of strings\n    \n    Returns:\n    List of reversed strings\n    \"\"\"\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    reversed_list = []\n    for string in strings:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    This function takes a list of string values and returns a new list where each string is reversed.\n\n    Args:\n    str_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A new list containing the reversed strings.\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n\n    >>> reverse_string_list(['Hello', 'World', 'Python', 'Programming'])\n    ['olleH', 'dlroW', 'nohtyP', 'gnimmargorP']\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings_list):\n    \"\"\"\n    This function takes a list of strings as input and returns a new list\n    where each string is reversed.\n\n    :param strings_list: List of strings to be reversed\n    :return: A new list with each string reversed\n\n    Examples:\n    >>> reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])\n    ['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n\n    >>> reverse_string_list(['123', '456', '789'])\n    ['321', '654', '987']\n\n    >>> reverse_string_list([])\n    []\n\n    >>> reverse_string_list([''])\n    ['']\n    \"\"\"\n    return [s[::-1] for s in strings_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [string[::-1] for string in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverse each string in a given list of string values.\n\n    :param string_list: A list of strings\n    :return: A list of strings where each string is reversed\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \"\"\"\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of string values and returns a list of those string values reversed.\n\n    Args:\n    string_list (list): A list of strings to be reversed.\n\n    Returns:\n    list: A list of reversed strings.\n    \"\"\"\n\n    # Ensure input is a list and contains only strings\n    if not isinstance(string_list, list) or not all(isinstance(i, str) for i in string_list):\n        raise ValueError(\"Input must be a list of strings.\")\n\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in a given list of string values.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    reversed_list = []\n    for string in string_list:\n        reversed_list.append(string[::-1])\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(str_list):\n    \"\"\"\n    This function receives a list of strings and returns a new list where each string is reversed.\n    :param str_list: List of strings.\n    :return: List of reversed strings.\n    \"\"\"\n    return [s[::-1] for s in str_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Check if input is a list\n    if not isinstance(string_list, list):\n        raise TypeError(\"Expected input to be a list\")\n    \n    # Check if all elements in the list are strings\n    if not all(isinstance(item, str) for item in string_list):\n        raise ValueError(\"All items in the list should be strings\")\n\n    # Reverse each string in the list and return the reversed list\n    return [item[::-1] for item in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of string values and returns a new list with each string reversed.\n\n    Parameters:\n    string_list (list): A list of string values to be reversed.\n\n    Returns:\n    list: A new list containing the reversed strings.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 87.01923076923077, "dps_norm": 95.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst): \n  return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"\n    Returns the first element of each sublist in the provided list of lists.\n\n    Args:\n    lst (list of list): A list where each element is a sublist from which the first element is to be extracted.\n\n    Returns:\n    list: A list of the first elements from each sublist in the input list.\n\n    Example:\n    >>> Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]])\n    [1, 3, 6]\n    \"\"\"\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst): \n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(list_of_lists):\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n  return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst): \n    \"\"\"Return the first element of each sublist\"\"\"\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [i[0] for i in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    \"\"\"\n    This function takes a list of lists and returns a new list that contains only the first element of each sublist.\n\n    Parameters:\n    lst (list of lists): a list of lists from which to extract the first element of each sublist\n\n    Returns:\n    list: a list containing the first element of each sublist in the input lst\n    \"\"\"\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst): \n    return [i[0] for i in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    \"\"\"Returns the first element of each sublist in the list.\n\n    Args:\n    lst: A list of sublists.\n\n    Returns:\n    A list of the first elements of the sublists.\n    \"\"\"\n    return [x[0] for x in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst): \n  return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst): \n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst): \n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    return [item[0] for item in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replace all occurrences of 'old' character with 'new' in the given string 's'\n    \n    :param s: Input string\n    :param old: Character to be replaced\n    :param new: Character to replace with\n    \n    :return: New string after replacing 'old' characters with 'new'\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of a specified character with another character in a given string.\n    \n    Parameters:\n    string (str): The string in which to perform the replacement.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace the old character with.\n    \n    Returns:\n    str: The modified string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, char_to_replace, replacement_char):\n    \"\"\"\n    Replace characters in a string.\n    Replace every instance of char_to_replace with replacement_char in the given string.\n\n    Parameters:\n    string (str): The input string\n    char_to_replace (str): The character to be replaced\n    replacement_char (str): The character to replace with\n\n    Returns:\n    str: The modified string\n    \"\"\"\n    return string.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    \"\"\"\n    Replaces all occurrences of 'old' character with 'new' character in the given string.\n    \"\"\"\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of the old_char in the string with new_char.\n    \n    Args:\n    string (str): The original string.\n    old_char (str): The character to be replaced.\n    new_char (str): The character to replace with.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, target, replacement):\n    return string.replace(target, replacement)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces occurrences of the old character with the new character in the given string.\n    \n    :param string: The string to perform the replacement on.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    \n    :return: A new string with all occurrences of old_char replaced by new_char.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char in the given string with new_char.\n\n    Args:\n        string (str): The input string.\n        old_char (str): The character to be replaced.\n        new_char (str): The character to replace old_char.\n\n    Returns:\n        str: The resulting string after all replacements.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, old_char, new_char):\n    return text.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the input string.\n    \"\"\"\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(text, char_to_replace, replacement_char):\n    \"\"\"Replace all occurrences of a character in a string.\"\"\"\n    return text.replace(char_to_replace, replacement_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    This function replaces characters in a string.\n    :param s: The original string.\n    :param old_char: The character to replace.\n    :param new_char: The new character.\n    :return: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(str, char_to_replace, replacement):\n    return str.replace(char_to_replace, replacement)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 89.8993288590604, "dps_norm": 94.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes an array as an input and returns the sum of the smallest and largest value in the array.\n    \"\"\"\n    # find the smallest and largest value in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    # return the sum of the smallest and largest value\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return min(arr) + max(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function calculates the sum of the largest and smallest values in a given list.\n    \n    Parameters:\n    arr (list): A list of numerical values.\n    \n    Returns:\n    int: The sum of the largest and smallest values in the list.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function takes a list of integers as input and returns the sum of the maximum and minimum values in the list.\n    \"\"\"\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Finds the sum of the largest and smallest value in a given array.\n    \"\"\"\n    max_val = max(arr)\n    min_val = min(arr)\n    return max_val + min_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(nums):\n    \"\"\"\n    This function takes a list of numbers, nums, and returns the sum of the smallest and largest number in the list.\n\n    :param nums: List of numbers\n    :return: Sum of smallest and largest number in the list\n    \"\"\"\n    # First, we ensure that the list is not empty\n    if not nums:\n        return 0\n\n    # Initialize min_num and max_num with the first number in the list\n    min_num = max_num = nums[0]\n\n    # Loop through the list to find the smallest and largest numbers\n    for num in nums:\n        if num < min_num:\n            min_num = num\n        elif num > max_num:\n            max_num = num\n\n    # Return the sum of the smallest and largest numbers\n    return min_num + max_num", "matching_cluster_idx": 3}, {"solution": "def big_sum(arr):\n    \"\"\"\n    The function takes an array as input and returns the sum of the smallest and largest value in the array.\n\n    Parameters:\n    arr (list): The list of numbers.\n\n    Returns:\n    int: The sum of the largest and smallest value.\n    \"\"\"\n    # find smallest and largest values\n    smallest_val = min(arr)\n    largest_val = max(arr)\n\n    # return the sum of smallest and largest value\n    return smallest_val + largest_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given list.\n    \"\"\"\n    if not lst:\n        return None\n    else:\n        return max(lst) + min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if len(arr) > 0:\n        return min(arr) + max(arr)\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def big_sum(numbers):\n    # Check for list with minimum two elements\n    if len(numbers) < 2:\n        raise ValueError(\"List must have at least two elements\")\n    \n    # Sort the numbers list\n    numbers.sort()\n    \n    # Return the sum of the first (smallest) and last (largest) number\n    return numbers[0] + numbers[-1]", "matching_cluster_idx": 2}, {"solution": "def big_sum(array):\n    return max(array) + min(array)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    This function calculates the sum of the largest and smallest values in the given array.\n    :param arr: A list of numbers.\n    :return: The sum of the largest and smallest values.\n    \"\"\"\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(lst):\n    return max(lst) + min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_sum(array):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    :param array: list of numbers\n    :return: sum of the smallest and largest number in the array\n    \"\"\"\n    if array:  # Check if the array is not empty\n        return max(array) + min(array)\n    else:  # Return 0 if the array is empty\n        return 0", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n\n    :param arr: List[int] - a list of integers\n    :return: int - the sum of the smallest and the largest value in the array\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    else:\n        min_val = arr[0]\n        max_val = arr[0]\n        for num in arr:\n            if num < min_val:\n                min_val = num\n            if num > max_val:\n                max_val = num\n        return min_val + max_val", "matching_cluster_idx": 3}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def is_lower(s):\n    \"\"\"\n    Function to convert the given string to lower case\n    :param s: str\n    :return: str\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str_input):\n    \"\"\"\n    Converts the given string to lower case.\n    >>> is_lower(\"InValid\")\n    'invalid'\n    >>> is_lower(\"PyThOn\")\n    'python'\n    >>> is_lower(\"EXAMPLE\")\n    'example'\n    \"\"\"\n    return str_input.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert a given string to lower case.\n    :param string: the string to convert\n    :return: a string that is in lower case\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n    :param input_string: string\n    :return: Lower case version of the input string\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string: str) -> str:\n    \"\"\"\n    Converts the given string to lower case.\n    :param string: String to be converted.\n    :return: Lower case version of the input string.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Converts the given string to lower case.\n    :param s: str\n    :return: str\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(str):\n    # Function to convert the given string to lower case.\n    return str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    This function takes a string and returns its lowercase version.\n    \n    :param input_string: The string to be converted to lowercase.\n    :return: The lowercase version of the input_string.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function converts the given string to lower case.\n    \n    Parameters:\n    s (str): the string to be converted to lower case.\n\n    Returns:\n    str: the converted string in lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(text):\n    \"\"\"\n    This function receives a string and returns it in lower case.\n    \"\"\"\n    return text.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_str):\n    return input_str.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(string):\n    \"\"\"\n    Convert the given string to lower case.\n    \"\"\"\n    return string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    This function takes a string as input and returns the string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 81.99453551912569, "dps_norm": 80.45454545454545, "pass@1": 38.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\\\"(.*?)\\\"'\n    return re.findall(pattern, input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extracts values between quotation marks from a string.\n\n    Parameters:\n    string (str): A string containing values between quotation marks.\n\n    Returns:\n    list: A list of strings extracted between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\".*?\"'\n    result = re.findall(pattern, input_string)\n    result = [value[1:-1] for value in result]\n    return result", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    \"\"\"\n    Extract values between quotation marks from a string.\n    :param input_string: A string containing values enclosed in quotation marks.\n    :return: A list of extracted values.\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    pattern = r'\\\"(.*?)\\\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    matches = re.findall(r'\"([^\"]*)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(test_str):\n    matches = re.findall(r'\"([^\"]*)\"', test_str)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 8}, {"solution": "def extract_values(string):\n    start = 0\n    values = []\n    for i in range(len(string)):\n        if string[i] == '\"':\n            if start == 0:\n                start = i + 1\n            else:\n                values.append(string[start:i])\n                start = 0\n    return values", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_values(string):\n    \"\"\"\n    Extract values between quotation marks from a string.\n\n    Parameters:\n    string (str): A string containing values between quotation marks.\n\n    Returns:\n    list: A list of strings with extracted values between quotation marks.\n    \"\"\"\n    pattern = r'\\\"(.*?)\\\"'\n    return re.findall(pattern, string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(test_str):\n    return re.findall(r'\"([^\"]*)\"', test_str)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 56.604938271604944, "dps_norm": 52.857142857142854, "pass@1": 20.0, "profiled": [{"solution": "def two_unique_nums(l):\n    unique_nums = []\n    for i in l:\n        if l.count(i) == 1:\n            unique_nums.append(i)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(lists):\n    unique_list = []\n    for item in lists:\n        if lists.count(item) == 1:\n            unique_list.append(item)\n    return unique_list", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(l):\n    result = []\n    for i in l:\n        if l.count(i) == 1:\n            result.append(i)\n    return result", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(*args):\n    unique_nums = []\n    for arg in args:\n        for num in arg:\n            if arg.count(num) == 1 and unique_nums.count(num) == 0:\n                unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(list1):\n    # Creating the frequency dictionary\n    freq_dict = {}\n    for num in list1:\n        if num not in freq_dict:\n            freq_dict[num] = 1\n        else:\n            freq_dict[num] += 1\n\n    # Finding the numbers with frequency 1\n    unique_nums = []\n    for num, freq in freq_dict.items():\n        if freq == 1:\n            unique_nums.append(num)\n\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef two_unique_nums(lists):\n    # Count occurrence of each number\n    num_counter = Counter(lists)\n    # Find numbers that appear exactly once\n    unique_nums = [num for num, count in num_counter.items() if count == 1]\n    return unique_nums", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(lst):\n    num_set = set()\n    result = []\n    for num in lst:\n        if num not in num_set:\n            num_set.add(num)\n            result.append(num)\n        elif num in result:\n            result.remove(num)\n    return result", "matching_cluster_idx": 4}, {"solution": "def two_unique_nums(list_nums):\n    unique_nums = []\n    for num in list_nums:\n        if list_nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(lst1):\n    unique_nums = []\n    for i in lst1:\n        if lst1.count(i) == 1:\n            unique_nums.append(i)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    Removes duplicates from a list of numbers and returns only numbers that appear exactly once.\n\n    :param nums: List of lists of integers.\n    :return: List of integers that appear exactly once in the input.\n    \"\"\"\n    d = {}\n    for i in nums:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    return [k for k, v in d.items() if v == 1]", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(list1):\n    unique_nums = []\n    for num in list1:\n        if list1.count(num) == 1 and num not in unique_nums:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    if len(nums) < 2:\n        return nums\n    hmap = {}\n    result = []\n    for i in nums:\n        if i in hmap:\n            hmap[i] += 1\n        else:\n            hmap[i] = 1\n    \n    for key in hmap:\n        if hmap[key] == 1:\n            result.append(key)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    from collections import Counter\n    c = Counter(nums)\n    return [key for key, value in c.items() if value == 1]", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(l):\n    unique_nums = []\n    for i in l:\n        if l.count(i) == 1:\n            unique_nums.append(i)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(list_nums):\n    unique_nums = []\n    for num in list_nums:\n        if list_nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function removes duplicate numbers from a given number of lists.\n    \"\"\"\n    counter = {}\n    for num in nums:\n        counter[num] = counter.get(num, 0) + 1\n\n    unique_nums = [num for num in counter if counter[num] == 1]\n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    unique_nums = []\n    for num in nums:\n        if nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "def two_unique_nums(nums_list):\n    \"\"\"\n    This function takes a list of numbers as input and removes duplicate numbers.\n    It returns a list containing only unique numbers.\n    \"\"\"\n    unique_nums = []\n    for num in nums_list:\n        if nums_list.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}, {"solution": "from collections import Counter\ndef two_unique_nums(nums):\n    counts = Counter(nums)\n    return [num for num, count in counts.items() if count == 1]", "matching_cluster_idx": 6}, {"solution": "def two_unique_nums(list_nums):\n    unique_nums = []\n    for num in list_nums:\n        if list_nums.count(num) == 1:\n            unique_nums.append(num)\n    return unique_nums", "matching_cluster_idx": 1}]}, "Mbpp/578": {"dps": 70.2063492063492, "dps_norm": 68.63636363636364, "pass@1": 86.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    This function takes 3 lists of the same length and interleaves them into a single flat list.\n    \n    Parameters:\n    list1 (list)\n    list2 (list)\n    list3 (list)\n    \n    Returns:\n    merged_list (list)\n    \"\"\"\n    \n    # Initialize an empty list to store the interleaved elements\n    merged_list = []\n    \n    # Determine the length of the lists\n    length = len(list1)\n    \n    # Interleave the lists\n    for i in range(length):\n        merged_list.append(list1[i])\n        merged_list.append(list2[i])\n        merged_list.append(list3[i])\n    \n    return merged_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves 3 lists of the same length into a single flat list.\n    \"\"\"\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must have the same length.\")\n    \n    flat_list = []\n    for i in range(len(list1)):\n        flat_list.append(list1[i])\n        flat_list.append(list2[i])\n        flat_list.append(list3[i])\n\n    return flat_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves 3 lists of the same length into a single flat list.\n\n    Args:\n    list1, list2, list3: Three lists of the same length.\n\n    Returns:\n    A flat list containing elements from list1, list2, and list3 in an interleaved manner.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(l1, l2, l3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    :param l1: List 1\n    :param l2: List 2\n    :param l3: List 3\n    :return: A single flat list with elements from l1, l2, and l3 interleaved\n    \"\"\"\n    assert len(l1) == len(l2) == len(l3), \"Lists must have the same length\"\n    \n    result = []\n    for i in range(len(l1)):\n        result.extend([l1[i], l2[i], l3[i]])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    assert len(list1) == len(list2) == len(list3), \"All lists must have the same length\"\n    flat_list = [None]*(3*len(list1))\n    flat_list[::3] = list1\n    flat_list[1::3] = list2\n    flat_list[2::3] = list3\n    return flat_list", "matching_cluster_idx": 9}, {"solution": "def interleave_lists(list1, list2, list3):\n    flat_list = []\n    for i in range(len(list1)):\n        flat_list.append(list1[i])\n        flat_list.append(list2[i])\n        flat_list.append(list3[i])\n    return flat_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves 3 lists of the same length into a single flat list.\n    \n    Args:\n        list1 (list): First list to be interleaved.\n        list2 (list): Second list to be interleaved.\n        list3 (list): Third list to be interleaved.\n\n    Returns:\n        list: A single list that is the result of interleaving list1, list2, and list3.\n\n    Raises:\n        ValueError: If the three lists are not of the same length.\n    \"\"\"\n    if len(list1) != len(list2) or len(list1) != len(list3):\n        raise ValueError(\"Input lists must be of the same length\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.extend([list1[i], list2[i], list3[i]])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved = []\n    for i in range(len(list1)):\n        interleaved.append(list1[i])\n        interleaved.append(list2[i])\n        interleaved.append(list3[i])\n    return interleaved", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"Lists must have the same length\")\n    return [value for pair in zip(list1, list2, list3) for value in pair]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n    :param list1: First list to interleave.\n    :param list2: Second list to interleave.\n    :param list3: Third list to interleave.\n    :return: A new list containing the elements of list1, list2, and list3 interleaved.\n    \"\"\"\n    if not (len(list1) == len(list2) == len(list3)):\n        raise ValueError(\"All lists must be of the same length.\")\n    \n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    if not list1 or not list2 or not list3 or len(list1) != len(list2) != len(list3):\n        return []\n\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    :param list1: List of integers\n    :param list2: List of integers\n    :param list3: List of integers\n    :return: Interleaved list of integers\n    \"\"\"\n    return [lst[i] for i in range(len(list1)) for lst in [list1, list2, list3]]", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Interleave lists\n    result = [None]*(len(list1)*3)\n    result[::3] = list1\n    result[1::3] = list2\n    result[2::3] = list3\n    return result", "matching_cluster_idx": 10}, {"solution": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Write a function to interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(l1, l2, l3):\n    return [val for sublist in zip(l1,l2,l3) for val in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(l1, l2, l3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \"\"\"\n    return [item for sublist in zip(l1, l2, l3) for item in sublist]", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"Return a flat list interleaved from 3 given lists\"\"\"\n    assert len(list1) == len(list2) == len(list3), \"All lists must have the same length\"\n    \n    flat_list = []\n    \n    for i in range(len(list1)):\n        flat_list.extend([list1[i], list2[i], list3[i]])\n    \n    return flat_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists into a single flat list.\n    \n    Parameters:\n    list1 (list): First list.\n    list2 (list): Second list.\n    list3 (list): Third list.\n    \n    Returns:\n    list: An interleaved list of the three input lists.\n    \"\"\"\n    interleaved_list = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved_list.extend([a, b, c])\n    return interleaved_list", "matching_cluster_idx": 7}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 91.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    \"\"\"Split a list at the nth eelment and add the first part to the end.\"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    This function splits a list at the nth element and adds the first part to the end.\n\n    Parameters:\n    arr (list): list to split.\n    n (int): index at which the list will be split.\n\n    Returns:\n    list: new list with the first part added to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Write a python function to split a list at the nth eelment and add the first part to the end.\n    :param arr: input list\n    :param n: index to split at\n    :return: list with first part at the end\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Args:\n    arr (list): The original list.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The updated list.\n\n    Examples:\n    >>> split_Arr([12,10,5,6,52,36],2)\n    [5,6,52,36,12,10]\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    The function takes a list and an index as input and returns the list split at the given index.\n    The first part of the list (from the start to the index) is moved to the end of the list.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Split a list at the nth element and add the first part to the end.\n\n    Parameters:\n    arr (list): The list to be split.\n    n (int): The index at which to split the list.\n\n    Returns:\n    list: The modified list.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    This function takes an array and an index as parameters,\n    and returns a new array that contains the first part of\n    the original array starting from the given index, followed\n    by the rest of the original array.\n\n    :param arr: array to be split\n    :param n: index at which to split the array\n    :return: new array after the split\n    \"\"\"\n\n    # slicing the array into two parts\n    first_part = arr[n:]\n    second_part = arr[:n]\n\n    # concatenating the two parts and returning the result\n    return first_part + second_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    first_part = arr[:n]\n    second_part = arr[n:]\n    return second_part + first_part", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits the list at the nth element and adds the first part to the end.\n\n    :param arr: List to be split.\n    :param n: Index at which to split the list.\n    :return: A new list with the first part added to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # split array at nth position\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # add first part to the end\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    # Concatenating the second part with the first part to simulate moving the first part to the end\n    result = second_part + first_part\n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Slicing the list at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenating the second part with the first part to achieve the desired rotation\n    rotated_arr = second_part + first_part\n    return rotated_arr", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Splitting the array at nth index and concatenating the first part to the end\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    This function takes a list and an index, n, as arguments. It will split the list at the nth element and add the first part to the end of the list.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and moves the first part of the list to the end.\n\n    :param arr: List of elements to be split and moved.\n    :param n: Index at which to split the list.\n    :return: Modified list with the first part moved to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 12.162162162162161, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    :param lst: list to be converted to a tuple\n    :return: a tuple with the elements of the input list\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Write a function to convert a list to a tuple.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Converts a list to a tuple.\n\n    Parameters:\n    lst (list): The list to convert.\n\n    Returns:\n    tuple: The converted tuple.\n\n    Examples:\n    >>> list_tuple([5, 10, 7, 4, 15, 3])\n    (5, 10, 7, 4, 15, 3)\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Function to convert a list to a tuple.\n    :param lst: List of items\n    :return: Tuple representation of the list\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(input_list):\n    return tuple(input_list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(list):\n    \"\"\"\n    Converts a list to a tuple.\n    \"\"\"\n    return tuple(list)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 2}]}, "Mbpp/588": {"dps": 94.26605504587155, "dps_norm": 98.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n  # find the smallest and largest values in the list\n  smallest = min(nums)\n  largest = max(nums)\n  # calculate and return the difference\n  return largest - smallest", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    This function takes a list of numbers and returns the difference between the maximum and minimum numbers in the list.\n    \"\"\"\n    if len(lst) == 0:\n        return None\n\n    max_num = lst[0]\n    min_num = lst[0]\n\n    for num in lst:\n        if num > max_num:\n            max_num = num\n        if num < min_num:\n            min_num = num\n\n    return max_num - min_num", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    max_val = max(nums)\n    min_val = min(nums)\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Returns the difference between the largest and smallest numbers in a list.\n\n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    int: The difference between the largest and smallest numbers in the list.\n\n    Example:\n    >>> big_diff([10, 5, 1, 20])\n    19\n    >>> big_diff([1, 2, 3, 4, 5])\n    4\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Given a list of ints, return the difference between the largest and smallest values.\n    \"\"\"\n    max_val = max(nums)\n    min_val = min(nums)\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Function to find the difference between the largest and smallest values in a given list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    max_val = max(nums)\n    min_val = min(nums)\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  \"\"\"\n  Return the difference between the largest and smallest values in a list of numbers.\n  \"\"\"\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    (list) -> int\n\n    Assumes list length >= 2\n    Finds difference between the max and min values in the given list.\n    \"\"\"\n    min_num = min(nums)\n    max_num = max(nums)\n    return max_num - min_num", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function takes a list of numbers as an input, and returns the difference between the \n    largest and smallest values in the list.\n    \n    Parameters:\n    nums (list): A list of numbers.\n\n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n\n    # Return the difference between max and min values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n  return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Given a list of integers, this function finds and returns the difference between the largest and smallest values in the list.\n    \"\"\"\n    return max(lst) - min(lst) if lst else 0", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    This function takes a list of numbers as an argument and returns the difference between the maximum and minimum value in the list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Write a python function to find the difference between largest and smallest value in a given list.\n    \n    >>> big_diff([1, 2, 3, 4])\n    3\n    \n    >>> big_diff([5, 3, 2, 8])\n    6\n    \n    >>> big_diff([-5, -3, -2, -8])\n    6\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    This function takes a list of integers as input and returns\n    the difference between the largest and smallest values in the list.\n    \"\"\"\n    # edge case: check if the list is empty\n    if not lst:\n        return 0\n\n    # initialize max and min\n    max_val = lst[0]\n    min_val = lst[0]\n\n    # iterate through the list to find max and min\n    for val in lst:\n        if val > max_val:\n            max_val = val\n        if val < min_val:\n            min_val = val\n\n    # return the difference\n    return max_val - min_val", "matching_cluster_idx": 4}, {"solution": "def big_diff(nums):\n    \"\"\"\n    Find the difference between largest and smallest value in a given list\n    :param nums: list of integers\n    :return: difference between largest and smallest value\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    \"\"\"\n    (list) -> int\n    Given a list of numbers, return the difference between the largest and smallest value in the list.\n    \"\"\"\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/597": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 12.0, "profiled": [{"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two sorted arrays\n    arr = arr1 + arr2\n    arr.sort()\n    \n    # Return the kth element in the merged sorted array\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the merged sorted array of arr1 and arr2.\n    \n    Parameters:\n    arr1 (list): The first sorted array.\n    arr2 (list): The second sorted array.\n    k (int): The kth position to find the element in the merged array.\n    \n    Returns:\n    int: The kth element in the merged sorted array.\n    \"\"\"\n    # Merge two sorted arrays\n    arr = sorted(arr1 + arr2)\n    # Return the kth element in 1-based index\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    arr = arr1 + arr2\n    arr.sort()\n    return arr[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(array1, array2, k):\n    \"\"\"\n    Finds the kth element in the merged sorted arrays formed by array1 and array2.\n    \n    Parameters:\n    array1 (list): First sorted array.\n    array2 (list): Second sorted array.\n    k (int): The kth position to find in the merged sorted arrays.\n    \n    Returns:\n    int: The kth element in the merged sorted arrays.\n    \"\"\"\n    # Merge the two arrays and sort\n    merged_array = array1 + array2\n    merged_array.sort()\n    \n    # Check if k is within the bounds of the merged array\n    if k < 1 or k > len(merged_array):\n        raise ValueError('k is out of bounds of the merged array.')\n    \n    # Return the kth element\n    return merged_array[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    # Merge the two arrays\n    merged_arr = sorted(arr1 + arr2)\n    # Return the kth element in the merged array (1-indexed)\n    return merged_arr[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    # Combine the two sorted arrays into a single one\n    total_nums = nums1 + nums2\n    # Sort the combined array\n    total_nums.sort()\n    # Return the kth element\n    return total_nums[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(nums1, nums2, k):\n    \"\"\"\n    Finds kth element in the two sorted arrays.\n    :param nums1: First sorted array\n    :param nums2: Second sorted array\n    :param k: The kth position to find\n    :return: kth element\n    \"\"\"\n    nums1.extend(nums2)\n    nums1.sort()\n    return nums1[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    arr1.extend(arr2)\n    arr1.sort()\n    return arr1[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element in the combined sorted arrays.\n\n    :param arr1: First sorted array.\n    :param arr2: Second sorted array.\n    :param k: The kth element to find (1-indexed).\n    :return: The kth element.\n    \"\"\"\n    # Merge both arrays and find the kth element\n    merged = sorted(arr1 + arr2)\n    return merged[k-1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Finds the kth element in the merged array of two sorted arrays.\n    \n    Parameters:\n    arr1 (list): The first sorted array.\n    arr2 (list): The second sorted array.\n    k (int): The position of the element to find (1-indexed).\n    \n    Returns:\n    int: The kth smallest element in the merged array.\n    \n    Precondition: 1 <= k <= len(arr1) + len(arr2)\n    \"\"\"\n    # Merge the two arrays into a single sorted array\n    merged = sorted(arr1 + arr2)\n    # Return the kth smallest element\n    return merged[k - 1]", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Write a function to find kth element from the given two sorted arrays.\n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n    \"\"\"\n    arr = sorted(arr1 + arr2)\n    return arr[k-1] if 0 < k <= len(arr) else None", "matching_cluster_idx": 3}, {"solution": "def find_kth(arr1, arr2, k):\n    #combine two sorted arrays into one\n    arr = sorted(arr1 + arr2)\n    #return the kth element of the combined array\n    return arr[k-1]", "matching_cluster_idx": 3}]}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 52.0, "profiled": [{"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    \"\"\"Reverses the words in a string, seperated by spaces.\"\"\"\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_string):\n    words = input_string.split()\n    return ' '.join(reversed(words))", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s: str) -> str:\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(text):\n    # Split the text into words\n    words = text.split()\n\n    # Reverse the order of the words\n    words = words[::-1]\n\n    # Join the reversed words into a string with spaces in between\n    reversed_text = ' '.join(words)\n\n    # Return the reversed text\n    return reversed_text", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    # Split the string into words\n    words = input_str.split()\n\n    # Reverse the order of the words\n    reversed_words = words[::-1]\n\n    # Join the reversed words back into a string with spaces\n    reversed_str = \" \".join(reversed_words)\n\n    return reversed_str", "matching_cluster_idx": 4}, {"solution": "def reverse_words(string):\n    \"\"\"\n    Write a function to reverse words separated by spaces in a given string.\n    \"\"\"\n    return ' '.join(string.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into a list of words, then reverse the order and join back into a string\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(input_str):\n    words = input_str.split()\n    reversed_words = ' '.join(reversed(words))\n    return reversed_words", "matching_cluster_idx": 4}, {"solution": "def reverse_words(sentence):\n    return ' '.join(sentence.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    return \" \".join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the sentence into words, reverse the list of words, and join them back into a sentence\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 39.090177133655395, "dps_norm": 45.23809523809524, "pass@1": 18.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    return [item for index, item in enumerate(lst) if index != k-1]", "matching_cluster_idx": 1}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the new list.\n\n    :param lst: List of elements.\n    :param k: The position of the element to remove (1-indexed).\n    :return: List with k'th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(l, k):\n    \"\"\"\n    Returns a list with the kth element removed\n    :param l: list\n    :param k: position to be removed\n    :return: new list without kth element\n    \"\"\"\n    # Checks if the list is empty or k is out of range\n    if not l or k <= 0 or k > len(l):\n        return l\n\n    # Returns the list without the kth element\n    return l[:k - 1] + l[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(alist, k):\n    \"\"\"\n    This function takes a list and an integer k, and returns a new list\n    with the same elements but with the kth element removed.\n    \"\"\"\n    return alist[:k-1] + alist[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the kth element from the list.\n\n    Parameters:\n    lst (list): The list from which to remove the element.\n    k (int): The index of the element to remove (1-indexed).\n\n    Returns:\n    list: The list with the element at index k removed.\n    \"\"\"\n    if k <= 0 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Returns a new list after removing the k-th element from the original list.\n    \n    Parameters:\n    lst (list): The original list.\n    k (int): The index of the element to be removed (1-indexed).\n    \n    Returns:\n    list: A new list with the k-th element removed.\n    \n    Examples:\n    >>> remove_kth_element([1,1,2,3,4,4,5,1], 3)\n    [1, 1, 3, 4, 4, 5, 1]\n    \n    >>> remove_kth_element(['a', 'b', 'c', 'd'], 2)\n    ['a', 'b', 'd']\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    This function takes a list and removes the k'th element from the list.\n\n    :param lst: list\n    :param k: int\n    :return: list\n    \"\"\"\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return [element for index, element in enumerate(lst) if index != k-1]", "matching_cluster_idx": 1}, {"solution": "def remove_kth_element(list1, k):\n    return list1[:k-1] + list1[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(alist, k):\n    \"\"\"\n    This function takes a list and an integer k as arguments. It removes the k-th element from the list and\n    returns the new list.\n\n    Parameters:\n    alist (list): The list from which to remove the element.\n    k (int): The index of the element to remove.\n\n    Returns:\n    list: A new list with the k-th element removed.\n    \"\"\"\n    return alist[:k-1] + alist[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return lst[:k-1] + lst[k:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    return [lst[i] for i in range(len(lst)) if i != k-1]", "matching_cluster_idx": 0}, {"solution": "def remove_kth_element(alist, k):\n    return [item for index, item in enumerate(alist) if index != k-1]", "matching_cluster_idx": 1}, {"solution": "def remove_kth_element(lst, k):\n    return [lst[i] for i in range(len(lst)) if i != k-1]", "matching_cluster_idx": 0}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k-th element from the list.\n    \n    Args:\n    lst: The list from which the element should be removed.\n    k: The index of the element to be removed.\n    \n    Returns:\n    A list with the same elements as the input list, but with the k-th element removed.\n    \n    Examples:\n    remove_kth_element([1,1,2,3,4,4,5,1],3) -> [1, 1, 2, 4, 4, 5, 1]\n    remove_kth_element([1,2,3,4,5],1) -> [1, 3, 4, 5]\n    \"\"\"\n    return [lst[i] for i in range(len(lst)) if i != k-1]", "matching_cluster_idx": 0}, {"solution": "def remove_kth_element(list_input, k):\n    if k > 0 and k <= len(list_input):\n        list_input.pop(k - 1)\n    return list_input", "matching_cluster_idx": 6}, {"solution": "def remove_kth_element(list1, k):\n    # check if k is within the bounds of the list\n    if 0 < k <= len(list1):\n        # create a new list without the kth element\n        return [list1[i] for i in range(len(list1)) if i != k-1]\n    else:\n        # return the original list if k is out of bounds\n        return list1", "matching_cluster_idx": 0}]}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 87.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, this function returns the max of the n'th column.\n\n    :param matrix: a list of lists, where each sublist represents a row in the matrix\n    :param n: an integer, the column number to find the max value from\n    :return: the max value in the n'th column of the matrix\n    \"\"\"\n    # initialize max value with the first row's n-th value\n    max_value = matrix[0][n]\n\n    # loop through all rows\n    for row in matrix:\n        # update max value if a larger value in the n-th column is found\n        if row[n] > max_value:\n            max_value = row[n]\n\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, return the max value of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \"\"\"\n    return max([row[n] for row in matrix])", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function returns the max value in the n-th column of a given matrix.\n\n    :param matrix: A list of lists where each inner list represents a row in the matrix.\n    :param n: An integer representing the column index.\n    :return: The maximum value in the n-th column.\n    \"\"\"\n    max_value = matrix[0][n]\n    for row in matrix:\n        if row[n] > max_value:\n            max_value = row[n]\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix (represented as a list of lists) and an index n, and returns\n    the maximum value found in the n-th column of the matrix.\n    \n    :param matrix: A matrix represented as a list of lists\n    :param n: The index of the column to find the maximum value for\n    :return: The maximum value in the n-th column\n    \"\"\"\n    # Check if the matrix is empty\n    if not matrix:\n        return None\n    \n    # Extract the n-th column values\n    column_values = [row[n] for row in matrix]\n    \n    # Return the maximum value\n    return max(column_values)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    The function returns the maximum value of the n'th column in a given matrix.\n\n    :param matrix: a 2D list (matrix) where each element is a list of numbers\n    :param n: an integer representing the column number\n    :return: the max value of the n'th column\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to find the maximum value in the given column of a matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix in which we want to find the max value.\n    n (int): The column number to consider.\n    \n    Returns:\n    max_val (int): The maximum value in the specified column.\n    \n    \"\"\"\n    # Initialize the maximum value with the value from the first row.\n    max_val = matrix[0][n]\n    \n    # Iterate through each row in the matrix.\n    for row in matrix:\n        # Update the maximum value if the current row's value is greater.\n        if row[n] > max_val:\n            max_val = row[n]\n            \n    return max_val", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix represented as a list of lists and an index.\n    It returns the maximum value of the n'th column in the matrix.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, this function returns the max of the n'th column.\n    \n    :param matrix: A list of lists representing the matrix.\n    :param n: An integer representing the index of the column to find the maximum value of.\n    :return: The maximum value in the n'th column.\n    \"\"\"\n    # Initialize max_value to be the smallest possible value\n    max_value = float('-inf')\n    \n    # Iterate over the rows in the matrix\n    for row in matrix:\n        # Update max_value if the current value in the n'th column is greater\n        max_value = max(max_value, row[n])\n    \n    # Return the maximum value found in the n'th column\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Function to return the maximum of the n'th column in a given matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix represented as a list of lists.\n    n (int): The column number to find the maximum value from.\n    \n    Returns:\n    int: The maximum value of the n'th column in the matrix.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the max value in the n-th column of the provided matrix.\n    \n    Parameters:\n    matrix (list of lists): The matrix to be processed.\n    n (int): The column index (0-indexed).\n    \n    Returns:\n    int: The max value in the n-th column of the matrix.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    This function takes a matrix represented as a list of lists and an index n.\n    It returns the max value in the n'th column of the matrix.\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the max value in the n-th column of a given matrix.\n\n    Parameters:\n    matrix (list of lists): The input matrix.\n    n (int): The index of the column to find the maximum value in.\n\n    Returns:\n    int: The maximum value in the n-th column.\n\n    Example:\n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \n    :param matrix: List of lists, the input matrix\n    :param n: int, the index of the column to find the max in\n    :return: int, the max value of the n'th column\n    \n    >>> max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2)\n    19\n    \"\"\"\n    return max(row[n] for row in matrix)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": 60.90277777777777, "dps_norm": 56.875, "pass@1": 41.0, "profiled": [{"solution": "def replace_spaces(string):\n    \"\"\"\n    This function replaces whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    new_string = ''\n    for char in string:\n        if char == ' ':\n            new_string += '_'\n        elif char == '_':\n            new_string += ' '\n        else:\n            new_string += char\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Write a function to replace whitespaces with an underscore and vice versa in a given string.\n    assert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n    \"\"\"\n    return ''.join(['_' if ch == ' ' else ch.replace('_', ' ') for ch in string])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace underscores with whitespaces and vice versa in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string.\n    \"\"\"\n    modified_s = ''\n    for char in s:\n        if char == '_':\n            modified_s += ' '\n        elif char == ' ':\n            modified_s += '_'\n        else:\n            modified_s += char\n    return modified_s", "matching_cluster_idx": 0}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string, replaces all whitespaces with an underscore,\n    and vice versa (if an underscore is encountered, it is replaced with a whitespace).\n    \"\"\"\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function takes a string s and replaces all whitespaces with an underscore,\n    and replaces all underscores with a whitespace.\n    \"\"\"\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    return s.replace(' ', '_') if ' ' in s else s.replace('_', ' ')", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    new_string = ''\n    for ch in input_string:\n        if ch == ' ':\n            new_string += '_'\n        elif ch == '_':\n            new_string += ' '\n        else:\n            new_string += ch\n    return new_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    This function replaces whitespaces in a given string with an underscore and vice versa.\n    \n    Example:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    >>> replace_spaces('Jumanji_The_Jungle')\n    'Jumanji The Jungle'\n    \n    :param input_string: the string to be processed\n    :return: the modified string with whitespaces replaced\n    \"\"\"\n    replaced_string = \"\"\n    for char in input_string:\n        if char == ' ':\n            replaced_string += '_'\n        elif char == '_':\n            replaced_string += ' '\n        else:\n            replaced_string += char\n            \n    return replaced_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(input_str):\n    # Replace whitespaces with underscore if they exist\n    result = input_str.replace(' ', '_')\n    \n    # If there are no whitespaces, replace underscores with whitespace\n    if result == input_str:\n        result = input_str.replace('_', ' ')\n\n    return result", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    This function takes in a string, replaces whitespace characters with underscores, and vice versa.\n    \"\"\"\n    output_string = \"\"\n    for char in input_string:\n        if char == \" \":\n            output_string += \"_\"\n        elif char == \"_\":\n            output_string += \" \"\n        else:\n            output_string += char\n    return output_string", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(string):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in the given string.\n\n    Args:\n    string (str): The input string to be processed.\n\n    Returns:\n    str: The processed string.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    return ''.join(['_' if ch == ' ' else ch.replace('_', ' ') for ch in string])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    result = ''\n    for char in s:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"Replace whitespaces with an underscore and vice versa in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    str: The processed string with whitespaces replaced.\n\n    Examples:\n    >>> replace_spaces('Jumanji The Jungle')\n    'Jumanji_The_Jungle'\n    \"\"\"\n    return s.replace(\" \", \"_\") if \" \" in s else s.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    \"\"\"Replace whitespaces with an underscore and vice versa in a given string.\"\"\"\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s: str) -> str:\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n\n    Parameters:\n    s (str): input string\n\n    Returns:\n    str: modified string\n    \"\"\"\n    return ''.join(['_' if c == ' ' else ' ' if c == '_' else c for c in s])", "matching_cluster_idx": 3}, {"solution": "def replace_spaces(s):\n    # Replace whitespaces with underscore if there are any\n    if ' ' in s:\n        return s.replace(' ', '_')\n\n    # Replace underscores with whitespace if there are any\n    if '_' in s:\n        return s.replace('_', ' ')\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces whitespaces with an underscore and vice versa in a given string.\n    :param s: The string to replace characters in.\n    :return: A new string with replaced characters.\n    \"\"\"\n    result = \"\"\n    for char in s:\n        if char == \" \":\n            result += \"_\"\n        elif char == \"_\":\n            result += \" \"\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    This function replaces whitespaces with an underscore and vice versa in a given string.\n    \"\"\"\n    # If there is a whitespace in the string replace it with underscore\n    if ' ' in s:\n        return s.replace(' ', '_')\n    # If there is an underscore in the string replace it with whitespace\n    elif '_' in s:\n        return s.replace('_', ' ')\n    else:\n        return s", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(text):\n    return text.replace(\" \", \"_\") if \" \" in text else text.replace(\"_\", \" \")", "matching_cluster_idx": 7}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with an underscore and vice versa in a given string.\n    :param input_string: string\n    :return: string with replaced whitespaces\n    \"\"\"\n    result = ''\n    for char in input_string:\n        if char == ' ':\n            result += '_'\n        elif char == '_':\n            result += ' '\n        else:\n            result += char\n    return result", "matching_cluster_idx": 2}]}, "Mbpp/632": {"dps": 90.56285178236398, "dps_norm": 97.14285714285714, "pass@1": 99.0, "profiled": [{"solution": "def move_zero(nums):\n    \"\"\"\n    Write a python function to move all zeroes to the end of the given list.\n    \n    Parameters:\n    nums (list): List of integers.\n    \n    Returns:\n    list: Modified list with all zeroes moved to the end.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Function to move all zeroes to the end of the list.\n\n    Parameters:\n    nums (list): List of integers\n\n    Returns:\n    list: Modified list with all zeroes moved to the end\n    \"\"\"\n    # Initialize a pointer for non-zero elements\n    non_zero = 0\n\n    # Traverse the list and move non-zero elements to the front\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero], nums[i] = nums[i], nums[non_zero]\n            non_zero += 1\n\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    This function moves all zeroes to the end of the given list.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] != 0:\n            arr[count], arr[i] = arr[i], arr[count]\n            count += 1\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    This function moves all zeroes to the end of the given list.\n\n    Parameters:\n    arr (list): The list to be processed.\n\n    Returns:\n    list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Create a new list to store non-zero elements\n    non_zero = [x for x in arr if x != 0]\n    \n    # Calculate the number of zeros in the original list\n    num_zeros = len(arr) - len(non_zero)\n    \n    # Append zeros to the end of the new list\n    result = non_zero + [0] * num_zeros\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    :param nums: List of integers.\n    :return: Modified list with all zeroes at the end.\n    \"\"\"\n    count = nums.count(0)\n    for i in range(count):\n        nums.remove(0)\n        nums.append(0)\n    return nums", "matching_cluster_idx": 4}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Moves all zeroes to the end of the given list.\n    :param nums: List of integers\n    :return: List with all zeroes moved to the end\n    \"\"\"\n    zeroes = nums.count(0)\n    for i in range(zeroes):\n        nums.remove(0)\n        nums.append(0)\n    return nums", "matching_cluster_idx": 4}, {"solution": "def move_zero(nums):\n    \"\"\"\n    Move all zeroes to the end of the list.\n    :param nums: List of integers\n    :return: Modified list with all zeroes moved to the end\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    This function takes a list as input and moves all the zeroes to the end of the list.\n    \"\"\"\n    non_zero = [num for num in nums if num != 0]\n    zeroes = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    :param arr: List of integers\n    :return: Modified list with all zeroes moved to the end\n    \"\"\"\n    non_zero = [x for x in arr if x != 0]\n    zeroes = [0] * (len(arr) - len(non_zero))\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    zero = 0  # count the zeros\n    non_zero = []  # list to hold non-zero elements\n    # traverse in the array\n    for i in arr:\n        if i == 0:\n            zero += 1\n        else:\n            non_zero.append(i)\n    # append the zeroes to the end\n    non_zero += [0] * zero\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    This function takes a list as input and moves all the zero elements to the end of the list.\n    The order of the non-zero elements remains unchanged.\n    \"\"\"\n    non_zero = []\n    zeroes = []\n    for num in arr:\n        if num == 0:\n            zeroes.append(0)\n        else:\n            non_zero.append(num)\n    return non_zero + zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    This function takes a list arr and moves all zeroes to the end of the list.\n    \"\"\"\n    zeroes = 0\n    non_zero_elements = []\n\n    for el in arr:\n        if el == 0:\n            zeroes += 1\n        else:\n            non_zero_elements.append(el)\n\n    return non_zero_elements + [0] * zeroes", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    This function moves all zeroes to the end of the given list.\n\n    Args:\n        lst (list): The list to be modified.\n\n    Returns:\n        list: The modified list with all zeroes at the end.\n\n    Example:\n        >>> move_zero([1,0,2,0,3,4])\n        [1,2,3,4,0,0]\n    \"\"\"\n    # Count the number of zeroes in the list\n    zero_count = lst.count(0)\n\n    # Remove all zeroes from the list\n    lst = [num for num in lst if num != 0]\n\n    # Extend the list by the number of zeroes found\n    lst.extend([0]*zero_count)\n\n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize the count of non-zero elements\n    count = 0\n    \n    # Traverse the array and copy non-zero elements\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[count] = nums[i]\n            count += 1\n            \n    # Fill the remaining positions with zeroes\n    while count < len(nums):\n        nums[count] = 0\n        count += 1\n        \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    This function moves all zeros to the end of the given list.\n    \n    :param nums: A list of integers\n    :return: A list with all zeros moved to the end\n    \"\"\"\n    count = 0  # Count of non-zero elements\n    n = len(nums)\n    \n    # Traverse the array. If element encountered is non-zero, then replace the element at index 'count' with this element\n    for i in range(n):\n        if nums[i] != 0:\n            nums[count] = nums[i]\n            count+=1\n    \n    # All remaining elements are zero\n    while count < n:\n        nums[count] = 0\n        count += 1\n    \n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    :param lst: List of integers\n    :return: List with all zeroes moved to the end\n\n    >>> move_zero([1,0,2,0,3,4])\n    [1,2,3,4,0,0]\n    \"\"\"\n    non_zero_elements = [i for i in lst if i != 0]\n    zero_elements = [i for i in lst if i == 0]\n    return non_zero_elements + zero_elements", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    This function takes a list of numbers and moves all zeroes to the end of the list.\n    \n    Parameters:\n    nums (list): The list of numbers.\n    \n    Returns:\n    list: The modified list with all zeroes moved to the end.\n    \"\"\"\n    # Initialize a counter for the zeroes\n    zero_counter = 0\n    \n    # Remove all zeroes from the list and count them\n    clean_list = []\n    for num in nums:\n        if num == 0:\n            zero_counter += 1\n        else:\n            clean_list.append(num)\n    \n    # Add the zeroes to the end of the list\n    for _ in range(zero_counter):\n        clean_list.append(0)\n    \n    return clean_list", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    \"\"\"\n    This function takes a list of integers and moves all the zeroes to the end of the list.\n    The relative order of the non-zero elements is maintained.\n    \"\"\"\n    non_zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index]\n            non_zero_index += 1\n    return nums", "matching_cluster_idx": 6}, {"solution": "def move_zero(arr):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n    \n    :param arr: list of numbers\n    :return: list with zeroes moved to the end\n    \"\"\"\n    count = 0  # Count of non-zero elements\n    n = len(arr)\n    \n    # Traverse the array. If element encountered is non-zero, then\n    # replace the element at index 'count' with this element\n    for i in range(n):\n        if arr[i] != 0:\n            # here count is previous index of non zero element.\n            arr[count] = arr[i]\n            count+=1\n    \n    # Now all non-zero elements have been shifted to front and 'count' is\n    # index of first 0. Make all elements 0 from count to end.\n    while count < n:\n        arr[count] = 0\n        count += 1\n    return arr", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    \"\"\"\n    Moves all zeros to the end of the given list.\n    \"\"\"\n    non_zero = [x for x in lst if x != 0]\n    zeros = [0] * (len(lst) - len(non_zero))\n    return non_zero + zeros", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 95.60975609756098, "dps_norm": 60.0, "pass@1": 81.0, "profiled": [{"solution": "def pair_xor_Sum(arr,n):\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            res += arr[i] ^ arr[j]\n    return res", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    sum = 0\n    for i in range(0,32):\n        count = 0\n        for j in range(0,n):\n            if((arr[j] & (1 << i))):\n                count+=1\n        sum += count * (n - count) * (1 << i)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr,n):\n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            result += arr[i] ^ arr[j]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    res = 0\n    for i in range(31, -1, -1):\n        x, y = 0, 0\n        for j in range(n):\n            if (arr[j] & (1 << i)):\n                x += 1\n            else:\n                y += 1\n        res += x*y*(1 << i)\n    return res", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    Given a list of 'n' integers, find the sum of XOR of all pairs of numbers in the list.\n\n    :param arr: List of 'n' integers\n    :param n: Number of integers in the list\n    :return: Sum of XOR of all pairs of numbers in the list\n    \"\"\"\n    result = 0\n    for i in range(32):\n        cnt = 0\n        for j in range(n):\n            if arr[j] & (1 << i):\n                cnt += 1\n        result += cnt * (n - cnt) * (1 << i)\n    return result", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr,n):\n    sum = 0\n    for i in range(0, 32):\n        count = 0\n        for j in range(0, n):\n            if((arr[j] >> i) & 1):\n                count+=1\n        sum += count * (n-count) * (1 << i)\n    return sum", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr,n): \n    xor_sum = 0 \n    for i in range(n): \n        for j in range(i+1,n): \n            xor_sum += arr[i] ^ arr[j] \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    xor_sum = 0\n    for i in range(0,n):\n        for j in range(i+1,n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    result = 0\n    for i in range(0,32):\n        count = 0\n        for j in range(0,n):\n            if((arr[j] & (1 << i))):\n                count+=1\n        result = result + (count * (n-count) * (1 << i))\n    return result", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr,n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    sum = 0\n    for i in range(0,n):\n        for j in range(i+1,n):\n            sum = sum + (arr[i] ^ arr[j])\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n) : \n    total_xor_sum = 0\n    for i in range(n) : \n        for j in range(i+1, n) : \n            total_xor_sum += arr[i] ^ arr[j] \n    return total_xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            xor_sum += arr[i] ^ arr[j]\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += arr[i] ^ arr[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(nums,n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += nums[i] ^ nums[j]\n    return sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    result = 0\n    for i in range(32):\n        count = 0\n        for j in range(n):\n            if(arr[j] & (1 << i)):\n                count += 1\n        result += count * (n - count) * (1 << i)\n    return result", "matching_cluster_idx": 4}, {"solution": "def pair_xor_Sum(arr, n):\n    # Calculate xor for all pairs and sum them up\n    sum_xor = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum_xor += arr[i] ^ arr[j]\n    return sum_xor", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr,n):  \n    ans = 0; \n    for i in range(31, -1, -1): \n        x = 0; \n        y = 0; \n        for j in range(0,n,1): \n            if((arr[j] & (1 << i))): \n                x = x + 1; \n            else: \n                y = y + 1; \n        ans = ans + (x * y * (1 << i)); \n    return ans;", "matching_cluster_idx": 3}, {"solution": "def pair_xor_Sum(nums,n):\n    # Calculate the sum of XOR of all pairs\n    total_xor_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total_xor_sum += nums[i] ^ nums[j]\n    return total_xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 90.18617021276594, "dps_norm": 90.0, "pass@1": 87.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array segment upto position k\n    \n    :param arr: List[int] - The input array\n    :param k: int - The ending index of the segment to be reversed\n    :return: List[int] - The modified array\n    \"\"\"\n    # Reverse the segment of the array upto position k\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse array upto position k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    i = 0\n    j = k - 1\n    while i < j:\n        arr[i], arr[j] = arr[j], arr[i]\n        i += 1\n        j -= 1\n    return arr", "matching_cluster_idx": 6}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Slice the array upto position k and reverse it\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the first k elements of the input array arr.\n\n    Args:\n    arr: List of integers.\n    k: An integer that defines the number of elements to reverse.\n\n    Returns:\n    arr: The input array after reversing the first k elements.\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(A,K):\n    A = A[:K][::-1] + A[K:]\n    return A", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of an array up to a given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The modified array after reversal.\n\n    Example:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(array, k):\n    \"\"\"\n    This function reverses the elements of an array up to a given position.\n    \n    Args:\n        array (list): The array to be reversed.\n        k (int): The position up to which the array should be reversed.\n    \n    Returns:\n        list: The reversed array.\n        \n    Raises:\n        IndexError: If k is larger than the size of the array.\n    \"\"\"\n    if k > len(array):\n        raise IndexError(\"k is larger than the size of the array\")\n    else:\n        array[:k] = array[:k][::-1]\n    return array", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr,k):\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array elements upto a given position K.\n\n    :param arr: List[int] - The input array.\n    :param k: int - The position upto which the array should be reversed.\n    :return: List[int] - The modified array.\n    \"\"\"\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(nums, k):\n    \"\"\"\n    Reverse the elements in the list `nums` up to the given position `k`.\n\n    Parameters:\n    nums (list): The list of integers to be reversed.\n    k (int): The position up to which the list should be reversed.\n\n    Returns:\n    list: The reversed list up to the given position `k`.\n    \"\"\"\n    if not nums or k <= 0 or k > len(nums):\n        return nums\n\n    nums[:k] = nums[:k][::-1]\n    return nums", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse the first k elements of the given array.\n\n    :param arr: List of elements to be reversed.\n    :param k: Number of elements from the start of the array to be reversed.\n    :return: Modified array with first k elements reversed.\n    \"\"\"\n    # Reversing the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(A, K):\n    return A[:K][::-1] + A[K:]", "matching_cluster_idx": 10}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Parameters:\n    arr (list): The input list.\n    k (int): The position up to which the list should be reversed.\n\n    Returns:\n    list: The reversed list up to position k.\n\n    Examples:\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 4)\n    [4, 3, 2, 1, 5, 6]\n\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 1)\n    [1, 2, 3, 4, 5, 6]\n\n    >>> reverse_Array_Upto_K([1, 2, 3, 4, 5, 6], 6)\n    [6, 5, 4, 3, 2, 1]\n    \"\"\"\n    arr[:k] = arr[k-1::-1]\n    return arr", "matching_cluster_idx": 14}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(nums, k):\n    \"\"\"\n    Reverses the first k elements of a given list.\n\n    :param nums: List of elements to reverse.\n    :param k: Number of elements from the beginning of the list to reverse.\n    :return: A list with first k elements reversed.\n    \"\"\"\n    nums[:k] = nums[:k][::-1]\n    return nums", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 93.84615384615384, "dps_norm": 98.0, "pass@1": 92.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dict_):\n    \"\"\"\n    Adds a dictionary to the end of a given tuple and returns it.\n\n    :param tup: Tuple to which the dictionary will be added.\n    :param dict_: Dictionary to be added.\n    :return: Tuple with dictionary added.\n    \"\"\"\n    return tup + (dict_,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    \"\"\"\n    This function takes a tuple and a dictionary as arguments and returns a new tuple containing the original tuple and the dictionary.\n    \n    :param my_tuple: a tuple to which the dictionary will be added.\n    :param my_dict: a dictionary to be added to the tuple.\n    \n    :return: A new tuple consisting of the original tuple followed by the dictionary.\n    \"\"\"\n    return my_tuple + (my_dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    This function takes a tuple and a dictionary as inputs and returns a new tuple\n    containing the original tuple elements along with the dictionary.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to be added to the tuple.\n    \n    Returns:\n    tuple: A new tuple containing the original tuple elements and the dictionary.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    :param tup: Tuple to which a dictionary will be added.\n    :param dict: Dictionary to be added.\n    :return: Tuple containing the original elements plus the dictionary.\n    \"\"\"\n    return tup + (dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Function to add a dictionary to the tuple. The output should be a tuple.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dictionary):\n    \"\"\"\n    Function to add a dictionary to a tuple.\n    The output should be a tuple.\n    \"\"\"\n    return tpl + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the given tuple.\n    :param tup: A tuple\n    :param dictionary: A dictionary\n    :return: A tuple with the dictionary appended\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tpl, dict_to_add):\n    \"\"\"\n    This function takes a tuple and a dictionary as parameters and returns a tuple with the dictionary added at the end.\n    \n    :param tpl: The tuple to which the dictionary will be added.\n    :param dict_to_add: The dictionary to add to the tuple.\n    :return: A new tuple containing all elements of the input tuple followed by the input dictionary.\n    \"\"\"\n    return tpl + (dict_to_add,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    test_tup = list(test_tup)\n    test_tup.append(test_dict)\n    return tuple(test_tup)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    \"\"\"\n    This function takes a tuple and a dictionary as arguments, and returns a new tuple which is the result of joining the original tuple with the dictionary.\n    \n    :param test_tup: tuple -- Tuple which needs to be joined.\n    :param test_dict: dict -- Dictionary which needs to be joined.\n    :return: tuple -- Tuple consisting of the joined tuple and dictionary.\n    \"\"\"\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    This function takes a tuple and a dictionary as input and returns a new tuple which includes the original tuple elements\n    as well as the dictionary. It does this by concatenating the dictionary to the tuple with a comma in between.\n\n    :param tup: A tuple\n    :param dictionary: A dictionary\n    :return: A new tuple with the dictionary appended to the original tuple.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_arg):\n    \"\"\"\n    This function takes a tuple and a dictionary, and appends the dictionary to the end of the tuple.\n    The output is another tuple containing all the original elements plus the dictionary.\n\n    Example:\n    >>> add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} )\n    (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n    \"\"\"\n    # Converting tuple to list to make it mutable\n    list_arg = list(tup)\n    \n    # Appending dictionary to list\n    list_arg.append(dict_arg)\n    \n    # Converting list back to tuple\n    result = tuple(list_arg)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(original_tuple, dictionary):\n    \"\"\"\n    Adds a dictionary to the original tuple.\n\n    Parameters:\n    original_tuple (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The modified tuple with the dictionary appended at the end.\n    \"\"\"\n    return original_tuple + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    \"\"\"\n    Adds a dictionary to the tuple.\n\n    Parameters:\n    tup (tuple): Existing tuple\n    dict (dict): Dictionary to be added\n\n    Returns:\n    tuple: New tuple containing all elements of the input tuple and the input dictionary\n    \"\"\"\n    return tup + (dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict_val):\n    return tup + (dict_val,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dict):\n    return tup + (dict,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tuple, test_dict):\n    return test_tuple + tuple([test_dict])", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Add a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add.\n\n    Returns:\n    tuple: The tuple with the dictionary added.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(my_tuple, my_dict):\n    return my_tuple + (my_dict,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 70.60109289617486, "dps_norm": 73.75, "pass@1": 31.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts values between quotation marks from a given string.\n\n    Parameters:\n    s (str): The input string from which to extract the values.\n\n    Returns:\n    list: A list of strings extracted between quotation marks.\n\n    Examples:\n    >>> extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"')\n    ['A53', 'multi', 'Processor']\n    \"\"\"\n    return re.findall(r'\\\"([^\"]*)\\\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(string):\n    \"\"\"\n    This function extracts values between quotation marks from a given string.\n\n    :param string: Input string.\n    :return: A list containing values between quotation marks.\n    \"\"\"\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, string)\n    return [match.strip('\"') for match in matches]", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"([^\"]*)\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\".*?\"'\n    matches = re.findall(pattern, s)\n    return [match.strip('\"') for match in matches]", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\\\"([^\\\"]*)\\\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\\\"(.*?)\\\"'\n    return re.findall(pattern, s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(string):\n    # Use regex to find all strings between quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    return re.findall(r'\"([^\"]*)\"', text)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    pattern = r'\"([^\"]*)\"'\n    matches = re.findall(pattern, s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    pattern = r'\\\"([^\\\"]*)\\\"'\n    matches = re.findall(pattern, text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s: str) -> list:\n    \"\"\"\n    Extracts values between quotation marks from the given string.\n    \n    Parameters:\n    s (str): A string potentially containing values between quotation marks.\n    \n    Returns:\n    list: A list of all values found between quotation marks.\n    \"\"\"\n    # Using regex to find all occurrences between quotation marks\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    \"\"\"\n    Extracts the values between quotation marks in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    list: A list of extracted values.\n    \"\"\"\n    return re.findall(r'\\\"(.*?)\\\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 95.29069767441861, "dps_norm": 97.0, "pass@1": 93.0, "profiled": [{"solution": "def replace_specialchar(text):\n    for special_char in [' ', ',', '.']:\n        text = text.replace(special_char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    \"\"\"Replace all occurrences of spaces, commas, or dots with a colon.\"\"\"\n    for ch in [' ', ',', '.']:\n        string = string.replace(ch, ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    This function takes a string as input and replaces all occurrences of spaces, commas, or dots with a colon.\n    \"\"\"\n    for specialchar in [' ', ',', '.']:\n        text = text.replace(specialchar, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    Function to replace all occurrences of spaces, commas, or dots with a colon.\n\n    Parameters:\n    text (str): The input text.\n\n    Returns:\n    str: The modified text with all special characters replaced with a colon.\n    \"\"\"\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    # replace spaces\n    s = s.replace(' ', ':')\n    # replace commas\n    s = s.replace(',', ':')\n    # replace dots\n    s = s.replace('.', ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s):\n    \"\"\"\n    Replace all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    str: The modified string with special characters replaced by a colon.\n    \"\"\"\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    This function replaces all occurrences of spaces, commas, or dots in the given text with a colon.\n    \"\"\"\n    for char in [' ', ',', '.']:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "import re\ndef replace_specialchar(string):\n    pattern = '[ ,.]'\n    rep = ':'\n    return re.sub(pattern, rep, string)", "matching_cluster_idx": 3}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    This function will take a string with space, comma, or dot as the separator and replaces them with a colon.\n    For example:\n    replace_specialchar('Python language, Programming language.') \n    should return 'Python:language::Programming:language:'\n    \"\"\"\n    for char in [' ', ',', '.']:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    for char in [' ', ',', '.']:\n        text = text.replace(char, ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(s: str) -> str:\n    \"\"\"Replace all occurrences of spaces, commas, or dots with a colon.\"\"\"\n    for char in [' ', ',', '.']:\n        s = s.replace(char, ':')\n    return s", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    special_chars = [' ', ',', '.']\n    for char in special_chars:\n        string = string.replace(char, ':')\n    return string", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(str):\n    for special_char in [' ', ',', '.']:\n        str = str.replace(special_char, ':')\n    return str", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"Replaces all spaces, commas, or dots in the input string with a colon.\"\"\"\n    # Replace spaces\n    text = text.replace(' ', ':')\n    # Replace commas\n    text = text.replace(',', ':')\n    # Replace dots\n    text = text.replace('.', ':')\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    \"\"\"\n    This function takes a string as an input and replaces all occurrences of spaces, commas, or dots with a colon.\n    Args:\n    text (str): input string\n\n    Returns:\n    str: modified string with all occurrences of spaces, commas, or dots replaced by a colon\n    \"\"\"\n\n    for special_char in [\" \", \",\", \".\"]:\n        text = text.replace(special_char, \":\")\n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(string):\n    for char in [' ', ',', '.']:\n        string = string.replace(char, ':')\n    return string", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 86.9090909090909, "dps_norm": 73.33333333333334, "pass@1": 97.0, "profiled": [{"solution": "def tuple_to_dict(test_tup):\n    res = {}\n    for i in range(0, len(test_tup), 2):\n        res[test_tup[i]] = test_tup[i + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    if len(input_tuple) % 2 != 0:\n        raise ValueError('Input tuple should contain an even number of elements')\n\n    # Convert the tuple into a dictionary\n    return dict(zip(input_tuple[::2], input_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n  res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup), 2)}\n  return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tuple):\n    return dict(zip(test_tuple[::2], test_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(test_tup):\n    res = {test_tup[i]: test_tup[i+1] for i in range(0, len(test_tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    \"\"\"\n    Converts the given tuple to a key-value dictionary using adjacent elements.\n\n    Parameters:\n    input_tuple (tuple): The input tuple to convert to dictionary.\n\n    Returns:\n    dict: The converted dictionary.\n    \"\"\"\n    return dict(zip(input_tuple[::2], input_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(test_tup):\n  res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup), 2)}\n  return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a tuple into a key-value dictionary with adjacent elements.\n    \n    Parameters:\n        t (tuple): The input tuple containing arbitrary elements.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \n    Examples:\n        >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n        {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    return {t[i]: t[i+1] for i in range(0, len(t)-1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    :param tup: A tuple where each item is considered as a key-value pair.\n    :return: A dictionary built from the tuple.\n    \"\"\"\n    result = {}\n    for i in range(0, len(tup), 2):\n        result[tup[i]] = tup[i + 1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Write a function to convert the given tuple to a key-value dictionary using adjacent elements.\n    assert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n    \"\"\"\n    result = {}\n    for i in range(0, len(tup)-1, 2):\n        result[tup[i]] = tup[i+1]\n    return result", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    output_dict = {}\n    for i in range(0, len(input_tuple), 2):\n        output_dict[input_tuple[i]] = input_tuple[i+1]\n    return output_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup), 2)}\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tuple):\n    return dict(zip(test_tuple[::2], test_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements. \n    \"\"\"\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    res = {}\n    for i in range(0, len(test_tup), 2):\n        res[test_tup[i]] = test_tup[i + 1]\n    return res", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    res = {test_tup[i]: test_tup[i + 1] for i in range(0, len(test_tup), 2)}\n    return (res)", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert a tuple of 2n elements into a dictionary with n key-value pairs.\n\n    Parameters:\n    t (tuple): A tuple with 2n elements where n represents the number of key-value pairs.\n\n    Returns:\n    dict: A dictionary constructed from the tuple.\n\n    Examples:\n    >>> tuple_to_dict((1, 5, 7, 10, 13, 5))\n    {1: 5, 7: 10, 13: 5}\n\n    >>> tuple_to_dict((2, 'apple', 3, 'banana', 4, 'cherry'))\n    {2: 'apple', 3: 'banana', 4: 'cherry'}\n    \"\"\"\n    result_dict = {}\n    for i in range(0, len(t), 2):\n        result_dict[t[i]] = t[i + 1]\n    return result_dict", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 69.6917808219178, "dps_norm": 78.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def check_none(input_tuple):\n    for value in input_tuple:\n        if value is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    \"\"\"\n    This function checks if the given tuple has any none value or not.\n    \"\"\"\n    return None in t", "matching_cluster_idx": 5}, {"solution": "def check_none(t):\n    \"\"\"\n    Check if the given tuple has any none value or not.\n    \"\"\"\n    for item in t:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    \"\"\"\n    Function to check if the given tuple has any none value or not.\n    If none value is present, the function returns True otherwise False.\n    \"\"\"\n    return any(val is None for val in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    for val in test_tup:\n        if val is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    return None in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tup):\n  return any(value is None for value in test_tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    This function checks whether the given tuple has any None value or not.\n\n    :param input_tuple: a tuple to be checked\n    :return: True if tuple has None, False otherwise\n    \"\"\"\n    return any(item is None for item in input_tuple)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    return any(x is None for x in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(t):\n    for i in t:\n        if i is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tuple):\n    \"\"\"\n    This function checks if the given tuple has any none value or not.\n    :param test_tuple: Tuple\n    :return: bool\n    \"\"\"\n    return None in test_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tuple):\n    for item in test_tuple:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    for i in input_tuple:\n        if i is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n    \"\"\"\n    for i in t:\n        if i is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    for element in test_tup:\n        if element is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    \"\"\"\n    This function checks if the given tuple has any none value or not.\n\n    :param test_tup: tuple\n    :return: boolean\n    \"\"\"\n    for value in test_tup:\n        if value is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(t):\n    for item in t:\n        if item is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(input_tuple):\n    \"\"\"\n    Function to check if the given tuple has any none value or not.\n    \"\"\"\n    return None in input_tuple", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    return any(val is None for val in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tuple):\n  for i in test_tuple:\n    if i is None:\n      return True\n  return False", "matching_cluster_idx": 4}]}, "Mbpp/750": {"dps": 64.8639455782313, "dps_norm": 63.333333333333336, "pass@1": 87.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list, tuple):\n    \"\"\"Adds a tuple to the given list\"\"\"\n    list.extend(tuple)\n    return list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    This function adds a tuple to a list.\n\n    Parameters:\n    lst (list): The list to which the tuple is added.\n    tup (tuple): The tuple to be added to the list.\n\n    Returns:\n    list: The modified list with the tuple added.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(test_list, test_tuple):\n    \"\"\"Function to add the given tuple to the given list\"\"\"\n    res = test_list + list(test_tuple)\n    return (res)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add a tuple to a list.\n\n    Parameters:\n    lst (list): The list to which the tuple is to be added.\n    tup (tuple): The tuple to add to the list.\n\n    Returns:\n    list: The updated list after adding the tuple.\n    \"\"\"\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(t_list, t_tuple):\n    \"\"\"\n    This function takes a list and a tuple as arguments, \n    and adds the tuple elements to the list.\n    \"\"\"\n    return t_list + list(t_tuple)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the tuple to the end of the list.\n    :param lst: list of elements\n    :param tup: tuple to add\n    :return: modified list\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    \"\"\"\n    This function adds the given tuple to the given list.\n\n    :param lst: list, a list to which a tuple should be added\n    :param tpl: tuple, a tuple to be added to the list\n    :return: list, a modified list with the tuple added at the end\n    \"\"\"\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"\n    This function takes a list and a tuple as parameters and \n    returns a new list that contains all the elements of the original list\n    followed by all the elements of the given tuple.\n    \"\"\"\n    return list1 + list(tuple1)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_elements, tuple_elements):\n    \"\"\"\n    Add a tuple to a list\n    \"\"\"\n    return list_elements + list(tuple_elements)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list, tuple):\n    \"\"\"\n    This function takes a list and a tuple as input. It adds the elements of the tuple to the end of the list and returns the updated list.\n    \"\"\"\n    for i in tuple:\n        list.append(i)\n    return list", "matching_cluster_idx": 0}, {"solution": "def add_tuple(test_list, test_tuple):\n    res = test_list + list(test_tuple)\n    return res", "matching_cluster_idx": 2}, {"solution": "def add_tuple(t_list, t_tuple):\n    \"\"\"\n    A function to add the given tuple to the given list.\n    \n    Parameters:\n    t_list (list): the list to which the tuple will be added\n    t_tuple (tuple): the tuple to add to the list\n    \n    Returns:\n    list: the updated list with the tuple added\n    \n    >>> add_tuple([5, 6, 7], (9, 10))\n    [5, 6, 7, 9, 10]\n    \n    >>> add_tuple([], (1, 2))\n    [1, 2]\n    \n    >>> add_tuple([1, 2, 3], ())\n    [1, 2, 3]\n    \"\"\"\n    t_list.extend(t_tuple)\n    return t_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    return lst + list(tup)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(list_input, tuple_input):\n    \"\"\"\n    Add the given tuple to the given list.\n    \n    Parameters:\n    list_input (list): The list to which the tuple will be added.\n    tuple_input (tuple): The tuple to add to the list.\n    \n    Returns:\n    list: The updated list with the tuple added.\n    \"\"\"\n    return list_input + list(tuple_input)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Function to add the given tuple to the given list.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(list1, tuple1):\n    \"\"\"\n    This function takes two parameters: list1, which is a list, and tuple1, which is a tuple.\n    It adds tuple1 to list1 and returns the resulting list.\n    \n    :param list1: a list\n    :param tuple1: a tuple\n    :return: list1 with tuple1 added as an element\n    \"\"\"\n    list1.extend(tuple1)\n    return list1", "matching_cluster_idx": 5}, {"solution": "def add_tuple(my_list, my_tuple):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Parameters:\n    my_list (list): The list to which the tuple will be added.\n    my_tuple (tuple): The tuple to add to the list.\n\n    Returns:\n    list: The updated list with the tuple added.\n    \"\"\"\n    return my_list + list(my_tuple)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 83.0, "profiled": [{"solution": "def min_k(test_list, K):\n    # use the built-in sort function to order the list of tuples based on the second item in the tuple\n    test_list.sort(key = lambda x: x[1])\n    \n    # return the first k tuples from the sorted list\n    return test_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sorting the list on basis of marks\n    res = sorted(test_list, key = lambda ele:ele[1]) \n      \n    # return the minimum k elements\n    res = res[:K]\n    return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, N):\n    test_list = sorted(test_list, key = lambda ele: ele[1]) \n    res = test_list[:N] \n    return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    test_list.sort(key = lambda x: x[1]) \n    return test_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, N):\n    test_list.sort(key = lambda x: x[1])\n    res = test_list[:N]\n    return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    test_list = sorted(test_list, key = lambda ele: ele[1])\n    res = test_list[:k]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n  test_list.sort(key = lambda ele: ele[1])\n  return (test_list[:k])", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    #Sort the list based on the second element in each tuple\n    lst = sorted(lst, key = lambda x: x[1]) \n    #Return the first k tuples from the sorted list\n    return lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    test_list.sort(key = lambda x: x[1])\n    res = test_list[:k]\n    return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    test_list.sort(key = lambda ele : ele[1])\n    res = test_list[:K]\n    return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    test_list.sort(key = lambda x: x[1])\n    res = test_list[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    test_list.sort(key = lambda ele:ele[1])\n    return test_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    \"\"\"\n    This function takes a list of tuples and an integer K, and returns the K tuples with minimum second element.\n    If K is greater than the length of the list, it returns the entire list.\n    \"\"\"\n    if K >= len(test_list):\n        return sorted(test_list, key=lambda x: x[1])\n    return sorted(test_list, key=lambda x: x[1])[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    res = sorted(test_list, key=lambda ele: ele[1])[:K]\n    return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, N):\n    res = sorted(test_list, key = lambda ele:ele[1])[:N]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    test_list.sort(key = lambda x: x[1])\n    return (test_list[:k])", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    test_list.sort(key = lambda x: x[1])\n    return (test_list[:K])", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n  res = sorted(test_list, key = lambda ele: ele[1])[:K]\n  return (res)", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    test_list = sorted(test_list, key = lambda ele : ele[1])\n    return test_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, N):\n  res = sorted(test_list, key = lambda ele: ele[1])[:N]\n  return (res)", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 61.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes in three lists, and returns a list of elements that are common for all three lists under the same index.\n\n    Args:\n    l1 (list): First list.\n    l2 (list): Second list.\n    l3 (list): Third list.\n\n    Returns:\n    list: A list of common elements for l1, l2, and l3 at the same indices.\n    \"\"\"\n\n    # Initialize an empty list to store the common elements\n    common_elements = []\n\n    # Loop through the lists and check for common elements\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    The function finds common elements from three lists. If an element is present in all three lists under the same index,\n    it adds this element to the common list. Finally, it returns the common list.\n    \"\"\"\n    common_list = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_list.append(l1[i])\n    return common_list", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists. The function should return a list.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index.\n    Write a function to find common elements from three lists.\n    The function should return a list.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n            \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    The function accepts three lists l1, l2, and l3 as input and returns a list of common elements.\n    Elements are considered common if they appear in all three lists at the same index.\n    \"\"\"\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n            \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef extract_index_list(l1: List[int], l2: List[int], l3: List[int]) -> List[int]:\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\n    :param l1: First list\n    :param l2: Second list\n    :param l3: Third list\n    :return: List of common elements\n    \"\"\"\n    common_elements = []\n\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n            \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds common elements from three lists under the same index and returns them in a list.\n    \"\"\"\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length list to avoid index out of range error\n    min_len = min(len(l1), len(l2), len(l3))\n    \n    # List to store common elements\n    common_elements = []\n\n    for i in range(min_len):\n        # Check if the element at index i is same in all lists\n        if l1[i] == l2[i] == l3[i]:\n            # Add the common element to the list\n            common_elements.append(l1[i])\n\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function finds common elements between three lists under the same index.\n    :param l1: List 1\n    :param l2: List 2\n    :param l3: List 3\n    :return: A list of common elements\n    \"\"\"\n    common_elements = []\n    # iterate over the minimum length of the three lists\n    for i in range(min(len(l1), len(l2), len(l3))):\n        # check if elements at current index in all three lists are same\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. \n    Write a function to find common elements from three lists. \n    The function should return a list.\n    \"\"\"\n    common = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common.append(l1[i])\n    return common", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    Extracts common elements at the same index from three input lists.\n    \n    Args:\n    l1: The first list.\n    l2: The second list.\n    l3: The third list.\n    \n    Returns:\n    A list containing common elements from l1, l2, and l3 at the same index.\n    \"\"\"\n\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate over the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the elements at the same index in all three lists are the same\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_len = min(len(l1), len(l2), len(l3))\n    for i in range(min_len):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    min_length = min(len(l1), len(l2), len(l3))\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 78.84955752212389, "dps_norm": 91.66666666666667, "pass@1": 44.0, "profiled": [{"solution": "def second_smallest(numbers):\n    unique_numbers = sorted(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    unique_nums = sorted(set(nums))\n    return unique_nums[1] if len(unique_nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    # Removing duplicates by converting the list to a set\n    unique_nums = set(nums)\n    \n    # If the length of unique numbers is less than 2, there is no second smallest number\n    if len(unique_nums) < 2:\n        return None\n\n    # Converting the set back to a list and sorting the list in ascending order\n    sorted_nums = sorted(list(unique_nums))\n\n    # Returning the second smallest number\n    return sorted_nums[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    \"\"\"\n    Find the second smallest number in a list.\n    \"\"\"\n    unique_nums = sorted(set(nums))\n    return unique_nums[1] if len(unique_nums) > 1 else None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    Returns the second smallest number in a list.\n    If the list has less than two distinct elements, returns None.\n    \"\"\"\n    unique_numbers = sorted(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if len(nums) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(lst):\n    \"\"\"\n    Find the second smallest number in a list.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    \n    # Check if list has at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None\n    \n    return unique_lst[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    if not nums or len(nums) < 2:\n        return None\n    smallest = second_smallest = float('inf')\n    for num in nums:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    if second_smallest == float('inf'):\n        return None\n    return second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    smallest = second_smallest_num = float('inf')\n    for num in numbers:\n        if num < smallest:\n            second_smallest_num = smallest\n            smallest = num\n        elif smallest < num < second_smallest_num:\n            second_smallest_num = num\n    return second_smallest_num if second_smallest_num != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    unique_numbers = sorted(set(numbers))\n    if len(unique_numbers) > 1:\n        return unique_numbers[1]\n    else:\n        return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(nums):\n    smallest = float('inf')\n    second_smallest_num = float('inf')\n\n    for num in nums:\n        if num < smallest:\n            second_smallest_num = smallest\n            smallest = num\n        elif smallest < num < second_smallest_num:\n            second_smallest_num = num\n    \n    if second_smallest_num == float('inf'):\n        return None\n    return second_smallest_num", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    unique_numbers = list(set(numbers))\n    unique_numbers.sort()\n    if len(unique_numbers) < 2:\n        return None\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest numbers to infinity\n    first, second = float('inf'), float('inf')\n    \n    # Traverse through all numbers in the list\n    for num in numbers:\n        # If the current number is smaller than the first smallest, update both first and second smallest\n        if num < first:\n            second = first\n            first = num\n        # If the current number is between the first and second smallest, update the second smallest\n        elif num < second and num != first:\n            second = num\n            \n    # If second smallest was updated from its initial value, return it, else return None\n    return second if second != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if not numbers:  # if the list is empty\n        return None\n    if len(numbers) < 2:  # if there are less than 2 elements\n        return None\n    unique_numbers = list(set(numbers))  # remove duplicates\n    if len(unique_numbers) < 2:  # if there are less than 2 unique elements\n        return None\n    unique_numbers.sort()  # sort the list\n    return unique_numbers[1]  # return the second smallest number", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    \"\"\"\n    This function takes a list of numbers and returns the second smallest number in the list.\n    \"\"\"\n    # Check if list is long enough\n    if len(numbers) < 2:\n        return None\n\n    # Initialize smallest and second_smallest to infinity\n    smallest = second_smallest = float('inf')\n\n    # Iterate through the list\n    for number in numbers:\n        # Update smallest if current number is smaller\n        if number < smallest:\n            second_smallest = smallest\n            smallest = number\n        # Update second_smallest if current number is not smaller but not equal to smallest\n        elif number < second_smallest and number != smallest:\n            second_smallest = number\n\n    # Check if second_smallest was updated\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if not numbers or len(numbers) < 2:\n        return None\n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    min1, min2 = float('inf'), float('inf')\n    for num in numbers:\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    unique_numbers = list(set(numbers)) # Remove duplicates\n    unique_numbers.sort() # Sort the list\n    if len(unique_numbers) > 1: # Check if there are at least 2 unique numbers\n        return unique_numbers[1] # Return the second smallest number\n    else:\n        return None # If there is only one unique number or none, return None", "matching_cluster_idx": 5}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    min_num = second_min = float('inf')\n    for num in numbers:\n        if num < min_num:\n            second_min = min_num\n            min_num = num\n        elif num < second_min and num != min_num:\n            second_min = num\n    return second_min if second_min != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    \n    unique_numbers = list(set(numbers))\n    if len(unique_numbers) < 2:\n        return None\n    \n    unique_numbers.sort()\n    return unique_numbers[1]", "matching_cluster_idx": 5}]}, "Mbpp/757": {"dps": 82.80373831775701, "dps_norm": 24.23076923076923, "pass@1": 94.0, "profiled": [{"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    # Initialize counter for reverse string pairs\n    count = 0\n    # Iterate over each string in the list\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            # Compare the reverse of the current string with the next string\n            if str_list[i] == str_list[j][::-1]:\n                # Increment the counter if a match is found\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list. \n    assert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== 2\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list. \n    \n    :param lst: List of strings\n    :return: Number of pairs of reverse strings\n    \n    Example:\n    count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== 2\n    \"\"\"\n    reverse_pairs_count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                reverse_pairs_count += 1\n    return reverse_pairs_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    # Initialize a counter\n    counter = 0\n    # Iterate through the list\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            # If the reverse of one string is equal to the other, increment counter\n            if lst[i][::-1] == lst[j]:\n                counter += 1\n    # Return the final count\n    return counter", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(words):\n    count = 0\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i] == words[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    \"\"\"\n    Write a function to count the pairs of reverse strings in the given string list. \n    :param str_list: List of strings\n    :return: Number of pairs of reverse strings\n    \"\"\"\n    str_pairs = 0\n    for i in range(len(str_list)):\n        for j in range(i+1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                str_pairs += 1\n    return str_pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(list_str):\n    \"\"\"\n    Counts the number of pairs of strings in a list which are reverse of each other.\n    The function returns an integer, where each pair is counted once.\n    :param list_str: List of strings.\n    :return: count: An integer representing the number of pairs of reverse strings.\n    \"\"\"\n    count = 0\n    for i in range(len(list_str)):\n        for j in range(i+1, len(list_str)):\n            if list_str[i] == list_str[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    This function takes a list of strings as input and returns the number of pairs of reverse strings.\n    A pair is defined as two strings where one is the reverse of the other.\n    \"\"\"\n    reverse_string_pairs_count = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                reverse_string_pairs_count += 1\n    return reverse_string_pairs_count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    reversed_dict = {i: i[::-1] for i in string_list}\n    pair_count = 0\n\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == reversed_dict[string_list[j]]:\n                pair_count += 1\n\n    return pair_count", "matching_cluster_idx": 5}, {"solution": "def count_reverse_pairs(str_list):\n    count = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    \"\"\"\n    This function takes a list of strings and returns the count of pairs that are reverses of each other.\n    \"\"\"\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(list):\n    count = 0\n    for i in range(len(list)):\n        for j in range(i+1, len(list)):\n            if list[i] == list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(str_list):\n    \"\"\"\n    Count the number of pairs of strings in a list that are reverse of each other.\n    Args:\n        str_list (list): List of strings\n    Returns:\n        int: Count of pairs of reverse strings\n    \"\"\"\n    pairs = 0\n    for i in range(len(str_list)):\n        for j in range(i + 1, len(str_list)):\n            if str_list[i] == str_list[j][::-1]:\n                pairs += 1\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(word_list):\n    count = 0\n    for i in range(len(word_list)):\n        for j in range(i+1, len(word_list)):\n            if word_list[i] == word_list[j][::-1]:\n                count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 64.69111969111968, "dps_norm": 75.0, "pass@1": 98.0, "profiled": [{"solution": "def unique_sublists(lst):\n    \"\"\"\n    Given a list of lists, return a dictionary where every list is converted to a tuple and the value of such tuple is the \n    number of its occurrences in the original list.\n    \"\"\"\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    sublist_count = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in sublist_count:\n            sublist_count[key] += 1\n        else:\n            sublist_count[key] = 1\n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Count the occurrences of sublists within a given list and returns a dictionary\n    where every sublist is converted to a tuple and the value of such tuple is\n    the number of its occurrences in the original list.\n\n    :param lst: A list of lists\n    :return: A dictionary with sublist tuples as keys and their counts as values\n    \"\"\"\n    result = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in result:\n            result[sublist_tuple] += 1\n        else:\n            result[sublist_tuple] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Create an empty dictionary to store the count of each sublist\n    sublist_count = {}\n\n    # Iterate through the list\n    for sublist in lst:\n        # Convert the sublist to a tuple to create a hashable key\n        tuple_sublist = tuple(sublist)\n\n        # Check if the key is already in the dictionary\n        if tuple_sublist in sublist_count:\n            # Increment the count by 1\n            sublist_count[tuple_sublist] += 1\n        else:\n            # Add the new key to the dictionary and set the count to 1\n            sublist_count[tuple_sublist] = 1\n\n    # Return the dictionary with the count of each sublist\n    return sublist_count", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    This function takes a list of lists, converts each list to a tuple,\n    counts how many times each tuple appears in the original list and\n    returns a dictionary where the keys are the unique tuples from the list\n    and the values are the counts of their occurrences.\n    \"\"\"\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    counts = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in counts:\n            counts[sublist_tuple] += 1\n        else:\n            counts[sublist_tuple] = 1\n    return counts", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    \"\"\"\n    Counts lists within a list and returns a dictionary with each unique list as a tuple and its count as the value.\n    \n    :param lst: Original list of lists.\n    :return: Dictionary with each unique list converted to a tuple and its count.\n    \"\"\"\n    count_dict = defaultdict(int)\n    \n    for sublist in lst:\n        count_dict[tuple(sublist)] += 1\n    \n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    \"\"\"\n    The function takes a list of lists as input and returns a dictionary.\n    Each key in the dictionary is a tuple representing a sublist from the input list,\n    and each value is the count of that sublist in the input list.\n    \"\"\"\n    # Convert each list to a tuple\n    tuple_list = [tuple(sublist) for sublist in lst]\n    \n    # Count occurrences of each tuple\n    count_dict = dict(Counter(tuple_list))\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for item in lst:\n        tuple_item = tuple(item)\n        if tuple_item in result:\n            result[tuple_item] += 1\n        else:\n            result[tuple_item] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    from collections import Counter\n    counter = Counter(tuple(sublist) for sublist in lst)\n    return dict(counter)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    result = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        else:\n            result[tuple_sublist] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Given a list of lists, the function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.\n    \"\"\"\n    dictionary = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in dictionary:\n            dictionary[tuple_sublist] += 1\n        else:\n            dictionary[tuple_sublist] = 1\n    return dictionary", "matching_cluster_idx": 5}, {"solution": "from collections import Counter\nfrom typing import List\ndef unique_sublists(lists: List[List[int]]) -> dict:\n    \"\"\"This function counts the occurrence of each list in the input list, converting each list to a tuple.\"\"\"\n    # Convert each list to a tuple\n    tuples = [tuple(sublist) for sublist in lists]\n    \n    # Count the occurrences of each tuple\n    counts = Counter(tuples)\n    \n    return dict(counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    This function counts lists within a list. It returns a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.\n    \"\"\"\n    sublist_dict = {}\n\n    for sublist in lst:\n        # Convert list to tuple\n        tuple_sublist = tuple(sublist)\n\n        # Add/subtract the count of the sublist tuple\n        if tuple_sublist in sublist_dict:\n            sublist_dict[tuple_sublist] += 1\n        else:\n            sublist_dict[tuple_sublist] = 1\n\n    return sublist_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Write a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.\n    \"\"\"\n    result = {}\n    for sublist in lst:\n        key = tuple(sublist)\n        if key in result:\n            result[key] += 1\n        else:\n            result[key] = 1\n    return result", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(list_of_lists):\n    count_dict = {}\n    for sublist in list_of_lists:\n        tuple_sublist = tuple(sublist)\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        else:\n            count_dict[tuple_sublist] = 1\n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    return {tuple(sublist): lst.count(sublist) for sublist in lst}", "matching_cluster_idx": 3}, {"solution": "def unique_sublists(lst):\n    sublists_count = {}\n    for sublist in lst:\n        # Convert sublist to tuple (which is hashable)\n        tuple_sublist = tuple(sublist)\n        \n        # If sublist tuple already exists in dictionary, increment its count\n        if tuple_sublist in sublists_count:\n            sublists_count[tuple_sublist] += 1\n        else:\n            # Otherwise, add sublist tuple with count of 1\n            sublists_count[tuple_sublist] = 1\n    return sublists_count", "matching_cluster_idx": 5}, {"solution": "from collections import defaultdict\ndef unique_sublists(lst):\n    counter = defaultdict(int)\n    for sublist in lst:\n        counter[tuple(sublist)] += 1\n    return dict(counter)", "matching_cluster_idx": 5}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 96.0, "profiled": [{"solution": "def unique_Element(nums):\n    # Return whether the list contains only one distinct element\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    return len(set(numbers)) <= 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    This function checks whether a list of numbers contains only one distinct element or not.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    This function checks whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n        nums (list): A list of numbers.\n        \n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    :param numbers: List of numbers.\n    :type numbers: List[int]\n    \n    :return: True if all elements in the list are the same, False otherwise.\n    :rtype: bool\n    \"\"\"\n    return len(set(numbers)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    Write a python function to check whether a list of numbers contains only one distinct element or not.\n\n    Example 1:\n    Input: [1,1,1]\n    Output: True\n\n    Example 2:\n    Input: [1,2,3,1]\n    Output: False\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    Args:\n    lst: list of integers.\n    Returns:\n    True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    This function checks whether a list of numbers contains only one distinct element.\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    \"\"\"\n    This function checks if a list of numbers contains only one distinct element.\n    :param nums: List[int] - a list of numbers\n    :return: bool - True if the list contains only one distinct element, otherwise False\n    \"\"\"\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    This function takes a list of numbers and checks whether it contains only one distinct element or not.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(arr):\n    return len(set(arr)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 84.50617283950616, "dps_norm": 49.166666666666664, "pass@1": 98.0, "profiled": [{"solution": "def number_ctr(str1):\n    number_count = 0\n    for char in str1:\n        if char.isdigit():\n            number_count += 1\n    return number_count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(str):\n    # Using regex to find all digits in the string\n    numbers = re.findall('\\d', str)\n    # Return the number of digits found\n    return len(numbers)", "matching_cluster_idx": 1}, {"solution": "def number_ctr(input_string):\n    \"\"\"Count number of digits in a given string.\n\n    Args:\n        input_string (str): The string to count digits from.\n\n    Returns:\n        int: The number of digits in the given string.\n    \"\"\"\n    return sum(c.isdigit() for c in input_string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    \"\"\"\n    This function counts number of digits in a given string\n    :param str: given string\n    :return: number of digits in the given string\n    \"\"\"\n    num = 0\n    for char in str:\n        if char.isdigit():\n            num += 1\n    return num", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    count = 0\n    for i in str:\n        if i.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    number_ctr = 0\n    for ch in str:\n        if ch.isdigit():\n            number_ctr += 1\n    return number_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    This function counts the number of digits in a given string.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    ctr = 0\n    for char in string:\n        if char.isdigit():\n            ctr += 1\n    return ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s: str) -> int:\n    \"\"\"\n    Count number of digits in a given string.\n\n    Parameters:\n    s (str): The input string.\n\n    Returns:\n    int: Number of digits in the string.\n    \"\"\"\n\n    # initialize counter\n    num_ctr = 0\n\n    # iterate over the string\n    for char in s:\n        # increment counter if char is a digit\n        if char.isdigit():\n            num_ctr += 1\n\n    return num_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    count = 0\n    for i in str:\n        if i.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    return sum(c.isdigit() for c in string)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(str):\n    count = 0\n    for i in str:\n        if i.isdigit():\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    number_count = 0\n\n    for char in s:\n        if char.isdigit():\n            number_count += 1\n\n    return number_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    # Initialize counter\n    ctr = 0\n    # Iterate over each character in the string\n    for char in string:\n        # If the character is a digit, increment the counter\n        if char.isdigit():\n            ctr += 1\n    # Return the final counter\n    return ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    num_ctr = 0\n    for i in s:\n        if i.isdigit():\n            num_ctr += 1\n    return num_ctr", "matching_cluster_idx": 2}, {"solution": "def number_ctr(string):\n    number_count = 0\n    for char in string:\n        if char.isdigit():\n            number_count += 1\n    return number_count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 65.23364485981308, "dps_norm": 56.66666666666667, "pass@1": 98.0, "profiled": [{"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    \"\"\"\n    This function returns a list of all pairs of consecutive items in a given list.\n    \"\"\"\n    # Create an empty list to store the pairs\n    pairs = []\n    \n    # Loop through the input list\n    for i in range(len(input_list) - 1):\n        # Append the pair of current and next item to the list\n        pairs.append((input_list[i], input_list[i+1]))\n    \n    # Return the list of pairs\n    return pairs", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i + 1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n\n    Parameters:\n    lst (list): list of items\n\n    Returns:\n    list: list of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Given a list, returns a list of all pairs of consecutive items in the given list.\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n    \n    :param lst: List of elements\n    :return: List of tuples, each tuple contains a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Return a list of all pairs of consecutive items in a given list.\n\n    Args:\n        lst (list): A list of items.\n\n    Returns:\n        list: A list of tuples, each containing a pair of consecutive items.\n    \n    Examples:\n        >>> pair_wise([1, 1, 2, 3, 3, 4, 4, 5])\n        [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n    \"\"\"\n    result = []\n    for i in range(len(lst) - 1):\n        result.append((lst[i], lst[i + 1]))\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    if len(lst) < 2:\n        return []\n\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Write a function to return a list of all pairs of consecutive items in a given list.\n    :param lst: List of items\n    :return: List of tuples\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}]}, "Mbpp/775": {"dps": 87.47999999999999, "dps_norm": 65.0, "pass@1": 93.0, "profiled": [{"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Checking each odd index\n    for i in range(1, len(lst), 2):\n        # If the element at odd index is not odd\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(x % 2 != 0 for x in lst[1::2])", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function takes a list as an argument and checks if every element at odd indexes\n    is an odd number.\n\n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks whether every odd index contains an odd number of a given list.\n    :param lst: List of numbers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    # Check if the list is empty\n    if not lst:\n        return False\n\n    for i in range(1, len(lst), 2):\n        # If the number at an odd index is even, return False\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    \n    Parameters:\n    lst (list): The list to be checked.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains odd numbers of a given list.\n    :param lst: list of integers\n    :return: boolean\n    \"\"\"\n    for i in range(len(lst)):\n        if i % 2 != 0 and lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    return all(lst[i] % 2 != 0 for i in range(1, len(lst), 2))", "matching_cluster_idx": 3}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2): # iterates through odd indexes\n        if lst[i] % 2 == 0: # checks if the number at the odd index is even\n            return False # returns False if even number found\n    return True # returns True if all odd index contains odd numbers", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    for i in range(len(nums)):\n        if i % 2 == 1 and nums[i] % 2 != 1:\n            return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if not lst[i] % 2:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    \"\"\"\n    This function takes a list of integers as input and checks whether all elements \n    at odd indices are odd numbers or not.\n\n    :param nums: List[int] - A list of integers.\n    :return: bool - Returns True if all elements at odd indices are odd numbers, otherwise returns False.\n    \"\"\"\n    for i in range(1, len(nums), 2): #Iterate from the 2nd index to the end of the list with a step of 2 (for odd indices).\n        if nums[i] % 2 == 0: #Check if the number at the current odd index is even.\n            return False #If the number is even, return False.\n    return True #If all numbers at odd indices are odd, return True.", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    return all(n % 2 != 0 for i, n in enumerate(lst) if i % 2 != 0)", "matching_cluster_idx": 2}, {"solution": "def odd_position(lst):\n    \"\"\"\n    This function checks if every odd index in the list contains an odd number.\n    \n    Parameters:\n    lst (list): The list to be checked.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    Function to check whether every odd index contains odd numbers of a given list.\n    \"\"\"\n    for i in range(1, len(numbers), 2):\n        if numbers[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    # Iterate over the list, stepping by 2 starting from index 1\n    for i in range(1, len(lst), 2):\n        # If the number at the odd index is not odd\n        if lst[i] % 2 == 0:\n            # Return False as not all odd indices are odd numbers\n            return False\n    # If the loop completes, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(numbers):\n    \"\"\"\n    This function checks whether every odd index contains odd numbers in the given list.\n    It returns True if all conditions are met, otherwise it returns False.\n\n    :param numbers: List of integers\n    :return: Boolean value\n    \"\"\"\n    for index, value in enumerate(numbers):\n        if index % 2 == 1 and value % 2 != 1:\n            return False\n    return True", "matching_cluster_idx": 2}]}, "Mbpp/777": {"dps": 89.1287284144427, "dps_norm": 92.3076923076923, "pass@1": 13.0, "profiled": [{"solution": "def find_sum(lst):\n    unique_nums = set(lst)\n    sum_unique = sum(unique_nums)\n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(arr):\n    \"\"\"\n    Returns the sum of unique numbers in the given list\n    \"\"\"\n    unique_numbers = set(arr)\n    sum_unique_numbers = sum(unique_numbers)\n    return sum_unique_numbers", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function takes a list as an argument and returns the sum of non-repeated elements in the list.\n    \"\"\"\n    non_repeated = set(lst) # Create a set of non-repeated elements\n    return sum(non_repeated) # Return the sum of non-repeated elements", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    non_repeated_elements_sum = sum(unique_elements)\n    return non_repeated_elements_sum", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function finds the sum of non-repeated elements in a given list.\n\n    Parameters:\n    lst (list): The input list.\n\n    Returns:\n    int: The sum of non-repeated elements in the list.\n    \"\"\"\n    # Convert list to dictionary to remove duplicates (as dictionary keys are unique)\n    unique_elements = dict.fromkeys(lst)\n\n    # Calculate the sum of unique elements\n    sum_unique = sum(unique_elements.keys())\n\n    return sum_unique", "matching_cluster_idx": 5}, {"solution": "def find_sum(list1):\n    unique_list = []\n    for i in list1:\n        if i not in unique_list:\n            unique_list.append(i)\n    return sum(unique_list)", "matching_cluster_idx": 2}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function takes a list of numbers as input and \n    returns the sum of non-repeated elements in the list.\n    \"\"\"\n    non_repeated = set(lst)\n    return sum(non_repeated)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    sum_unique = sum(unique_elements)\n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    unique_elements = set(lst)\n    sum_unique = sum(unique_elements)\n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    \"\"\"\n    This function takes a list as input and returns the sum of non-repeated elements in that list.\n\n    Args:\n    lst (list): list of integers\n\n    Returns:\n    int: sum of non-repeated elements in the list\n\n    Test cases:\n    >>> find_sum([1, 2, 3, 1, 1, 4, 5, 6])\n    21\n    >>> find_sum([10, 20, 30, 20, 40, 50, 60])\n    210\n    >>> find_sum([1, 1, 2, 2, 3, 3])\n    0\n    \"\"\"\n    return sum(set(lst))", "matching_cluster_idx": 8}, {"solution": "def find_sum(nums):\n    unique_nums = set(nums)\n    return sum(unique_nums)", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 50.94488188976378, "dps_norm": 58.0, "pass@1": 92.0, "profiled": [{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if n // i != i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            if n/i == i:\n                count = count + 1\n            else:\n                count = count + 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if n // i != i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n//i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if n // i != i:\n                count += 1\n    return count % 2 == 0", "matching_cluster_idx": 3}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0:\n            count += 2 if i * i != n else 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "import math\ndef count_divisors(n):\n    count = 0\n    for i in range(1, math.isqrt(n) + 1):\n        if n % i == 0:\n            count += 2 if i != n // i else 1\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(num):\n    count = 0\n    for i in range(1, num + 1):\n        if num % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            if n / i == i:\n                count += 1\n            else:\n                count += 2\n    return count % 2 == 0", "matching_cluster_idx": 4}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function removes all whitespaces from a string.\n    \"\"\"\n    result = input_string.replace(\" \", \"\")\n    return result", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    This function takes a string as input and returns a new string with all whitespaces removed.\n    \n    Parameters:\n    input_string (str): The string from which whitespace characters are to be removed.\n    \n    Returns:\n    str: A new string with all whitespaces removed.\n    \"\"\"\n    # Use the str.replace() function to replace all whitespaces with nothing\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    This function will remove all whitespaces from the input string\n    \"\"\"\n    return s.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    This function will remove all whitespaces from the input string.\n\n    :param s: string with whitespaces\n    :return: string without whitespaces\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    result_string = input_string.replace(' ', '')\n    return result_string", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Write a function to remove all whitespaces from a string.\n\n    Args:\n        s (str): input string\n    Returns:\n        str: output string without whitespaces\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    # This function removes all whitespaces from a string\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    max_sum = float('-inf')\n    max_list = []\n    for lst in list_of_lists:\n        if sum(lst) > max_sum:\n            max_sum = sum(lst)\n            max_list = lst\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    if not list_of_lists:\n        return []\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns the list in the list of lists with the highest sum of elements.\n    \"\"\"\n    # Initialize the max sum to be the sum of the first list in the list of lists\n    max_sum = sum(list_of_lists[0])\n    # Initialize the index of the max sum list to be 0\n    max_sum_list_index = 0\n    \n    # Iterate over the lists in the list of lists, starting from the second list\n    for i in range(1, len(list_of_lists)):\n        # Calculate the sum of the current list\n        current_list_sum = sum(list_of_lists[i])\n        \n        # If the sum of the current list is greater than the max sum, update the max sum and the index\n        if current_list_sum > max_sum:\n            max_sum = current_list_sum\n            max_sum_list_index = i\n            \n    # Return the list with the max sum\n    return list_of_lists[max_sum_list_index]", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\" Returns the list in a list of lists whose sum of elements is the highest.\"\"\"\n    max_list = max(list_of_lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"Return the list from a list of lists with the highest sum of its elements.\"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lsts):\n    return max(lst_of_lsts, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize max_sum with the sum of the first list\n    max_sum = sum(list_of_lists[0])\n    # Initialize max_list with the first list\n    max_list = list_of_lists[0]\n\n    # Iterate over the lists in the list_of_lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # Check if this list has a higher sum than the current max_sum\n        if current_sum > max_sum:\n            # If so, update max_sum and max_list\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize max_sum with the sum of the first list\n    max_sum = sum(list_of_lists[0])\n    max_list = list_of_lists[0]\n\n    # Iterate over the rest of the lists\n    for lst in list_of_lists[1:]:\n        current_sum = sum(lst)\n        # If this list's sum is larger than the current max_sum, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    This function takes a list of lists and returns the list whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    This function finds the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    return max(list_of_lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "def check_K(test_tup, k):\n    \"\"\"\n    Check if the given tuples contain the k or not.\n\n    Parameters:\n    test_tup (tuple): The tuple to be checked.\n    k (int): The number to check for in the tuple.\n\n    Returns:\n    bool: True if k is found in the tuple, False otherwise.\n    \"\"\"\n    return k in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, k):\n    return k in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    This function takes a tuple and a number as inputs. \n    It returns True if the number exists in the tuple and False otherwise.\n    \n    Example:\n    check_K((10, 4, 5, 6, 8), 6) == True\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    The function to check if the given tuples contain the k or not.\n    It takes two arguments:\n        - tup: a tuple to be checked\n        - k: an integer number\n    It returns:\n        - True if k is present in tup, otherwise False\n    \"\"\"\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if the given tuples contain the k or not.\n    \"\"\"\n    if k in tup:\n        return True\n    else:\n        return False", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tuples, k):\n    return k in test_tuples", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Write a function to check if the given tuples contain the k or not.\n\n    :param tup: tuple of integers\n    :param k: integer to check in tuple\n\n    :return: True if k is in tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified integer k.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuples contain the k or not.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n  return K in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    This function checks if a given number k is present in a given tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to check.\n    k (int or float): The number to check for in the tuple.\n    \n    Returns:\n    bool: True if k is found in tup, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    This function takes a tuple and an integer k, \n    and checks if the tuple contains the integer k or not.\n    \n    Args:\n        test_tup (tuple): The tuple to be checked.\n        k (int): The integer to search for in the tuple.\n        \n    Returns:\n        bool: True if the tuple contains k, otherwise False.\n    \"\"\"\n    return k in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(t, k):\n    \"\"\"\n    Function to check if the given tuples contain the k or not.\n    \n    Parameters:\n    t (tuple): The tuple to search in.\n    k (int): The value to search for.\n    \n    Returns:\n    bool: True if 'k' is found in 't', False otherwise.\n    \"\"\"\n    return k in t", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, k):\n    \"\"\"\n    This function checks if the given tuples contains the given number k or not.\n    \n    Args:\n    test_tup (tuple): A tuple to be checked.\n    k (int or float): The number to check in the tuple.\n    \n    Returns:\n    bool: True if the tuple contains k, False otherwise.\n    \"\"\"\n    return k in test_tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tuples, k):\n    \"\"\"\n    This function checks if the given tuple contains the k or not.\n\n    Args:\n    test_tuples: A tuple to be checked.\n    k: An integer to find in the tuple.\n\n    Returns:\n    A boolean value: True if k is present in the tuple, False otherwise.\n    \"\"\"\n    return k in test_tuples", "matching_cluster_idx": 5}]}}}
