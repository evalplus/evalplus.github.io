{"date": "2024-10-19 16:31", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 86.84652683144942, "dps_norm": 79.08774817854689, "pass@1": 88.51694915254237}, "eval": {"HumanEval/9": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate through each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Calculate the absolute difference between the two numbers\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate through each pair of numbers\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Calculate the absolute difference between the two numbers\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate through each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Calculate the absolute difference between the two numbers\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Iterate through each pair of numbers in the list\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            # Calculate the absolute difference between the two numbers\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "matching_cluster_idx": 6}]}, "HumanEval/4": {"dps": 76.26582278481013, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Return 0.0 for an empty list to avoid division by zero\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty.\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty.\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"The input list must not be empty\")\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 4}]}, "HumanEval/16": {"dps": 45.73643410852713, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    lower_string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_characters = set(lower_string)\n    \n    # Return the number of distinct characters\n    return len(distinct_characters)", "matching_cluster_idx": 7}]}, "HumanEval/20": {"dps": 92.10653753026634, "dps_norm": 94.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the smallest difference is between consecutive elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Ensure the smaller number is first in the tuple\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n    \n    # Iterate through the list to find the closest pair\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n    \n    # Ensure the pair is returned in the correct order\n    return (min(closest_pair), max(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Return the closest pair in the required order\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent after sorting\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Return the closest pair in the required order\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Initialize variables to store the closest pair and the minimum difference\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n    \n    # Iterate through the list to find the closest pair\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (numbers[i], numbers[j])\n    \n    # Ensure the pair is returned in the correct order\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 3}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent after sorting\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent after sorting\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the minimum difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Return the closest pair in order (smaller number, larger number)\n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the smallest difference is between consecutive elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_difference = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if current_difference < min_difference:\n            min_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure that the closest elements are adjacent in the sorted list\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the minimum difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Ensure the smaller number is first in the tuple\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the minimum difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure that the closest elements are adjacent after sorting\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the minimum difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Ensure the smaller number is first in the tuple\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the numbers are in order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to track the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure the closest elements are adjacent after sorting\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Ensure the smaller number is first in the tuple\n    return tuple(sorted(closest_pair))", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to ensure that the closest elements are adjacent\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    # Return the closest pair in order\n    return closest_pair", "matching_cluster_idx": 8}]}, "HumanEval/24": {"dps": 47.75510204081633, "dps_norm": 30.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No valid divisor for n <= 1\n    \n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 4}]}, "HumanEval/26": {"dps": 24.0, "dps_norm": 25.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        elif num not in seen:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if numbers.count(num) == 1:\n            result.append(num)\n        else:\n            seen.add(num)\n    \n    return result", "matching_cluster_idx": 0}]}, "HumanEval/31": {"dps": 97.46835443037975, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "import math\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    indices_div_by_three = [l[i] for i in range(0, len(l), 3)]\n    sorted_indices_div_by_three = sorted(indices_div_by_three)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_indices_div_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in enumerate(sorted_elements):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    indices_div_by_three = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    sorted_indices_div_by_three = sorted(indices_div_by_three)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_indices_div_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    sorted_elements = sorted(to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    indices_div_by_three = [l[i] for i in range(0, len(l), 3)]\n    sorted_indices_div_by_three = sorted(indices_div_by_three)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_indices_div_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    sorted_elements = sorted(to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = sorted([l[i] for i in range(0, len(l), 3)])\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), to_sort):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(to_sort[sort_index])\n            sort_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    indices_div_by_3 = [l[i] for i in range(0, len(l), 3)]\n    sorted_indices_div_by_3 = sorted(indices_div_by_3)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_indices_div_by_3):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(to_sort[sort_index])\n            sort_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    to_sort.sort()\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in enumerate(to_sort):\n        result[i * 3] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if len(l) < 3:\n        return l\n    \n    # Extract elements at indices divisible by 3 and sort them\n    indices_div_by_three = [l[i] for i in range(0, len(l), 3)]\n    sorted_indices_div_by_three = sorted(indices_div_by_three)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_indices_div_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = sorted([l[i] for i in range(len(l)) if i % 3 == 0])\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = []\n    sort_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result.append(to_sort[sort_index])\n            sort_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    sorted_elements = sorted(to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    indices_div_by_3 = [l[i] for i in range(0, len(l), 3)]\n    sorted_indices_div_by_3 = sorted(indices_div_by_3)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_indices_div_by_3):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    to_sort = sorted([l[i] for i in range(0, len(l), 3)])\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    for i, value in zip(range(0, len(l), 3), to_sort):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_to_sort = [l[i] for i in range(len(l)) if i % 3 == 0]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_to_sort)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l[:]\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def count_sevens(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in the given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_sevens(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_7(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in a given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_7(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_7(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in the given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_7(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_7(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in the given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_7(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_7(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in a given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_7(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_sevens(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in the given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_sevens(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_sevens(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in the given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_sevens(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_digit_7(number: int) -> int:\n    \"\"\"Count the number of times the digit 7 appears in a given number.\"\"\"\n    return str(number).count('7')\ndef fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += count_digit_7(i)\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 94.92635024549918, "dps_norm": 90.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create the new list with sorted even-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indices, while its values at the even indices are equal\n    to the values of the even indices of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 19.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Convert both strings to sets of characters\n    set0 = set(s0)\n    set1 = set(s1)\n    \n    # Check if the sets are equal\n    return set0 == set1", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find common elements using intersection\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to get unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 95.74652777777777, "dps_norm": 99.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for smallest factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it must be prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Start with the smallest prime factor\n    largest_factor = 1\n    factor = 2\n\n    # Divide n by 2 until it is odd\n    while n % factor == 0:\n        largest_factor = factor\n        n //= factor\n\n    # Now n must be odd, so we can skip even numbers\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it must be prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factor (2)\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 1, then it must be prime\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Start with the smallest prime factor\n    largest_factor = 1\n    factor = 2\n\n    # Check for smallest factors first\n    while n % factor == 0:\n        largest_factor = factor\n        n //= factor\n\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it must be prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for smallest prime factor (2)\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            if is_prime(n // i):\n                largest_factor = n // i\n                break\n    return largest_factor", "matching_cluster_idx": 7}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            if is_prime(factor):\n                largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n    \n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors from 3 upwards\n    factor = 3\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n        # If factor^2 exceeds n, then n must be prime\n        if factor * factor > n:\n            if n > 1:\n                largest_factor = n\n            break\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n        # If factor^2 exceeds n, then n must be prime\n        if factor * factor > n:\n            if n > 1:\n                largest_factor = n\n            break\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n        # If factor^2 exceeds n, then n must be prime\n        if factor * factor > n:\n            if n > 1:\n                largest_factor = n\n            break\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            if is_prime(factor):\n                largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n    \n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Helper function to check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors from 3 upwards\n    factor = 3\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n        # If the factor squared is greater than n, then n must be prime\n        if factor * factor > n:\n            if n > 1:\n                largest_factor = n\n            break\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors\n    factor = 3\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n        # If factor squared is greater than n, then n must be prime\n        if factor * factor > n:\n            if n > 1:\n                largest_factor = n\n            break\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest factors first\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n\n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n\n    # If n is still greater than 1, then it must be prime\n    if n > 1:\n        largest_factor = n\n\n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num: int) -> bool:\n        \"\"\"Check if a number is prime.\"\"\"\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for smallest factors first\n    if n % 2 == 0:\n        largest_factor = 2\n        while n % 2 == 0:\n            n //= 2\n    \n    # Check for odd factors\n    factor = 3\n    while n > 1:\n        if n % factor == 0:\n            largest_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 2\n        # If factor^2 exceeds n, then n must be prime\n        if factor * factor > n:\n            if n > 1:\n                largest_factor = n\n            break\n    \n    return largest_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_factor = 1\n    # Check for the smallest prime factor (2)\n    while n % 2 == 0:\n        largest_factor = 2\n        n //= 2\n    \n    # Check for odd factors from 3 upwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 1, then it is a prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 92.20779220779221, "dps_norm": 62.5, "pass@1": 60.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if 'y' is at the end of the word\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    s = s.lower()\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    s = s.lower()\n    count = 0\n    \n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 83.66336633663366, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for i, num in enumerate(lst):\n        # Check if the index is odd and the number is even\n        if i % 2 != 0 and num % 2 == 0:\n            total += num\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for i, num in enumerate(lst):\n        # Check if the index is odd and the number is even\n        if i % 2 != 0 and num % 2 == 0:\n            total += num\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for i, num in enumerate(lst):\n        # Check if the index is odd and the number is even\n        if i % 2 != 0 and num % 2 == 0:\n            total += num\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum(x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0)", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_parts = [''.join(sorted(part)) for part in parts]\n    \n    # Join the processed words back together with spaces\n    return ' '.join(ordered_parts)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces preserved\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces preserved\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces preserved\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: Keeps the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: Keeps the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    def sort_word(word):\n        return ''.join(sorted(word))\n\n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return ''.join(sorted(word))\n    \n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces preserved\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the ordered words back into a single string with spaces\n    ordered_string = ' '.join(ordered_words)\n    \n    return ordered_string", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string is a string where all words (separated by space)\n    are replaced by a new word where all the characters are arranged in\n    ascending order based on ascii value.\n    Note: Keeps the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the ordered words back into a single string with spaces\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    def sort_word(word):\n        return ''.join(sorted(word))\n    \n    words = s.split(' ')\n    sorted_words = [sort_word(word) for word in words]\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    parts = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_parts = [''.join(sorted(part)) for part in parts]\n    \n    # Join the processed words back together with spaces\n    return ' '.join(ordered_parts)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces preserved\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 95.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the list lst and return a list of tuples representing their coordinates.\n    Sort coordinates initially by rows in ascending order.\n    Sort coordinates of the same row by columns in descending order.\n    \n    :param lst: A 2-dimensional list (nested lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x in lst\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by row in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of the same row by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find integers x in the list and return their coordinates sorted by rows in ascending order\n    and by columns in descending order within each row.\n    \n    :param lst: 2-dimensional list (nested lists)\n    :param x: integer to find in the list\n    :return: list of tuples [(row, column), ...]\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the integer x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional list and an integer x, find all occurrences of x\n    and return their coordinates sorted by rows in ascending order and\n    by columns in descending order within each row.\n    \n    :param lst: A 2 dimensional list (list of lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the value matches x, add the coordinate to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of the same row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional list and an integer x, find all occurrences of x\n    and return their coordinates as a list of tuples, sorted by rows in ascending order\n    and by columns in descending order within each row.\n    \n    :param lst: A 2 dimensional list (list of lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row in ascending order, and by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find all occurrences of integer x in the nested list lst and return their coordinates\n    sorted by rows in ascending order and by columns in descending order within each row.\n    \n    :param lst: A 2-dimensional list (list of lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x in lst\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional list and an integer x, find all occurrences of x\n    and return their coordinates as a list of tuples. The coordinates should\n    be sorted by rows in ascending order and by columns in descending order\n    within each row.\n    \n    :param lst: A 2 dimensional list (similar to a matrix but with varying row lengths).\n    :param x: The integer to search for in the list.\n    :return: A list of tuples representing the coordinates of x in the list.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data as a nested list, find integer x and return\n    a list of tuples representing the coordinates of x in the list.\n    Sort coordinates by rows in ascending order and by columns in descending order.\n    \n    :param lst: Nested list representing the 2D data\n    :param x: Integer to search for\n    :return: List of tuples [(row, column)]\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and column to find the integer x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of the same row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional list and an integer x, find all occurrences of x\n    and return their coordinates sorted by rows in ascending order and\n    by columns in descending order within each row.\n    \n    :param lst: A 2 dimensional list (nested lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the value matches x, append the coordinate (row_index, col_index)\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order, and by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the value matches x, add the coordinate to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates first by row in ascending order\n    # and then by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find all occurrences of integer x in the nested list lst and return their coordinates\n    sorted by rows in ascending order and by columns in descending order within each row.\n    \n    :param lst: A 2-dimensional list (list of lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x in lst\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the element matches x, append the coordinate to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort the coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the value matches x, append the coordinate (row, col) to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of the same row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find all occurrences of integer x in the nested list lst and return their coordinates\n    sorted by rows in ascending order and by columns in descending order within each row.\n    \n    :param lst: A 2-dimensional list (list of lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x in lst\n    \"\"\"\n    coordinates = []\n    \n    # Iterate over each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data as a nested list, find the integer x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2) ...] such that each tuple\n    is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coordinates = []\n    \n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort by row in ascending order, and by column in descending order for each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find all occurrences of integer x in the nested list lst and return their coordinates\n    as a list of tuples, sorted by rows in ascending order and by columns in descending order within each row.\n    \n    :param lst: A 2-dimensional list (nested lists)\n    :param x: The integer to search for\n    :return: A list of tuples representing the coordinates of x in lst\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data as a nested list, find the coordinates of integer x.\n    Return a list of tuples sorted by rows in ascending order and by columns in descending order within each row.\n    \n    :param lst: Nested list representing the 2D data.\n    :param x: Integer to search for in the 2D data.\n    :return: List of tuples representing the coordinates of x.\n    \"\"\"\n    coordinates = []\n    \n    # Iterate through each row and column to find the coordinates of x\n    for row_index, row in enumerate(lst):\n        for col_index, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates within each row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the value matches x, append the coordinate (row, col) to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of the same row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_index, row in enumerate(lst):\n        # Iterate over each element in the row\n        for col_index, value in enumerate(row):\n            # If the element matches x, add the coordinate to the list\n            if value == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    \n    # Sort coordinates of the same row by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 96.95876288659795, "dps_norm": 45.714285714285715, "pass@1": 98.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by two multiplied to two places.\"\"\"\n    encrypted_string = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            # Determine the shift amount (2 * 2 = 4)\n            shift = 4\n            \n            # Calculate the new character position\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            \n            encrypted_string += new_char\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by 2 * 2 = 4 places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine the new character by shifting 4 places in the alphabet\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a letter, append it as is\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    shift = 2 * 2  # Shift by 4 places\n\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                # Calculate the new character position in the alphabet\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Calculate the new character position in the alphabet\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            encrypted_string += new_char\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the shift amount\n    shift = 2 * 2\n    \n    # Create a translation table for the shift\n    translation_table = str.maketrans(\n        'abcdefghijklmnopqrstuvwxyz',\n        'abcdefghijklmnopqrstuvwxyz'[shift:] + 'abcdefghijklmnopqrstuvwxyz'[:shift]\n    )\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    shift = 2 * 2  # Shift by 4 places\n\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                # Shift within lowercase letters\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Shift within uppercase letters\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n        else:\n            # Non-alphabetic characters remain unchanged\n            new_char = char\n        \n        encrypted_string += new_char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    shift = 2 * 2  # Shift by 4 places\n\n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            is_upper = char.isupper()\n            # Convert to lowercase for easier manipulation\n            char = char.lower()\n            # Shift the character\n            shifted_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a'))\n            # Convert back to uppercase if necessary\n            if is_upper:\n                shifted_char = shifted_char.upper()\n            encrypted_string += shifted_char\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string += char\n\n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the shift amount\n    shift = 2 * 2\n    \n    # Create a translation table for the shift\n    translation_table = str.maketrans(\n        'abcdefghijklmnopqrstuvwxyz',\n        'abcdefghijklmnopqrstuvwxyz'[shift:] + 'abcdefghijklmnopqrstuvwxyz'[:shift]\n    )\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the shift amount\n    shift = 2 * 2\n    \n    # Create a translation table for the shift\n    translation_table = str.maketrans(\n        'abcdefghijklmnopqrstuvwxyz',\n        'abcdefghijklmnopqrstuvwxyz'[shift:] + 'abcdefghijklmnopqrstuvwxyz'[:shift]\n    )\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by two multiplied to two places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the new character by shifting it down by 2 * 2 = 4 places\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a lowercase letter, leave it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet by 2 * 2 = 4 places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 places in the alphabet\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a lowercase letter, leave it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by 2 * 2 places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine the shift amount (2 * 2 = 4)\n            shift = 4\n            \n            # Determine if the character is uppercase or lowercase\n            if char.islower():\n                # Calculate the new character position\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                # Calculate the new character position\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            \n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by two multiplied to two places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine the new character by shifting it down by 4 places (2 * 2)\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by two multiplied to two places.\"\"\"\n    encrypted_string = \"\"\n    \n    for char in s:\n        if char.isalpha():\n            # Determine the shift amount (2 * 2 = 4)\n            shift = 4\n            # Calculate the new character position\n            if char.islower():\n                new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n            else:\n                new_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n            encrypted_string += new_char\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted_string = \"\"\n    shift = 2 * 2  # Shift by 4 places\n\n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            if char.islower():\n                base = ord('a')\n            else:\n                base = ord('A')\n            \n            # Calculate the new character after shifting\n            new_char = chr((ord(char) - base + shift) % 26 + base)\n            encrypted_string += new_char\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the shift value\n    shift = 2 * 2\n    \n    # Create a translation table for the shift\n    translation_table = str.maketrans(\n        'abcdefghijklmnopqrstuvwxyz',\n        'abcdefghijklmnopqrstuvwxyz'[shift:] + 'abcdefghijklmnopqrstuvwxyz'[:shift]\n    )\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypt the string by rotating the alphabet by 2 * 2 = 4 places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift the character by 4 places\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_string.append(new_char)\n        elif 'A' <= char <= 'Z':\n            # Shift the character by 4 places\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a letter, leave it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the shift amount\n    shift = 2 * 2\n    \n    # Create a translation table for the shift\n    translation_table = str.maketrans(\n        'abcdefghijklmnopqrstuvwxyz',\n        'abcdefghijklmnopqrstuvwxyz'[shift:] + 'abcdefghijklmnopqrstuvwxyz'[:shift]\n    )\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by 2 * 2 = 4 places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the new character by shifting 4 places down in the alphabet\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_string.append(new_char)\n        elif 'A' <= char <= 'Z':\n            # Calculate the new character by shifting 4 places down in the alphabet\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the shift amount\n    shift = 2 * 2\n    \n    # Create a translation table for the shift\n    translation_table = str.maketrans(\n        'abcdefghijklmnopqrstuvwxyz',\n        'abcdefghijklmnopqrstuvwxyz'[shift:] + 'abcdefghijklmnopqrstuvwxyz'[:shift]\n    )\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"Encrypts a string by rotating the alphabet such that each letter shifts down by 2 * 2 = 4 places.\"\"\"\n    encrypted_string = []\n    \n    for char in s:\n        if 'a' <= char <= 'z':\n            # Calculate the new character by shifting 4 places down in the alphabet\n            new_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_string.append(new_char)\n        elif 'A' <= char <= 'Z':\n            # Calculate the new character by shifting 4 places down in the alphabet\n            new_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_string.append(new_char)\n        else:\n            # If the character is not a letter, keep it unchanged\n            encrypted_string.append(char)\n    \n    return ''.join(encrypted_string)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 87.54863813229572, "dps_norm": 58.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_elements = sorted(set(lst))\n    \n    if len(sorted_unique_elements) < 2:\n        return None\n    \n    return sorted_unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    unique_sorted_lst = sorted(set(lst))\n    \n    if len(unique_sorted_lst) < 2:\n        return None\n    \n    return unique_sorted_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_elements = sorted(set(lst))\n    \n    if len(sorted_unique_elements) < 2:\n        return None\n    \n    return sorted_unique_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if there is a 2nd smallest element\n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Remove duplicates and sort the list\n    sorted_unique_lst = sorted(set(lst))\n    \n    # Check if there is a second smallest element\n    if len(sorted_unique_lst) < 2:\n        return None\n    \n    return sorted_unique_lst[1]", "matching_cluster_idx": 6}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odds(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n    \n    result = []\n    for i, s in enumerate(lst):\n        odd_digits_count = count_odds(s)\n        result.append(f\"the number of odd elements {odd_digits_count}n the str{odd_digits_count}ng {odd_digits_count} of the {odd_digits_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    def count_odd_digits(s):\n        return sum(1 for char in s if int(char) % 2 != 0)\n\n    result = []\n    for i, s in enumerate(lst):\n        odd_count = count_odd_digits(s)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 35.0, "profiled": [{"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    \n    # Check both possible concatenations\n    if is_balanced(str1 + str2) or is_balanced(str2 + str1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    \n    # Check both possible concatenations\n    if is_balanced(str1 + str2) or is_balanced(str2 + str1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    \n    # Check if concatenating in both orders results in a balanced string\n    if is_balanced(str1 + str2) or is_balanced(str2 + str1):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    max_k_elements = sorted_arr[:k]\n    \n    # Sort the k elements in ascending order\n    result = sorted(max_k_elements)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    arr_sorted = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    max_k_elements = arr_sorted[:k]\n    \n    # Sort the k elements in ascending order\n    result = sorted(max_k_elements)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order and then take the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    # Take the first k elements and sort them in ascending order\n    result = sorted(sorted_arr[:k])\n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the top k elements\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order\n    result = sorted(top_k)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements\n    max_k_elements = sorted_arr[:k]\n    \n    # Sort the k elements in ascending order\n    result = sorted(max_k_elements)\n    \n    return result", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 78.02690582959642, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            # Add the value to the total sum\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            total_sum += value\n    \n    return total_sum", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length (ascending) and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False if the number is prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False  # 2 is the only even prime number\n    if n % 2 == 0:\n        return True  # All other even numbers are not prime\n    \n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    \n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True  # 2 is the only even prime number\n    if n % 2 == 0:\n        return False  # other even numbers are not prime\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_not_prime(n):\n    \"\"\"Check if a number is not prime.\"\"\"\n    return not is_prime(n)", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to check if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Parameters:\n    n (int): The number to check for primality.\n    \n    Returns:\n    bool: True if the number is not prime, False if it is prime.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to determine if a number is not prime.\n\n    Args:\n    n (int): The number to check.\n\n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    \"\"\"\n    Function to identify non-prime numbers.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is not prime, False otherwise.\n    \"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Return the elements in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_elements = heapq.nlargest(n, nums)\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest elements\n    largest_elements = heapq.nlargest(n, numbers)\n    \n    # Return the elements in descending order\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the largest numbers in descending order\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_elements = heapq.nlargest(n, nums)\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \n    :param numbers: List of integers\n    :param n: Number of largest integers to find\n    :return: List of n largest integers in descending order\n    \"\"\"\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the largest numbers in descending order\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_elements = heapq.nlargest(n, nums)\n    return largest_elements", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_n = heapq.nlargest(n, nums)\n    return largest_n", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(numbers, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_numbers = heapq.nlargest(n, numbers)\n    return largest_numbers", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 94.93197278911563, "dps_norm": 59.5, "pass@1": 96.0, "profiled": [{"solution": "def find_Rotations(s):\n    # Check if the string is empty or has only one character\n    if len(s) <= 1:\n        return 1\n    \n    # Create a double string to simulate rotations\n    double_s = s + s\n    \n    # Iterate through the string to find the minimum rotations\n    for i in range(1, len(s)):\n        if s == double_s[i:i+len(s)]:\n            return i\n    \n    # If no rotations are found, return the length of the string\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the string to simulate rotation\n    double_s = s + s\n    \n    # Iterate through each possible rotation\n    for i in range(1, len(s) + 1):\n        # Check if the substring matches the original string\n        if double_s[i:i + len(s)] == s:\n            return i\n    \n    # If no rotation matches, return -1 (though this should not happen for valid input)\n    return -1", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    # If the string is empty or has only one character, no rotation is needed\n    if len(s) <= 1:\n        return 0\n    \n    # Concatenate the string with itself\n    double_s = s + s\n    \n    # Iterate through the string to find the minimum rotation\n    for i in range(1, len(s)):\n        if s == double_s[i:i+len(s)]:\n            return i\n    \n    # If no rotation is found, return the length of the string (which is the worst case)\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Double the string to simulate rotation\n    doubled_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if doubled_s[i:i+n] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to simulate rotations\n    double_s = s + s\n    \n    for i in range(1, n + 1):\n        if s == double_s[i:i+n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to simulate rotation\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if double_s[i:i + n] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Check if the string is empty or has only one character\n    if len(s) <= 1:\n        return 0\n    \n    # Concatenate the string with itself\n    double_s = s + s\n    \n    # Iterate through the string to find the minimum rotations\n    for i in range(1, len(s)):\n        if s == double_s[i:i+len(s)]:\n            return i\n    \n    # If no rotations are found, return the length of the string\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    if len(s) == 0:\n        return 0\n    \n    # Concatenate the string with itself\n    double_s = s + s\n    \n    # Iterate through the string to find the minimum rotations\n    for i in range(1, len(s) + 1):\n        if s == double_s[i:i + len(s)]:\n            return i\n    \n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to avoid modular arithmetic\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to avoid modular arithmetic\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to avoid modular arithmetic\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to simulate rotation\n    double_s = s + s\n    \n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to avoid modular arithmetic\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to avoid modular arithmetic\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The minimum number of rotations required.\n    \"\"\"\n    # If the string is empty or has only one character, no rotation is needed.\n    if len(s) <= 1:\n        return 0\n    \n    # Check for each possible rotation\n    for i in range(1, len(s)):\n        # Perform the rotation\n        rotated = s[i:] + s[:i]\n        # If the rotated string matches the original, return the number of rotations\n        if rotated == s:\n            return i\n    \n    # If no rotations match, return the length of the string (which is the worst case)\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Double the string to simulate rotation\n    doubled_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if doubled_s[i:i+n] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s: str) -> int:\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    # If the string is empty, no rotations are needed\n    if not s:\n        return 0\n    \n    # Concatenate the string with itself\n    double_s = s + s\n    \n    # Iterate through the string and check for rotations\n    for i in range(1, len(s)):\n        if s == double_s[i:i+len(s)]:\n            return i\n    \n    # If no rotations are found, return the length of the string\n    return len(s)", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to simulate rotation\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if s == double_s[i:i + n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to simulate rotation\n    double_s = s + s\n    \n    for i in range(1, n + 1):\n        if s == double_s[i:i+n]:\n            return i\n    \n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The minimum number of rotations required.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    # Create a double string to simulate rotation\n    double_s = s + s\n    \n    # Check for each rotation if it matches the original string\n    for i in range(1, n + 1):\n        if double_s[i:i + n] == s:\n            return i\n    \n    return n", "matching_cluster_idx": 5}]}, "Mbpp/11": {"dps": 25.448028673835125, "dps_norm": 88.88888888888889, "pass@1": 99.0, "profiled": [{"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index -= 1  # Adjust the index after removing the first occurrence\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence (if it's different from the first occurrence)\n    if last_index != -1 and last_index != first_index:\n        last_index -= 1  # Adjust index after removing the first occurrence\n        s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    if first_index != -1:\n        s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence\n    if last_index != -1:\n        last_index = s.rfind(char)  # Recalculate the last index after removing the first occurrence\n        if last_index != -1:\n            s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence (if it's different from the first)\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    if first_index != -1:\n        s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence\n    if last_index != -1:\n        last_index = s.rfind(char)  # Recalculate the last index after removing the first occurrence\n        if last_index != -1:\n            s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    \n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence (if it's different from the first occurrence)\n    if last_index != -1 and last_index != first_index:\n        last_index -= 1  # Adjust index after removing the first occurrence\n        s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first and last occurrence of the character\n    first_index = s.find(char)\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index+1:]\n    \n    # Remove the last occurrence (if it's different from the first occurrence)\n    if last_index != -1 and last_index != first_index:\n        last_index -= 1  # Adjust index after removing the first occurrence\n        s = s[:last_index] + s[last_index+1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    if first_index != -1:\n        s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence\n    if last_index != -1:\n        last_index = s.rfind(char)  # Recalculate the last index after removing the first occurrence\n        if last_index != -1:\n            s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found in the string, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    if first_index != -1:\n        s = s[:first_index] + s[first_index + 1:]\n    \n    # Remove the last occurrence\n    if last_index != -1:\n        # Since the first occurrence has been removed, we need to adjust the index\n        last_index = s.rfind(char)\n        if last_index != -1:\n            s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Remove the first occurrence\n    s = s[:first_index] + s[first_index + 1:]\n    \n    # If the character was only present once, return the modified string\n    if first_index == last_index:\n        return s\n    \n    # Remove the last occurrence\n    last_index = s.rfind(char)\n    s = s[:last_index] + s[last_index + 1:]\n    \n    return s", "matching_cluster_idx": 7}]}, "Mbpp/12": {"dps": 74.28571428571429, "dps_norm": 98.125, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of the rows\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Create a list of tuples where each tuple is (sum of row, row)\n    rows_with_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples by the sum of the row (first element of the tuple)\n    rows_with_sums.sort(key=lambda x: x[0])\n    \n    # Extract the sorted rows from the sorted list of tuples\n    sorted_matrix = [row for _, row in rows_with_sums]\n    \n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of the rows\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), index) for index, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[index] for _, index in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of the rows\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), index) for index, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of the rows\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[index] for _, index in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Create a list of tuples where each tuple is (sum of row, row)\n    rows_with_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples by the sum of the row (first element of the tuple)\n    rows_with_sums.sort(key=lambda x: x[0])\n    \n    # Extract the sorted rows from the sorted list of tuples\n    sorted_matrix = [row for _, row in rows_with_sums]\n    \n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum (and index for stability)\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of each row\n    sorted_row_sums = sorted(row_sums, key=lambda x: x[0])\n    \n    # Create the sorted matrix based on the sorted row indices\n    sorted_matrix = [matrix[i] for _, i in sorted_row_sums]\n    \n    return sorted_matrix", "matching_cluster_idx": 14}, {"solution": "def sort_matrix(matrix):\n    # Calculate the sum of each row and pair it with the row index\n    row_sums = [(sum(row), i) for i, row in enumerate(matrix)]\n    \n    # Sort the rows based on the sum of the rows\n    sorted_rows = sorted(row_sums, key=lambda x: x[0])\n    \n    # Extract the sorted rows from the original matrix\n    sorted_matrix = [matrix[i] for _, i in sorted_rows]\n    \n    return sorted_matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 98.0, "profiled": [{"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern for sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern for sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern for sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    # Define the regular expression pattern\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore,\n    and False otherwise.\n    \"\"\"\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, text))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    return bool(re.match(pattern, input_string))", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Regular expression pattern to match sequences of lowercase letters joined with an underscore\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}, {"solution": "import re\ndef text_lowercase_underscore(input_string):\n    # Define the regular expression pattern\n    pattern = r'^[a-z]+(_[a-z]+)*$'\n    \n    # Use re.match to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        return True\n    else:\n        return False", "matching_cluster_idx": 7}]}, "Mbpp/19": {"dps": 98.23232323232324, "dps_norm": 99.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the element is already in the set, it's a duplicate\n        if element in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(element)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the element is already in the set, it's a duplicate\n        if element in unique_elements:\n            return True\n        # Otherwise, add the element to the set\n        unique_elements.add(element)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if there are duplicates, False otherwise.\n    \"\"\"\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the element is already in the set, it's a duplicate\n        if element in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(element)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the element is already in the set, it's a duplicate\n        if element in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(element)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through each element in the array\n    for element in arr:\n        # If the element is already in the set, it's a duplicate\n        if element in unique_elements:\n            return True\n        # Add the element to the set\n        unique_elements.add(element)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create a set to store unique elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    \"\"\"\n    Function to check if a given array of integers contains any duplicate element.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    bool: True if the array contains duplicates, False otherwise.\n    \"\"\"\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", "matching_cluster_idx": 14}]}, "Mbpp/62": {"dps": 70.0, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The smallest number in the list.\n    \"\"\"\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    smallest = lst[0]\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    return smallest", "matching_cluster_idx": 3}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility by\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor to check against.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n\n    :param tuples_list: List of tuples to check.\n    :param k: The divisor.\n    :return: List of tuples where all elements are divisible by k.\n    \"\"\"\n    return [tup for tup in tuples_list if all(element % k == 0 for element in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}, {"solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    Find tuples which have all elements divisible by k from the given list of tuples.\n    \n    :param tuples_list: List of tuples\n    :param k: Integer to check divisibility\n    :return: List of tuples where all elements are divisible by k\n    \"\"\"\n    return [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    frequency = {}\n    for element in lst:\n        if element in frequency:\n            frequency[element] += 1\n        else:\n            frequency[element] = 1\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 79.51219512195122, "dps_norm": 85.71428571428571, "pass@1": 77.0, "profiled": [{"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Initialize the maximum length with the length of the first word\n    max_length = len(words[0])\n    \n    # Iterate through the list to find the longest word\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Parameters:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Use the max function with a key that returns the length of each word\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Parameters:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update the maximum length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Parameters:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Use the max function with a key that returns the length of each word\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of words.\n    \n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update the maximum length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in the list.\n\n    Args:\n    words (list): A list of strings.\n\n    Returns:\n    int: The length of the longest word.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Parameters:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    :param words: List of words\n    :return: Length of the longest word\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of words.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Initialize the maximum length with the length of the first word\n    max_length = len(words[0])\n    \n    # Iterate through the list to find the longest word\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Initialize the maximum length with the length of the first word\n    max_length = len(words[0])\n    \n    # Iterate through the list to find the longest word\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list of words.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    \"\"\"\n    Function to find the length of the longest word in a list.\n    \n    Args:\n    words (list): A list of strings.\n    \n    Returns:\n    int: The length of the longest word in the list.\n    \"\"\"\n    if not words:\n        return 0\n    \n    # Initialize the maximum length with the length of the first word\n    max_length = len(words[0])\n    \n    # Iterate through the list to find the longest word\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 97.0, "profiled": [{"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(tuples_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(tuples_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 67.3611111111111, "dps_norm": 40.714285714285715, "pass@1": 97.0, "profiled": [{"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n\n    Args:\n    n (int): The integer to find the divisors of.\n\n    Returns:\n    int: The number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which we need to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which we need to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which we need to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the given integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Args:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    \"\"\"\n    Function to find the number of divisors of a given integer.\n    \n    Parameters:\n    n (int): The integer for which to find the number of divisors.\n    \n    Returns:\n    int: The number of divisors of the integer n.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 1}]}, "Mbpp/97": {"dps": 99.65811965811966, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists and return it as a dictionary.\n    \n    :param list_of_lists: A list of lists containing elements.\n    :return: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    from collections import Counter\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = Counter(flattened_list)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    frequency_dict = {}\n    for sublist in nested_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists and return it in a dictionary.\n    \n    :param list_of_lists: A list of lists containing elements.\n    :return: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    from collections import Counter\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = Counter(flattened_list)\n    \n    # Convert Counter object to a regular dictionary\n    return dict(frequency_dict)", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists and return it as a dictionary.\n    \n    Args:\n    lists (list of lists): A list containing lists of elements.\n    \n    Returns:\n    dict: A dictionary where the keys are the elements and the values are their frequencies.\n    \"\"\"\n    frequency_dict = {}\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists and return it as a dictionary.\n    \n    :param nested_lists: A list of lists containing elements.\n    :return: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    frequency_dict = {}\n    \n    for sublist in nested_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Count the frequency of each element in the flattened list\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    frequency_dict = {}\n    for sublist in lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists and return it as a dictionary.\n    \n    :param nested_lists: A list of lists containing elements.\n    :return: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    frequency_dict = {}\n    \n    for sublist in nested_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    \"\"\"\n    Find the frequency of each element in a flattened list of lists and return it as a dictionary.\n    \n    :param list_of_lists: A list of lists containing elements.\n    :return: A dictionary where keys are elements and values are their frequencies.\n    \"\"\"\n    frequency_dict = {}\n    \n    # Flatten the list of lists\n    flattened_list = [item for sublist in list_of_lists for item in sublist]\n    \n    # Count the frequency of each element\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(list_of_lists):\n    frequency_dict = {}\n    for sublist in list_of_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(nested_lists):\n    frequency_dict = {}\n    for sublist in nested_lists:\n        for element in sublist:\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            else:\n                frequency_dict[element] = 1\n    return frequency_dict", "matching_cluster_idx": 6}]}, "Mbpp/106": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Parameters:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Append the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n    \n    Args:\n    lst (list): The list to append.\n    tup (tuple): The tuple to which the list will be appended.\n    \n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}, {"solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Parameters:\n    lst (list): The list to be appended.\n    tup (tuple): The tuple to which the list will be appended.\n\n    Returns:\n    tuple: A new tuple with the list appended to the original tuple.\n    \"\"\"\n    return tup + tuple(lst)", "matching_cluster_idx": 5}]}, "Mbpp/108": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/111": {"dps": 99.38461538461539, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set to use set operations\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists and update the set of common elements\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the set to only include elements that are common with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use the first list as the initial set of common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the set to only include elements that are in the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set to find the intersection of all lists\n    common_elements = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the common elements set by intersecting it with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the set to only include elements that are common with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set to find the common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each list to a set and find the intersection of all sets\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert each list to a set and find the intersection of all sets\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the set to contain only elements that are common with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the set with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the set to only include elements that are common with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Initialize the result with the elements of the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Convert the first list to a set to use set operations\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists and find the intersection\n    for lst in nested_lists[1:]:\n        common_elements &= set(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}]}, "Mbpp/123": {"dps": 99.62686567164178, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the given limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the given limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # 1 is a proper divisor for any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the specified limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # 1 is a proper divisor for any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1  # 1 is a proper divisor for any n > 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the given limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Calculate the sum of proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a number is part of an amicable pair.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Sum all amicable numbers from 1 to the specified limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors_sum += i\n            if i != n // i:\n                divisors_sum += n // i\n    return divisors_sum\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\ndef is_amicable(a):\n    \"\"\"Check if a is an amicable number.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers from 1 to limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def sum_of_divisors(n):\n    \"\"\"Return the sum of proper divisors of n.\"\"\"\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\ndef is_amicable(a):\n    \"\"\"Check if a number is part of an amicable pair.\"\"\"\n    b = sum_of_divisors(a)\n    return b != a and sum_of_divisors(b) == a\ndef amicable_numbers_sum(limit):\n    \"\"\"Return the sum of all amicable numbers up to the given limit.\"\"\"\n    amicable_sum = 0\n    for num in range(1, limit + 1):\n        if is_amicable(num):\n            amicable_sum += num\n    return amicable_sum", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, text):\n    # Split the text into words\n    words = text.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the sentence that are longer than n characters.\n    \n    :param n: The minimum length of words to include.\n    :param sentence: A string containing words separated by spaces.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    # Filter the list to include only words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    # Filter the words that are longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    \"\"\"\n    Returns a list of words from the sentence that are longer than n characters.\n    \n    :param n: The minimum length of words to include.\n    :param sentence: A string containing words separated by spaces.\n    :return: A list of words longer than n characters.\n    \"\"\"\n    words = sentence.split()\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, words):\n    # Split the input string into a list of words\n    word_list = words.split()\n    # Filter the list to include only words longer than n characters\n    result = [word for word in word_list if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    # Filter words that are longer than n characters\n    result = [word for word in words if len(word) > n]\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 96.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - i - 1] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it's a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_constant:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_constant:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    \n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 74.66367713004485, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Count the occurrences of each item in the list\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/140": {"dps": 84.02173913043478, "dps_norm": 76.875, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_lists (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_lists for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of tuples): A list containing tuples of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    flat_set = set()\n    for sublist in nested_list:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    # Initialize an empty set to store the unique numbers\n    unique_numbers = set()\n    \n    # Iterate through each sublist in the nested list\n    for sublist in nested_list:\n        # Add each number in the sublist to the set\n        unique_numbers.update(sublist)\n    \n    return unique_numbers", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten a list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested list.\n    \"\"\"\n    flat_set = set()\n    for sublist in nested_list:\n        flat_set.update(sublist)\n    return flat_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(nested_list):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n    \n    Args:\n    nested_list (list of lists): A list containing lists of numbers.\n    \n    Returns:\n    set: A set containing all unique numbers from the nested lists.\n    \"\"\"\n    return {num for sublist in nested_list for num in sublist}", "matching_cluster_idx": 5}]}, "Mbpp/141": {"dps": 96.12244897959184, "dps_norm": 49.375, "pass@1": 99.0, "profiled": [{"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts the list using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the max element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to flip the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not already at the end, flip it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    Pancake Sort is a sorting algorithm that works by repeatedly flipping the largest unsorted element\n    to the front of the list and then flipping the entire unsorted portion to move it to its correct position.\n    \n    Args:\n        arr (list): The list of elements to be sorted.\n    \n    Returns:\n        list: The sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        Args:\n            arr (list): The list of elements.\n            k (int): The number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not already at the end, flip it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts the given list using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the max element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts the given list using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the first k elements of the list.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to reverse.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            # Flip the max element to the front\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the max element to the correct position\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to reverse.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            # Flip the max element to the front\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the max element to its correct position\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # Reverse the elements from the start to the max_idx to move the max element to the start\n        arr[:max_idx + 1] = reversed(arr[:max_idx + 1])\n        \n        # Reverse the entire unsorted portion to move the max element to the end\n        arr[:n] = reversed(arr[:n])\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not already at the end, flip the array to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                # Flip the array from the start to the max_idx to bring the max element to the front\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            \n            # Flip the entire array to move the max element to the end of the unsorted portion\n            arr[:n] = arr[:n][::-1]\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts the list using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the max element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to flip the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the max element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    Pancake Sort works by repeatedly flipping the largest unsorted element to the front\n    and then flipping the entire unsorted portion to move it to its correct position.\n    \n    Args:\n    arr (list): The list of elements to be sorted.\n    \n    Returns:\n    list: The sorted list.\n    \"\"\"\n    \n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        Args:\n        arr (list): The list of elements.\n        k (int): The number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not already at the end of the unsorted portion\n        if max_idx != n - 1:\n            # Flip the maximum element to the front\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to flip the first k elements of the array.\"\"\"\n        start = 0\n        while start < k:\n            arr[start], arr[k] = arr[k], arr[start]\n            start += 1\n            k -= 1\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx)\n            # Flip the entire unsorted portion to move the max element to the end\n            flip(arr, n - 1)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to flip the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the max element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end of the unsorted portion,\n        # flip the array to bring the maximum element to the front,\n        # then flip the entire unsorted portion to move it to the end.\n        if max_idx != n - 1:\n            if max_idx != 0:\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            arr[:n] = arr[:n][::-1]\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Reverses the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to reverse.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end of the unsorted portion,\n        # flip the array to bring the maximum element to the front,\n        # then flip the entire unsorted portion to move it to the end.\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    def flip(arr, k):\n        \"\"\"Helper function to flip the first k elements of the array.\"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not already at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list of elements.\n    \"\"\"\n    def flip(arr, k):\n        \"\"\"\n        Flips the first k elements of the array.\n        \n        :param arr: List of elements.\n        :param k: Number of elements to flip.\n        \"\"\"\n        arr[:k] = arr[:k][::-1]\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not at the end, flip to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                flip(arr, max_idx + 1)\n            # Flip the entire unsorted portion to move the maximum element to the end\n            flip(arr, n)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts the given list using the Pancake Sort algorithm.\n    \n    :param arr: List of elements to be sorted.\n    :return: Sorted list.\n    \"\"\"\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        max_idx = arr.index(max(arr[:n]))\n        \n        # If the maximum element is not already at the end, flip the array to bring it to the front\n        if max_idx != n - 1:\n            if max_idx != 0:\n                # Flip the array from the start to the max_idx to bring the max element to the front\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            \n            # Flip the entire unsorted portion to move the max element to its correct position\n            arr[:n] = arr[:n][::-1]\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 3}]}, "Mbpp/166": {"dps": 89.96, "dps_norm": 48.75, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(nums):\n    count = 0\n    n = len(nums)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # XOR the two numbers\n            xor_result = nums[i] ^ nums[j]\n            # Check if the result is even\n            if xor_result % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    # Helper function to check if a number is even\n    def is_even(num):\n        return num % 2 == 0\n    \n    count = 0\n    n = len(lst)\n    \n    # Iterate through all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_even(lst[i] ^ lst[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 0}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate through all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate through all pairs of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of lst[i] and lst[j] is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of lst[i] and lst[j] is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate through each pair of integers in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of the pair is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(lst):\n    count = 0\n    n = len(lst)\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Check if the xor of lst[i] and lst[j] is even\n            if (lst[i] ^ lst[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 68.0, "profiled": [{"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list lst from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the valid range of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the valid range of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list `lst` from `start_index` to `end_index` (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list `lst` from `start_index` to `end_index` (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list `lst` from `start_index` to `end_index` (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n\n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n\n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list within the specified range of indices.\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the valid range of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list lst from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list within the specified range.\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list `lst` within the range specified by `start_index` and `end_index`.\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list `lst` from `start_index` to `end_index` (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list within the specified range.\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list within the specified range of indices.\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the valid range of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list from start_index to end_index (inclusive).\n    \n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the valid range of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Returns the sum of numbers in the list lst from start_index to end_index (inclusive).\n    \"\"\"\n    # Ensure the indices are within the valid range of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start_index, end_index):\n    \"\"\"\n    Calculate the sum of numbers in the list within the specified range.\n\n    :param lst: List of numbers\n    :param start_index: Starting index (inclusive)\n    :param end_index: Ending index (inclusive)\n    :return: Sum of numbers in the specified range\n    \"\"\"\n    # Ensure the indices are within the bounds of the list\n    if start_index < 0:\n        start_index = 0\n    if end_index >= len(lst):\n        end_index = len(lst) - 1\n\n    # Calculate the sum of the elements in the specified range\n    return sum(lst[start_index:end_index + 1])", "matching_cluster_idx": 7}]}, "Mbpp/226": {"dps": 68.21705426356588, "dps_norm": 14.285714285714286, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for index, char in enumerate(input_string) if index % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for index, char in enumerate(input_string) if index % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for index, char in enumerate(input_string) if index % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([input_string[i] for i in range(len(input_string)) if i % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for idx, char in enumerate(input_string) if idx % 2 == 0])\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Use list comprehension to filter out characters at odd indices\n    result = ''.join([char for index, char in enumerate(input_string) if index % 2 == 0])\n    return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n    \n    :param input_string: The input string to be modified.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The input string to be modified.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n\n    :param input_string: The input string to be modified.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n\n    :param input_string: The input string to be modified.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The input string to be modified.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n\n    Args:\n    input_string (str): The input string to be modified.\n    char (str): The character to replace blank spaces with.\n\n    Returns:\n    str: The modified string with blank spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n    \n    :param input_string: The input string to be modified.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The input string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The string in which spaces need to be replaced.\n    :param char: The character to replace the spaces with.\n    :return: The modified string with spaces replaced by the specified character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n    \n    :param input_string: The string to be modified.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replaces all blank spaces in the input string with the specified character.\n\n    :param input_string: The input string to modify.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    \"\"\"\n    Replace all blank spaces in the input string with the specified character.\n\n    :param input_string: The string in which to replace blank spaces.\n    :param char: The character to replace blank spaces with.\n    :return: The modified string with blank spaces replaced by the character.\n    \"\"\"\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 51.72413793103448, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(2 * current, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for next_value in range(2 * current_value, m + 1):\n            count += count_sequences(next_value, remaining_length - 1)\n        return count\n\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        return count\n\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_value, length):\n        if length == n:\n            return 1\n        count = 0\n        for next_value in range(2 * current_value, m + 1):\n            count += count_sequences(next_value, length + 1)\n        return count\n\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, 1)\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for next_value in range(2 * current_value, m + 1):\n            count += count_sequences(next_value, remaining_length - 1)\n        return count\n\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(2 * current, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for next_value in range(2 * current_value, m + 1):\n            count += count_sequences(next_value, remaining_length - 1)\n        return count\n\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, n - 1)\n\n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for next_value in range(2 * current_value, m + 1):\n            count += count_sequences(next_value, remaining_length - 1)\n        return count\n\n    total_count = 0\n    for start_value in range(1, m + 1):\n        total_count += count_sequences(start_value, n - 1)\n    \n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(2 * current, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_value, remaining_length):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for next_value in range(2 * current_value, m + 1):\n            count += count_sequences(next_value, remaining_length - 1)\n        return count\n\n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(start_value, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(2 * current, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(2 * current, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n\n    total_count = 0\n    for start in range(1, m + 1):\n        total_count += count_sequences(start, n - 1)\n    return total_count", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current_length, previous_value):\n        if current_length == n:\n            return 1\n        \n        count = 0\n        for next_value in range(2 * previous_value, m + 1):\n            count += count_sequences(current_length + 1, next_value)\n        \n        return count\n    \n    total_sequences = 0\n    for start_value in range(1, m + 1):\n        total_sequences += count_sequences(1, start_value)\n    \n    return total_sequences", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    def count_sequences(current, length):\n        if length == 0:\n            return 1\n        count = 0\n        for next_val in range(2 * current, m + 1):\n            count += count_sequences(next_val, length - 1)\n        return count\n\n    total_sequences = 0\n    for start in range(1, m + 1):\n        total_sequences += count_sequences(start, n - 1)\n    \n    return total_sequences", "matching_cluster_idx": 5}]}, "Mbpp/240": {"dps": 81.46341463414635, "dps_norm": 89.44444444444444, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    # Check if the first list is not empty\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}, {"solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    \n    Returns:\n    list: The modified first list.\n    \"\"\"\n    if not list1:\n        return list2  # If list1 is empty, return list2\n    \n    # Remove the last element of list1\n    list1.pop()\n    \n    # Extend list1 with the elements of list2\n    list1.extend(list2)\n    \n    return list1", "matching_cluster_idx": 8}, {"solution": "def replace_list(list1, list2):\n    # Check if list1 is not empty to avoid index errors\n    if list1:\n        # Replace the last element of list1 with list2\n        list1[-1:] = list2\n    return list1", "matching_cluster_idx": 7}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before each item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before each item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element before each item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: List of elements\n    :param element: Element to insert\n    :return: List with the element inserted before each element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: List of elements\n    :param element: Element to insert\n    :return: List with the element inserted before each element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts the given element before each element in the list and returns the resulting list.\n    \n    :param lst: List of elements\n    :param element: Element to be inserted\n    :return: List with the element inserted before each element\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 69.40639269406392, "dps_norm": 64.70588235294117, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given non-negative number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def is_prime(n):\n    \"\"\"Helper function to check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    \"\"\"Function to count the number of prime numbers less than the given number.\"\"\"\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}]}, "Mbpp/265": {"dps": 70.93023255813954, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist based on the index\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist based on the index\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist based on the index\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with an index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist based on the index\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, element in enumerate(lst):\n        # Append the element to the appropriate sublist\n        result[i % n].append(element)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the resulting lists\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list with index\n    for i, item in enumerate(lst):\n        # Append the item to the appropriate sublist based on the index\n        result[i % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}]}, "Mbpp/281": {"dps": 94.0, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n        lst (list): The list to check for unique elements.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Parameters:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n        lst (list): The list to check for unique elements.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n\n    Args:\n    lst (list): The list to check for unique elements.\n\n    Returns:\n    bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}, {"solution": "def all_unique(lst):\n    \"\"\"\n    Check if all elements in the list are unique.\n\n    Args:\n        lst (list): The list to check.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n    \"\"\"\n    return len(lst) == len(set(lst))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array to store the sorted subarrays\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array to store the sorted subarrays\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (arr[i], arr[j]) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array to store the sorted subarrays\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray\n            # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is defined as a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0]*n\n    return merge_sort_and_count(arr, temp_arr, 0, n-1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array to store the sorted subarrays\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array to store the sorted subarrays\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)", "matching_cluster_idx": 5}, {"solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all remaining elements in the left subarray (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}, {"solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Function to count the number of inversions in an array.\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n    \"\"\"\n    def merge_and_count(arr, temp_arr, left, mid, right):\n        i = left    # Starting index for left subarray\n        j = mid + 1 # Starting index for right subarray\n        k = left    # Starting index to be sorted\n        inv_count = 0\n\n        # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n        while i <= mid and j <= right:\n            if arr[i] <= arr[j]:\n                temp_arr[k] = arr[i]\n                i += 1\n            else:\n                # There are mid - i inversions, because all remaining elements in the left subarray\n                # (arr[i], arr[i+1], ..., arr[mid]) are greater than arr[j]\n                temp_arr[k] = arr[j]\n                inv_count += (mid - i + 1)\n                j += 1\n            k += 1\n\n        # Copy the remaining elements of left subarray, if any\n        while i <= mid:\n            temp_arr[k] = arr[i]\n            i += 1\n            k += 1\n\n        # Copy the remaining elements of right subarray, if any\n        while j <= right:\n            temp_arr[k] = arr[j]\n            j += 1\n            k += 1\n\n        # Copy the sorted subarray into Original array\n        for i in range(left, right + 1):\n            arr[i] = temp_arr[i]\n\n        return inv_count\n\n    def merge_sort_and_count(arr, temp_arr, left, right):\n        inv_count = 0\n        if left < right:\n            mid = (left + right) // 2\n\n            inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n            inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n\n            inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n        return inv_count\n\n    # Create a temporary array\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)", "matching_cluster_idx": 5}]}, "Mbpp/308": {"dps": 90.96551724137932, "dps_norm": 65.0, "pass@1": 100.0, "profiled": [{"solution": "def large_product(list1, list2, num_products):\n    # Calculate all possible products\n    products = [(x * y, x, y) for x in list1 for y in list2]\n    \n    # Sort products by the product value in descending order\n    products.sort(key=lambda x: x[0], reverse=True)\n    \n    # Extract the largest products\n    largest_products = [product[0] for product in products[:num_products]]\n    \n    return largest_products", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [(x * y, x, y) for x in list1 for y in list2]\n    \n    # Sort products by the product value in descending order\n    products.sort(reverse=True, key=lambda x: x[0])\n    \n    # Extract the top n products\n    top_products = [product[0] for product in products[:n]]\n    \n    return top_products", "matching_cluster_idx": 2}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num_products):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n    \n    :param list1: First list of integers\n    :param list2: Second list of integers\n    :param num_products: Number of largest products to find\n    :return: List of the largest products\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and take the top 'num_products'\n    largest_products = sorted(products, reverse=True)[:num_products]\n    \n    return largest_products", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Create a list of all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the top n largest products\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        \n        # Store the result in the memo dictionary\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, return 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        \n        # Store the result in the memo dictionary\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0, the maximum sum is 0\n        if n == 0:\n            return 0\n        \n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(n, f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        \n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        # Calculate the maximum sum using the given equation\n        result = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        memo[x] = result\n        return result\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        \n        # Store the result in the memo dictionary\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, the maximum sum is 0\n        if n <= 0:\n            return 0\n        \n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        \n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, the maximum sum is 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        \n        # Store the result in the memo dictionary\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, the maximum sum is 0\n        if n <= 0:\n            return 0\n        \n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        \n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or less, return 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(n, f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, the maximum sum is 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, return 0\n        if n <= 0:\n            return 0\n        \n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(n, f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        \n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, return 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, the maximum sum is 0\n        if n <= 0:\n            return 0\n        \n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(n, f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5))\n        \n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        \n        return max_sum\n\n    # Call the helper function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        # Calculate the maximum sum using the given equation\n        max_sum = max(x, f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5))\n        \n        # Store the result in the memoization dictionary\n        memo[x] = max_sum\n        return max_sum\n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, the maximum sum is 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, return 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Start the recursion with the given number n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, return 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Memoization dictionary to store already computed values\n    memo = {}\n\n    def f(n):\n        # Base case: if n is 0 or negative, return 0\n        if n <= 0:\n            return 0\n        # If the value is already computed, return it\n        if n in memo:\n            return memo[n]\n        # Compute the maximum sum using the given equation\n        max_sum = max(f(n // 2) + f(n // 3) + f(n // 4) + f(n // 5), n)\n        # Store the computed value in the memo dictionary\n        memo[n] = max_sum\n        return max_sum\n\n    # Call the recursive function with the initial value of n\n    return f(n)", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to count the occurrences of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Count the frequency of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a frequency of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    :param tup: The tuple to search within.\n    :param element: The element to search for.\n    :return: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    :param tup: The tuple to search within.\n    :param element: The element to search for.\n    :return: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n\n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n\n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    \"\"\"\n    Check whether an element exists within a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search within.\n    element: The element to search for.\n    \n    Returns:\n    bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tup", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 91.30434782608695, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence to check.\n    :param seq2: Second sequence to check.\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Args:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check.\n    \n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Parameters:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence to check.\n    seq2 (list): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Parameters:\n    seq1 (list): The first sequence to check.\n    seq2 (list): The second sequence to check.\n    \n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence to check.\n    seq2 (list): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n    \n    Parameters:\n    seq1 (list or tuple): The first sequence to check.\n    seq2 (list or tuple): The second sequence to check.\n    \n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    :param seq1: First sequence (list, tuple, etc.)\n    :param seq2: Second sequence (list, tuple, etc.)\n    :return: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}, {"solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n    seq1 (list): The first sequence.\n    seq2 (list): The second sequence.\n\n    Returns:\n    bool: True if any value in seq1 exists in seq2, False otherwise.\n    \"\"\"\n    return any(item in seq2 for item in seq1)", "matching_cluster_idx": 7}]}, "Mbpp/421": {"dps": 79.25925925925927, "dps_norm": 87.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use between elements. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple of elements to concatenate.\n    :param delimiter: The delimiter to use between elements. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: String delimiter to join the elements.\n    :return: String resulting from the concatenation of the tuple elements.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple of elements to concatenate.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string with each element of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: String to be used as the delimiter between elements.\n    :return: A single string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple of elements to concatenate.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string where each element of the tuple is concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: String to be used as the delimiter between elements.\n    :return: A single string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The string to use as a delimiter between elements.\n    :return: A single string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple of elements to concatenate.\n    :param delimiter: The delimiter to use between elements. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple of elements to concatenate.\n    :param delimiter: The delimiter to use between elements. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string where each element of the tuple is concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: A tuple containing elements to be concatenated.\n    :param delimiter: The string to use as a delimiter between elements.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple of elements to concatenate.\n    :param delimiter: The delimiter to use between elements. Default is '-'.\n    :return: A string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n    \n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The string to be used as a delimiter between elements.\n    :return: A single string with all elements of the tuple concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: String to be used as the delimiter between elements.\n    :return: A single string with all elements concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup, delimiter='-'):\n    \"\"\"\n    Concatenate each element of the tuple by the specified delimiter.\n\n    :param tup: Tuple containing elements to be concatenated.\n    :param delimiter: The delimiter to use for concatenation. Default is '-'.\n    :return: A string where each element of the tuple is concatenated by the delimiter.\n    \"\"\"\n    return delimiter.join(map(str, tup))", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n\n    Args:\n    strings_tuple (tuple): A tuple of strings.\n\n    Returns:\n    list: A list of rear index elements from each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of characters, each being the rear index element of the corresponding string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(tup):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    tup (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string in the tuple.\n    \"\"\"\n    return [s[-1] for s in tup]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list of rear index elements from each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}, {"solution": "def extract_rear(strings_tuple):\n    \"\"\"\n    Extracts the rear index element of each string in the given tuple.\n    \n    Args:\n    strings_tuple (tuple): A tuple of strings.\n    \n    Returns:\n    list: A list containing the rear index element of each string.\n    \"\"\"\n    return [s[-1] for s in strings_tuple]", "matching_cluster_idx": 4}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists that contain a particular element.\n\n    :param nested_list: A list of lists.\n    :param element: The element to search for in the sublists.\n    :return: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Count the number of sublists that contain a particular element.\n\n    :param nested_list: A list of lists.\n    :param element: The element to search for in the sublists.\n    :return: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    :param nested_list: A list of lists.\n    :param element: The element to search for in the sublists.\n    :return: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, target_element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n    \n    :param nested_list: A list of lists.\n    :param target_element: The element to count occurrences of.\n    :return: The number of sublists containing the target element.\n    \"\"\"\n    count = 0\n    for sublist in nested_list:\n        if target_element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(nested_list, element):\n    count = 0\n    for sublist in nested_list:\n        if element in sublist:\n            count += 1\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 100.0, "profiled": [{"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            \n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            arr[j] = temp\n        \n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    # Perform gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell Sort algorithm.\n    \n    :param arr: List of integers to be sorted.\n    :return: Sorted list of integers.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Start with a big gap, then reduce the gap\n    n = len(arr)\n    gap = n // 2\n    \n    # Do a gapped insertion sort for this gap size.\n    # The first gap elements a[0..gap-1] are already in gapped order\n    # keep adding one more element until the entire array is gap sorted\n    while gap > 0:\n        for i in range(gap, n):\n            # add a[i] to the elements that have been gap sorted\n            # save a[i] in temp and make a hole at position i\n            temp = arr[i]\n            \n            # shift earlier gap-sorted elements up until the correct location for a[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            \n            # put temp (the original a[i]) in its correct location\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    \"\"\"\n    Sorts the given array using the Shell Sort algorithm.\n    \n    :param arr: List of integers to be sorted.\n    :return: Sorted list of integers.\n    \"\"\"\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 63.82978723404255, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    :param arr: List of integers\n    :param num: Integer to compare with elements of the array\n    :return: Boolean indicating if num is greater than all elements of arr\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    :param arr: List of integers\n    :param num: Integer to compare with elements of the array\n    :return: Boolean, True if num is greater than all elements in arr, False otherwise\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int/float): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int/float): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n\n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n\n    Returns:\n    bool: True if num is greater than all elements in arr, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    \"\"\"\n    Check whether the entered number is greater than all elements of the given array.\n    \n    Parameters:\n    arr (list): The array of numbers to compare against.\n    num (int): The number to check.\n    \n    Returns:\n    bool: True if the number is greater than all elements in the array, False otherwise.\n    \"\"\"\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}]}, "Mbpp/437": {"dps": 71.61764705882354, "dps_norm": 22.0, "pass@1": 83.0, "profiled": [{"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string with index\n    for i, char in enumerate(s):\n        # Check if the index is even (0, 2, 4, ...)\n        if i % 2 == 1:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string with index\n    for i, char in enumerate(s):\n        # Check if the index is even (0, 2, 4, ...)\n        if i % 2 == 1:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out characters at odd indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string with index\n    for i, char in enumerate(s):\n        # Check if the index is even (0, 2, 4, ...)\n        if i % 2 == 1:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string with index\n    for i, char in enumerate(s):\n        # Check if the index is even (0, 2, 4, ...)\n        if i % 2 == 1:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out characters at odd indices\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 1}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes odd-indexed characters from the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with odd-indexed characters removed.\n    \"\"\"\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string with index\n    for i, char in enumerate(s):\n        # Check if the index is even (0, 2, 4, ...)\n        if i % 2 == 1:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    \"\"\"\n    Removes odd-indexed characters from the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The string with odd-indexed characters removed.\n    \"\"\"\n    return ''.join(s[i] for i in range(len(s)) if i % 2 == 1)", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Use list comprehension to filter out odd-indexed characters\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n    \n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n    \n    :param tup: A tuple containing elements.\n    :param lst: A list containing elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n    \n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n    \n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of the list in the tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n    \n    Parameters:\n    tup (tuple): The tuple to search for occurrences.\n    lst (list): The list of elements to count in the tuple.\n    \n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    :param tup: A tuple containing elements.\n    :param lst: A list of elements to count in the tuple.\n    :return: The total count of elements from the list that appear in the tuple.\n    \"\"\"\n    count = 0\n    for element in lst:\n        count += tup.count(element)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    \"\"\"\n    Count the occurrence of all elements of a list in a tuple.\n\n    Parameters:\n    tup (tuple): The tuple in which to count occurrences.\n    lst (list): The list of elements to count in the tuple.\n\n    Returns:\n    int: The total count of occurrences of elements from the list in the tuple.\n    \"\"\"\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 49.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        input_string (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        input_string (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n        input_string (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n        input_string (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the given string.\n\n    Args:\n        input_string (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        input_string (str): The input string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n\n    Args:\n        input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n        str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use a list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use a list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    \"\"\"\n    Reverses each string in the given list of string values.\n    \n    Args:\n    string_list (list): A list of string values.\n    \n    Returns:\n    list: A list of reversed string values.\n    \"\"\"\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use a list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use a list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Use a list comprehension to reverse each string in the list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}, {"solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]", "matching_cluster_idx": 4}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace old_char with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with replacements.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of `old_char` with `new_char` in the string `s`.\n\n    :param s: The input string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the string s.\n    \n    :param s: The input string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with replacements.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with replacements.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string with replacements.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of `old_char` with `new_char` in the string `s`.\n    \n    :param s: The input string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace `old_char` with.\n    :return: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s: str, old_char: str, new_char: str) -> str:\n    \"\"\"\n    Replace all occurrences of `old_char` with `new_char` in the string `s`.\n    \n    :param s: The input string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace `old_char` with.\n    :return: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char with new_char in the input_string.\n    \n    :param input_string: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements.\n    \"\"\"\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    :param arr: List of integers\n    :return: Sum of the largest and smallest value in the array\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        raise ValueError(\"Array is empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    if not arr:\n        return 0  # Return 0 if the array is empty\n    smallest = min(arr)\n    largest = max(arr)\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Function to find the sum of the largest and smallest value in a given array.\n    \n    Parameters:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest values in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The array must not be empty\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    \"\"\"\n    Find the sum of the largest and smallest value in a given array.\n    \n    Args:\n    arr (list): A list of integers.\n    \n    Returns:\n    int: The sum of the largest and smallest value in the array.\n    \"\"\"\n    if not arr:\n        raise ValueError(\"The input array must not be empty.\")\n    \n    smallest = min(arr)\n    largest = max(arr)\n    \n    return smallest + largest", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        input_string (str): The string to be converted to lower case.\n\n    Returns:\n        str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    s (str): The input string to be converted.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The input string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Args:\n    input_string (str): The string to be converted to lower case.\n\n    Returns:\n    str: The input string in lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(input_string):\n    \"\"\"\n    Converts the given string to lower case.\n\n    Parameters:\n    input_string (str): The string to be converted.\n\n    Returns:\n    str: The string converted to lower case.\n    \"\"\"\n    return input_string.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s: str) -> str:\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    \"\"\"\n    Convert the given string to lower case.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The input string converted to lower case.\n    \"\"\"\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(s):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"(.*?)\"', s)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regex to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}, {"solution": "def extract_values(input_string):\n    import re\n    # Use regular expression to find all values between quotation marks\n    values = re.findall(r'\"([^\"]*)\"', input_string)\n    return values", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.06172839506173, "dps_norm": 85.71428571428571, "pass@1": 84.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count each number in the list\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count the occurrences of each number\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in count_dict if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that appear more than once\n    unique_nums = [num for num in nums if count_dict[num] == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 62.25396825396825, "dps_norm": 64.54545454545455, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n    \n    Returns:\n    list: A single flat list containing elements from the input lists interleaved.\n    \"\"\"\n    interleaved_list = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved_list.extend([a, b, c])\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave 3 lists of the same length into a single flat list.\n    \n    Args:\n    list1 (list): The first list.\n    list2 (list): The second list.\n    list3 (list): The third list.\n    \n    Returns:\n    list: A single flat list containing elements from list1, list2, and list3 interleaved.\n    \"\"\"\n    interleaved_list = []\n    for a, b, c in zip(list1, list2, list3):\n        interleaved_list.extend([a, b, c])\n    return interleaved_list", "matching_cluster_idx": 7}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Check if all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Ensure all lists are of the same length\n    if len(list1) != len(list2) or len(list2) != len(list3):\n        raise ValueError(\"All lists must be of the same length\")\n    \n    # Interleave the lists\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": null, "dps_norm": null, "pass@1": 4.0, "profiled": []}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Args:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    Parameters:\n    lst (list): The list to be converted.\n\n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \n    Parameters:\n    lst (list): The list to be converted.\n    \n    Returns:\n    tuple: The tuple representation of the list.\n    \"\"\"\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    return tuple(lst)", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest values in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Parameters:\n    lst (list): A list of integers.\n    \n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Function to find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}, {"solution": "def big_diff(lst):\n    \"\"\"\n    Find the difference between the largest and smallest value in a given list.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    int: The difference between the largest and smallest value in the list.\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n    \n    return max(lst) - min(lst)", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 40.13333333333334, "dps_norm": 47.5, "pass@1": 57.0, "profiled": [{"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef binomial_coefficient(n, k):\n    \"\"\"Calculate the binomial coefficient C(n, k).\"\"\"\n    return math.comb(n, k)\ndef sum_Of_product(n):\n    \"\"\"Calculate the sum of the product of consecutive binomial coefficients.\"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef binomial_coefficient(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 0}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients for a given n.\n    \n    The sum of the product of consecutive binomial coefficients C(n, k) * C(n, k+1) for k in [0, n-1].\n    \n    Args:\n        n (int): The upper limit for the binomial coefficients.\n        \n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    The sum is given by:\n    sum_{i=0}^{n-1} C(n, i) * C(n, i+1)\n    \n    where C(n, k) is the binomial coefficient \"n choose k\".\n    \"\"\"\n    total_sum = 0\n    for i in range(n):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\ndef binomial_coefficient(n, k):\n    return factorial(n) // (factorial(k) * factorial(n - k))\ndef sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        total_sum += binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n    return total_sum", "matching_cluster_idx": 0}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n    \n    Args:\n    n (int): The upper limit for the binomial coefficients.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += comb(n, k) * comb(n, k - 1)\n    return total_sum", "matching_cluster_idx": 4}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words based on spaces\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}]}, "Mbpp/610": {"dps": 58.69565217391305, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list without the k'th element\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the valid range for the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list without the k'th element\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the range of the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the range of the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the valid range for the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the valid range for the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the range of the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list.\n    \n    :param lst: List of elements.\n    :param k: Index of the element to remove (1-based index).\n    :return: List with the k'th element removed.\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from the list and returns the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the valid range for the list\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}, {"solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Remove the k'th element from the list and return the modified list.\n    \n    :param lst: List of elements\n    :param k: Index of the element to remove (1-based index)\n    :return: List with the k'th element removed\n    \"\"\"\n    # Convert 1-based index to 0-based index\n    k_index = k - 1\n    \n    # Check if the index is valid\n    if k_index < 0 or k_index >= len(lst):\n        raise ValueError(\"k is out of the list's range\")\n    \n    # Return the list with the k'th element removed\n    return lst[:k_index] + lst[k_index + 1:]", "matching_cluster_idx": 3}]}, "Mbpp/611": {"dps": null, "dps_norm": null, "pass@1": 8.0, "profiled": []}, "Mbpp/631": {"dps": 56.249999999999986, "dps_norm": 81.25, "pass@1": 31.0, "profiled": [{"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table to swap spaces and underscores\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n\n    Args:\n    input_string (str): The input string to be modified.\n\n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Replace underscores with a temporary placeholder to avoid conflicts\n    temp_placeholder = 'TEMP_PLACEHOLDER'\n    input_string = input_string.replace('_', temp_placeholder)\n    \n    # Replace whitespaces with underscores\n    input_string = input_string.replace(' ', '_')\n    \n    # Replace the temporary placeholder with whitespaces\n    input_string = input_string.replace(temp_placeholder, ' ')\n    \n    return input_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    :param s: The input string\n    :return: The modified string\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the string using the translation table\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    :param s: The input string\n    :return: The modified string\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the string using the translation table\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table to swap spaces and underscores\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Replace underscores with a temporary placeholder to avoid conflicts\n    temp_string = input_string.replace('_', 'TEMP_PLACEHOLDER')\n    \n    # Replace whitespaces with underscores\n    temp_string = temp_string.replace(' ', '_')\n    \n    # Replace the temporary placeholder with whitespaces\n    result_string = temp_string.replace('TEMP_PLACEHOLDER', ' ')\n    \n    return result_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Replace underscores with a temporary placeholder to avoid conflicts\n    temp_placeholder = 'TEMP_PLACEHOLDER'\n    input_string = input_string.replace('_', temp_placeholder)\n    \n    # Replace whitespaces with underscores\n    input_string = input_string.replace(' ', '_')\n    \n    # Replace the temporary placeholder with whitespaces\n    input_string = input_string.replace(temp_placeholder, ' ')\n    \n    return input_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Replace underscores with a temporary placeholder to avoid conflicts\n    temp_string = input_string.replace('_', 'TEMP_PLACEHOLDER')\n    \n    # Replace whitespaces with underscores\n    temp_string = temp_string.replace(' ', '_')\n    \n    # Replace the temporary placeholder with whitespaces\n    result_string = temp_string.replace('TEMP_PLACEHOLDER', ' ')\n    \n    return result_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the string using the translation table\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with spaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table for the replacements\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(s):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    str: The modified string.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Use the translate method to replace characters according to the translation table\n    return s.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    Args:\n    input_string (str): The input string to be processed.\n    \n    Returns:\n    str: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Use str.translate to swap spaces and underscores\n    return input_string.translate(str.maketrans(' _', '_ '))", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    :param input_string: The input string to be processed.\n    :return: The processed string with spaces and underscores swapped.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    return input_string.translate(translation_table)", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    :param input_string: The input string to be modified.\n    :return: The modified string with spaces and underscores swapped.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and underscores with whitespaces in the given string.\n    \n    :param input_string: The input string to be modified.\n    :return: The modified string.\n    \"\"\"\n    # Create a translation table to swap spaces and underscores\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Replace underscores with a temporary placeholder to avoid conflicts\n    temp_string = input_string.replace('_', 'TEMP_PLACEHOLDER')\n    \n    # Replace whitespaces with underscores\n    temp_string = temp_string.replace(' ', '_')\n    \n    # Replace the temporary placeholder with whitespaces\n    result_string = temp_string.replace('TEMP_PLACEHOLDER', ' ')\n    \n    return result_string", "matching_cluster_idx": 4}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replace whitespaces with underscores and vice versa in the given string.\n    \n    Args:\n    input_string (str): The input string to be modified.\n    \n    Returns:\n    str: The modified string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Create a translation table that maps spaces to underscores and underscores to spaces\n    translation_table = str.maketrans(' _', '_ ')\n    \n    # Translate the input string using the translation table\n    modified_string = input_string.translate(translation_table)\n    \n    return modified_string", "matching_cluster_idx": 6}]}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeros to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Count the number of non-zero elements\n    non_zero_count = sum(1 for x in lst if x != 0)\n    \n    # Create a new list with non-zero elements first\n    result = [x for x in lst if x != 0]\n    \n    # Append the remaining zeroes to the end of the list\n    result.extend([0] * (len(lst) - non_zero_count))\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/644": {"dps": 96.27659574468083, "dps_norm": 93.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array upto the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position upto which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position `k`.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first `k` elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"Position k exceeds the length of the array.\")\n    \n    # Reverse the first `k` elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position `k`.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first `k` elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first `k` elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array upto the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position upto which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverse an array upto a given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position upto which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array upto the given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position upto which the array should be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    :param arr: List of integers\n    :param k: Integer representing the position up to which the array should be reversed\n    :return: List of integers with the first k elements reversed\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position k.\n\n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n\n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position `k`.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first `k` elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    # Ensure k is within the bounds of the array\n    if k > len(arr):\n        raise ValueError(\"k should be less than or equal to the length of the array\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position `k`.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first `k` elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"Position k exceeds the length of the array.\")\n    \n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    \n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses an array up to a given position `k`.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first `k` elements reversed.\n    \"\"\"\n    if k > len(arr):\n        raise ValueError(\"Position k exceeds the length of the array.\")\n    \n    # Reverse the first `k` elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the array up to the given position k.\n    \n    Parameters:\n    arr (list): The input array.\n    k (int): The position up to which the array should be reversed.\n    \n    Returns:\n    list: The array with the first k elements reversed.\n    \"\"\"\n    # Reverse the first k elements\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n    \n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Args:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple and returns the resulting tuple.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n    \n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n    \n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to be added to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: The new tuple with the dictionary appended.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    tup (tuple): The original tuple.\n    dictionary (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(t, d):\n    \"\"\"\n    Adds a dictionary to the end of a tuple.\n\n    Parameters:\n    t (tuple): The original tuple.\n    d (dict): The dictionary to add to the tuple.\n\n    Returns:\n    tuple: A new tuple with the dictionary appended at the end.\n    \"\"\"\n    return t + (d,)", "matching_cluster_idx": 4}]}, "Mbpp/725": {"dps": 88.96174863387978, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all sequences of characters between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all sequences between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', s)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all sequences of characters between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all sequences between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all sequences between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all sequences of characters within double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(s):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"([^\"]*)\"', s)", "matching_cluster_idx": 5}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}, {"solution": "def extract_quotation(input_string):\n    import re\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"([^\"]*)\"', input_string)\n    return matches", "matching_cluster_idx": 6}]}, "Mbpp/732": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate over each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Replace each special character with a colon\n    for char in special_chars:\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Define the characters to be replaced\n    special_chars = [' ', ',', '.']\n    \n    # Iterate through each character in the text\n    for char in special_chars:\n        # Replace the character with a colon\n        text = text.replace(char, ':')\n    \n    return text", "matching_cluster_idx": 9}, {"solution": "def replace_specialchar(text):\n    # Replace spaces, commas, and dots with a colon\n    return text.replace(' ', ':').replace(',', ':').replace('.', ':')", "matching_cluster_idx": 9}]}, "Mbpp/740": {"dps": 83.63636363636364, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param tup: A tuple of elements.\n    :return: A dictionary where each key is an element from the tuple and its value is the next element.\n    \"\"\"\n    # Ensure the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Ensure the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n        \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple containing key-value pairs as adjacent elements.\n    \n    Returns:\n        dict: A dictionary where each key is an element from the tuple and its value is the next element.\n    \"\"\"\n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(tup), 2):\n        # Add the key-value pair to the dictionary\n        result_dict[tup[i]] = tup[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary using adjacent elements\n    result_dict = {}\n    for i in range(0, len(tup), 2):\n        result_dict[tup[i]] = tup[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary using adjacent elements\n    result_dict = {}\n    for i in range(0, len(tup), 2):\n        result_dict[tup[i]] = tup[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple.\n        \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    tup (tuple): The input tuple.\n    \n    Returns:\n    dict: The resulting dictionary.\n    \"\"\"\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: A tuple of elements.\n    :return: A dictionary where each key is an element from the tuple and its value is the next element.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"The tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Parameters:\n    tup (tuple): The input tuple containing elements to be converted to a dictionary.\n    \n    Returns:\n    dict: A dictionary where each key is an element from the tuple and its value is the next element in the tuple.\n    \"\"\"\n    # Initialize an empty dictionary\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2\n    for i in range(0, len(tup) - 1, 2):\n        # Assign the current element as the key and the next element as the value\n        result_dict[tup[i]] = tup[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n    t (tuple): The input tuple.\n    \n    Returns:\n    dict: The resulting dictionary.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Converts a given tuple to a key-value dictionary using adjacent elements.\n    \n    :param t: A tuple containing elements to be converted to a dictionary.\n    :return: A dictionary where each key is an element from the tuple and its value is the next element.\n    \"\"\"\n    # Check if the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Create the dictionary using adjacent elements\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(t):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        t (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Ensure the tuple has an even number of elements\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple must have an even number of elements to form key-value pairs.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {t[i]: t[i+1] for i in range(0, len(t), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Ensure the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by iterating over the tuple in steps of 2\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \n    Args:\n        tup (tuple): The input tuple.\n    \n    Returns:\n        dict: The resulting dictionary.\n    \"\"\"\n    # Ensure the tuple has an even number of elements\n    if len(tup) % 2 != 0:\n        raise ValueError(\"The input tuple must have an even number of elements.\")\n    \n    # Create the dictionary by pairing adjacent elements\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 28.28767123287671, "dps_norm": 49.166666666666664, "pass@1": 100.0, "profiled": [{"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n    \n    Parameters:\n    tup (tuple): The tuple to be checked.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n    \n    Parameters:\n    tup (tuple): The tuple to be checked.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Function to check if the given tuple has any None value or not.\n    \n    Args:\n    tup (tuple): The tuple to be checked.\n    \n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return None in tup", "matching_cluster_idx": 5}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Args:\n        tup (tuple): The tuple to check.\n\n    Returns:\n        bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 2}, {"solution": "def check_none(tup):\n    \"\"\"\n    Check if the given tuple has any None value.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n\n    Returns:\n    bool: True if the tuple contains any None value, False otherwise.\n    \"\"\"\n    return any(item is None for item in tup)", "matching_cluster_idx": 1}]}, "Mbpp/750": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n    \n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n    \n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the elements of the given tuple to the end of the given list.\n\n    Parameters:\n    lst (list): The list to which the tuple elements will be added.\n    tup (tuple): The tuple whose elements will be added to the list.\n\n    Returns:\n    list: The modified list with the tuple elements appended.\n    \"\"\"\n    lst.extend(tup)\n    return lst", "matching_cluster_idx": 5}]}, "Mbpp/753": {"dps": 87.71812080536913, "dps_norm": 72.5, "pass@1": 100.0, "profiled": [{"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (the value) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of each tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (the value) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 1}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (the value) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (the integer) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element (the value) in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the records based on the second element of the tuple (the value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the indices up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If so, add it to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at index i is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists using the shortest list's length\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at index i is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If it is, add it to the list of common elements\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Find the minimum length of the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the element at the current index is the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If true, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/757": {"dps": 82.71028037383178, "dps_norm": 23.076923076923077, "pass@1": 98.0, "profiled": [{"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n    \n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    # Helper function to check if two strings are reverse of each other\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    # Initialize a counter for the pairs\n    count = 0\n\n    # Iterate through the list to find reverse pairs\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n    \n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(str1, str2):\n        return str1 == str2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_reverse_pairs(string_list):\n    def is_reverse(s1, s2):\n        return s1 == s2[::-1]\n\n    count = 0\n    n = len(string_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_reverse(string_list[i], string_list[j]):\n                count += 1\n    \n    return count", "matching_cluster_idx": 2}]}, "Mbpp/758": {"dps": 89.67181467181466, "dps_norm": 84.375, "pass@1": 100.0, "profiled": [{"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # Increment the count for this tuple in the dictionary\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    \"\"\"\n    Counts the occurrences of each sublist in the given list and returns a dictionary\n    where each sublist is converted to a tuple and the value is the number of its occurrences.\n    \"\"\"\n    from collections import defaultdict\n    \n    # Initialize a defaultdict to count occurrences of each sublist\n    count_dict = defaultdict(int)\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple and increment its count\n        count_dict[tuple(sublist)] += 1\n    \n    # Convert the defaultdict to a regular dictionary and return it\n    return dict(count_dict)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    # Return the dictionary with the counts\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    # Return the resulting dictionary\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    # Return the resulting dictionary\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple to use it as a dictionary key\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 82.04379562043796, "dps_norm": 80.0, "pass@1": 97.0, "profiled": [{"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Parameters:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Parameters:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return all(x == lst[0] for x in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return all(x == lst[0] for x in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n\n    Args:\n    lst (list): A list of numbers.\n\n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return all(x == lst[0] for x in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Check if all elements in the list are the same\n    return all(x == lst[0] for x in lst)", "matching_cluster_idx": 3}, {"solution": "def unique_Element(lst):\n    \"\"\"\n    Check whether a list of numbers contains only one distinct element or not.\n    \n    Args:\n    lst (list): A list of numbers.\n    \n    Returns:\n    bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 88.88888888888889, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    \"\"\"\n    Count the number of digits in a given string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 80.37383177570094, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples containing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples, each containing a pair of consecutive items\n    \"\"\"\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in the given list.\n    \n    :param lst: List of items\n    :return: List of tuples containing consecutive pairs\n    \"\"\"\n    return [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}]}, "Mbpp/775": {"dps": 94.39999999999999, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    :param lst: List of integers\n    :return: True if every odd index contains an odd number, False otherwise\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 != 1:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n\n    Args:\n    lst (list): The list to check.\n\n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 != 1:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 != 1:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(lst):\n    \"\"\"\n    Check whether every odd index contains an odd number in the given list.\n    \n    Args:\n    lst (list): The list of integers to check.\n    \n    Returns:\n    bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": 81.63265306122449, "dps_norm": 86.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    \n    # Sum the unique elements\n    total_sum = sum(unique_elements)\n    \n    return total_sum", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list and add elements to the set\n    for element in lst:\n        unique_elements.add(element)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list and add elements to the set\n    for element in lst:\n        unique_elements.add(element)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list and add elements to the set\n    for element in lst:\n        unique_elements.add(element)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    \n    # Sum the unique elements\n    total_sum = sum(unique_elements)\n    \n    return total_sum", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list and add elements to the set\n    for element in lst:\n        unique_elements.add(element)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list and add elements to the set\n    for element in lst:\n        unique_elements.add(element)\n    \n    # Calculate the sum of the unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Use a set to store unique elements\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Iterate through the list and add elements to the set\n    for element in lst:\n        unique_elements.add(element)\n    \n    # Calculate the sum of the unique elements\n    sum_of_unique_elements = sum(unique_elements)\n    \n    return sum_of_unique_elements", "matching_cluster_idx": 4}, {"solution": "def find_sum(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Create a set to store unique elements\n    unique_elements = set(lst)\n    \n    # Calculate the sum of unique elements\n    sum_unique = sum(unique_elements)\n    \n    return sum_unique", "matching_cluster_idx": 8}, {"solution": "def find_sum(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    # Sum the unique elements\n    return sum(unique_elements)", "matching_cluster_idx": 8}]}, "Mbpp/781": {"dps": 3.937007874015748, "dps_norm": 20.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Count the number of divisors of a given number n.\n    Returns True if the count of divisors is even, otherwise False.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Parameters:\n    n (int): The number to check for divisors.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 0}, {"solution": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "matching_cluster_idx": 0}]}, "Mbpp/800": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(s):\n    \"\"\"\n    Removes all whitespaces from the given string.\n    \n    Args:\n    s (str): The input string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which whitespaces are to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n\n    Args:\n        input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n        str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from a given string.\n\n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from a given string.\n\n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n\n    Returns:\n    str: The string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Remove all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    \"\"\"\n    Removes all whitespaces from the input string.\n    \n    Args:\n    input_string (str): The string from which whitespaces need to be removed.\n    \n    Returns:\n    str: The input string with all whitespaces removed.\n    \"\"\"\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater than the previous max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst_of_lsts):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in lst_of_lsts:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum and corresponding list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update the maximum sum and corresponding list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lst):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        \n        # Update max_sum and max_list if the current sum is greater than the max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    max_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # Update max_sum and max_list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to be searched for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to be searched for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Function to check if the given tuple contains the element k.\n    \n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to be searched in the tuple.\n    \n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to be searched for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the element k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (any): The element to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the value k.\n\n    Parameters:\n    tup (tuple): The tuple to be checked.\n    k (int): The value to search for in the tuple.\n\n    Returns:\n    bool: True if k is in the tuple, False otherwise.\n    \"\"\"\n    return k in tup", "matching_cluster_idx": 5}]}}}
