{"date": "2024-10-19 16:29", "config": {"n_samples": 100, "temperature": 1.0, "min_correct": 10, "max_profile": 20}, "summary": {"dps": 84.69258296490358, "dps_norm": 79.00610315513151, "pass@1": 88.27966101694915}, "eval": {"HumanEval/9": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n    \n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n\n    max_so_far = numbers[0]\n    result = []\n\n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n\n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n    \n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n    \n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    \n    :param numbers: List of integers.\n    :return: List of rolling maximums.\n    \n    Example:\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = []\n    \n    for number in numbers:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    \n    return result", "matching_cluster_idx": 8}]}, "HumanEval/0": {"dps": 52.325581395348834, "dps_norm": 57.142857142857146, "pass@1": 98.0, "profiled": [{"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers: List of floating-point numbers.\n    threshold: A floating-point number representing the threshold.\n    \n    Returns:\n    A boolean value indicating if any two numbers in the list are closer to each other than the threshold.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer to each other than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(1, len(sorted_numbers)):\n        if sorted_numbers[i] - sorted_numbers[i - 1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make comparison easier\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to ensure that we only need to compare adjacent elements\n    numbers.sort()\n    \n    # Iterate through the list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n    \n    :param numbers: List of floating point numbers\n    :param threshold: A floating point number representing the threshold\n    :return: True if any two numbers are closer than the threshold, otherwise False\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, otherwise False.\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to make sure that any two adjacent elements are the closest pair\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparisons easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    Args:\n    numbers: A list of floating-point numbers.\n    threshold: A floating-point number representing the threshold.\n    \n    Returns:\n    A boolean value indicating if any two numbers in the list are closer to each other than the threshold.\n    \"\"\"\n    # Sort the list to make the comparison more efficient\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, any two numbers are closer to each other than\n    the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer to each other than the threshold, False otherwise.\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparison easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in the given list of numbers, are any two numbers closer to each other than\n    the given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to ensure that we only need to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if sorted_numbers[i + 1] - sorted_numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\nimport math\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer to each other than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to check for close elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparison easier\n    for i in range(len(numbers) - 1):\n        if abs(numbers[i] - numbers[i + 1]) < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \n    :param numbers: List of floating-point numbers.\n    :param threshold: A floating-point number representing the threshold.\n    :return: True if any two numbers are closer to each other than the threshold, False otherwise.\n    \"\"\"\n    # Sort the list to make it easier to find close elements\n    numbers.sort()\n    \n    # Iterate through the sorted list and check the difference between consecutive elements\n    for i in range(1, len(numbers)):\n        if numbers[i] - numbers[i - 1] < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Sort the list to ensure that we only need to check adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Iterate through the sorted list and check the difference between adjacent elements\n    for i in range(len(sorted_numbers) - 1):\n        if abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold:\n            return True\n    \n    return False", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    numbers.sort()  # Sort the list to make comparisons easier\n    for i in range(len(numbers) - 1):\n        if numbers[i + 1] - numbers[i] < threshold:\n            return True\n    return False", "matching_cluster_idx": 3}]}, "HumanEval/4": {"dps": 95.14240506329114, "dps_norm": 95.83333333333333, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    abs_diffs = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of these absolute differences\n    mad = sum(abs_diffs) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    abs_differences = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(abs_differences) / len(abs_differences)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    abs_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(abs_differences) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the mean absolute deviation\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean_value) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0  # Handle empty list case\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\nfrom statistics import mean\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    x_mean = mean(numbers)\n    mad = sum(abs(x - x_mean) for x in numbers) / len(numbers)\n    return mad", "matching_cluster_idx": 0}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n\n    # Calculate the mean of the numbers\n    mean_value = sum(numbers) / len(numbers)\n    \n    # Calculate the Mean Absolute Deviation\n    mad = sum(abs(x - mean_value) for x in numbers) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}, {"solution": "from typing import List\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    # Calculate the mean of the numbers\n    mean = sum(numbers) / len(numbers)\n    \n    # Calculate the absolute differences from the mean\n    absolute_differences = [abs(x - mean) for x in numbers]\n    \n    # Calculate the mean of the absolute differences\n    mad = sum(absolute_differences) / len(numbers)\n    \n    return mad", "matching_cluster_idx": 5}]}, "HumanEval/16": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Parameters:\n    string (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make the comparison case-insensitive\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lower case to ensure case insensitivity\n    lower_case_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(lower_case_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    lower_string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(lower_string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # The length of the set is the number of distinct characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n    string (str): The input string to check.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    :param string: The input string to analyze.\n    :return: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set(string)\n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    :param string: The input string.\n    :return: The number of distinct characters, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case and then use a set to find distinct characters\n    distinct_chars = set(string.lower())\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Parameters:\n    string (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ensure case-insensitivity\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # The number of unique characters is the length of the set\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to keep track of distinct characters\n    distinct_chars = set(string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Parameters:\n    string (str): The input string to evaluate.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences and use a set to find unique characters\n    unique_chars = set(string.lower())\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    :param string: The input string.\n    :return: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to make it case-insensitive\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    distinct_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Parameters:\n    string (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, case-insensitive.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n    string (str): The input string to analyze.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store unique characters\n    unique_chars = set(string)\n    \n    # Return the number of unique characters\n    return len(unique_chars)", "matching_cluster_idx": 8}, {"solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) it consists of.\n    \n    Args:\n    string (str): The input string.\n    \n    Returns:\n    int: The number of distinct characters in the string, ignoring case.\n    \n    Examples:\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case differences\n    string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    \n    # Return the number of distinct characters\n    return len(distinct_chars)", "matching_cluster_idx": 8}]}, "HumanEval/20": {"dps": 96.05326876513317, "dps_norm": 97.22222222222223, "pass@1": 100.0, "profiled": [{"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    :param numbers: List of floating-point numbers.\n    :return: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    :param numbers: List of floating-point numbers.\n    :return: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    # Sort the list to make it easier to find the closest pair\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to ensure that we can find the closest elements by comparing adjacent elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first two elements and their difference\n    closest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < closest_diff:\n            closest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to ensure that the closest elements are adjacent in the list\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest elements and their difference\n    closest_diff = float('inf')\n    closest_pair = (None, None)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < closest_diff:\n            closest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    numbers.sort()\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_diff = sys.maxsize\n    closest_pair = (0.0, 0.0)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    Parameters:\n    numbers (List[float]): A list of numbers.\n    \n    Returns:\n    Tuple[float, float]: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    numbers.sort()\n    \n    # Initialize the closest elements and their difference\n    closest_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n    \n    # Iterate through the list to find the closest pair\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_difference = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_difference = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_difference < smallest_difference:\n            smallest_difference = current_difference\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest elements and their difference\n    closest_diff = float('inf')\n    closest_elements = (None, None)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_elements = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    :param numbers: List of floating-point numbers.\n    :return: A tuple containing the two closest numbers.\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize the closest pair with the first two elements\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    numbers.sort()\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n    \n    # Iterate through the sorted list to find the pair with the smallest difference\n    for i in range(1, len(numbers) - 1):\n        current_diff = abs(numbers[i + 1] - numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to ensure that the closest elements are adjacent\n    numbers.sort()\n    \n    # Initialize variables to store the closest pair and the smallest difference\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i + 1] - numbers[i])\n        if diff < smallest_diff:\n            smallest_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make finding the closest elements easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest elements and their difference\n    closest_diff = float('inf')\n    closest_elements = (None, None)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if diff < closest_diff:\n            closest_diff = diff\n            closest_elements = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_elements", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the smallest difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    smallest_diff = abs(sorted_numbers[1] - sorted_numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(sorted_numbers) - 1):\n        current_diff = abs(sorted_numbers[i + 1] - sorted_numbers[i])\n        if current_diff < smallest_diff:\n            smallest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \n    :param numbers: List of floating-point numbers.\n    :return: A tuple containing the two closest numbers in ascending order.\n    \"\"\"\n    # Sort the list to make finding the closest pair easier\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and their difference\n    closest_diff = float('inf')\n    closest_pair = (None, None)\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        current_diff = sorted_numbers[i + 1] - sorted_numbers[i]\n        if current_diff < closest_diff:\n            closest_diff = current_diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Sort the list to make it easier to find the closest elements\n    numbers.sort()\n    \n    # Initialize the closest pair with the first two elements\n    closest_pair = (numbers[0], numbers[1])\n    min_distance = abs(numbers[1] - numbers[0])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(1, len(numbers) - 1):\n        current_distance = abs(numbers[i + 1] - numbers[i])\n        if current_distance < min_distance:\n            min_distance = current_distance\n            closest_pair = (numbers[i], numbers[i + 1])\n    \n    return closest_pair", "matching_cluster_idx": 8}, {"solution": "from typing import List, Tuple\nimport sys\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    \"\"\"\n    # Initialize the closest pair and the smallest difference\n    closest_pair = (numbers[0], numbers[1])\n    smallest_diff = abs(numbers[1] - numbers[0])\n\n    # Iterate through the list to find the closest pair\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            current_diff = abs(numbers[i] - numbers[j])\n            if current_diff < smallest_diff:\n                smallest_diff = current_diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n\n    return closest_pair", "matching_cluster_idx": 3}]}, "HumanEval/24": {"dps": 65.68027210884354, "dps_norm": 28.125, "pass@1": 100.0, "profiled": [{"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    # If no divisor is found, which theoretically shouldn't happen, return 1\n    return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Parameters:\n    n (int): The number for which to find the largest divisor.\n    \n    Returns:\n    int: The largest divisor of n that is smaller than n.\n    \n    Example:\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor other than 1 is found, return 1 (n is prime)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, 1 is always a divisor", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start from the largest possible divisor, which is n-1, and go downwards\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start from the largest number smaller than n and decrement until a divisor is found\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (which is always a divisor)", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return 0  # No divisors smaller than 1 or 0\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1", "matching_cluster_idx": 4}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1, so return 1 if no other divisor is found", "matching_cluster_idx": 0}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    # Start checking from n-1 down to 1 to find the largest divisor\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, 1 is the smallest possible divisor of any integer", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \n    Args:\n    n (int): The number to find the largest divisor for.\n    \n    Returns:\n    int: The largest divisor of n that is smaller than n.\n    \n    Examples:\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(28)\n    14\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor other than 1 is found, return 1", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # If no divisor is found, return 1 (every number is divisible by 1)", "matching_cluster_idx": 1}, {"solution": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1  # Every number is divisible by 1", "matching_cluster_idx": 0}]}, "HumanEval/26": {"dps": 96.4, "dps_norm": 98.75, "pass@1": 100.0, "profiled": [{"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the occurrence of each number\n    count_map = {}\n    for number in numbers:\n        if number in count_map:\n            count_map[number] += 1\n        else:\n            count_map[number] = 1\n    \n    # Build the result list with numbers that occur exactly once\n    result = []\n    for number in numbers:\n        if count_map[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    :param numbers: List of integers\n    :return: A new list with duplicates removed, maintaining original order of non-duplicate elements.\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n        else:\n            if number in result:\n                result.remove(number)\n    return result", "matching_cluster_idx": 2}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    \n    # Identify duplicates\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n    \n    # Filter out duplicates\n    return [number for number in numbers if number not in duplicates]", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the occurrence of each number\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n\n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    :param numbers: List of integers.\n    :return: A new list with duplicates removed.\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n\n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the count of each number\n    count_map = {}\n    for number in numbers:\n        if number in count_map:\n            count_map[number] += 1\n        else:\n            count_map[number] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [number for number in numbers if count_map[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track seen elements and their counts\n    seen = {}\n    for number in numbers:\n        seen[number] = seen.get(number, 0) + 1\n    \n    # Filter out elements that occur more than once, maintaining original order\n    result = [number for number in numbers if seen[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the occurrence of each element\n    count_dict = {}\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n    \n    # Build the result list with elements that occur only once\n    result = []\n    for number in numbers:\n        if count_dict[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    :param numbers: List of integers.\n    :return: List of integers with duplicates removed.\n    \"\"\"\n    # Track the count of each number\n    count_dict = {}\n    for number in numbers:\n        count_dict[number] = count_dict.get(number, 0) + 1\n    \n    # Filter out numbers that occur more than once\n    result = [number for number in numbers if count_dict[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n\n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Track the count of each element\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out elements that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the frequency of each number\n    frequency = {}\n    for num in numbers:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if frequency[num] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    Example:\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Track the occurrence of each number\n    count = {}\n    for number in numbers:\n        if number in count:\n            count[number] += 1\n        else:\n            count[number] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [number for number in numbers if count[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    :param numbers: List of integers.\n    :return: A new list with duplicates removed.\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for number in numbers:\n        if number in seen:\n            duplicates.add(number)\n        else:\n            seen.add(number)\n\n    for number in numbers:\n        if number not in duplicates:\n            result.append(number)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \n    :param numbers: List of integers.\n    :return: List of integers with duplicates removed.\n    \"\"\"\n    # Track the count of each number\n    count_map = {}\n    for number in numbers:\n        if number in count_map:\n            count_map[number] += 1\n        else:\n            count_map[number] = 1\n    \n    # Build the result list with only numbers that appear once\n    result = [number for number in numbers if count_map[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    duplicates = set()\n    result = []\n\n    for num in numbers:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n\n    for num in numbers:\n        if num not in duplicates:\n            result.append(num)\n\n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n    \n    # Filter out numbers that occur more than once and maintain the order\n    result = [number for number in numbers if count_dict[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n    \n    # Create a list to store the result, only adding numbers that occur once\n    result = []\n    for number in numbers:\n        if count_dict[number] == 1:\n            result.append(number)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    \"\"\"\n    # Track the occurrence of each number\n    count_map = {}\n    for number in numbers:\n        if number in count_map:\n            count_map[number] += 1\n        else:\n            count_map[number] = 1\n\n    # Filter out numbers that occur more than once, preserving order\n    result = [number for number in numbers if count_map[number] == 1]\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/31": {"dps": 97.46835443037975, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}, {"solution": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True", "matching_cluster_idx": 6}]}, "HumanEval/33": {"dps": 97.22222222222223, "dps_norm": 81.81818181818181, "pass@1": 27.0, "profiled": [{"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three (0-based indexing)\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3) == 0]\n    \n    # Sort the extracted elements\n    divisible_by_three.sort()\n    \n    # Create a new list with the sorted elements at the correct positions\n    l_prime = l.copy()\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three (0-based)\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3) == 0]\n    \n    # Sort the extracted elements\n    divisible_by_three_sorted = sorted(divisible_by_three)\n    \n    # Create a new list with the sorted elements at the correct positions\n    l_prime = l.copy()\n    for i, value in enumerate(divisible_by_three_sorted):\n        l_prime[i * 3] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list l' that is a copy of l\n    l_prime = l[:]\n    \n    # Replace elements at indices divisible by 3 with the sorted values\n    for i, value in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    elements_at_divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort these elements\n    sorted_elements = sorted(elements_at_divisible_by_three)\n    \n    # Create a new list with the sorted elements placed back in their original positions\n    result = l.copy()\n    sorted_index = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            result[i] = sorted_elements[sorted_index]\n            sorted_index += 1\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    l_prime = []\n    \n    # Counter for the sorted elements\n    sorted_index = 0\n    \n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(sorted_divisible_by_three[sorted_index])\n            sorted_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Replace elements in the original list with the sorted elements\n    l_prime = l[:]\n    for i, value in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3) == 0]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list with the sorted elements at the correct positions\n    result = l.copy()\n    for i, value in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3 and sort them\n    divisible_by_three = sorted([l[i] for i in range(0, len(l), 3)])\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Create a new list to store the result\n    l_prime = []\n    \n    # Index for the sorted third elements\n    sorted_index = 0\n    \n    for i in range(len(l)):\n        if i % 3 == 0:\n            l_prime.append(sorted_third_elements[sorted_index])\n            sorted_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    divisible_by_three_sorted = sorted(divisible_by_three)\n    \n    # Create a new list to store the result\n    result = l.copy()\n    \n    # Replace elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), divisible_by_three_sorted):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create the new list l' with the same elements as l\n    l_prime = l.copy()\n    \n    # Replace elements at indices divisible by 3 with the sorted elements\n    sorted_index = 0\n    for i in range(len(l_prime)):\n        if i % 3 == 0:\n            l_prime[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three (including index 0)\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    divisible_by_three_sorted = sorted(divisible_by_three)\n    \n    # Create a new list with the sorted elements placed back at the correct indices\n    l_prime = l.copy()\n    for i, value in enumerate(divisible_by_three_sorted):\n        l_prime[i * 3] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    indices_div_by_three = [i for i in range(len(l)) if (i % 3 == 0)]\n    elements_div_by_three = [l[i] for i in indices_div_by_three]\n    \n    # Sort the extracted elements\n    sorted_elements = sorted(elements_div_by_three)\n    \n    # Create a new list with the sorted elements placed back\n    l_prime = l.copy()\n    for idx, value in zip(indices_div_by_three, sorted_elements):\n        l_prime[idx] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract the elements at indices divisible by three\n    indices_div_by_three = [i for i in range(len(l)) if (i % 3) == 0]\n    elements_div_by_three = [l[i] for i in indices_div_by_three]\n    \n    # Sort the extracted elements\n    elements_div_by_three_sorted = sorted(elements_div_by_three)\n    \n    # Create a new list with the sorted elements in the correct positions\n    l_prime = l.copy()\n    for i, idx in enumerate(indices_div_by_three):\n        l_prime[idx] = elements_div_by_three_sorted[i]\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create the new list with sorted elements at the correct positions\n    result = l[:]\n    for i, val in enumerate(sorted_divisible_by_three):\n        result[3 * i] = val\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list l' with the same elements as l\n    l_prime = l[:]\n    \n    # Replace elements at indices divisible by 3 with the sorted elements\n    for i, value in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indices that are not divisible by three, while its values at the indices that are divisible by three are equal\n    to the values of the corresponding indices of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create the new list l'\n    l_prime = l.copy()\n    \n    # Replace elements at indices divisible by 3 with sorted elements\n    for i, value in zip(range(0, len(l), 3), sorted_divisible_by_three):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_elements = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_third_elements = sorted(third_elements)\n    \n    # Create a new list with the sorted elements in the correct positions\n    l_prime = l.copy()\n    for i, value in zip(range(0, len(l), 3), sorted_third_elements):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \n    :param l: List of elements\n    :return: Modified list according to the problem description\n    \n    Examples:\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(len(l)) if (i % 3 == 0)]\n    \n    # Sort the extracted elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Replace elements in the original list with sorted elements at indices divisible by 3\n    j = 0\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l[i] = sorted_divisible_by_three[j]\n            j += 1\n    \n    return l", "matching_cluster_idx": 8}, {"solution": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    \"\"\"\n    # Extract elements at indices divisible by three\n    third_indices = [i for i in range(len(l)) if (i % 3 == 0)]\n    third_elements = [l[i] for i in third_indices]\n    \n    # Sort the extracted elements\n    third_elements_sorted = sorted(third_elements)\n    \n    # Create a new list with the sorted elements at the correct positions\n    l_prime = l.copy()\n    for idx, value in zip(third_indices, third_elements_sorted):\n        l_prime[idx] = value\n    \n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/34": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert it back to a sorted list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Use set to remove duplicates and then convert back to list\n    unique_set = set(l)\n    # Sort the unique elements\n    unique_sorted_list = sorted(unique_set)\n    return unique_sorted_list", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a sorted list\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Convert the list to a set to remove duplicates, then convert back to a list and sort it\n    return sorted(set(l))", "matching_cluster_idx": 4}, {"solution": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "matching_cluster_idx": 4}]}, "HumanEval/36": {"dps": 96.77419354838709, "dps_norm": 71.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (non-inclusive).\n    :return: The count of digit 7 appearances.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (exclusive) to check for numbers.\n    :return: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (non-inclusive) to check for numbers.\n    :return: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (exclusive) for checking the numbers.\n    :return: The count of the digit 7 in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (non-inclusive).\n    :return: The count of digit 7 appearances.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (non-inclusive) for checking numbers.\n    :return: The count of the digit 7 in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: An integer specifying the upper limit (exclusive).\n    :return: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (exclusive) to check for numbers.\n    :return: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (exclusive) to check for numbers.\n    :return: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (non-inclusive) to check for numbers divisible by 11 or 13.\n    :return: The count of digit 7 appearances in numbers less than n that are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \n    :param n: The upper limit (exclusive) for checking numbers.\n    :return: The count of digit 7 appearances in numbers less than n and divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}, {"solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/37": {"dps": 95.18003273322422, "dps_norm": 90.5, "pass@1": 100.0, "profiled": [{"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Create the result list\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-index elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-index elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create the new list with sorted even indices\n    result = l[:]\n    for i, value in zip(range(0, len(l), 2), even_elements_sorted):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Reconstruct the list with sorted even-indexed elements\n    l_prime = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_elements[even_index])\n            even_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices values and sort them\n    even_indices_values = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create the new list with the sorted even indices values and the original odd indices values\n    l_prime = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices_values[even_index])\n            even_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the even indices elements and sort them\n    even_indices_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create a new list to hold the sorted result\n    sorted_list = []\n    \n    # Iterate over the original list and place elements in the new list\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Place the sorted even index element\n            sorted_list.append(even_indices_elements[even_index])\n            even_index += 1\n        else:\n            # Place the original odd index element\n            sorted_list.append(l[i])\n    \n    return sorted_list", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = l[::2]\n    \n    # Sort the even-indexed elements\n    sorted_even_indices = sorted(even_indices)\n    \n    # Create the result list with the same length as the original list\n    result = l[:]\n    \n    # Replace the even-indexed elements with the sorted ones\n    for i, value in enumerate(sorted_even_indices):\n        result[2 * i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract the elements at even indices\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a new list to store the result\n    result = []\n    \n    # Counter for the sorted even elements\n    even_counter = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            # Append the next sorted even element\n            result.append(even_elements_sorted[even_counter])\n            even_counter += 1\n        else:\n            # Append the original odd element\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices and sort them\n    even_indices = [l[i] for i in range(len(l)) if i % 2 == 0]\n    even_indices_sorted = sorted(even_indices)\n    \n    # Create a new list to store the result\n    result = []\n    even_index = 0\n    \n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_indices_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)])\n    \n    # Create the new list with sorted even-indexed elements\n    result = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list to store the result\n    l_prime = []\n    \n    # Iterate through the original list and build the new list\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_elements[even_index])\n            even_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices values and sort them\n    even_indices_values = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list with the same length as the original\n    result = l[:]\n    \n    # Replace even indices in the result list with the sorted values\n    for i, value in zip(range(0, len(result), 2), even_indices_values):\n        result[i] = value\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create the new list with sorted even-indexed elements\n    l_prime = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_elements_sorted[even_idx])\n            even_idx += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    even_values = [l[i] for i in even_indices]\n    \n    # Sort the even-indexed elements\n    even_values_sorted = sorted(even_values)\n    \n    # Create the new list with sorted even-indexed elements\n    l_prime = l.copy()\n    for idx, value in zip(even_indices, even_values_sorted):\n        l_prime[idx] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices and sort them\n    even_indices_values = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Create a new list to store the result\n    l_prime = l.copy()\n    \n    # Replace even indices in l_prime with sorted values\n    for i, value in zip(range(0, len(l), 2), even_indices_values):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-index elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Alternate between even and odd index elements\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices and sort them\n    even_indices = [l[i] for i in range(0, len(l), 2)]\n    even_indices_sorted = sorted(even_indices)\n    \n    # Create a new list with sorted even indices and original odd indices\n    l_prime = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices_sorted[even_idx])\n            even_idx += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-index elements and sort them\n    even_elements = sorted(l[::2])\n    \n    # Reconstruct the list with sorted even-index elements\n    l_prime = []\n    even_idx = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_elements[even_idx])\n            even_idx += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements\n    even_elements = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even-indexed elements\n    even_elements_sorted = sorted(even_elements)\n    \n    # Create a new list to hold the result\n    result = []\n    \n    # Reconstruct the list with sorted even-indexed elements\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements_sorted[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[::2])\n    # Create the result list with the same length as the input list\n    result = [None] * len(l)\n    # Place the sorted even-indexed elements back into the result list\n    result[::2] = even_elements\n    # Place the odd-indexed elements from the original list into the result list\n    result[1::2] = l[1::2]\n    return result", "matching_cluster_idx": 9}, {"solution": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract even indices\n    even_indices = [i for i in range(len(l)) if i % 2 == 0]\n    # Extract the values at even indices and sort them\n    even_values_sorted = sorted([l[i] for i in even_indices])\n    \n    # Create the new list with sorted even indices\n    l_prime = l.copy()\n    for i, value in zip(even_indices, even_values_sorted):\n        l_prime[i] = value\n    \n    return l_prime", "matching_cluster_idx": 8}]}, "HumanEval/49": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Efficiently compute 2^n modulo p using modular exponentiation\n    result = pow(2, n, p)\n    return result", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\"\"\"\n    # Use the built-in pow function with three arguments to efficiently compute (2^n) % p\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Parameters:\n    n (int): The exponent to raise 2 by.\n    p (int): The modulus.\n    \n    Returns:\n    int: The result of (2^n) % p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Efficiently compute 2^n modulo p using Python's built-in pow function\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Args:\n    n (int): The exponent to raise 2 by.\n    p (int): The modulus.\n    \n    Returns:\n    int: The result of 2^n modulo p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Parameters:\n    n (int): The exponent to which 2 is raised.\n    p (int): The modulus.\n    \n    Returns:\n    int: The result of 2^n modulo p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Efficiently compute 2^n modulo p using the pow function\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    :param n: The exponent to which 2 is raised.\n    :param p: The modulus.\n    :return: The result of (2^n) % p.\n    \"\"\"\n    # Using pow with three arguments to efficiently compute (2^n) % p\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    :param n: The exponent to which 2 is raised.\n    :param p: The modulus.\n    :return: The result of 2^n modulo p.\n    \"\"\"\n    # Using Python's built-in pow function for efficient modular exponentiation\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    # Using pow for efficient modular exponentiation\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Parameters:\n    n (int): The exponent.\n    p (int): The modulus.\n    \n    Returns:\n    int: The result of 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    :param n: Exponent to which 2 is raised.\n    :param p: Modulus.\n    :return: Result of (2^n) % p.\n    \"\"\"\n    # Using pow function for better performance and handling large numbers\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    :param n: Exponent to which 2 is raised.\n    :param p: Modulus.\n    :return: 2^n modulo p.\n    \n    Examples:\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    :param n: Exponent to which 2 is raised.\n    :param p: Modulus.\n    :return: 2^n modulo p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}, {"solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p.\n    \n    This function computes 2 raised to the power of n, then takes the result modulo p.\n    It handles large numbers efficiently using Python's built-in pow function with three arguments.\n    \n    Args:\n        n (int): The exponent to which 2 is raised.\n        p (int): The modulus.\n    \n    Returns:\n        int: The result of (2^n) % p.\n    \"\"\"\n    return pow(2, n, p)", "matching_cluster_idx": 4}]}, "HumanEval/51": {"dps": 96.13526570048309, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "import doctest\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\\\nghijklm\")\n    'bcdf\\\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}, {"solution": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "matching_cluster_idx": 5}]}, "HumanEval/54": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to compare the unique characters\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets of characters to remove duplicates and check if they are equal\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create a set of characters for each string\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets of characters to compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets of characters and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to compare unique characters\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to remove duplicate characters and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create sets of characters from both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    return set_s0 == set_s1", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create sets from the strings to remove duplicates and compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert both strings to sets to compare unique characters\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Create sets of characters from both strings\n    set_s0 = set(s0)\n    set_s1 = set(s1)\n    \n    # Check if the sets are equal\n    if set_s0 == set_s1:\n        return True\n    else:\n        return False", "matching_cluster_idx": 6}, {"solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    \"\"\"\n    # Convert strings to sets to remove duplicates and then compare\n    return set(s0) == set(s1)", "matching_cluster_idx": 6}]}, "HumanEval/58": {"dps": 92.51968503937007, "dps_norm": 83.33333333333333, "pass@1": 100.0, "profiled": [{"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert the lists to sets to remove duplicates and find the intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find the intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert the lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find unique elements and then find intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert the lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set back to a sorted list\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Convert lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find intersection of the two sets\n    common_elements = set1 & set2\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to remove duplicates and find intersection\n    common_elements = set(l1).intersection(set(l2))\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    \n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find intersection\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = set1 & set2\n    \n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find unique elements and then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    \n    :param l1: First list of elements.\n    :param l2: Second list of elements.\n    :return: A sorted list of unique common elements.\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and find common elements\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert lists to sets to find unique elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements back to a sorted list\n    return sorted(common_elements)", "matching_cluster_idx": 4}, {"solution": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Convert both lists to sets to remove duplicates and then find the intersection\n    common_elements = set(l1) & set(l2)\n    # Return the sorted list of common elements\n    return sorted(list(common_elements))", "matching_cluster_idx": 4}]}, "HumanEval/59": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    Args:\n    n (int): The number to find the largest prime factor of.\n    \n    Returns:\n    int: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime number.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime number.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n            factor += 1\n        else:\n            factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime number.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime number.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: The number to find the largest prime factor of.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n            factor += 1\n        else:\n            factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime number.\n    :return: The largest prime factor of n.\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    \n    # Divide n by 2 as many times as possible\n    while n % factor == 0:\n        last_factor = factor\n        n //= factor\n    \n    # Move to the next potential factors\n    factor = 3\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 2\n    \n    # If n is not 1 by now, it must be a prime number greater than the last factor found\n    if n > 1:\n        last_factor = n\n    \n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n            if factor * factor > n:\n                if n > 1:\n                    last_factor = n\n                break\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    # Initialize the smallest prime factor\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n    if n > 1:\n        last_factor = n\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n            factor = 2\n        else:\n            factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n            factor += 1\n        else:\n            factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n        else:\n            factor += 1\n    return last_factor", "matching_cluster_idx": 8}, {"solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    \n    :param n: An integer greater than 1 and not a prime.\n    :return: The largest prime factor of n.\n    \"\"\"\n    factor = 2\n    last_factor = 1\n    while n > 1:\n        if n % factor == 0:\n            last_factor = factor\n            n //= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return last_factor", "matching_cluster_idx": 8}]}, "HumanEval/64": {"dps": 92.20779220779221, "dps_norm": 62.5, "pass@1": 98.0, "profiled": [{"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert to lowercase to handle uppercase letters\n\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to simplify the checks\n    s = s.lower()\n    # Define the vowels\n    vowels = \"aeiou\"\n    count = 0\n    \n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' and add it to the count if it is\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to simplify the comparison\n    s = s.lower()\n    # Define the vowels\n    vowels = \"aeiou\"\n    # Initialize the count of vowels\n    count = 0\n    # Iterate over the characters in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    # Check if the last character is 'y' and add to the count if true\n    if s.endswith('y'):\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to handle both uppercase and lowercase inputs\n    s = s.lower()\n    # Define the set of vowels\n    vowels = set('aeiou')\n    # Initialize the count of vowels\n    count = 0\n\n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if the last character is 'y' and add to count if true\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert to lowercase to simplify checks\n\n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to make the function case-insensitive\n    s = s.lower()\n    \n    # Define the vowels and initialize the count\n    vowels = \"aeiou\"\n    count = 0\n    \n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' and add to the count if true\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to handle both uppercase and lowercase letters\n    s = s.lower()\n    # Define the vowels and a variable to count them\n    vowels = 'aeiou'\n    count = 0\n    \n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the string and add to the count if true\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = sum(1 for char in s if char in vowels)\n    \n    # Check if the last character is 'y' or 'Y'\n    if s and s[-1] in \"yY\":\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s_lower = s.lower()\n\n    for char in s_lower:\n        if char in vowels:\n            count += 1\n\n    if s_lower.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiou\"\n    count = 0\n    s = s.lower()  # Convert the string to lowercase to simplify checks\n\n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    # Check if the last character is 'y'\n    if s.endswith('y'):\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Convert the string to lowercase to handle both uppercase and lowercase letters\n    s = s.lower()\n    # Define the vowels and a variable to count them\n    vowels = 'aeiou'\n    count = 0\n    \n    # Count the vowels in the string\n    for char in s:\n        if char in vowels:\n            count += 1\n    \n    # Check if the last character is 'y' and add to count if it is\n    if s.endswith('y'):\n        count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiou'\n    count = 0\n    s = s.lower()  # Convert to lowercase to handle both uppercase and lowercase letters\n\n    for char in s:\n        if char in vowels:\n            count += 1\n\n    if s and s[-1] == 'y':  # Check if the last character is 'y'\n        count += 1\n\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in 'yY':\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1] in \"yY\":\n        count += 1\n    return count", "matching_cluster_idx": 4}]}, "HumanEval/74": {"dps": 98.04878048780488, "dps_norm": 88.88888888888889, "pass@1": 100.0, "profiled": [{"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or the first list if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    len1 = sum(len(s) for s in lst1)\n    len2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer characters, or the first list if they are equal\n    return lst1 if len1 <= len2 else lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n\n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['4']\n    '''\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer characters, or the first list if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}, {"solution": "def total_match(lst1, lst2):\n    # Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Return the list with fewer total characters, or the first list if they are equal\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "matching_cluster_idx": 7}]}, "HumanEval/85": {"dps": 91.01485148514851, "dps_norm": 59.16666666666667, "pass@1": 100.0, "profiled": [{"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to zero\n    result = 0\n    \n    # Iterate over the list, checking only odd indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            result += lst[i]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    result = 0\n    \n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            result += lst[i]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate through the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the total\n            total += lst[i]\n    \n    return total", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and increment by 2 to check odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            result += lst[i]\n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    result = 0\n    \n    # Iterate through the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            result += value\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    even_sum = 0\n    \n    # Iterate over the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            even_sum += value\n    \n    return even_sum", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            result += lst[i]\n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. Add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            result += lst[i]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate through the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the total\n            total += value\n    \n    return total", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate over the list using enumerate to get both index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            result += value\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current index is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the result\n            result += lst[i]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize a variable to store the sum of even elements at odd indices\n    result = 0\n\n    # Iterate over the list with both index and value using enumerate\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            # Add the value to the result\n            result += value\n\n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to zero\n    result = 0\n    \n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current index is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the result\n            result += lst[i]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    result = 0\n    for i in range(1, len(lst), 2):  # Start from index 1 and step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if the element at the odd index is even\n            result += lst[i]\n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum of even elements at odd indices\n    even_sum = 0\n    \n    # Iterate through the list, starting from the first odd index (1) and increment by 2\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current index is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the sum\n            even_sum += lst[i]\n    \n    return even_sum", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to zero\n    result = 0\n    \n    # Iterate over the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            result += value\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst. add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate over the list, but only consider elements at odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current index is even\n        if lst[i] % 2 == 0:\n            # Add the even element to the result\n            result += lst[i]\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to zero\n    result = 0\n    \n    # Iterate over the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            result += value\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n    \n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate through the list with index\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            result += value\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2\n    \"\"\"\n    # Initialize the sum to 0\n    result = 0\n    \n    # Iterate over the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is odd and the value is even\n        if index % 2 != 0 and value % 2 == 0:\n            result += value\n    \n    return result", "matching_cluster_idx": 2}]}, "HumanEval/86": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 16.0, "profiled": [{"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string with spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word\n    ordered_words = []\n    for word in words:\n        # Sort the characters in the word\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    # Join the ordered words back into a string\n    result = ' '.join(ordered_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a single string\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Sort each word's characters and join them back together\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the processed words back into a string\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the processed words back into a single string\n    result = ' '.join(ordered_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving the original spaces\n    words = s.split(' ')\n    # Sort the characters of each word\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back together with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    # Sort each word's characters and rejoin them\n    sorted_words = [''.join(sorted(word)) for word in words]\n    # Join the sorted words back into a string with spaces\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Sort the characters in each word and join them back\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string with spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Sort the characters in each word and join them back\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string with spaces\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_words = []\n    for word in words:\n        # Sort the characters in the word\n        sorted_word = ''.join(sorted(word))\n        ordered_words.append(sorted_word)\n    \n    # Join the ordered words back into a string, preserving the original spaces\n    result = ' '.join(ordered_words)\n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words while preserving spaces\n    words = s.split(' ')\n    \n    # Sort the characters in each word and join them back\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the sorted words back into a string\n    result = ' '.join(sorted_words)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    sorted_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the processed words back into a string\n    return ' '.join(sorted_words)", "matching_cluster_idx": 4}, {"solution": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    # Split the string into words and spaces\n    words = s.split(' ')\n    \n    # Process each word to sort its characters\n    ordered_words = [''.join(sorted(word)) for word in words]\n    \n    # Join the processed words back together\n    return ' '.join(ordered_words)", "matching_cluster_idx": 4}]}, "HumanEval/87": {"dps": 93.94812680115274, "dps_norm": 57.142857142857146, "pass@1": 97.0, "profiled": [{"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the occurrences of an integer x in a 2D list and returns their coordinates.\n    The coordinates are sorted by rows in ascending order and by columns in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list with both index and row\n    for row_idx, row in enumerate(lst):\n        # Find the occurrences of x in the current row and store their column indices\n        col_indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        col_indices.sort(reverse=True)\n        # Add the coordinates to the list\n        coordinates.extend([(row_idx, col_idx) for col_idx in col_indices])\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of x in a 2D list and returns a list of tuples\n    representing their coordinates. The coordinates are sorted by rows in\n    ascending order and by columns in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate through each row and its index\n    for row_idx, row in enumerate(lst):\n        # Find the occurrences of x in the current row and store their indices\n        col_indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Sort the column indices in descending order\n        col_indices.sort(reverse=True)\n        # Append the (row, column) tuples to the coordinates list\n        for col_idx in col_indices:\n            coordinates.append((row_idx, col_idx))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in the given 2D list and returns a list of tuples representing\n    the coordinates (row, column) of each occurrence of x. The coordinates are sorted\n    by rows in ascending order and by columns in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n\n    # Iterate through each row in the list\n    for row_idx, row in enumerate(lst):\n        # Iterate through each element in the row\n        for col_idx, value in enumerate(row):\n            # If the value matches x, add the coordinate to the list\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n\n    # Sort the coordinates by row in ascending order, and by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in a 2D list (matrix) where each row can have a different number of columns.\n    Returns a list of tuples representing the coordinates (row, column) of x, sorted by row in ascending\n    order and by column in descending order within each row.\n    \n    :param lst: List of lists representing the 2D data structure.\n    :param x: The integer to find in the 2D list.\n    :return: List of tuples with the coordinates of x.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order and then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of x in a 2D list and returns a list of tuples\n    with coordinates sorted by row in ascending order and columns in descending order.\n    \"\"\"\n    coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by row in ascending order, then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Find occurrences of integer x in the 2D list lst and return a list of tuples representing the coordinates.\n    Each tuple is (row, column), with both row and column indices starting from 0.\n    The result is sorted by rows in ascending order, and by columns in descending order within each row.\n    \n    :param lst: List of lists representing the 2D data.\n    :param x: Integer to find in the 2D list.\n    :return: List of tuples (row, column) for each occurrence of x.\n    \"\"\"\n    result = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                result.append((i, j))\n    \n    # Sort by row in ascending order, and by column in descending order within each row\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in the nested list lst and returns a list of tuples representing\n    the coordinates (row, column) of x. The coordinates are sorted by rows in ascending order,\n    and within each row, by columns in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list with enumerate to get both index and row\n    for row_index, row in enumerate(lst):\n        # For each row, find the columns where the value equals x\n        for col_index in range(len(row)):\n            if row[col_index] == x:\n                # Append the (row, column) tuple to the coordinates list\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates first by row in ascending order, then by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in a 2D list (lst) and returns the coordinates\n    of all occurrences of x, sorted by row in ascending order and\n    by column in descending order within each row.\n    \n    Parameters:\n    lst (list of list of int): The 2D list to search.\n    x (int): The integer to find in the list.\n    \n    Returns:\n    list of tuples: A list of coordinates (row, column) where x is found.\n    \"\"\"\n    result = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                result.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order\n    result.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of an integer x in a 2D list and returns a list of tuples\n    representing the coordinates (row, column) of each occurrence. The coordinates\n    are sorted first by row in ascending order, and then by column in descending order\n    within each row.\n    \n    :param lst: List of lists representing the 2D data.\n    :param x: The integer to find in the 2D list.\n    :return: A list of tuples (row, column) for each occurrence of x.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, and then by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in a 2D list and returns the coordinates of x in a list of tuples.\n    Each tuple represents the (row, column) of the found element, with sorting as specified.\n    \n    :param lst: List of lists representing the 2D data.\n    :param x: Integer to find in the 2D list.\n    :return: List of tuples with coordinates of x, sorted by rows (ascending) and columns (descending).\n    \"\"\"\n    # Find all occurrences of x and store their coordinates\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order, and by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of an integer x in a 2D list and returns their coordinates.\n    Coordinates are sorted by rows in ascending order and by columns in descending order within the same row.\n    \n    :param lst: List of lists representing the 2D data.\n    :param x: The integer to find in the 2D list.\n    :return: A list of tuples, where each tuple is a coordinate (row, column).\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row in ascending order, then by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \"\"\"\n    # Find all occurrences of x and store their coordinates\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order, and by column in descending order within the same row\n    sorted_coordinates = sorted(coordinates, key=lambda coord: (coord[0], -coord[1]))\n    \n    return sorted_coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate through the list to find the occurrences of x\n    for row_index, row in enumerate(lst):\n        # Find all occurrences of x in the current row\n        for col_index in reversed(range(len(row))):\n            if row[col_index] == x:\n                coordinates.append((row_index, col_index))\n    \n    # Sort the coordinates by row in ascending order and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in the 2D list lst and returns a list of tuples representing\n    the coordinates (row, column) of x, sorted by row in ascending order and by column\n    in descending order within each row.\n    \"\"\"\n    # Find all occurrences of x and store their coordinates\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort coordinates by row in ascending order and by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in the 2D list and returns a list of tuples representing the coordinates.\n    The coordinates are sorted by row in ascending order, and by column in descending order within each row.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over each row in the list\n    for row_idx, row in enumerate(lst):\n        # Find the columns where the value is x and store the coordinates\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order, and by column in descending order within each row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds the integer x in a 2D list (lst) and returns a list of tuples representing the coordinates of x.\n    The coordinates are sorted by rows in ascending order, and by columns in descending order within the same row.\n    \n    :param lst: List of lists, representing the 2D data structure.\n    :param x: Integer to find in the 2D list.\n    :return: List of tuples, where each tuple is (row, column) of the found integer.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the rows and columns of the 2D list\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                # Append the coordinate as a tuple (row, column)\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order, and by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds occurrences of an integer x in a 2D list and returns a list of tuples\n    representing the coordinates of x, sorted by row in ascending order and by\n    column in descending order within each row.\n    \n    :param lst: 2D list of integers\n    :param x: Integer to find in the list\n    :return: List of tuples (row, column) of x's positions\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of x in the current row and append their coordinates\n        for col_idx in range(len(row) - 1, -1, -1):\n            if row[col_idx] == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order and by column in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds occurrences of integer x in the 2D list lst and returns a list of tuples\n    representing the coordinates (row, column) of each occurrence. The coordinates\n    are sorted by rows in ascending order and by columns in descending order within\n    each row.\n    \n    :param lst: List of lists, where each inner list represents a row.\n    :param x: Integer to search for in the 2D list.\n    :return: List of tuples (row, column) indicating the positions of x.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate through each row and its index\n    for row_idx, row in enumerate(lst):\n        # Find all occurrences of x in the current row and store their indices\n        col_indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Add the coordinates (row_idx, col_idx) to the coordinates list\n        # Sort the column indices in descending order before adding\n        for col_idx in sorted(col_indices, reverse=True):\n            coordinates.append((row_idx, col_idx))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list to find occurrences of x\n    for row_idx, row in enumerate(lst):\n        # Find all columns where x appears in the current row\n        col_indices = [col_idx for col_idx, value in enumerate(row) if value == x]\n        # Add the coordinates to the list, sorting columns in descending order\n        coordinates.extend((row_idx, col_idx) for col_idx in sorted(col_indices, reverse=True))\n    \n    # Sort the coordinates by rows in ascending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}, {"solution": "def get_row(lst, x):\n    \"\"\"\n    Finds all occurrences of x in the 2D list lst and returns a list of tuples\n    where each tuple represents the coordinates (row, column) of the occurrences.\n    The rows are sorted in ascending order, and the columns in each row are sorted\n    in descending order.\n    \"\"\"\n    # Initialize an empty list to store the coordinates\n    coordinates = []\n    \n    # Iterate over the list to find all occurrences of x\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                # Append the coordinates as a tuple\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort the coordinates by row in ascending order\n    # and by column in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "matching_cluster_idx": 3}]}, "HumanEval/89": {"dps": 97.07474226804125, "dps_norm": 46.42857142857143, "pass@1": 100.0, "profiled": [{"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shift by 4 places).\n    \"\"\"\n    # Define the alphabet and the shifted alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, shifted_alphabet)\n    \n    # Encrypt the string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 6}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    # Define the alphabet and the shift amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    encrypted = ''\n\n    # Loop through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the current position of the character in the alphabet\n            index = alphabet.index(char)\n            # Calculate the new position with the shift\n            new_index = (index + shift) % 26\n            # Append the new character to the encrypted string\n            encrypted += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, leave it unchanged\n            encrypted += char\n\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    # Define the alphabet and the shift amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    encrypted = ''\n    \n    # Loop through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the index of the character in the alphabet\n            index = alphabet.index(char)\n            # Calculate the new index after the shift\n            new_index = (index + shift) % 26\n            # Append the new character to the encrypted string\n            encrypted += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, leave it unchanged\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet such that each letter\n    is shifted down by four places (2 * 2).\n    \n    :param s: The input string to be encrypted.\n    :return: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the encrypted alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    encrypted_alphabet = alphabet[shift:] + alphabet[:shift]\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, encrypted_alphabet)\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each letter down by 2 * 2 = 4 places in the alphabet.\n    \n    Parameters:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the shift amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    \n    # Initialize the encrypted string\n    encrypted_string = ''\n    \n    # Loop through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the new position with the shift, wrapping around the alphabet\n            new_index = (alphabet.index(char) + shift) % 26\n            encrypted_string += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, leave it as is\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by rotating the alphabet such that each letter\n    shifts down by 4 places (2 * 2).\n    \n    Parameters:\n    s (str): The string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the encrypted alphabet with a shift of 4\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shifted_alphabet = alphabet[4:] + alphabet[:4]\n    \n    # Create a translation table for the encryption\n    translation_table = str.maketrans(alphabet, shifted_alphabet)\n    \n    # Encrypt the string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., shift by 4 places).\n    \"\"\"\n    # Define the alphabet and the shifted alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, shifted_alphabet)\n    \n    # Translate the input string using the translation table\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each letter down by 2 * 2 = 4 places in the alphabet.\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the shift amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    \n    # Create a dictionary to map each letter to its shifted counterpart\n    shift_map = {char: alphabet[(i + shift) % 26] for i, char in enumerate(alphabet)}\n    \n    # Encrypt the input string\n    encrypted = ''.join(shift_map.get(char, char) for char in s)\n    \n    return encrypted", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each letter down the alphabet by 2*2 (4 places).\n    \n    Parameters:\n    s (str): The input string to encrypt.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the shift amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    \n    # Initialize the result string\n    encrypted = ''\n    \n    # Loop through each character in the input string\n    for char in s:\n        # Check if the character is a lowercase letter\n        if char in alphabet:\n            # Find the new position by adding the shift and wrapping around the alphabet\n            new_index = (alphabet.index(char) + shift) % 26\n            encrypted += alphabet[new_index]\n        else:\n            # If the character is not a letter, keep it as is\n            encrypted += char\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    # Define the alphabet and the shifted alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2  # The shift is 4 places\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    \n    # Encrypt the string by mapping each character to its shifted counterpart\n    encrypted = ''.join([shifted_alphabet[alphabet.index(c)] if c in alphabet else c for c in s])\n    \n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each letter down by 4 places in the alphabet.\n    Wraps around if the shift goes beyond 'z'.\n    \n    :param s: The string to be encrypted.\n    :return: The encrypted string.\n    \"\"\"\n    # Define the alphabet and the shift amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2  # Shift by 4 places\n    \n    # Create a shifted version of the alphabet\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    \n    # Create a dictionary for the mapping from original to shifted characters\n    encryption_dict = {char: shifted_char for char, shifted_char in zip(alphabet, shifted_alphabet)}\n    \n    # Encrypt the input string\n    encrypted_string = ''.join(encryption_dict.get(char, char) for char in s)\n    \n    return encrypted_string", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each letter down by 4 places in the alphabet.\n    \n    :param s: The string to be encrypted.\n    :return: The encrypted string.\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_string = ''\n    \n    for char in s:\n        if char in alphabet:\n            # Find the index of the character in the alphabet\n            index = alphabet.index(char)\n            # Shift the index by 4 places and wrap around using modulo\n            new_index = (index + 4) % 26\n            # Append the new character to the encrypted string\n            encrypted_string += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, keep it as is\n            encrypted_string += char\n    \n    return encrypted_string", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet and the shift value\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 4\n    encrypted = ''\n\n    # Iterate through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the current position of the character in the alphabet\n            current_index = alphabet.index(char)\n            # Calculate the new position with the shift, wrapping around if necessary\n            new_index = (current_index + shift) % 26\n            # Append the shifted character to the encrypted string\n            encrypted += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, leave it unchanged\n            encrypted += char\n\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., 4 places).\n    \"\"\"\n    # Define the alphabet and the rotation value\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotation = 2 * 2  # 4 places\n\n    # Initialize the encrypted string\n    encrypted = ''\n\n    # Iterate over each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the new position of the character after rotation\n            new_pos = (alphabet.index(char) + rotation) % 26\n            encrypted += alphabet[new_pos]\n        else:\n            # If the character is not in the alphabet, leave it unchanged\n            encrypted += char\n\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    \"\"\"\n    # Define the alphabet and the shift value\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    shift = 2 * 2  # Shift by 4 places\n\n    # Initialize the result string\n    result = ''\n\n    # Iterate over each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the new position after the shift\n            new_index = (alphabet.index(char) + shift) % 26\n            # Append the shifted character to the result\n            result += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, append it as is\n            result += char\n\n    return result", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the rotation factor\n    rotation = 2 * 2\n    \n    # Define the alphabet and the rotated alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotated_alphabet = alphabet[rotation:] + alphabet[:rotation]\n    \n    # Create a translation table\n    translation_table = str.maketrans(alphabet, rotated_alphabet)\n    \n    # Encrypt the string\n    encrypted_string = s.translate(translation_table)\n    \n    return encrypted_string", "matching_cluster_idx": 5}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts the given string by shifting each letter down by 4 places in the alphabet.\n    \n    :param s: The input string to be encrypted.\n    :return: The encrypted string.\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Create a dictionary to map each letter to its encrypted counterpart\n    shift = 4  # 2 * 2 as specified\n    shifted_alphabet = alphabet[shift:] + alphabet[:shift]\n    encryption_dict = {char: shifted_char for char, shifted_char in zip(alphabet, shifted_alphabet)}\n    \n    # Encrypt the input string\n    encrypted = ''.join(encryption_dict.get(char, char) for char in s)\n    \n    return encrypted", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by rotating the alphabet such that each letter\n    is shifted down by 4 places (2 multiplied by 2).\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    # Define the alphabet\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # Create a dictionary for the encryption mapping\n    encryption_dict = {char: alphabet[(i + 4) % 26] for i, char in enumerate(alphabet)}\n    \n    # Encrypt the string\n    encrypted = ''.join(encryption_dict.get(char, char) for char in s)\n    \n    return encrypted", "matching_cluster_idx": 2}, {"solution": "def encrypt(s):\n    \"\"\"\n    Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places (i.e., 4 places).\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    # Define the alphabet and the rotation amount\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rotation = 4  # 2 * 2\n\n    # Initialize the encrypted string\n    encrypted = ''\n\n    # Iterate through each character in the input string\n    for char in s:\n        if char in alphabet:\n            # Find the index of the character in the alphabet\n            index = alphabet.index(char)\n            # Calculate the new index after rotation\n            new_index = (index + rotation) % 26\n            # Append the new character to the encrypted string\n            encrypted += alphabet[new_index]\n        else:\n            # If the character is not in the alphabet, leave it unchanged\n            encrypted += char\n\n    return encrypted", "matching_cluster_idx": 1}, {"solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a given string by shifting each letter down by four places in the alphabet.\n    \n    Args:\n    s (str): The input string to be encrypted.\n    \n    Returns:\n    str: The encrypted string.\n    \"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            shift = 4  # 2 * 2 as specified\n            if char.islower():\n                start = ord('a')\n                new_char = chr((ord(char) - start + shift) % 26 + start)\n            else:\n                start = ord('A')\n                new_char = chr((ord(char) - start + shift) % 26 + start)\n            result.append(new_char)\n        else:\n            result.append(char)\n    return ''.join(result)", "matching_cluster_idx": 1}]}, "HumanEval/90": {"dps": 58.50194552529183, "dps_norm": 51.666666666666664, "pass@1": 99.0, "profiled": [{"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # If the list has less than 2 elements, return None\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest with None\n    smallest = second_smallest = None\n    \n    for num in lst:\n        if smallest is None or num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num != smallest and (second_smallest is None or num < second_smallest):\n            second_smallest = num\n    \n    return second_smallest", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # If the list has less than 2 elements, return None\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest elements\n    first, second = float('inf'), float('inf')\n    \n    for num in lst:\n        # Update the smallest and second smallest elements\n        if num < first:\n            second, first = first, num\n        elif first < num < second:\n            second = num\n    \n    # If the second smallest element was never updated, return None\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Remove duplicates to ensure we have distinct elements\n    unique_lst = list(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n    \n    # Sort the list to find the second smallest element\n    unique_lst.sort()\n    \n    # Return the second smallest element\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if the list is empty or has less than 2 unique elements\n    if len(lst) < 2 or len(set(lst)) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest elements\n    first, second = float('inf'), float('inf')\n    \n    for num in lst:\n        # Update the first and second smallest elements\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    \n    # Return the second smallest element if found\n    return second if second != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_lst = list(set(lst))\n    if len(unique_lst) < 2:\n        return None\n    \n    unique_lst.sort()\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    # Initialize the smallest and second smallest with infinity\n    smallest = second_smallest = float('inf')\n    \n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n\n    # Check if second_smallest was updated from its initial value\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = set(lst)\n    if len(unique_lst) < 2:\n        return None\n\n    return sorted(unique_lst)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None  # Not enough elements to find the 2nd smallest\n    \n    # Remove duplicates and sort the list\n    unique_lst = sorted(set(lst))\n    \n    # Check if there are at least 2 unique elements\n    if len(unique_lst) < 2:\n        return None  # No 2nd smallest element\n    \n    return unique_lst[1]  # Return the 2nd smallest element", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest with infinity\n    smallest, second_smallest = float('inf'), float('inf')\n    \n    for number in lst:\n        # Update smallest and second smallest accordingly\n        if number < smallest:\n            smallest, second_smallest = number, smallest\n        elif smallest < number < second_smallest:\n            second_smallest = number\n    \n    # If second_smallest is still infinity, it means there was no second smallest element\n    if second_smallest == float('inf'):\n        return None\n    \n    return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest with None\n    smallest = second_smallest = None\n    \n    for num in lst:\n        if smallest is None or num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num != smallest and (second_smallest is None or num < second_smallest):\n            second_smallest = num\n    \n    return second_smallest", "matching_cluster_idx": 4}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest with infinity\n    smallest = second_smallest = float('inf')\n    \n    for num in lst:\n        if num < smallest:\n            smallest, second_smallest = num, smallest\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    # If second_smallest is still infinity, it means there was no second smallest element\n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n\n    unique_lst = set(lst)\n    if len(unique_lst) < 2:\n        return None\n\n    return sorted(unique_lst)[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Use a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_elements) < 2:\n        return None\n    \n    # Convert the set back to a sorted list\n    sorted_elements = sorted(unique_elements)\n    \n    # Return the second smallest element\n    return sorted_elements[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest\n    first, second = float('inf'), float('inf')\n    \n    for num in lst:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    \n    # If second is still infinity, it means there was no second smallest element\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest with max values\n    first, second = float('inf'), float('inf')\n    \n    for number in lst:\n        # Update the smallest and second smallest numbers\n        if number < first:\n            second = first\n            first = number\n        elif first < number < second:\n            second = number\n    \n    # If second smallest is still infinity, it means there was no second smallest number\n    return second if second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if the list has less than 2 unique elements\n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    \n    # Remove the smallest element\n    smallest = min(unique_elements)\n    unique_elements.remove(smallest)\n    \n    # Return the next smallest element\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # Check if the list is empty or has less than 2 unique elements\n    if len(lst) < 2:\n        return None\n\n    # Use a set to remove duplicates and then convert back to a list\n    unique_lst = list(set(lst))\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n\n    # Sort the list to find the 2nd smallest element\n    unique_lst.sort()\n    \n    # Return the 2nd smallest element\n    return unique_lst[1]", "matching_cluster_idx": 6}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    # Initialize the smallest and second smallest\n    first, second = float('inf'), float('inf')\n    \n    for number in lst:\n        if number < first:\n            second = first\n            first = number\n        elif first < number < second:\n            second = number\n    \n    return second if second != first and second != float('inf') else None", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    If the list is empty or all elements are the same, returns None.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_elements = set(lst)\n    if len(unique_elements) < 2:\n        return None\n    \n    unique_elements.remove(min(lst))\n    return min(unique_elements)", "matching_cluster_idx": 5}, {"solution": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    Examples:\n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    # If the list has less than 2 elements, return None\n    if len(lst) < 2:\n        return None\n    \n    # Convert the list to a set to remove duplicates\n    unique_lst = set(lst)\n    \n    # If there are less than 2 unique elements, return None\n    if len(unique_lst) < 2:\n        return None\n    \n    # Find the smallest and second smallest elements\n    smallest = min(unique_lst)\n    unique_lst.remove(smallest)\n    second_smallest = min(unique_lst)\n    \n    return second_smallest", "matching_cluster_idx": 5}]}, "HumanEval/113": {"dps": 98.98580121703854, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    :param lst: List of strings, each string containing only digits\n    :return: List of strings with the number of odd digits replaced in the template\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace the 'i' in the template with the odd_count\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_str)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    output = []\n    for s in lst:\n        count = sum(int(d) % 2 != 0 for d in s)\n        output.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return output", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    Args:\n    lst (list of str): A list of strings, each containing only digits.\n    \n    Returns:\n    list of str: A list of strings as described.\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' in the template string with the count\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3', '11111111'])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        # Replace 'i' in the template string with the odd_count\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    :param lst: List of strings, each string contains only digits\n    :return: List of strings as per the problem statement\n    \"\"\"\n    result = []\n    for item in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in item if int(char) % 2 != 0)\n        # Replace 'i' in the template string with the count of odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(int(d) % 2 != 0 for d in s)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    :param lst: List of strings containing only digits\n    :return: List of strings with the count of odd digits\n    \"\"\"\n    result = []\n    for s in lst:\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    :param lst: List of strings containing only digits\n    :return: List of formatted strings as described\n    \"\"\"\n    result = []\n    for string in lst:\n        count = sum(1 for char in string if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    :param lst: List of strings containing only digits\n    :return: List of strings with the number of odd digits replaced in the template\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        # Replace the 'i's in the template with the odd_count\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \n    Args:\n    lst (list of str): A list of strings, each string consists of only digits.\n    \n    Returns:\n    list of str: A list of strings with the specified format.\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    :param lst: List of strings, each string consists of digits.\n    :return: List of strings with the number of odd digits in each input string.\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' in the template string with the count of odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    :param lst: List of strings, each string containing only digits\n    :return: List of strings with the count of odd digits in each input string\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace the 'i' in the template string with the count of odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for string in lst:\n        odd_count = sum(1 for char in string if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' in the template string with the count of odd digits\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    :param lst: List of strings, each string containing only digits.\n    :return: List of strings with the specified format.\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        # Replace 'i' in the template string with the count of odd digits\n        output_string = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output_string)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    result = []\n    for s in lst:\n        # Count the number of odd digits in the string\n        odd_count = sum(1 for digit in s if int(digit) % 2 != 0)\n        # Replace 'i' with the count of odd digits\n        output = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        result.append(output)\n    return result", "matching_cluster_idx": 3}, {"solution": "def odd_count(lst):\n    \"\"\"\n    Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n    \"\"\"\n    # Define the output list\n    result = []\n    \n    # Iterate over each string in the input list\n    for s in lst:\n        # Count the number of odd digits in the current string\n        odd_count = sum(1 for char in s if int(char) % 2 != 0)\n        \n        # Construct the output string by replacing 'i' with the count of odd digits\n        output_str = f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\"\n        \n        # Append the constructed string to the result list\n        result.append(output_str)\n    \n    return result", "matching_cluster_idx": 3}]}, "HumanEval/119": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 81.0, "profiled": [{"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Function to check if a string of parentheses is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = lst\n    return 'Yes' if is_balanced(s1 + s2) or is_balanced(s2 + s1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Check if concatenating in either order results in a balanced string\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    # Function to check if a string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    first_concat = lst[0] + lst[1]\n    second_concat = lst[1] + lst[0]\n\n    if is_balanced(first_concat) or is_balanced(second_concat):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    return 'Yes' if is_balanced(str1 + str2) or is_balanced(str2 + str1) else 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_balanced(lst[0] + lst[1]):\n        return 'Yes'\n    if is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]):\n        return 'Yes'\n    if is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    # Try concatenating in both possible orders\n    for order in [lst, lst[::-1]]:\n        combined = ''.join(order)\n        balance = 0\n        for char in combined:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                break\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if it is possible to concatenate the two strings in some order\n    so that the resulting string will have balanced parentheses.\n    \n    :param lst: List containing two strings of parentheses\n    :return: 'Yes' if a good string can be formed, 'No' otherwise\n    '''\n    # Unpack the two strings from the list\n    str1, str2 = lst\n    \n    # Check if concatenating in one order results in a balanced string\n    if is_balanced(str1 + str2):\n        return 'Yes'\n    # Check if concatenating in the reverse order results in a balanced string\n    if is_balanced(str2 + str1):\n        return 'Yes'\n    \n    return 'No'\ndef is_balanced(s):\n    '''\n    Helper function to check if a string of parentheses is balanced.\n    \n    :param s: String of parentheses\n    :return: True if the string is balanced, False otherwise\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try concatenating in both possible orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]):\n        return 'Yes'\n    if is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Checks if it is possible to concatenate two strings in some order to form a balanced parentheses string.\n    \n    Parameters:\n    lst (list): A list containing two strings of parentheses.\n    \n    Returns:\n    str: 'Yes' if a balanced string can be formed, 'No' otherwise.\n    '''\n    # Try concatenating in both possible orders\n    for first, second in [(lst[0], lst[1]), (lst[1], lst[0])]:\n        balance = 0\n        # Check if the concatenated string is balanced\n        for char in first + second:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            # If balance goes negative, it means there are more closing parentheses\n            if balance < 0:\n                break\n        # If balance is zero, the string is balanced\n        if balance == 0:\n            return 'Yes'\n    return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Function to check if a string has balanced parentheses\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    first_concat = lst[0] + lst[1]\n    second_concat = lst[1] + lst[0]\n\n    if is_balanced(first_concat) or is_balanced(second_concat):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    Check if it is possible to concatenate two strings in some order to form a good string.\n    A good string is one where all parentheses are balanced.\n    \n    :param lst: List of two strings consisting of '(' and ')' only.\n    :return: 'Yes' if a good string can be formed, 'No' otherwise.\n    '''\n    str1, str2 = lst\n    # Check if concatenating in one order forms a good string\n    if is_balanced(str1 + str2):\n        return 'Yes'\n    # Check if concatenating in the other order forms a good string\n    if is_balanced(str2 + str1):\n        return 'Yes'\n    return 'No'\ndef is_balanced(s):\n    '''\n    Check if the given string has balanced parentheses.\n    \n    :param s: String consisting of '(' and ')' only.\n    :return: True if the string is balanced, False otherwise.\n    '''\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Try both possible concatenations\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "matching_cluster_idx": 4}, {"solution": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    # Define a helper function to check if a string is balanced\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible concatenations\n    if is_balanced(lst[0] + lst[1]):\n        return 'Yes'\n    if is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    \n    return 'No'", "matching_cluster_idx": 4}]}, "HumanEval/120": {"dps": 89.65517241379311, "dps_norm": 97.14285714285714, "pass@1": 37.0, "profiled": [{"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order and take the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    \n    # Return the result sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the first k elements\n    sorted_arr = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the k largest elements in ascending order\n    return sorted(sorted_arr)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Get the last k elements from the sorted array\n    max_k_elements = sorted_arr[-k:]\n    \n    # Return the sorted list of the maximum k elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements and sort them in ascending order\n    result = sorted_arr[:k]\n    result.sort()\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order and take the last k elements\n    sorted_arr = sorted(arr)\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order and slice the last k elements\n    return sorted(arr)[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order and slice the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    \n    # Return the result sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in descending order and take the first k elements\n    max_k = sorted(arr, reverse=True)[:k]\n    # Return the result sorted in ascending order\n    return sorted(max_k)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and then slice the first k elements\n    # Finally, sort the result in ascending order to match the expected output\n    return sorted(sorted(arr, reverse=True)[:k])", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Return the last k elements of the sorted array\n    return arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in ascending order\n    arr.sort()\n    \n    # If k is 0, return an empty list\n    if k == 0:\n        return []\n    \n    # Return the last k elements of the sorted array, which are the largest k elements\n    return arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    # Get the last k elements (which are the largest k elements)\n    max_k_elements = sorted_arr[-k:]\n    # Return the sorted list of these k elements\n    return sorted(max_k_elements)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order to get the largest elements at the beginning\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements from the sorted array and sort them in ascending order\n    result = sorted(sorted_arr[:k])\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and take the first k elements\n    max_k_elements = sorted(arr, reverse=True)[:k]\n    # Return the result sorted in ascending order\n    return sorted(max_k_elements)", "matching_cluster_idx": 5}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    # Sort the array in ascending order and slice the last k elements\n    sorted_arr = sorted(arr)\n    return sorted_arr[-k:]", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements from the sorted array\n    top_k = sorted_arr[:k]\n    \n    # Sort the top k elements in ascending order before returning\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and take the first k elements\n    max_k = sorted(arr, reverse=True)[:k]\n    # Return the sorted list of the k maximum elements\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and slice the top k elements\n    sorted_arr = sorted(arr, reverse=True)\n    top_k = sorted_arr[:k]\n    \n    # Return the result sorted in ascending order\n    return sorted(top_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order and take the first k elements\n    max_k = sorted(arr, reverse=True)[:k]\n    # Sort the result in ascending order before returning\n    return sorted(max_k)", "matching_cluster_idx": 6}, {"solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Take the first k elements and sort them in ascending order for the result\n    result = sorted(sorted_arr[:k])\n    \n    return result", "matching_cluster_idx": 6}]}, "HumanEval/121": {"dps": 88.69955156950672, "dps_norm": 67.14285714285714, "pass@1": 100.0, "profiled": [{"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd_even_pos = 0\n    \n    # Iterate over the list with index\n    for i, num in enumerate(lst):\n        # Check if the position is even (0-based index) and the number is odd\n        if i % 2 == 0 and num % 2 != 0:\n            sum_odd_even_pos += num\n    \n    return sum_odd_even_pos", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum of odd elements at even positions\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements at even positions\n    sum_odd_at_even = 0\n    \n    # Iterate through the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_at_even += value\n    \n    return sum_odd_at_even", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd = 0\n    \n    # Iterate through the list, considering only even indices\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    # Return the final sum\n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd_elements = 0\n    \n    # Iterate through the list, considering only even positions (index 0, 2, 4, ...)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current position is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd_elements += lst[i]\n    \n    return sum_odd_elements", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to zero\n    sum_odd = 0\n    \n    # Iterate over the list, considering only even indices\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements at even positions\n    sum_odd = 0\n    \n    # Iterate over the list, considering only even indices\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    sum_odd_elements = 0\n    \n    # Iterate through the list with index and value\n    for index, value in enumerate(lst):\n        # Check if the position is even and the element is odd\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_elements += value\n    \n    return sum_odd_elements", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to zero\n    sum_odd_elements = 0\n    \n    # Iterate over the list with index\n    for index, value in enumerate(lst):\n        # Check if the position is even and the element is odd\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd_elements += value\n    \n    return sum_odd_elements", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd_elements = 0\n    \n    # Iterate through the list, considering only even indices (0, 2, 4, ...)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd_elements += lst[i]\n    \n    return sum_odd_elements", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum odd elements at even indices\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Sum of odd elements at even indices\n    return sum(lst[i] for i in range(0, len(lst), 2) if lst[i] % 2 != 0)", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements\n    sum_odd = 0\n    \n    # Iterate over the list, considering only even indices\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd_elements = 0\n    \n    # Iterate over the list, considering only even positions\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd_elements += lst[i]\n    \n    return sum_odd_elements", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd = 0\n    \n    # Iterate through the list, considering only even indices\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd_elements = 0\n    \n    # Iterate over the list, considering only even positions\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even position is odd\n        if lst[i] % 2 != 0:\n            sum_odd_elements += lst[i]\n    \n    return sum_odd_elements", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd = 0\n    \n    # Iterate through the list, considering only even positions (0, 2, 4, ...)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current position is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd += lst[i]\n    \n    return sum_odd", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements at even positions\n    sum_odd_at_even = 0\n    \n    # Iterate over the list, considering only even indices (0, 2, 4, ...)\n    for i in range(0, len(lst), 2):\n        # Check if the element at the even index is odd\n        if lst[i] % 2 != 0:\n            # Add the odd element to the sum\n            sum_odd_at_even += lst[i]\n    \n    return sum_odd_at_even", "matching_cluster_idx": 4}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum of odd elements in even positions\n    sum_odd_even_pos = 0\n    \n    # Iterate through the list with index and value\n    for i, value in enumerate(lst):\n        # Check if the index is even and the value is odd\n        if i % 2 == 0 and value % 2 != 0:\n            sum_odd_even_pos += value\n    \n    return sum_odd_even_pos", "matching_cluster_idx": 3}, {"solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples:\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    # Initialize the sum to 0\n    sum_odd = 0\n    \n    # Iterate over the list with both index and value\n    for index, value in enumerate(lst):\n        # Check if the position is even (index is odd) and the value is odd\n        if index % 2 == 0 and value % 2 != 0:\n            sum_odd += value\n    \n    return sum_odd", "matching_cluster_idx": 3}]}, "HumanEval/149": {"dps": 85.82677165354332, "dps_norm": 57.142857142857146, "pass@1": 100.0, "profiled": [{"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list sorted first by length and then alphabetically.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    \n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the resulting list in sorted order. The sorting is first by the\n    length of the strings in ascending order, and then alphabetically for strings\n    of the same length.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    even_length_strings.sort(key=lambda x: (len(x), x))\n    \n    return even_length_strings", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function takes a list of strings, removes strings with odd lengths,\n    and returns a sorted list. The list is sorted by the length of the strings\n    in ascending order. If two strings have the same length, they are sorted\n    alphabetically.\n    \n    Parameters:\n    lst (list): A list of strings\n    \n    Returns:\n    list: A sorted list of strings with even lengths\n    \"\"\"\n    # Remove strings with odd lengths\n    even_length_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    even_length_lst.sort(key=lambda word: (len(word), word))\n    \n    return even_length_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length of each word, and alphabetically if lengths are equal\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths,\n    and returns the remaining strings in ascending order by length and alphabetically\n    if the lengths are the same.\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(even_length_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) == [\"ab\", \"cd\"]\n    \"\"\"\n    \n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    \n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes strings with odd lengths,\n    and returns the resulted list sorted by length and alphabetically.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function takes a list of strings, removes those with odd lengths,\n    and returns the remaining strings sorted first by their length and then alphabetically.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(even_length_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    Write a function that accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the resulted list with a sorted order.\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The order of the list should be ascending by length of each word, and you\n    should return the list sorted by that rule.\n    If two words have the same length, sort the list alphabetically.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert sorted_list_sum([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}, {"solution": "def sorted_list_sum(lst):\n    \"\"\"\n    This function accepts a list of strings, deletes the strings that have odd lengths,\n    and returns the resulted list with a sorted order.\n    The list is sorted first by the length of each word in ascending order, and then\n    alphabetically for words of the same length.\n    \n    :param lst: List of strings\n    :return: Sorted list of strings with even lengths\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list by length, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "matching_cluster_idx": 3}]}, "Mbpp/3": {"dps": 69.15254237288136, "dps_norm": 82.5, "pass@1": 100.0, "profiled": [{"solution": "def is_not_prime(n):\n    # 1 is not considered a prime number\n    if n <= 1:\n        return True\n    # 2 and 3 are prime numbers\n    if n <= 3:\n        return False\n    # If the number is divisible by 2 or 3, it is not prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    # Check for divisors up to the square root of n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # Handle edge cases for numbers less than 2\n    if n <= 1:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2 (not a prime number)\n    if n < 2:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # 1 is not considered a prime number\n    if n <= 1:\n        return True\n    # 2 and 3 are prime numbers\n    if n <= 3:\n        return False\n    # Eliminate numbers divisible by 2 or 3\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n    # Check for factors up to the square root of n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # A number is not prime if it is less than 2 or if it has any divisors other than 1 and itself\n    if n < 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # 1 is not considered a prime number\n    if n <= 1:\n        return True\n    # 2 is the only even prime number\n    if n == 2:\n        return False\n    # All other even numbers are not primes\n    if n % 2 == 0:\n        return True\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2, which is not a prime number\n    if n < 2:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2 (0 and 1 are not prime)\n    if n < 2:\n        return True\n    # Check for factors other than 1 and the number itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # 0 and 1 are not prime numbers\n    if n <= 1:\n        return True\n    # 2 is a prime number\n    if n == 2:\n        return False\n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2 (not prime)\n    if n < 2:\n        return True\n    # Check for any divisor from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2, which is not prime\n    if n < 2:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # A number is non-prime if it has any divisor other than 1 and itself\n    if n <= 1:\n        return True  # 1 and numbers less than 1 are not considered prime\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, hence n is not prime\n    return False  # No divisors found, n is prime", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2 (0 and 1 are not prime)\n    if n < 2:\n        return True\n    # Check for factors other than 1 and the number itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2, which is not prime\n    if n < 2:\n        return True\n    # Check for factors other than 1 and the number itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # 0 and 1 are not prime numbers\n    if n <= 1:\n        return True\n    # 2 is a prime number\n    if n == 2:\n        return False\n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # 0 and 1 are not prime numbers\n    if n <= 1:\n        return True\n    # 2 is a prime number\n    if n == 2:\n        return False\n    # Even numbers greater than 2 are not prime\n    if n % 2 == 0:\n        return True\n    # Check for factors from 3 to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 7}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2, which means it's not prime\n    if n < 2:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Handle the special cases where n is less than 2\n    if n < 2:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2\n    if n < 2:\n        return True\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False", "matching_cluster_idx": 5}, {"solution": "def is_not_prime(n):\n    # Check if the number is less than 2, which means it's not prime\n    if n < 2:\n        return True\n    # Check for factors other than 1 and the number itself\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    # If no factors found, the number is prime\n    return False", "matching_cluster_idx": 5}]}, "Mbpp/4": {"dps": 95.22184300341297, "dps_norm": 83.33333333333333, "pass@1": 99.0, "profiled": [{"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements and then sort them in descending order\n    largest_nums = heapq.nlargest(n, nums)\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements and sort them in descending order\n    largest_n = heapq.nlargest(n, nums)\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_numbers = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_numbers", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use nlargest from heapq to find the n largest numbers\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to get the n largest numbers from the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest elements in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return largest_nums", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq to find the n largest numbers in the list\n    largest_n = heapq.nlargest(n, nums)\n    # Return the result in descending order\n    return sorted(largest_n, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the result sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}, {"solution": "import heapq\ndef heap_queue_largest(nums, n):\n    # Use heapq.nlargest to find the n largest numbers in the list\n    largest_nums = heapq.nlargest(n, nums)\n    # Return the list sorted in descending order\n    return sorted(largest_nums, reverse=True)", "matching_cluster_idx": 9}]}, "Mbpp/9": {"dps": 83.19727891156462, "dps_norm": 57.0, "pass@1": 98.0, "profiled": [{"solution": "def find_Rotations(s):\n    # Double the string to simulate infinite rotations\n    temp = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Extract the substring of length n starting from index i\n        rotated = temp[i:i + n]\n        # Check if the rotated string matches the original string\n        if rotated == s:\n            return i\n    # If no rotation results in the same string, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Initialize the number of rotations\n    rotations = 1\n    \n    # Loop until the string is rotated back to its original form\n    while rotations < len(s):\n        # Rotate the string by one position\n        rotated_s = s[rotations:] + s[:rotations]\n        \n        # Check if the rotated string matches the original string\n        if rotated_s == s:\n            return rotations\n        \n        # Increment the number of rotations\n        rotations += 1\n    \n    # If no valid rotation found, return the length of the string\n    return len(s)", "matching_cluster_idx": 3}, {"solution": "def find_Rotations(s):\n    # Length of the string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Generate the rotated string\n        rotated_s = s[i:] + s[:i]\n        \n        # Check if the rotated string matches the original string\n        if rotated_s == s:\n            return i\n    \n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Initialize the number of rotations\n    n = len(s)\n    rotations = 1\n    \n    # Loop through the string to check for rotations\n    while rotations < n:\n        # Rotate the string by one position\n        rotated_s = s[rotations:] + s[:rotations]\n        \n        # Check if the rotated string is the same as the original string\n        if rotated_s == s:\n            return rotations\n        \n        # Increment the number of rotations\n        rotations += 1\n    \n    # If no rotation results in the same string, return the length of the string\n    return n", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Double the string to handle rotations\n    double_s = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate over possible rotations\n    for i in range(1, n + 1):\n        # Get the substring of length n starting from i\n        rotated = double_s[i:i + n]\n        # Check if the rotated substring is equal to the original string\n        if rotated == s:\n            return i\n    # If no rotation results in the same string, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    # Length of the string\n    n = len(s)\n    \n    # Check for the minimum number of rotations\n    for i in range(1, n + 1):\n        # Generate the substring of length n starting from i\n        substring = temp[i:i + n]\n        # If the substring matches the original string, return the number of rotations\n        if substring == s:\n            return i\n    # If no rotation results in the original string, return 0 (though this case won't occur for non-empty strings)\n    return 0", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the string to handle rotations\n    temp = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Extract the substring from the doubled string\n        substring = temp[i: i + n]\n        # Check if the substring matches the original string\n        if substring == s:\n            return i\n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Append the string to itself to handle rotations\n    temp = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Generate the rotated string\n        rotated = temp[i: i + n]\n        # Check if the rotated string matches the original string\n        if rotated == s:\n            return i\n    return 0", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to handle rotations\n    temp = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through the possible rotations\n    for i in range(1, n + 1):\n        # Extract the substring of length n starting from i\n        substring = temp[i:i + n]\n        # Check if the substring matches the original string\n        if substring == s:\n            return i\n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Iterate through the string to find the minimum rotations\n    for i in range(1, len(s)):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        # Check if the rotated string is the same as the original\n        if rotated == s:\n            return i\n    # If no rotation results in the same string, return the length of the string\n    return len(s)", "matching_cluster_idx": 4}, {"solution": "def find_Rotations(s):\n    # Double the input string to simulate all possible rotations\n    temp = s + s\n    # Length of the input string\n    n = len(s)\n    # Iterate over the doubled string to find the minimum rotation\n    for i in range(1, n + 1):\n        # Extract the substring of length n starting from index i\n        substring = temp[i: i + n]\n        # Check if the substring is equal to the original string\n        if substring == s:\n            return i\n    # If no rotation results in the original string, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself to handle rotations\n    temp = s + s\n    # Length of the string\n    n = len(s)\n    \n    # Iterate through possible rotation points\n    for i in range(1, n + 1):\n        # Generate the rotated string\n        rotated = temp[i:i + n]\n        # Check if the rotated string is the same as the original string\n        if rotated == s:\n            return i\n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the input string to handle rotations\n    temp = s + s\n    # Length of the input string\n    n = len(s)\n    \n    # Iterate through the string to find the minimum rotations\n    for i in range(1, n + 1):\n        # Extract the substring of length n starting from index i\n        substring = temp[i:i + n]\n        # If the substring matches the original string, return the rotation count\n        if substring == s:\n            return i\n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Append the string to itself to handle rotations\n    temp = s + s\n    # Length of the string\n    n = len(s)\n    \n    # Iterate over the possible rotations\n    for i in range(1, n + 1):\n        # Generate the rotated string\n        rotated = temp[i:i + n]\n        # Check if the rotated string matches the original string\n        if rotated == s:\n            return i\n    # If no rotation matches, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the input string to handle rotations\n    temp = s + s\n    # Length of the input string\n    n = len(s)\n    \n    # Iterate through the possible rotations\n    for i in range(1, n + 1):\n        # Generate the rotated string\n        substring = temp[i: i + n]\n        # Check if the rotated string matches the original string\n        if substring == s:\n            return i\n    # If no valid rotation is found, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Double the input string to simulate infinite rotations\n    temp = s + s\n    # Length of the input string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Extract the substring of length n starting from index i\n        substring = temp[i:i + n]\n        # Check if the substring matches the original string\n        if substring == s:\n            return i\n    return n  # In case no valid rotation is found, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Append the string to itself to handle rotations\n    temp = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Extract the rotated substring\n        substring = temp[i:i + n]\n        # Check if the rotated substring matches the original string\n        if substring == s:\n            return i\n    return n  # If no rotation matches, return the length of the string", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    concatenated = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, n + 1):\n        # Extract the rotated substring\n        rotated = concatenated[i : i + n]\n        # Check if the rotated substring matches the original string\n        if rotated == s:\n            return i\n    # If no rotation matches, return 0 (though this case won't occur for non-empty strings)\n    return 0", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Concatenate the string with itself\n    temp = s + s\n    # Length of the original string\n    n = len(s)\n    \n    # Iterate through the string to find the minimum rotations\n    for i in range(1, n + 1):\n        # Generate the substring of length n starting from i\n        substring = temp[i:i + n]\n        # Check if the substring is equal to the original string\n        if substring == s:\n            return i\n    # If no rotations found, return the length of the string\n    return n", "matching_cluster_idx": 5}, {"solution": "def find_Rotations(s):\n    # Get the length of the string\n    n = len(s)\n    \n    # Iterate over possible rotations\n    for i in range(1, n + 1):\n        # Generate the rotated string\n        rotated = s[i:] + s[:i]\n        \n        # Check if the rotated string is the same as the original\n        if rotated == s:\n            return i  # Return the number of rotations\n    \n    # If no rotation results in the same string, return 0 (though this case should not occur for valid input)\n    return 0", "matching_cluster_idx": 4}]}, "Mbpp/11": {"dps": 62.22222222222222, "dps_norm": 93.88888888888889, "pass@1": 89.0, "profiled": [{"solution": "def remove_Occ(s, ch):\n    # Find and remove the first occurrence of the character\n    first_occ = s.find(ch)\n    if first_occ != -1:\n        s = s[:first_occ] + s[first_occ + 1:]\n    \n    # Find and remove the last occurrence of the character\n    last_occ = s.rfind(ch)\n    if last_occ != -1:\n        s = s[:last_occ] + s[last_occ + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # If the first and last occurrences are the same, remove only one occurrence\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the first and last occurrences of the character\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # Construct the new string by removing the first and last occurrence\n    result = s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]\n    \n    return result", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of ch\n    first = s.find(ch)\n    # Find the index of the last occurrence of ch\n    last = s.rfind(ch)\n    \n    # Remove the first and last occurrence of ch\n    if first != -1 and last != -1:\n        return s[:first] + s[first+1:last] + s[last+1:]\n    else:\n        return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Remove the first occurrence of the character\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Remove the last occurrence of the character\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, char):\n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(char)\n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(char)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    \n    # If the first and last occurrences are the same, remove that single occurrence\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the first and last occurrences of the character\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the first occurrence of the character and remove it\n    first_occurrence = s.find(ch)\n    if first_occurrence != -1:\n        s = s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Find the last occurrence of the character and remove it\n    last_occurrence = s.rfind(ch)\n    if last_occurrence != -1:\n        s = s[:last_occurrence] + s[last_occurrence + 1:]\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Find and remove the first occurrence of the character\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Find and remove the last occurrence of the character\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(ch)\n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character does not exist in the string, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # If the first and last occurrences are the same, remove that character\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the first and last occurrences of the character\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # Find the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # Remove the first and last occurrence of the character\n    if first_occurrence != -1 and last_occurrence != -1:\n        s = s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    \n    return s", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the first occurrence of the character and remove it\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Find the last occurrence of the character and remove it\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Remove the first occurrence of the character\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Remove the last occurrence of the character\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Remove the first occurrence of the character\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Remove the last occurrence of the character\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Check if the character is in the string\n    if ch in s:\n        # Remove the first occurrence\n        for i in range(len(s)):\n            if s[i] == ch:\n                s = s[:i] + s[i+1:]\n                break\n        \n        # Remove the last occurrence\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == ch:\n                s = s[:i] + s[i+1:]\n                break\n    \n    return s", "matching_cluster_idx": 6}, {"solution": "def remove_Occ(s, ch):\n    # Remove the first occurrence of the character\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Remove the last occurrence of the character\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of ch\n    first_occurrence = s.find(ch)\n    # Find the index of the last occurrence of ch\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1:\n        return s\n    \n    # If the first and last occurrence are the same, remove one instance of the character\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the first and last occurrences of the character\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character does not exist in the string, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # If the first and last occurrence is the same, it means the character appears only once\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the first and last occurrence of the character\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_occurrence = s.find(ch)\n    \n    # Find the index of the last occurrence of the character\n    last_occurrence = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_occurrence == -1 or last_occurrence == -1:\n        return s\n    \n    # If the first and last occurrences are the same, remove one character\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence + 1:]\n    \n    # Remove the first and last occurrences of the character\n    return s[:first_occurrence] + s[first_occurrence + 1:last_occurrence] + s[last_occurrence + 1:]", "matching_cluster_idx": 8}, {"solution": "def remove_Occ(s, ch):\n    # Remove the first occurrence of the character\n    for i in range(len(s)):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    # Remove the last occurrence of the character\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == ch:\n            s = s[:i] + s[i+1:]\n            break\n    \n    return s", "matching_cluster_idx": 7}, {"solution": "def remove_Occ(s, ch):\n    # Find the index of the first occurrence of the character\n    first_index = s.find(ch)\n    \n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(ch)\n    \n    # If the character is not found, return the original string\n    if first_index == -1 or last_index == -1:\n        return s\n    \n    # If the character is found, remove the first and last occurrences\n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "matching_cluster_idx": 8}]}, "Mbpp/12": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of elements in each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix", "matching_cluster_idx": 15}, {"solution": "def sort_matrix(matrix):\n    # Sort the matrix based on the sum of each row\n    matrix.sort(key=sum)\n    return matrix", "matching_cluster_idx": 15}]}, "Mbpp/16": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/19": {"dps": 85.85858585858585, "dps_norm": 92.0, "pass@1": 100.0, "profiled": [{"solution": "def test_duplicate(arr):\n    # Convert the list to a set and compare lengths\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Use a set to track unique elements\n    seen = set()\n    \n    for num in arr:\n        # If the number is already in the set, a duplicate is found\n        if num in seen:\n            return True\n        # Add the number to the set\n        seen.add(num)\n    \n    # No duplicates found\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set and compare its length to the original list\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Using a set to track seen elements\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Using a set to track seen elements\n    seen = set()\n    \n    for num in arr:\n        if num in seen:\n            return True  # Duplicate found\n        seen.add(num)\n    \n    return False  # No duplicates found", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create an empty set to track seen elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, a duplicate is found\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Use a set to track seen elements\n    seen = set()\n    \n    # Iterate through the array\n    for num in arr:\n        # If the element is already in the set, we have a duplicate\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates were found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Using a set to track seen elements\n    seen = set()\n    \n    for num in arr:\n        # If the element is already in the set, a duplicate is found\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # No duplicates found\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the length of the set is less than the original list, there were duplicates\n    return len(unique_elements) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Create an empty set to keep track of seen elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, return True (duplicate found)\n        if num in seen:\n            return True\n        # Otherwise, add the element to the set\n        seen.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Use a set to track seen elements\n    seen = set()\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # If the element is already in the set, a duplicate is found\n        if num in seen:\n            return True\n        # Otherwise, add the element to the set\n        seen.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create an empty set to store elements\n    seen = set()\n    \n    # Iterate through the array\n    for num in arr:\n        # If the element is already in the set, return True (duplicate found)\n        if num in seen:\n            return True\n        # Add the element to the set\n        seen.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set and compare the lengths\n    # If lengths differ, there are duplicates\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is less than the original list, there were duplicates\n    return len(set(arr)) != len(arr)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(nums):\n    # Use a set to track seen elements\n    seen = set()\n    \n    # Iterate through the list of numbers\n    for num in nums:\n        # If the number is already in the set, a duplicate is found\n        if num in seen:\n            return True\n        # Add the number to the set\n        seen.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(arr)\n    \n    # If the lengths of the set and the original list differ, there were duplicates\n    return len(arr) != len(unique_elements)", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Create an empty set to keep track of seen elements\n    seen = set()\n    \n    # Iterate through the array\n    for element in arr:\n        # If the element is already in the set, we have a duplicate\n        if element in seen:\n            return True\n        # Otherwise, add the element to the set\n        seen.add(element)\n    \n    # If we reach this point, no duplicates were found\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Create an empty set to store elements\n    seen = set()\n    \n    # Iterate through each element in the array\n    for num in arr:\n        # If the element is already in the set, a duplicate is found\n        if num in seen:\n            return True\n        # Otherwise, add the element to the set\n        seen.add(num)\n    \n    # If no duplicates are found, return False\n    return False", "matching_cluster_idx": 14}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set and compare its length with the original list\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}, {"solution": "def test_duplicate(arr):\n    # Convert the list to a set and compare lengths\n    # If there are duplicates, the set will be smaller\n    return len(arr) != len(set(arr))", "matching_cluster_idx": 11}]}, "Mbpp/62": {"dps": 88.0, "dps_norm": 92.0, "pass@1": 100.0, "profiled": [{"solution": "def smallest_num(lst):\n    # Use the min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None if the list is empty\n    \n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None for an empty list\n    \n    # Initialize min_num with the first element of the list\n    min_num = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    \n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty to avoid ValueError from min()\n    if not lst:\n        return None  # or raise an exception, depending on requirements\n    # Use the built-in min() function to find the smallest number\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None\n    \n    # Initialize min_value with the first element of the list\n    min_value = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < min_value:\n            min_value = num\n    \n    return min_value", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty to avoid ValueError from min()\n    if not lst:\n        return None  # or raise an exception, depending on the desired behavior\n    # Use the built-in min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty to avoid calling min() on an empty list\n    if not lst:\n        return None  # or raise an exception, e.g., raise ValueError(\"List is empty\")\n    \n    # Use the min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Use the min function to find the smallest number in the list\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None for an empty list\n\n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Use the min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None or an appropriate value for an empty list\n\n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n\n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n\n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Use the min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Use the built-in min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # Return None for empty list\n    \n    # Initialize smallest with the first element of the list\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Initialize the minimum with the first element of the list\n    min_num = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < min_num:\n            min_num = num\n    \n    return min_num", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty\n    if not lst:\n        return None  # or raise an error, depending on the desired behavior\n    \n    # Initialize the smallest number with the first element of the list\n    smallest = lst[0]\n    \n    # Iterate through the list to find the smallest number\n    for num in lst:\n        if num < smallest:\n            smallest = num\n    \n    return smallest", "matching_cluster_idx": 3}, {"solution": "def smallest_num(lst):\n    # Check if the list is empty to avoid calling min() on an empty list\n    if not lst:\n        return None\n    # Use the min() function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Use the min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(numbers):\n    # Use the min function to find the smallest number in the list\n    return min(numbers)", "matching_cluster_idx": 4}, {"solution": "def smallest_num(lst):\n    # Use the min function to find the smallest number in the list\n    return min(lst)", "matching_cluster_idx": 4}]}, "Mbpp/75": {"dps": 92.85714285714286, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    \n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Create a result list to store tuples where all elements are divisible by k\n    result = []\n    # Iterate through each tuple in the test_list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(ele % k == 0 for ele in tup):\n            # If true, add the tuple to the result list\n            result.append(tup)\n    # Return the result list\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(x % K == 0 for x in tup):\n            # If so, add the tuple to the result list\n            result.append(tup)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each tuple in the list\n    for tuple_ in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(element % K == 0 for element in tuple_):\n            # If so, add the tuple to the result list\n            result.append(tuple_)\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    # Iterate through each tuple in the given list\n    for tup in test_list:\n        # Use a generator expression to check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in tup):\n            # If all elements are divisible by K, append the tuple to the result list\n            res.append(tup)\n    # Return the final list of tuples\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    \n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Create a new list to store tuples where all elements are divisible by K\n    res = []\n    # Iterate through each tuple in the list\n    for tuple_ in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(x % K == 0 for x in tuple_):\n            # If so, add the tuple to the result list\n            res.append(tuple_)\n    # Return the list of tuples where all elements are divisible by K\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K using all() and a generator expression\n        if all(ele % K == 0 for ele in tup):\n            # If all elements are divisible by K, add the tuple to the result list\n            res.append(tup)\n    # Return the list of tuples where all elements are divisible by K\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    res = []\n    \n    # Iterate through each tuple in the provided list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    \n    # Return the list of tuples that satisfy the condition\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store tuples where all elements are divisible by K\n    res = []\n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(x % K == 0 for x in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    # Return the list of tuples\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Create a new list to store tuples where all elements are divisible by k\n    res = []\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(ele % k == 0 for ele in tup):\n            res.append(tup)\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Filter tuples where all elements are divisible by K\n    res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            result.append(tup)\n    \n    # Return the final result list\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Initialize an empty list to store the resulting tuples\n    res = []\n    \n    # Iterate through each tuple in the provided list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(ele % k == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    \n    # Return the list of tuples where all elements are divisible by k\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Create a new list to store tuples that meet the criteria\n    result = []\n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(ele % k == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            result.append(tup)\n    # Return the list of tuples that meet the criteria\n    return result", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the resulting tuples\n    res = []\n    # Iterate through each tuple in the list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(x % K == 0 for x in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    # Return the list of tuples\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, k):\n    # Filter tuples where all elements are divisible by k\n    res = [sub for sub in test_list if all(ele % k == 0 for ele in sub)]\n    return res", "matching_cluster_idx": 5}, {"solution": "def find_tuples(test_list, K):\n    # Initialize an empty list to store the resulting tuples\n    res = []\n    \n    # Iterate through each tuple in the provided list\n    for tup in test_list:\n        # Check if all elements in the tuple are divisible by K\n        if all(ele % K == 0 for ele in tup):\n            # If so, add the tuple to the result list\n            res.append(tup)\n    \n    # Return the list of tuples where all elements are divisible by K\n    return res", "matching_cluster_idx": 5}]}, "Mbpp/88": {"dps": 96.56862745098039, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the frequency dictionary\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq_dict = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the frequency dictionary\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq = {}\n    \n    # Iterate through the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq:\n            freq[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq[item] = 1\n    \n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq:\n            freq[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in freq:\n            freq[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            freq[item] = 1\n    \n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    freq_dict = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq_dict:\n            freq_dict[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq_dict[item] = 1\n    \n    return freq_dict", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the frequency dictionary\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the frequency dictionary\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of elements\n    freq = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq:\n            freq[item] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            freq[item] = 1\n    \n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    freq = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq:\n            freq[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq[item] = 1\n    \n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    freq = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in freq:\n            freq[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            freq[item] = 1\n    \n    return freq", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # If the item is not in the dictionary, add it with a count of 1\n        else:\n            frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 5}, {"solution": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # If the element is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the element to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 5}]}, "Mbpp/90": {"dps": 86.6829268292683, "dps_norm": 90.71428571428571, "pass@1": 58.0, "profiled": [{"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update the maximum length if the current word is longer\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize a variable to keep track of the maximum length\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the maximum length found\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word by using the max function with key=len\n    longest_word = max(words, key=len)\n    # Return the length of the longest word\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    longest_word = max(words, key=len)\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return len(max(words, key=len))", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Find the length of the longest word in the list\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    if not words:  # Check if the list is empty\n        return 0\n    longest_word = max(words, key=len)\n    return len(longest_word)", "matching_cluster_idx": 6}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    longest_length = 0\n    for word in words:\n        if len(word) > longest_length:\n            longest_length = len(word)\n    return longest_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize a variable to keep track of the maximum length\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the maximum length found\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Initialize a variable to keep track of the maximum length\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Update max_length if the current word's length is greater\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    # Return the maximum length found\n    return max_length", "matching_cluster_idx": 5}, {"solution": "def len_log(words):\n    # Find the longest word in the list and return its length\n    return max(len(word) for word in words)", "matching_cluster_idx": 5}]}, "Mbpp/94": {"dps": 78.04878048780488, "dps_norm": 60.0, "pass@1": 99.0, "profiled": [{"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first element of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first element of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first element of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of that tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value and return its first value\n    return min(test_list, key=lambda x: x[1])[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the tuple with the smallest second value\n    return min_tuple[0]", "matching_cluster_idx": 2}, {"solution": "def index_minimum(test_list):\n    # Find the tuple with the smallest second value\n    min_tuple = min(test_list, key=lambda x: x[1])\n    # Return the first value of the found tuple\n    return min_tuple[0]", "matching_cluster_idx": 2}]}, "Mbpp/96": {"dps": 77.77777777777777, "dps_norm": 42.857142857142854, "pass@1": 100.0, "profiled": [{"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    # Loop through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize count of divisors\n    count = 0\n    \n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment count\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a count variable to keep track of the number of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    \n    # Return the total number of divisors\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of divisors\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    # Loop through all numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to count the divisors\n    count = 0\n    \n    # Iterate through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through all numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Increment the count\n    return count  # Return the total count of divisors", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors\n    count = 0\n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of divisors\n    count = 0\n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a count variable to store the number of divisors\n    count = 0\n    \n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter to keep track of the number of divisors\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the counter\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize the count of divisors to 0\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def divisor(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/97": {"dps": 99.6923076923077, "dps_norm": 88.75, "pass@1": 99.0, "profiled": [{"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                frequency[element] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists and count the frequency of each element\n    flattened_list = [item for sublist in lists for item in sublist]\n    frequency_dict = dict(Counter(flattened_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for item in sublist:\n            # If the item is already in the dictionary, increment its count\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            # Otherwise, add the item to the dictionary with a count of 1\n            else:\n                frequency_dict[item] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each list in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency[element] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists using a list comprehension\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flattened_list)\n    \n    # Convert Counter object to a dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists into a single list\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element\n    frequency = Counter(flattened_list)\n    \n    # Convert the Counter object to a dictionary\n    return dict(frequency)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    # Flatten the list of lists and count the frequency of each element\n    return dict(Counter(item for sublist in lists for item in sublist))", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency[element] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each list in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the sublist\n        for item in sublist:\n            # If the item is already in the dictionary, increment its count\n            if item in frequency:\n                frequency[item] += 1\n            # Otherwise, add the item to the dictionary with a count of 1\n            else:\n                frequency[item] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Create an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency_dict:\n                frequency_dict[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                frequency_dict[element] = 1\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(lists):\n    # Flatten the list of lists and count the frequency of each element\n    frequency_dict = dict(Counter(chain(*lists)))\n    return frequency_dict", "matching_cluster_idx": 7}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each list in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency[element] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                frequency[element] = 1\n    \n    return frequency", "matching_cluster_idx": 6}, {"solution": "def frequency_lists(lists):\n    # Initialize an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in lists:\n        # Iterate over each element in the sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in frequency:\n                frequency[element] += 1\n            # Otherwise, add the element to the dictionary with a count of 1\n            else:\n                frequency[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    # Flatten the list of lists using a list comprehension\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Use Counter to count the frequency of each element in the flattened list\n    frequency_dict = dict(Counter(flattened_list))\n    \n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef frequency_lists(lists):\n    # Flatten the list of lists into a single list\n    flat_list = [item for sublist in lists for item in sublist]\n    # Count the frequency of each element in the flattened list\n    frequency_dict = dict(Counter(flat_list))\n    return frequency_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\nfrom itertools import chain\ndef frequency_lists(lists):\n    # Flatten the list of lists and count the frequency of each element\n    return dict(Counter(chain.from_iterable(lists)))", "matching_cluster_idx": 7}]}, "Mbpp/106": {"dps": 15.681818181818182, "dps_norm": 62.5, "pass@1": 100.0, "profiled": [{"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert it back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the new list, and convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list\n    tpl_list = list(tpl)\n    # Extend the converted list with the given list\n    tpl_list.extend(lst)\n    # Convert the list back to a tuple\n    result = tuple(tpl_list)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list to allow modification\n    tpl_list = list(tpl)\n    # Extend the converted list with the given list\n    tpl_list.extend(lst)\n    # Convert the list back to a tuple\n    return tuple(tpl_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, add the given list, and convert it back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list to allow appending\n    temp_list = list(tpl)\n    # Extend the temporary list with the given list\n    temp_list.extend(lst)\n    # Convert the temporary list back to a tuple\n    return tuple(temp_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the new list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the new list, and convert back to a tuple\n    result = list(tpl) + lst\n    return tuple(result)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list to allow appending\n    tpl_list = list(tpl)\n    # Extend the converted list with the given list\n    tpl_list.extend(lst)\n    # Convert the list back to a tuple and return it\n    return tuple(tpl_list)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert it back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list to allow appending\n    new_tup = list(tup)\n    # Extend the new list with the elements from the given list\n    new_tup.extend(lst)\n    # Convert the list back to a tuple\n    return tuple(new_tup)", "matching_cluster_idx": 4}, {"solution": "def add_lists(lst, tup):\n    # Convert the tuple to a list, append the given list, and convert it back to a tuple\n    result = list(tup) + lst\n    return tuple(result)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, add the given list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 3}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list, append the given list, and convert back to a tuple\n    return tuple(list(tpl) + lst)", "matching_cluster_idx": 2}, {"solution": "def add_lists(lst, tpl):\n    # Convert the tuple to a list\n    tpl_list = list(tpl)\n    # Extend the list with the elements of the given list\n    tpl_list.extend(lst)\n    # Convert the extended list back to a tuple\n    return tuple(tpl_list)", "matching_cluster_idx": 4}]}, "Mbpp/108": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    combined_list.sort()\n    \n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list\n    combined_list.sort()\n    \n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    combined_list.sort()\n    return combined_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Merge the three lists\n    merged_list = list1 + list2 + list3\n    # Sort the merged list\n    merged_list.sort()\n    return merged_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}, {"solution": "def merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    # Sort the combined list\n    sorted_list = sorted(combined_list)\n    return sorted_list", "matching_cluster_idx": 10}]}, "Mbpp/111": {"dps": 75.84615384615385, "dps_norm": 83.75, "pass@1": 100.0, "profiled": [{"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements across all sublists\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements across all lists\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set.intersection to find common elements across all nested lists\n    common_elements = set.intersection(*map(set, nested_lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set to store the common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common_elements set by keeping only the elements that are also in the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set to store the common elements starting with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common_elements set by taking the intersection with the current list\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements across all sublists\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set.intersection to find common elements across all lists\n    common_elements = set.intersection(*map(set, lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use set intersection to find common elements across all lists\n    common_elements = set(nested_lists[0]).intersection(*nested_lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert each sublist to a set and find the intersection of all sets\n    common_elements = set.intersection(*map(set, lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements across all lists\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements across all lists\n    common_elements = set.intersection(*map(set, lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements in all sublists\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert the first list to a set for comparison\n    common_elements = set(lists[0])\n    \n    # Iterate through the rest of the lists\n    for lst in lists[1:]:\n        # Update the common_elements set by finding intersection with the current list\n        common_elements.intersection_update(lst)\n    \n    # Return the set of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set.intersection to find common elements across all lists\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(nested_lists):\n    # Use a set to store the common elements\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the rest of the lists and update the common_elements set\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    \n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements across all lists\n    common_elements = set.intersection(*map(set, lists))\n    return list(common_elements)", "matching_cluster_idx": 5}, {"solution": "def common_in_nested_lists(lists):\n    # Use set intersection to find common elements\n    common_elements = set(lists[0]).intersection(*lists[1:])\n    return list(common_elements)", "matching_cluster_idx": 6}, {"solution": "def common_in_nested_lists(lists):\n    # Convert each sublist into a set to remove duplicates and for easier comparison\n    sets = [set(sublist) for sublist in lists]\n    \n    # Use the intersection method to find common elements across all sets\n    common_elements = sets[0].intersection(*sets[1:])\n    \n    return list(common_elements)", "matching_cluster_idx": 5}]}, "Mbpp/123": {"dps": 99.63619402985074, "dps_norm": 86.07142857142857, "pass@1": 33.0, "profiled": [{"solution": "def amicable_numbers_sum(num):\n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        divisors_sum = 1  # Start with 1, which is a proper divisor of all numbers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through all numbers from 1 to num\n    for i in range(1, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if sum_div_i is an amicable number with i\n        if sum_div_i != i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of n\n    def sum_of_divisors(n):\n        divisors_sum = 1  # Start with 1, which is a proper divisor of all integers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum1 = sum_of_divisors(i)\n        # Check if sum1 is different from i and sum1 is within the range\n        if sum1 != i and sum1 <= num:\n            # Calculate the sum of proper divisors of sum1\n            sum2 = sum_of_divisors(sum1)\n            # Check if sum2 is equal to i\n            if sum2 == i:\n                amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # Start with 1, which is a proper divisor of any n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through each number from 2 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if sum_div_i is different from i and if i is the sum of divisors of sum_div_i\n        if sum_div_i != i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # Start with 1 because it is a proper divisor of any number\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of divisors of the current number\n        sum_div = sum_of_divisors(i)\n        # Check if the sum of divisors is different from the number and if it forms an amicable pair\n        if sum_div != i and sum_of_divisors(sum_div) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of a given number\n    def sum_of_divisors(n):\n        divisors_sum = 1  # 1 is a proper divisor of all numbers\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through all numbers from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum1 = sum_of_divisors(i)\n        # Calculate the sum of proper divisors of sum1\n        sum2 = sum_of_divisors(sum1)\n        # Check if they are amicable numbers and not the same number\n        if sum2 == i and sum1 != i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # Start with 1, which is a proper divisor of all integers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through each number from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if sum_div_i is different from i and if i is the sum of proper divisors of sum_div_i\n        if sum_div_i != i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(x):\n        total = 1  # Start with 1 because it is a proper divisor of every number\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                total += i\n                if i != x // i:\n                    total += x // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 1 to n\n    for i in range(2, n + 1):\n        # Calculate the sum of proper divisors of the current number\n        sum_div = sum_of_divisors(i)\n        # Check if the sum of proper divisors is different from the current number\n        if sum_div != i and sum_of_divisors(sum_div) == i:\n            # If it is an amicable number, add it to the sum\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of n\n    def sum_of_divisors(n):\n        total = 1  # Start with 1 because it is a proper divisor of any number\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Set to store amicable numbers\n    amicable_numbers = set()\n    \n    # Loop through each number from 2 to num\n    for i in range(2, num + 1):\n        sum_div_i = sum_of_divisors(i)\n        if sum_div_i > i and sum_of_divisors(sum_div_i) == i:\n            amicable_numbers.add(i)\n            amicable_numbers.add(sum_div_i)\n    \n    # Return the sum of all amicable numbers found\n    return sum(amicable_numbers)", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        divisors_sum = 1  # Start with 1, which is a proper divisor of all numbers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Iterate through each number from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if the sum of proper divisors of sum_div_i equals i and they are not the same number\n        if sum_div_i != i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Helper function to calculate the sum of divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # Start with 1, which is a divisor of any number\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 1 to num\n    for i in range(1, num + 1):\n        # Calculate the sum of divisors of the current number\n        sum_div_i = sum_of_divisors(i)\n        # Check if the sum of divisors is different from the current number\n        if sum_div_i != i:\n            # Calculate the sum of divisors of the sum of divisors\n            sum_div_sum_div_i = sum_of_divisors(sum_div_i)\n            # Check if the sum of divisors of the sum of divisors equals the current number\n            if sum_div_sum_div_i == i:\n                # If so, add the current number to the sum of amicable numbers\n                amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(n):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(x):\n        total = 1  # Start with 1, which is a proper divisor of any number\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                total += i\n                if i != x // i:\n                    total += x // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 2 to n\n    for num in range(2, n + 1):\n        # Calculate the sum of proper divisors of the current number\n        sum_div = sum_of_divisors(num)\n        \n        # Check if the sum of proper divisors of sum_div equals the current number\n        # and that the current number is not equal to sum_div\n        if sum_div > 1 and sum_div <= n and sum_of_divisors(sum_div) == num and sum_div != num:\n            amicable_sum += num\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of n\n    def sum_of_divisors(n):\n        total = 1  # Start with 1, which is a proper divisor of all integers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:  # Avoid adding the square root twice for perfect squares\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through all numbers up to the given number\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of the current number\n        sum_div = sum_of_divisors(i)\n        # Check if the sum of proper divisors is a different number and forms an amicable pair\n        if sum_div != i and sum_of_divisors(sum_div) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        divisors_sum = 1  # Start with 1, which is a proper divisor of any n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 2 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if sum_div_i is different from i and if it is an amicable number\n        if sum_div_i != i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of n\n    def sum_of_divisors(n):\n        total = 1  # 1 is a proper divisor of all numbers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through all numbers from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        \n        # Check if the sum of proper divisors of sum_div_i equals i and i is not equal to sum_div_i\n        if sum_div_i != i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to compute the sum of proper divisors of a given number\n    def sum_proper_divisors(n):\n        divisors_sum = 1  # Start with 1, which is a proper divisor of all numbers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_divisors_i = sum_proper_divisors(i)\n        # Check if the sum of proper divisors of sum_divisors_i equals i and i is not equal to sum_divisors_i\n        if i != sum_divisors_i and sum_proper_divisors(sum_divisors_i) == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Initialize a list to store the sum of divisors for each number\n    divisors_sum = [0] * (num + 1)\n    \n    # Calculate the sum of divisors for each number from 1 to num\n    for i in range(1, num + 1):\n        for j in range(i * 2, num + 1, i):\n            divisors_sum[j] += i\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Check for amicable pairs and sum them\n    for i in range(1, num + 1):\n        if divisors_sum[i] <= num and divisors_sum[i] != i and divisors_sum[divisors_sum[i]] == i:\n            amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 12}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of n\n    def sum_of_divisors(n):\n        divisors_sum = 1  # Start with 1, which is a proper divisor of any n > 1\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:  # Avoid adding the square root twice for perfect squares\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    amicable_sum = 0\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if sum_div_i is an amicable pair with i\n        if sum_div_i > i and sum_of_divisors(sum_div_i) == i:\n            amicable_sum += i + sum_div_i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # Start with 1 as it is a divisor of all numbers\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through numbers from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of divisors of the current number\n        sum_div = sum_of_divisors(i)\n        # Check if the sum of divisors is different from the current number and is within the range\n        if sum_div != i and sum_div <= num:\n            # Calculate the sum of divisors of the sum of divisors\n            sum_div_div = sum_of_divisors(sum_div)\n            # Check if the sum of divisors of the sum of divisors equals the current number\n            if sum_div_div == i:\n                amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Helper function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        divisors_sum = 1  # Start with 1 as it is a proper divisor\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors_sum += i\n                if i != n // i:\n                    divisors_sum += n // i\n        return divisors_sum\n    \n    # Initialize the sum of amicable numbers\n    amicable_sum = 0\n    \n    # Iterate through each number from 1 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of the current number\n        sum_div_i = sum_of_divisors(i)\n        \n        # Check if the sum of proper divisors is different from the current number\n        if sum_div_i != i:\n            # Calculate the sum of proper divisors of the sum of proper divisors\n            sum_div_sum_div_i = sum_of_divisors(sum_div_i)\n            \n            # Check if the current number is an amicable number\n            if sum_div_sum_div_i == i:\n                amicable_sum += i\n    \n    return amicable_sum", "matching_cluster_idx": 11}, {"solution": "def amicable_numbers_sum(num):\n    # Function to calculate the sum of proper divisors of a number\n    def sum_of_divisors(n):\n        total = 1  # 1 is a proper divisor of any number\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                total += i\n                if i != n // i:\n                    total += n // i\n        return total\n    \n    # Set to store amicable numbers\n    amicable_set = set()\n    \n    # Loop through each number from 2 to num\n    for i in range(2, num + 1):\n        # Calculate the sum of proper divisors of i\n        sum_div_i = sum_of_divisors(i)\n        # Check if sum_div_i is an amicable number with i\n        if sum_div_i > i and sum_of_divisors(sum_div_i) == i:\n            amicable_set.add(i)\n            amicable_set.add(sum_div_i)\n    \n    # Return the sum of all unique amicable numbers found\n    return sum(amicable_set)", "matching_cluster_idx": 11}]}, "Mbpp/128": {"dps": 99.5475113122172, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Use list comprehension to filter words longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the string into a list of words\n    words = string.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the string into a list of words\n    words = string.split()\n    \n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Filter the words that have more than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Initialize an empty list to store words longer than n characters\n    result = []\n    \n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If so, add the word to the result list\n            result.append(word)\n    \n    # Return the list of words longer than n characters\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    # Use a list comprehension to filter out words shorter than or equal to n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Initialize an empty list to store words longer than n characters\n    longer_words = []\n    \n    # Split the input string into individual words\n    words = word_list.split()\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If true, append the word to the longer_words list\n            longer_words.append(word)\n    \n    # Return the list of words longer than n characters\n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, lst):\n    # Use a list comprehension to filter words longer than n characters\n    return [word for word in lst.split() if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Initialize an empty list to store words longer than n characters\n    longer_words = []\n    \n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If so, add the word to the longer_words list\n            longer_words.append(word)\n    \n    # Return the list of words longer than n characters\n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    # Filter and return words longer than n characters\n    return [word for word in words if len(word) > n]", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Use a list comprehension to filter words longer than n characters\n    result = [word for word in word_list.split() if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the input string into a list of words\n    words = string.split()\n    # Filter the words based on the length criteria\n    long_words_list = [word for word in words if len(word) > n]\n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Initialize an empty list to store words longer than n characters\n    longer_words = []\n    \n    # Split the input string into a list of words\n    words = word_list.split()\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If so, append the word to the longer_words list\n            longer_words.append(word)\n    \n    # Return the list of words that are longer than n characters\n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, string):\n    # Split the string into a list of words\n    words = string.split()\n    \n    # Filter words that are longer than n characters\n    long_words_list = [word for word in words if len(word) > n]\n    \n    return long_words_list", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Split the input string into a list of words\n    words = word_list.split()\n    # Filter words that are longer than n characters\n    longer_words = [word for word in words if len(word) > n]\n    return longer_words", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list.split() if len(word) > n]\n    return result", "matching_cluster_idx": 3}, {"solution": "def long_words(n, word_list):\n    # Use list comprehension to filter words longer than n characters\n    result = [word for word in word_list.split() if len(word) > n]\n    return result", "matching_cluster_idx": 3}]}, "Mbpp/129": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix[0])):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sums of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sums of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to establish the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as the reference sum\n    magic_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the target sum using the first row\n    target_sum = sum(matrix[0])\n    \n    # Check sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the main diagonal sum\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the secondary diagonal sum\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the target sum using the first row\n    target_sum = sum(matrix[0])\n    \n    # Check sums of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check sums of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use it as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set a target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set the magic sum\n    magic_sum = sum(matrix[0])\n    \n    # Check the sums of the rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sums of the columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as the magic constant\n    magic_constant = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_constant:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_constant:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_constant:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as the reference magic sum\n    magic_sum = sum(matrix[0])\n    \n    # Check the sums of all rows\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sums of all columns\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # If all checks pass, the matrix is a magic square\n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to set as the target sum\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != target_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}, {"solution": "def magic_square_test(matrix):\n    # Calculate the sum of the first row to use as a reference\n    magic_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(len(matrix)):\n        if sum(matrix[row][col] for row in range(len(matrix))) != magic_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][len(matrix) - 1 - i] for i in range(len(matrix))) != magic_sum:\n        return False\n    \n    return True", "matching_cluster_idx": 14}]}, "Mbpp/130": {"dps": 77.10762331838565, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item in the list\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(frequency, key=frequency.get)\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item in the list\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item in the list\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate over the list and count the frequency of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate over the list and count occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count occurrences of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Initialize an empty dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate over each item in the list\n    for item in lst:\n        # If the item is already in the dictionary, increment its count\n        if item in frequency:\n            frequency[item] += 1\n        # Otherwise, add the item to the dictionary with a count of 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    # Return the item with the maximum frequency\n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Use Counter to count the frequency of each item in the list\n    frequency = Counter(lst)\n    # Find the item with the maximum frequency\n    # If multiple items have the same maximum frequency, return the first one encountered\n    max_freq_item = max(frequency, key=frequency.get)\n    return max_freq_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate through the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(frequency, key=frequency.get)\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Initialize an empty dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate over the list to count the frequency of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(frequency, key=frequency.get)\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate over the list to populate the frequency dictionary\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Initialize a dictionary to count the occurrences of each item\n    count = {}\n    \n    # Iterate over the list to populate the count dictionary\n    for item in lst:\n        if item in count:\n            count[item] += 1\n        else:\n            count[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = max(count, key=count.get)\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n    \n    return max_item", "matching_cluster_idx": 3}, {"solution": "from collections import Counter\ndef max_occurrences(lst):\n    # Count the frequency of each item in the list\n    frequency = Counter(lst)\n    \n    # Find the item with the maximum frequency\n    max_item = max(frequency, key=frequency.get)\n    \n    return max_item", "matching_cluster_idx": 4}, {"solution": "def max_occurrences(lst):\n    # Dictionary to store the frequency of each item\n    frequency = {}\n    \n    # Iterate over the list and count the occurrences of each item\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_freq_item = max(frequency, key=frequency.get)\n    \n    return max_freq_item", "matching_cluster_idx": 3}, {"solution": "def max_occurrences(lst):\n    # Create a dictionary to count the frequency of each item in the list\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Find the item with the maximum frequency\n    max_item = None\n    max_count = 0\n    for item, count in frequency.items():\n        if count > max_count:\n            max_item = item\n            max_count = count\n    \n    return max_item", "matching_cluster_idx": 3}]}, "Mbpp/137": {"dps": 56.29032258064515, "dps_norm": 69.375, "pass@1": 57.0, "profiled": [{"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Calculate the total number of elements in the array\n    total_count = len(arr)\n    \n    # Calculate the number of non-zero elements\n    non_zero_count = total_count - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    # Count the number of non-zeroes in the array\n    non_zero_count = len(arr) - zero_count\n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    ratio = zero_count / non_zero_count\n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    else:\n        ratio = zero_count / non_zero_count\n        return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Handle the case where there are no non-zero elements\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    else:\n        ratio = zero_count / non_zero_count\n        return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        # If there are no non-zero elements, the ratio is undefined\n        return float('inf')\n    else:\n        ratio = zero_count / non_zero_count\n        return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Handle the case where there are no non-zero elements\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zeroes in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    else:\n        ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Handle division by zero\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 7}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    else:\n        ratio = zero_count / non_zero_count\n        return ratio", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Count the number of non-zero elements in the array\n    non_zero_count = len(arr) - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # If there are no non-zero elements, the ratio is undefined (return infinity)\n    else:\n        ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 6}, {"solution": "import math\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through the array to count zeroes and non-zeroes\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n        else:\n            non_zero_count += 1\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Return infinity if there are no non-zero elements\n    else:\n        return zero_count / non_zero_count", "matching_cluster_idx": 3}, {"solution": "import math\ndef zero_count(arr):\n    # Count the number of zeroes in the array\n    zero_count = arr.count(0)\n    \n    # Calculate the total number of elements in the array\n    total_count = len(arr)\n    \n    # Calculate the number of non-zero elements\n    non_zero_count = total_count - zero_count\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    if non_zero_count == 0:\n        return float('inf')  # Avoid division by zero\n    ratio = zero_count / non_zero_count\n    \n    return ratio", "matching_cluster_idx": 6}]}, "Mbpp/140": {"dps": 78.07453416149069, "dps_norm": 86.25, "pass@1": 100.0, "profiled": [{"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the result set\n        for item in tup:\n            result_set.add(item)\n    \n    # Return the result set\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for t in list_of_tuples:\n        # Add each element of the tuple to the set\n        for item in t:\n            result_set.add(item)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 4}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        for item in tup:\n            result_set.add(item)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Add all elements of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        for item in tup:\n            result_set.add(item)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the flattened elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the result set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for t in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(t)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the flattened elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element in the tuple to the set\n        result_set.update(tup)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        for element in tup:\n            result_set.add(element)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 3}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Update the set with the elements of the current tuple\n        result_set.update(tup)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate over each tuple in the list\n    for tup in list_of_tuples:\n        # Update the set with the elements of the tuple\n        result_set.update(tup)\n    \n    # Return the resulting set\n    return result_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Update the set with the elements from the current tuple\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 6}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 7}, {"solution": "def extract_singly(list_of_tuples):\n    # Initialize an empty set to store the unique elements\n    result_set = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Add each element of the tuple to the set\n        result_set.update(tup)\n    \n    # Return the set containing all unique elements\n    return result_set", "matching_cluster_idx": 7}]}, "Mbpp/141": {"dps": 57.69715293524818, "dps_norm": 38.888888888888886, "pass@1": 18.0, "profiled": [{"solution": "def pancake_sort(arr):\n    # Helper function to reverse elements from start to index i\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    # Main function to perform pancake sort\n    def find_max(arr, n):\n        mi = 0\n        for i in range(n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the current array\n        mi = find_max(arr, n)\n        \n        # Move the maximum element to the end of the current array\n        if mi != n - 1:\n            # First flip the maximum element to the start\n            flip(arr, mi)\n            # Now flip it to the end\n            flip(arr, n - 1)\n        \n        # Reduce the size of the current array by one\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    # Reverses the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr\ndef find_max_index(arr, n):\n    # Finds the index of the maximum element in the first n elements of the array\n    max_idx = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_idx]:\n            max_idx = i\n    return max_idx\ndef pancake_sort(arr):\n    # Sorts the array using the pancake sort algorithm\n    curr_size = len(arr)\n    while curr_size > 1:\n        # Find the index of the maximum element in the current array\n        max_idx = find_max_index(arr, curr_size)\n        \n        if max_idx != curr_size - 1:\n            # Move the maximum element to the beginning if it's not already there\n            arr = flip(arr, max_idx + 1)\n            # Now move the maximum element to its correct position\n            arr = flip(arr, curr_size)\n        \n        # Reduce the current size of the array\n        curr_size -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the sublist arr[0...i]\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n    \n    # Function to find the index of the maximum element in arr[0...n-1]\n    def find_max(arr, n):\n        max_index = 0\n        for i in range(n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n    \n    # Main function to perform pancake sort\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the current array\n        max_index = find_max(arr, n)\n        \n        # Move the maximum element to the end of the current array\n        if max_index != n - 1:\n            # Flip the maximum element to the beginning\n            flip(arr, max_index)\n            # Flip it to the end\n            flip(arr, n - 1)\n        \n        # Reduce the size of the current array\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in the array\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    # Function to find the index of the maximum element in the first n elements of the array\n    def find_max_index(arr, n):\n        return max(range(n), key=lambda i: arr[i])\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the first n elements\n        max_index = find_max_index(arr, n)\n        \n        # Move the maximum element to the beginning\n        flip(arr, max_index + 1)\n        \n        # Move the maximum element to its correct position\n        flip(arr, n)\n        \n        # Reduce the size of the array to consider\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        # Reverse the elements from the start up to index i\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    def find_max(arr, n):\n        # Find the index of the maximum element in the array up to index n\n        max_idx = 0\n        for i in range(1, n):\n            if arr[i] > arr[max_idx]:\n                max_idx = i\n        return max_idx\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part of the array\n        max_idx = find_max(arr, n)\n        \n        # Move the maximum element to the end of the array\n        if max_idx != n - 1:\n            # Flip the array up to the max element\n            flip(arr, max_idx)\n            # Flip the entire unsorted part to move the max element to the end\n            flip(arr, n - 1)\n        \n        # Reduce the size of the unsorted part of the array\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in the array\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    # Helper function to find the index of the maximum element in the first n elements\n    def find_max_index(arr, n):\n        return max(range(n), key=lambda i: arr[i])\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion of the array\n        max_index = find_max_index(arr, n)\n        \n        # Move the maximum element to the beginning\n        flip(arr, max_index + 1)\n        \n        # Move the maximum element to its correct position\n        flip(arr, n)\n        \n        # Reduce the size of the unsorted portion of the array\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in arr\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    # Function to find the index of the maximum element in the first n elements\n    def find_max(arr, n):\n        max_index = 0\n        for i in range(n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted part of the array\n        max_index = find_max(arr, size)\n        \n        if max_index != size - 1:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index + 1)\n            # Flip the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in the array\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n\n    # Function to find the index of the maximum element in the first n elements\n    def find_max(arr, n):\n        return arr.index(max(arr[:n]))\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the current array\n        max_index = find_max(arr, n)\n        \n        # Move the maximum element to the beginning\n        flip(arr, max_index + 1)\n        \n        # Move the maximum element to its correct position\n        flip(arr, n)\n        \n        # Reduce the size of the array to consider\n        n -= 1\n\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse elements from 0 to i\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            temp = arr[start]\n            arr[start] = arr[i]\n            arr[i] = temp\n            start += 1\n            i -= 1\n    \n    # Main function to sort the array using pancake sort\n    def find_max(arr, n):\n        mi = 0\n        for i in range(n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n    \n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted part\n        mi = find_max(arr, n)\n        \n        # Move the maximum element to the end of the current unsorted part\n        flip(arr, mi)\n        flip(arr, n - 1)\n        \n        # Reduce the size of the unsorted part\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse elements from start to index i\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n\n    # Main function to sort the array using pancake sort\n    def find_max(arr, n):\n        mi = 0\n        for i in range(n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion\n        mi = find_max(arr, n)\n        \n        # Move the maximum element to the beginning if it's not already there\n        if mi != n - 1:\n            flip(arr, mi)\n            # Now flip the maximum element to its correct position\n            flip(arr, n - 1)\n        \n        # Reduce the size of the unsorted portion\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def flip(arr, k):\n    # Reverses the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr\ndef find_max_index(arr, n):\n    # Finds the index of the maximum element in the first n elements of the array\n    max_idx = 0\n    for i in range(n):\n        if arr[i] > arr[max_idx]:\n            max_idx = i\n    return max_idx\ndef pancake_sort(arr):\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current subarray\n        max_idx = find_max_index(arr, size)\n        \n        # Move the maximum element to the end of the current subarray\n        if max_idx != size - 1:\n            # If the maximum element is not already at the end, flip it to the front\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            # Then flip it to the end\n            arr = flip(arr, size)\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in the array\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n\n    # Function to find the index of the maximum element in the first k elements\n    def find_max_index(arr, k):\n        return max(range(k), key=lambda i: arr[i])\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the current array slice\n        max_index = find_max_index(arr, size)\n        \n        # Move the maximum element to the beginning\n        flip(arr, max_index + 1)\n        \n        # Move the maximum element to its correct position\n        flip(arr, size)\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Function to reverse the order of elements from the start to the ith index\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            temp = arr[start]\n            arr[start] = arr[i]\n            arr[i] = temp\n            start += 1\n            i -= 1\n\n    # Main function to perform pancake sort\n    def find_max(arr, n):\n        # Find the index of the maximum element in arr[0..n-1]\n        mi = 0\n        for i in range(0, n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the current array\n        mi = find_max(arr, n)\n        # Move the maximum element to the end of the current array\n        flip(arr, mi)\n        flip(arr, n - 1)\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in the array\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    # Main function to perform pancake sort\n    def sort(arr):\n        n = len(arr)\n        # Start with the entire array and reduce the size by one after each iteration\n        for size in range(n, 1, -1):\n            # Find the index of the maximum element in the current subarray\n            max_index = arr.index(max(arr[0:size]))\n            \n            # Move the maximum element to the end of the current subarray\n            if max_index != size - 1:\n                # Flip the maximum element to the beginning if it's not already there\n                if max_index != 0:\n                    flip(arr, max_index + 1)\n                # Flip the maximum element to the end\n                flip(arr, size)\n    \n    # Perform the sort\n    sort(arr)\n    return arr", "matching_cluster_idx": 3}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements of arr\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    # Function to find the index of the maximum element in the first k elements\n    def find_max_index(arr, n):\n        max_index = 0\n        for i in range(n):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        return max_index\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the unsorted portion of the array\n        max_index = find_max_index(arr, n)\n        \n        # Move the maximum element to the beginning\n        flip(arr, max_index + 1)\n        \n        # Move the maximum element to its correct position\n        flip(arr, n)\n        \n        # Reduce the size of the unsorted portion of the array\n        n -= 1\n    \n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the sublist arr[0...i]\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n    \n    # Main function to perform pancake sort\n    def find_max(arr, n):\n        # Find the index of the maximum element in arr[0...n-1]\n        mi = 0\n        for i in range(0, n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the current array\n        mi = find_max(arr, n)\n        \n        # Move the maximum element to the end of the current array\n        if mi != n - 1:\n            # Flip the maximum number to the beginning\n            flip(arr, mi)\n            # Flip it to the end\n            flip(arr, n - 1)\n        \n        # Reduce the size of the current array\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse elements from 0 to index i\n    def flip(arr, i):\n        start = 0\n        while start < i:\n            arr[start], arr[i] = arr[i], arr[start]\n            start += 1\n            i -= 1\n    \n    # Main function to sort the array\n    def find_max(arr, n):\n        # Find the index of the maximum element in arr[0...n-1]\n        mi = 0\n        for i in range(n):\n            if arr[i] > arr[mi]:\n                mi = i\n        return mi\n\n    # Length of the current array\n    n = len(arr)\n    while n > 1:\n        # Find the index of the maximum element in the current array\n        max_index = find_max(arr, n)\n        \n        # Move the maximum element to the end of the current array\n        flip(arr, max_index)\n        flip(arr, n-1)\n        \n        # Reduce the size of the current array\n        n -= 1\n\n    return arr", "matching_cluster_idx": 2}, {"solution": "def pancake_sort(arr):\n    # Helper function to reverse the order of the first k elements in the array\n    def flip(arr, k):\n        arr[:k] = arr[:k][::-1]\n    \n    # Helper function to find the index of the maximum element in the first n elements of the array\n    def find_max_index(arr, n):\n        return max(range(n), key=lambda i: arr[i])\n    \n    n = len(arr)\n    for size in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion of the array\n        max_index = find_max_index(arr, size)\n        if max_index + 1 != size:\n            # Move the maximum element to the beginning\n            flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            flip(arr, size)\n    \n    return arr", "matching_cluster_idx": 2}]}, "Mbpp/166": {"dps": 94.39999999999999, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the list\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize count of pairs that XOR to an even number\n    count = 0\n    \n    # Iterate through the array to find all pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the list with two nested loops\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the list to check each pair\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the list to find all pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each pair of elements in the list\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize count of pairs\n    count = 0\n    \n    # Iterate through the list to find pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the list to find pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through the list to find pairs\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}, {"solution": "def find_even_pair(arr):\n    # Initialize the count of pairs\n    count = 0\n    \n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # Check if the XOR of the pair is even\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n                \n    return count", "matching_cluster_idx": 1}]}, "Mbpp/170": {"dps": 89.78260869565217, "dps_norm": 94.375, "pass@1": 100.0, "profiled": [{"solution": "def sum_range_list(nums, start, end):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through the list from the start index to the end index (inclusive)\n    for i in range(start, end + 1):\n        total_sum += nums[i]\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of elements in the list from index 'start' to 'end' (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of elements in the list from index 'start' to index 'end' (inclusive)\n    return sum(nums[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of the numbers in the list from index 'start' to index 'end' (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Initialize the sum to zero\n    total_sum = 0\n    \n    # Iterate over the range from start to end (inclusive)\n    for i in range(start, end + 1):\n        # Add the current element to the sum\n        total_sum += nums[i]\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of numbers in the list from index 'start' to 'end' (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of elements from index 'start' to index 'end' (inclusive)\n    return sum(nums[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of elements in the list from index 'start' to 'end' (inclusive)\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Ensure the start and end indices are within the list bounds\n    if start < 0 or end >= len(nums) or start > end:\n        return 0\n    \n    # Calculate the sum of the elements in the specified range\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of elements in the list from index 'start' to index 'end' (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of elements from index 'start' to 'end' (inclusive)\n    return sum(nums[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Ensure the start index is less than or equal to the end index\n    if start > end:\n        return 0\n    \n    # Calculate the sum of the numbers in the specified range\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of elements in the list from index 'start' to 'end' (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of the elements in the list from index 'start' to index 'end' (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Sum the elements in the list from index 'start' to 'end' (inclusive)\n    return sum(lst[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Calculate the sum of the elements in the list from index start to end (inclusive)\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Ensure the start and end indices are within the bounds of the list\n    if start < 0 or end >= len(nums) or start > end:\n        return 0\n    \n    # Calculate the sum of the elements between the specified indices\n    return sum(nums[start:end+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(lst, start, end):\n    # Calculate the sum of elements from the start index to the end index (inclusive)\n    return sum(lst[start:end + 1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, left, right):\n    # Calculate the sum of the elements in the list from index 'left' to 'right' (inclusive)\n    return sum(nums[left:right+1])", "matching_cluster_idx": 7}, {"solution": "def sum_range_list(nums, start, end):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through the range from start to end (inclusive)\n    for i in range(start, end + 1):\n        # Add the number at the current index to the total sum\n        total_sum += nums[i]\n    \n    return total_sum", "matching_cluster_idx": 4}]}, "Mbpp/226": {"dps": 68.60465116279069, "dps_norm": 15.0, "pass@1": 100.0, "profiled": [{"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result_string = ''\n    \n    # Iterate over the string using its indices\n    for i in range(len(input_string)):\n        # Check if the index is even (0-based index)\n        if i % 2 == 0:\n            # Append the character at the current index to the result string\n            result_string += input_string[i]\n    \n    return result_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate through the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (since index starts at 0, even index means odd position)\n        if index % 2 == 0:\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (since indexing starts at 0, even indices correspond to odd positions)\n        if i % 2 == 0:\n            # Append the character at the current index to the result string\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (considering 0-based indexing)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    \n    # Return the final result string\n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using its indices\n    for i in range(len(s)):\n        # Check if the index is even (since indices start at 0)\n        if i % 2 == 0:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store characters at even indices\n    result_string = ''\n    \n    # Iterate through the string using enumerate to get both index and character\n    for index, char in enumerate(input_string):\n        # Check if the index is even (since index starts from 0, even index means odd position)\n        if index % 2 == 0:\n            result_string += char\n    \n    return result_string", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate through the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (since index starts from 0, even index means odd position)\n        if index % 2 == 0:\n            result += char  # Append the character to the result string\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate through the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (considering 0 as an even index)\n        if index % 2 == 0:\n            result += char  # Append the character to the result string\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for i, char in enumerate(s):\n        # Check if the index is even (0-based indexing)\n        if i % 2 == 0:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(input_string):\n        # Check if the index is even (0-based index)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (since index starts from 0, even index corresponds to odd position)\n        if index % 2 == 0:\n            result += char  # Append the character to the result if the index is even\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for index in range(len(input_string)):\n        # Check if the index is even (since index starts from 0)\n        if index % 2 == 0:\n            # Append the character at the current index to the result\n            result += input_string[index]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using its index\n    for index in range(len(input_string)):\n        # Check if the index is even (considering index 0 as even)\n        if index % 2 == 0:\n            # Append the character at the current index to the result\n            result += input_string[index]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (since index starts from 0, even index means odd position)\n        if index % 2 == 0:\n            # Append the character to the result\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(input_string):\n        # Check if the index is even (since index starts at 0, even index means odd position)\n        if index % 2 == 0:\n            result += char  # Append the character to the result if the index is even\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (considering 0 as even)\n        if index % 2 == 0:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store the result\n    result_string = ''\n    \n    # Iterate through the string, considering only even indices\n    for i in range(0, len(input_string), 2):\n        result_string += input_string[i]\n    \n    return result_string", "matching_cluster_idx": 1}, {"solution": "def odd_values_string(input_string):\n    # Initialize an empty string to store characters at even indices\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(input_string):\n        # Check if the index is even (since index starts from 0, even index means odd position)\n        if index % 2 == 0:\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (since index starts from 0, even index means odd position in human terms)\n        if index % 2 == 0:\n            result += char  # Append the character to the result string\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def odd_values_string(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (since index starts from 0, even index means odd position)\n        if index % 2 == 0:\n            result += char  # Append the character to the result string\n    \n    return result", "matching_cluster_idx": 0}]}, "Mbpp/230": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_blank(input_string, char):\n    # Replace all blank spaces in the input_string with the specified character\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all spaces in the input_string with replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    return modified_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all blank spaces in the input_string with replacement_char\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all spaces in the string `s` with the character `char`\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all blank spaces in the string 's' with the character 'char'\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all spaces in the string 's' with the character 'char'\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    # Replace all blank spaces in the string 's' with the character 'ch'\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    # Replace all spaces in the input_string with the specified character\n    modified_string = input_string.replace(' ', char)\n    return modified_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(string, character):\n    # Replace all blank spaces in the string with the specified character\n    return string.replace(' ', character)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    # Replace all spaces in the input_string with the specified character\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all spaces in the input_string with the replacement_char\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all blank spaces in the string `s` with the character `char`\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all blank spaces in the input_string with the replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    return modified_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all spaces in the input_string with the replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    return modified_string", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all spaces in the string `s` with the character `char`\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    # Replace all spaces in the string 's' with the character 'ch'\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, replacement_char):\n    # Replace all blank spaces in the input_string with replacement_char\n    return input_string.replace(' ', replacement_char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, char):\n    # Replace all occurrences of blank spaces in the string `s` with the character `char`\n    return s.replace(' ', char)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(s, ch):\n    # Replace all spaces in the string 's' with the character 'ch'\n    return s.replace(' ', ch)", "matching_cluster_idx": 7}, {"solution": "def replace_blank(input_string, char):\n    # Replace all blank spaces in the input_string with the specified character\n    return input_string.replace(' ', char)", "matching_cluster_idx": 7}]}, "Mbpp/239": {"dps": 70.86206896551724, "dps_norm": 74.5, "pass@1": 26.0, "profiled": [{"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a DP table with dimensions (n+1) x (m+1)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Base case: There's one way to form a sequence of length 0\n    for j in range(m + 1):\n        dp[0][j] = 1\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j // 2]\n    \n    # The answer is the value in dp[n][m]\n    return dp[n][m]", "matching_cluster_idx": 8}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Initialize a 2D DP array with all zeros\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Base case: There's exactly one way to form a sequence of length 1\n    for i in range(1, m + 1):\n        dp[i][1] = 1\n    \n    # Fill the DP table\n    for length in range(2, n + 1):\n        for current in range(1, m + 1):\n            # Sum all valid previous elements\n            for previous in range(1, current // 2 + 1):\n                dp[current][length] += dp[previous][length - 1]\n    \n    # Sum all possible sequences of length n\n    result = sum(dp[i][n] for i in range(1, m + 1))\n    \n    return result", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to find the number of valid sequences using recursion\n    def count_sequences(prev, remaining, m):\n        # Base case: if no more elements are needed, there's one valid sequence\n        if remaining == 0:\n            return 1\n        # Initialize the count of valid sequences\n        count = 0\n        # Start from the next possible element (prev * 2) up to m\n        for next_val in range(max(1, 2 * prev), m + 1):\n            # Recursively count the sequences with the next value\n            count += count_sequences(next_val, remaining - 1, m)\n        return count\n\n    # Start the recursion with an initial previous value of 0\n    return count_sequences(0, n, m)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: If n is 0, there is only one sequence, the empty sequence.\n    if n == 0:\n        return 1\n    \n    # Base case: If n is 1, each number from 1 to m can be a sequence.\n    if n == 1:\n        return m\n    \n    # Initialize a list to store the number of sequences ending with each number.\n    dp = [0] * (m + 1)\n    \n    # Initialize the first row of the DP table.\n    for i in range(1, m + 1):\n        dp[i] = 1\n    \n    # Fill the DP table.\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        for i in range(1, m + 1):\n            for j in range(1, (i // 2) + 1):\n                new_dp[i] += dp[j]\n        dp = new_dp\n    \n    # Sum up the number of sequences of length n ending with any number from 1 to m.\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base cases: if n is 0, there's only one sequence (an empty one)\n    if n == 0:\n        return 1\n    # If n is 1, each number from 1 to m can be a valid sequence\n    if n == 1:\n        return m\n    \n    # Initialize a list to store the number of sequences\n    dp = [0] * (m + 1)\n    \n    # There's only one sequence of length 1 for each number from 1 to m\n    for i in range(1, m + 1):\n        dp[i] = 1\n    \n    # Compute the number of sequences for lengths from 2 to n\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        for i in range(1, m + 1):\n            # The number of sequences ending at i is the sum of sequences ending at j where 1 <= j <= i // 2\n            new_dp[i] = sum(dp[j] for j in range(1, (i // 2) + 1))\n        dp = new_dp\n    \n    # The answer is the sum of all possible sequences of length n\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: if n is 1, there are m possible sequences (1 to m)\n    if n == 1:\n        return m\n    \n    # Initialize a list to store the number of sequences for each starting number\n    dp = [0] * (m + 1)\n    \n    # There is exactly one sequence of length 1 for each starting number\n    for i in range(1, m + 1):\n        dp[i] = 1\n    \n    # Calculate the number of sequences for lengths from 2 to n\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        for start in range(1, m + 1):\n            for next_val in range(start * 2, m + 1):\n                new_dp[next_val] += dp[start]\n        dp = new_dp\n    \n    # Sum up the number of sequences starting from each number\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to find the number of valid sequences\n    def count_sequences(prev, remaining, memo):\n        # Base case: if no more elements are left to be chosen, a valid sequence is formed\n        if remaining == 0:\n            return 1\n        # If the current state is already computed, return the stored result\n        if (prev, remaining) in memo:\n            return memo[(prev, remaining)]\n        \n        count = 0\n        # Start from the next possible number and try to build the sequence\n        start = 1 if prev == 0 else (prev * 2)\n        for i in range(start, m + 1):\n            count += count_sequences(i, remaining - 1, memo)\n        \n        # Store the result in the memo dictionary\n        memo[(prev, remaining)] = count\n        return count\n\n    # Initialize memoization dictionary\n    memo = {}\n    # Start the sequence with no previous element and the full length of the sequence\n    return count_sequences(0, n, memo)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to find the number of valid sequences\n    def count_sequences(prev, remaining, memo):\n        if remaining == 0:\n            return 1\n        if (prev, remaining) in memo:\n            return memo[(prev, remaining)]\n        \n        count = 0\n        start = prev * 2 if prev > 0 else 1\n        for i in range(start, m + 1):\n            count += count_sequences(i, remaining - 1, memo)\n        \n        memo[(prev, remaining)] = count\n        return count\n    \n    return count_sequences(0, n, {})", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: if n is 0, there is exactly one sequence: the empty sequence\n    if n == 0:\n        return 1\n    # Base case: if m is 0, there are no positive integers to form sequences\n    if m == 0:\n        return 0\n\n    # Initialize a list to store the count of sequences ending with each number\n    dp = [0] * (m + 1)\n\n    # There is exactly one sequence of length 1 for each number from 1 to m\n    for i in range(1, m + 1):\n        dp[i] = 1\n\n    # Compute the number of sequences for lengths from 2 to n\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        for i in range(1, m + 1):\n            # Sum up the sequences where the current number is at least twice the previous number\n            for j in range(1, i // 2 + 1):\n                new_dp[i] += dp[j]\n        dp = new_dp\n\n    # The result is the sum of all sequences of length n ending with any number from 1 to m\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to find the number of sequences using dynamic programming\n    def count_sequences(dp, m, n, last=0, start=1):\n        if n == 0:\n            return 1\n        if dp[last][n] != -1:\n            return dp[last][n]\n        \n        dp[last][n] = 0\n        for i in range(start, m + 1):\n            if i >= 2 * last:\n                dp[last][n] += count_sequences(dp, m, n - 1, i, i)\n        return dp[last][n]\n    \n    # Initialize the DP table with -1\n    dp = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Start the recursive function\n    return count_sequences(dp, m, n)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to count sequences\n    def count_sequences(remaining_length, last_value):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for i in range(max(1, last_value * 2), m + 1):\n            count += count_sequences(remaining_length - 1, i)\n        return count\n\n    return count_sequences(n, 0)", "matching_cluster_idx": 3}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: if n is 1, there are m possible sequences (1 to m)\n    if n == 1:\n        return m\n    \n    # Initialize a list to store the count of valid sequences ending with each number\n    dp = [0] * (m + 1)\n    \n    # Initialize the first row of the DP table\n    for i in range(1, m + 1):\n        dp[i] = 1\n    \n    # Fill the DP table\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        for end in range(1, m + 1):\n            for start in range(1, (end // 2) + 1):\n                new_dp[end] += dp[start]\n        dp = new_dp\n    \n    # Sum up all possible sequences of length n\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: if n is 0, there's one empty sequence\n    if n == 0:\n        return 1\n    \n    # Base case: if m is less than the smallest possible value for the first element, return 0\n    if m < 1:\n        return 0\n    \n    # Recursive case: count sequences starting with 1 and those starting with a higher number\n    return get_total_number_of_sequences(m // 2, n - 1) + get_total_number_of_sequences(m - 1, n)", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: if n is 0, there is only one sequence: the empty sequence.\n    if n == 0:\n        return 1\n    # Base case: if m is less than 2 * (n - 1), it's impossible to form such a sequence.\n    if m < 2 * (n - 1):\n        return 0\n    \n    # Initialize the dynamic programming table\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # There is exactly one way to form a sequence of length 0\n    for i in range(m + 1):\n        dp[0][i] = 1\n    \n    # Fill the DP table\n    for length in range(1, n + 1):\n        for value in range(1, m + 1):\n            dp[length][value] = dp[length][value - 1] + dp[length - 1][value // 2]\n    \n    # The answer is the number of sequences of length n with maximum value m\n    return dp[n][m]", "matching_cluster_idx": 9}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to count sequences recursively\n    def count_sequences(prev, length):\n        if length == 0:\n            return 1\n        count = 0\n        start = prev * 2 if prev > 0 else 1\n        for i in range(start, m + 1):\n            count += count_sequences(i, length - 1)\n        return count\n\n    # Start the recursion with no previous element and the full length\n    return count_sequences(0, n)", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: If n is 0, there's only one sequence: the empty sequence.\n    if n == 0:\n        return 1\n    \n    # Base case: If n is 1, each number from 1 to m is a valid sequence.\n    if n == 1:\n        return m\n    \n    # Initialize a list to store the number of valid sequences for each starting number.\n    dp = [0] * (m + 1)\n    \n    # For a sequence of length 1, any number from 1 to m is valid.\n    for i in range(1, m + 1):\n        dp[i] = 1\n    \n    # Calculate the number of valid sequences for lengths 2 to n.\n    for length in range(2, n + 1):\n        new_dp = [0] * (m + 1)\n        for i in range(1, m + 1):\n            for j in range(i * 2, m + 1):\n                new_dp[j] += dp[i]\n        dp = new_dp\n    \n    # Sum up all the valid sequences starting from each number.\n    return sum(dp)", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to count sequences recursively\n    def count_sequences(start, remaining_length):\n        if remaining_length == 0:\n            return 1\n        count = 0\n        for i in range(start, m + 1):\n            count += count_sequences(i * 2, remaining_length - 1)\n        return count\n\n    # Start the sequence with the first element being 1\n    return count_sequences(1, n)", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Helper function to find sequences using depth-first search (DFS)\n    def dfs(start, length, m):\n        if length == 0:\n            return 1\n        count = 0\n        for i in range(start, m + 1):\n            count += dfs(i * 2, length - 1, m)\n        return count\n    \n    # Start the DFS from 1 with the full length n\n    return dfs(1, n, m)", "matching_cluster_idx": 5}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: If n is 0, there is exactly one sequence: the empty sequence.\n    if n == 0:\n        return 1\n    # Base case: If n is 1, each number from 1 to m is a valid sequence.\n    if n == 1:\n        return m\n\n    # Initialize the dynamic programming table\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    # Fill the table\n    for i in range(1, m + 1):\n        dp[i][1] = i  # If n is 1, there are i possible sequences for each i\n\n    for j in range(2, n + 1):\n        for i in range(1, m + 1):\n            dp[i][j] = dp[i - 1][j]  # Exclude the current number\n            if i >= 2:\n                dp[i][j] += dp[i // 2][j - 1]  # Include the current number\n\n    return dp[m][n]", "matching_cluster_idx": 7}, {"solution": "def get_total_number_of_sequences(m, n):\n    # Base case: If n is 1, there are m possible sequences (each number from 1 to m)\n    if n == 1:\n        return m\n    \n    # Base case: If m is less than 2^(n-1), no valid sequences can be formed\n    if m < (1 << (n - 1)):\n        return 0\n    \n    # Recursive case: Calculate the number of sequences by considering the last element\n    return get_total_number_of_sequences(m // 2, n - 1) + get_total_number_of_sequences(m - 1, n)", "matching_cluster_idx": 9}]}, "Mbpp/240": {"dps": 93.17073170731709, "dps_norm": 96.11111111111111, "pass@1": 100.0, "profiled": [{"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with all elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with all elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with the elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with all elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with the elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with all elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with the elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with the elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with elements from lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with all elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with all elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with the elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with all elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of the first list\n    lst1.pop()\n    # Extend the first list with the elements of the second list\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with the elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}, {"solution": "def replace_list(lst1, lst2):\n    # Replace the last element of lst1 with all elements of lst2\n    lst1[-1:] = lst2\n    return lst1", "matching_cluster_idx": 7}, {"solution": "def replace_list(lst1, lst2):\n    # Remove the last element of lst1\n    lst1.pop()\n    # Extend lst1 with all elements of lst2\n    lst1.extend(lst2)\n    return lst1", "matching_cluster_idx": 8}]}, "Mbpp/251": {"dps": 91.95402298850576, "dps_norm": 77.77777777777777, "pass@1": 100.0, "profiled": [{"solution": "def insert_element(lst, element):\n    # Initialize an empty result list\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate over each item in the original list\n    for item in lst:\n        # Insert the given element before the current item\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element to be inserted before the current item\n        result.append(element)\n        # Append the current item\n        result.append(item)\n    # Return the resulting list\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate over each item in the original list\n    for item in lst:\n        # Append the element to be inserted\n        result.append(element)\n        # Append the current item\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate through each item in the original list\n    for item in lst:\n        # Append the element and then the item to the result list\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    \n    # Iterate through each item in the original list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    \n    # Iterate over each item in the original list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the original list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the original list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Create a new list to store the result\n    result = []\n    # Iterate through each item in the original list\n    for item in lst:\n        # Append the given element before the current item\n        result.append(element)\n        result.append(item)\n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the element and then the item to the result list\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Insert the specified element before the current item\n        result.append(element)\n        result.append(item)\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/256": {"dps": 57.89954337899543, "dps_norm": 54.11764705882353, "pass@1": 100.0, "profiled": [{"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Iterate through each number from 2 to n-1\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check divisibility by any number from 2 to the square root of num\n        for divisor in range(2, int(num**0.5) + 1):\n            if num % divisor == 0:\n                # If divisible, it's not a prime number\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Iterate through numbers from 2 up to (but not including) n\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check divisibility from 2 up to the square root of num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not prime\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize the count of prime numbers\n    count = 0\n    \n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Iterate through numbers less than n to count primes\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Define a helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Count the number of prime numbers less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    \n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Iterate through numbers less than n and count primes\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    \n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Iterate through all numbers less than n and count primes\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is prime\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    # Count the number of prime numbers less than the given number\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}, {"solution": "def count_Primes_nums(n):\n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Count the number of prime numbers less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    \n    # Function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Iterate through numbers less than n and count primes\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    \n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Iterate over each number from 2 up to (but not including) n\n    for num in range(2, n):\n        # Assume the number is prime until proven otherwise\n        is_prime = True\n        # Check divisibility by all numbers from 2 to the square root of num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not prime\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Loop through numbers from 2 to n-1\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check divisibility by any number from 2 to the square root of num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not a prime number\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is prime\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    # Count the number of prime numbers less than the given number\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Iterate through each number from 2 to n-1\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check divisibility by any number from 2 to the square root of num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not a prime number\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is a prime number\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    # Count the number of prime numbers less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Loop through numbers from 2 to n-1\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check divisibility by any number from 2 to the square root of num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not a prime number\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Loop through all numbers from 2 to n-1\n    for num in range(2, n):\n        # Assume the number is prime\n        is_prime = True\n        # Check divisibility from 2 to the square root of num\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                # If divisible, it's not prime\n                is_prime = False\n                break\n        # If the number is prime, increment the counter\n        if is_prime:\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is a prime number\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(num):\n    # Count the number of prime numbers less than the given number\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is a prime number\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    # Count the number of prime numbers less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(num):\n    # Check if a number is a prime number\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef count_Primes_nums(n):\n    # Count the number of prime numbers less than n\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 8}, {"solution": "def is_prime(n):\n    # Check if a number is a prime number\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\ndef count_Primes_nums(num):\n    # Count the number of prime numbers less than the given number\n    count = 0\n    for i in range(2, num):\n        if is_prime(i):\n            count += 1\n    return count", "matching_cluster_idx": 10}]}, "Mbpp/265": {"dps": 67.26744186046511, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def list_split(lst, n):\n    # Create a list of lists, where each sublist contains elements at positions\n    # that are multiples of the current index when divided by n\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Create a list of lists, where each sublist contains elements from the original list\n    # starting from index i and taking every nth element.\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the split lists\n    result = []\n    \n    # Loop from 0 to n-1 to create n lists\n    for i in range(n):\n        # Use list comprehension to collect every nth element starting from i\n        result.append([lst[j] for j in range(i, len(lst), n)])\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Create a list of lists by slicing the original list every nth element\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create an empty list of lists to hold the result\n    result = [[] for _ in range(n)]\n    \n    # Iterate over the list, placing each element in the appropriate sublist\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n    \n    return result", "matching_cluster_idx": 3}, {"solution": "def list_split(lst, n):\n    # Create a list of lists where each inner list contains elements from the original list\n    # starting from index i and skipping n-1 elements each time\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create a list of lists, where each inner list contains elements at positions\n    # that are multiples of n, starting from the index 0 up to n-1\n    result = [[] for _ in range(n)]\n    for i in range(len(lst)):\n        result[i % n].append(lst[i])\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Split the list for every nth element and return a list of the resulting lists\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to hold the result\n    result = []\n    \n    # Loop through the range of n to create n sublists\n    for i in range(n):\n        # Create a sublist starting from the i-th element, taking every n-th element\n        sub_list = lst[i::n]\n        # Append the sublist to the result list\n        result.append(sub_list)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the range of n to create sublists\n    for i in range(n):\n        # Use list comprehension to collect every nth element starting from i\n        sublist = [lst[j] for j in range(i, len(lst), n)]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Create a list of lists by splitting the original list every nth element\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list of lists to store the result\n    result = []\n    \n    # Iterate over the range of n to create n sublists\n    for i in range(n):\n        # Create a sublist by slicing the original list starting from i and taking every nth element\n        sublist = lst[i::n]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create a list of lists, where each inner list contains elements from the original list\n    # at positions that are multiples of n, starting from each of the first n elements.\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Create a list of lists by slicing the original list at intervals of n\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 1}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list of lists to store the result\n    result = []\n    \n    # Loop through the range of n to create n sublists\n    for i in range(n):\n        # Create a sublist starting from the ith element and taking every nth element\n        sublist = lst[i::n]\n        # Append the sublist to the result list\n        result.append(sublist)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Initialize an empty list of lists to hold the result\n    result = []\n    \n    # Create n empty sublists in the result list\n    for _ in range(n):\n        result.append([])\n    \n    # Distribute elements of the original list into the sublists\n    for index, item in enumerate(lst):\n        result[index % n].append(item)\n    \n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create a list of lists, where each inner list contains elements at positions that are multiples of n, starting from 0 to n-1\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Split the list into sublists for every nth element\n    return [lst[i::n] for i in range(n)]", "matching_cluster_idx": 5}, {"solution": "def list_split(lst, n):\n    # Create a list of lists by slicing the original list at intervals of n\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 4}, {"solution": "def list_split(lst, n):\n    # Create a list of lists where each sublist contains elements at positions that are multiples of n, starting from 0 to n-1\n    result = [lst[i::n] for i in range(n)]\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/281": {"dps": 94.05, "dps_norm": 82.27272727272727, "pass@1": 100.0, "profiled": [{"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is the same as the list, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    # If lengths are equal, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is the same as the length of the list, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare lengths\n    # If lengths are the same, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Use a set to track unique elements\n    seen = set()\n    for item in data:\n        # If the item is already in the set, return False\n        if item in seen:\n            return False\n        # Otherwise, add the item to the set\n        seen.add(item)\n    # If all items are unique, return True\n    return True", "matching_cluster_idx": 9}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare the lengths\n    # If lengths are the same, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    # If they are equal, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length with the original list\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    # If they are equal, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is the same as the length of the list, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare lengths\n    # If lengths are the same, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    # If they are the same, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length to the original list's length\n    # If lengths are equal, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare the lengths\n    # If lengths are the same, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare lengths\n    # If lengths are the same, all elements are unique\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}, {"solution": "def all_unique(data):\n    # Convert the list to a set and compare its length with the original list\n    return len(data) == len(set(data))", "matching_cluster_idx": 8}]}, "Mbpp/296": {"dps": 28.205128205128204, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count to 0\n    inv_count = 0\n    # Iterate over each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with all subsequent elements\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare with each subsequent element\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the number of inversions to 0\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with the rest of the elements in the array\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count to 0\n    inv_count = 0\n    # Iterate over each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with all subsequent elements\n        for j in range(i + 1, len(arr)):\n            # If a pair (arr[i], arr[j]) forms an inversion, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count to 0\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count\n    inv_count = 0\n    # Traverse through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize the inversion count to 0\n    inv_count = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    # Initialize inversion count to 0\n    inv_count = 0\n    # Iterate through each element in the array\n    for i in range(len(arr)):\n        # Compare the current element with the elements that come after it\n        for j in range(i + 1, len(arr)):\n            # If an inversion is found, increment the count\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}, {"solution": "def get_Inv_Count(arr):\n    n = len(arr)\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count", "matching_cluster_idx": 3}]}, "Mbpp/308": {"dps": 97.58620689655173, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def large_product(list1, list2, num):\n    # Sort both lists in descending order to get the largest values first\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, k):\n    # Sort both lists in descending order to get the largest products\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Initialize a list to store the products\n    products = []\n    \n    # Calculate the product of each combination of elements from both lists\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first k elements from the sorted products list\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products between elements of list1 and list2\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products between elements of list1 and list2\n    products = sorted([x * y for x in list1 for y in list2], reverse=True)\n    \n    # Return the first 'num' largest products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(nums1, nums2, k):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Compute the product of each pair (x, y) where x is from nums1 and y is from nums2\n    for x in nums1:\n        for y in nums2:\n            products.append(x * y)\n    \n    # Sort the list of products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first k elements from the sorted list\n    return products[:k]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products by taking one element from each list\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(lst1, lst2, num):\n    # Generate all possible products from elements of lst1 and lst2\n    products = [x * y for x in lst1 for y in lst2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' elements from the sorted products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order to get the largest products\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products from the sorted list\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Compute all possible products between elements of list1 and list2\n    for i in list1:\n        for j in list2:\n            products.append(i * j)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' elements from the sorted list\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Iterate through each element in the first list\n    for i in list1:\n        # Iterate through each element in the second list\n        for j in list2:\n            # Calculate the product and append it to the products list\n            products.append(i * j)\n    \n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' elements from the sorted list\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Iterate through each element in list1\n    for i in list1:\n        # Iterate through each element in list2\n        for j in list2:\n            # Calculate the product of the two elements\n            product = i * j\n            # Append the product to the products list\n            products.append(product)\n    \n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' elements from the sorted products list\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order to get the largest products\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order and get the top n products\n    products.sort(reverse=True)\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products from elements of list1 and list2\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products from the sorted list\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Iterate through each element in the first list\n    for num1 in list1:\n        # Iterate through each element in the second list\n        for num2 in list2:\n            # Calculate the product and add it to the products list\n            products.append(num1 * num2)\n    \n    # Sort the products list in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n elements from the sorted list\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Generate all possible products between elements of the two lists\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n products from the sorted list\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products from the two lists\n    products = sorted([x * y for x in list1 for y in list2], reverse=True)\n    \n    # Return the first 'num' elements from the sorted products list\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products between elements of list1 and list2\n    products = sorted([x * y for x in list1 for y in list2], reverse=True)\n    \n    # Return the first 'num' elements from the sorted products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Sort both lists in descending order to get the largest elements first\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    \n    # Initialize an empty list to store the products\n    products = []\n    \n    # Calculate the product of each element in list1 with each element in list2\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n largest products\n    return products[:n]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, num):\n    # Generate all possible products between elements of list1 and list2\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'num' elements from the sorted products\n    return products[:num]", "matching_cluster_idx": 3}, {"solution": "def large_product(list1, list2, n):\n    # Calculate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n elements from the sorted list\n    return products[:n]", "matching_cluster_idx": 3}]}, "Mbpp/392": {"dps": 89.15492957746478, "dps_norm": 89.23076923076923, "pass@1": 92.0, "profiled": [{"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Compute the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than 2, the maximum sum is n itself\n    if n < 2:\n        return n\n    \n    # Compute the maximum sum using the given formula\n    # Also, include n itself as a potential maximum\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the computed result in memo to avoid redundant calculations\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than 2, return n\n    if n < 2:\n        return n\n    \n    # Recursive case: calculate the maximum sum using the given equation\n    return max(n, get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5))", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Compute the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in the memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than or equal to 1, the sum is n itself\n    if n <= 1:\n        return n\n    \n    # Calculate the sum using the given equation\n    sum_with_division = get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo)\n    \n    # Determine the maximum between the calculated sum and the number itself\n    result = max(sum_with_division, n)\n    \n    # Store the result in the memo dictionary\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is 0, the sum is 0\n    if n == 0:\n        return 0\n    \n    # Recursive case: calculate the sum using the given equation\n    return max(n, get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5))", "matching_cluster_idx": 2}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is 0 or 1, return n\n    if n <= 1:\n        return n\n    \n    # Recursive case: compute the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in the memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than the smallest integer that can be divided by 2, 3, 4, and 5\n    if n < 2:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo to avoid recomputation\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is 0 or 1, return n\n    if n <= 1:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    result = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in the memo dictionary\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than or equal to 5, return n\n    if n <= 5:\n        return n\n    \n    # Recursive case: calculate the maximum of n and the sum of f(n/2), f(n/3), f(n/4), f(n/5)\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo to avoid redundant calculations\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Compute the maximum sum using the given formula\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Compute the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is 0 or 1, the sum is n itself\n    if n == 0 or n == 1:\n        return n\n    \n    # Compute the maximum sum using the given formula\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in the memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Base case: if n is less than or equal to 0, return 0\n    if n <= 0:\n        return 0\n    \n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Compute the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo to avoid redundant calculations\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is 0 or 1, the sum is n itself\n    if n <= 1:\n        return n\n    \n    # Recursive case: compute the maximum sum using the given equation\n    result = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in the memo dictionary to avoid redundant calculations\n    memo[n] = result\n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than 6, return n\n    if n < 6:\n        return n\n    \n    # Recursive case: compute the sum of f(n/2), f(n/3), f(n/4), and f(n/5)\n    result = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo to avoid redundant calculations\n    memo[n] = result\n    \n    return result", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n    \n    # Recursive case: calculate the maximum sum using the given equation\n    return max(n, get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5))", "matching_cluster_idx": 3}, {"solution": "def get_max_sum(n, memo={}):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than 2, return n\n    if n < 2:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in the memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "memo = {}\ndef get_max_sum(n):\n    # Check if the result is already computed\n    if n in memo:\n        return memo[n]\n    \n    # Base case: if n is less than 2, return n\n    if n < 2:\n        return n\n    \n    # Calculate the maximum sum using the given equation\n    # f(n) = max(f(n/2) + f(n/3) + f(n/4) + f(n/5), n)\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    \n    # Store the result in the memo dictionary\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}, {"solution": "def get_max_sum(n, memo={}):\n    # Base case: if n is 0 or 1, return n\n    if n == 0 or n == 1:\n        return n\n    \n    # Check if the result is already computed and stored in memo\n    if n in memo:\n        return memo[n]\n    \n    # Compute the maximum sum using the given equation\n    max_sum = max(n, get_max_sum(n // 2, memo) + get_max_sum(n // 3, memo) + get_max_sum(n // 4, memo) + get_max_sum(n // 5, memo))\n    \n    # Store the result in memo to avoid recomputation\n    memo[n] = max_sum\n    \n    return max_sum", "matching_cluster_idx": 12}]}, "Mbpp/395": {"dps": 98.08429118773947, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass to count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Iterate over the string to populate the dictionary\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate over the string again to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass: count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to keep track of character counts\n    char_count = {}\n    \n    # Iterate over the string to populate the dictionary\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate over the string again to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the frequency of each character\n    char_count = {}\n    \n    # Iterate over the string to populate the dictionary\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Iterate over the string again to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass to count the characters\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass to find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to keep track of character counts\n    char_count = {}\n    \n    # First pass: count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to keep track of character counts\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass to count the characters\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass to find the first non-repeating character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Dictionary to keep track of character counts\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that appears only once\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first non-repeated character\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeated character is found, return None\n    return None", "matching_cluster_idx": 5}, {"solution": "def first_non_repeating_character(s):\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None", "matching_cluster_idx": 5}]}, "Mbpp/405": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # The 'in' keyword checks if the element is present in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element is in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element is in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element is in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tup, element):\n    # Check if the element is in the tuple\n    return element in tup", "matching_cluster_idx": 3}, {"solution": "def check_tuplex(tuplex, element):\n    # Check if the element is in the tuple\n    return element in tuplex", "matching_cluster_idx": 3}]}, "Mbpp/414": {"dps": 38.47826086956522, "dps_norm": 68.33333333333334, "pass@1": 100.0, "profiled": [{"solution": "def overlapping(seq1, seq2):\n    # Convert both sequences to sets and check for intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the first sequence to a set for efficient look-up\n    set1 = set(seq1)\n    \n    # Check if any element in the second sequence is in the set\n    for element in seq2:\n        if element in set1:\n            return True\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert the first sequence to a set for efficient lookup\n    set1 = set(sequence1)\n    \n    # Check if any element in the second sequence is in the set\n    for element in sequence2:\n        if element in set1:\n            return True\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the first sequence to a set for efficient lookups\n    set_seq1 = set(seq1)\n    \n    # Check if any element in the second sequence exists in the set\n    for element in seq2:\n        if element in set_seq1:\n            return True\n    return False", "matching_cluster_idx": 6}, {"solution": "def overlapping(seq1, seq2):\n    # Convert both sequences to sets to utilize set intersection for checking overlaps\n    set1 = set(seq1)\n    set2 = set(seq2)\n    \n    # Check if there is any intersection between the two sets\n    return bool(set1 & set2)", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Use set intersection to check if there is any common element\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Use set intersection to find common elements\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert both sequences to sets to use set intersection for checking overlap\n    set1 = set(sequence1)\n    set2 = set(sequence2)\n    \n    # Check if there is any intersection between the two sets\n    return bool(set1.intersection(set2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert both sequences to sets and check for intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(sequence1) & set(sequence2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert the sequences to sets for efficient lookup\n    set1 = set(sequence1)\n    set2 = set(sequence2)\n    \n    # Check if there is any common element between the two sets\n    return bool(set1 & set2)", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(sequence1, sequence2):\n    # Convert both sequences to sets for efficient lookup\n    set1 = set(sequence1)\n    set2 = set(sequence2)\n    \n    # Check if there is any intersection between the two sets\n    return bool(set1 & set2)", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert the sequences to sets and check for intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Convert both sequences to sets and check for intersection\n    return bool(set(seq1) & set(seq2))", "matching_cluster_idx": 5}, {"solution": "def overlapping(seq1, seq2):\n    # Use set intersection to find common elements\n    common_elements = set(seq1) & set(seq2)\n    # Return True if there are any common elements, otherwise False\n    return bool(common_elements)", "matching_cluster_idx": 5}]}, "Mbpp/421": {"dps": 88.8477366255144, "dps_norm": 94.28571428571428, "pass@1": 100.0, "profiled": [{"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a string, separated by the delimiter '-'\n    return '-'.join(str(x) for x in tup)", "matching_cluster_idx": 4}, {"solution": "def concatenate_tuple(input_tuple):\n    # Join each element of the tuple into a single string separated by '-'\n    return '-'.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a single string, separated by hyphens\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Join the elements of the tuple into a single string separated by hyphens\n    return '-'.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    # Convert all elements in the tuple to strings and join them using the '-' delimiter\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Join the elements of the tuple into a single string, separated by the delimiter '-'\n    return '-'.join(map(str, input_tuple))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    # Join each element of the tuple into a string, using '-' as the delimiter\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(t):\n    # Join each element of the tuple into a single string with '-' as the delimiter\n    return '-'.join(map(str, t))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a single string with '-' as the delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a single string, separated by '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Join the elements of the tuple into a single string separated by the specified delimiter\n    return '-'.join(map(str, input_tuple))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Join each element of the tuple with a hyphen\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a string with '-' as the delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple with a hyphen (-) as the delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(t):\n    # Join each element of the tuple into a string, separated by hyphens\n    return '-'.join(map(str, t))", "matching_cluster_idx": 5}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a string, separated by '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a single string, separated by the delimiter '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Convert all elements to strings and join them with the specified delimiter\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(tup):\n    # Join each element of the tuple into a string, separated by '-'\n    return '-'.join(map(str, tup))", "matching_cluster_idx": 6}, {"solution": "def concatenate_tuple(input_tuple):\n    # Join the elements of the tuple into a single string with '-' as the delimiter\n    result = '-'.join(map(str, input_tuple))\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/424": {"dps": 51.624548736462096, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def extract_rear(input_tuple):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in t]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(t):\n    # Create an empty list to store the last characters\n    rear_elements = []\n    \n    # Iterate over each string in the tuple\n    for string in t:\n        # Append the last character of the string to the list\n        rear_elements.append(string[-1])\n    \n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character from each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    result = [s[-1] for s in input_tuple]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character from each string in the tuple\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Use a list comprehension to extract the last character of each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(tup):\n    # Extract the last character of each string in the tuple\n    result = [s[-1] for s in tup]\n    return result", "matching_cluster_idx": 3}, {"solution": "def extract_rear(test_tup):\n    # Extract the last character from each string in the tuple\n    res = [sub[-1] for sub in test_tup]\n    return res", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Using a list comprehension to extract the last character of each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    rear_elements = [s[-1] for s in input_tuple]\n    return rear_elements", "matching_cluster_idx": 3}, {"solution": "def extract_rear(input_tuple):\n    # Extract the last character of each string in the tuple\n    return [s[-1] for s in input_tuple]", "matching_cluster_idx": 3}]}, "Mbpp/425": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # If the element is in the sublist, increment the counter\n        if element in sublist:\n            count += 1\n            \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize the count to zero\n    count = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the count if the element is found\n            count += 1\n    \n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a count to keep track of sublists containing the element\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # If the element is found in the current sublist, increment the count\n        if element in sublist:\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each sublist in the list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    \n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    \n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate over each sublist in the main list\n    for sublist in list1:\n        # If the element is in the current sublist, increment the counter\n        if element in sublist:\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a count to keep track of how many sublists contain the element\n    count = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the count if the element is found\n            count += 1\n    \n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, k):\n    # Initialize a counter to zero\n    counter = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element k is in the current sublist\n        if k in sublist:\n            # Increment the counter if the element is found\n            counter += 1\n    \n    # Return the final count\n    return counter", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a count to keep track of the number of sublists containing the element\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # If the element is found, increment the count\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a count variable to zero\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the count if the element is found\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    \n    # Iterate over each sublist in the list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    \n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a counter for the sublists containing the element\n    count = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # If the element is found in the current sublist, increment the counter\n        if element in sublist:\n            count += 1\n    \n    # Return the final count\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize the count of sublists containing the element\n    count = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the count if the element is found\n            count += 1\n    \n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(list1, element):\n    # Initialize a count to keep track of sublists containing the element\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in list1:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the count if the element is found\n            count += 1\n    # Return the total count of sublists containing the element\n    return count", "matching_cluster_idx": 4}, {"solution": "def count_element_in_list(lst, element):\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    # Iterate through each sublist in the main list\n    for sublist in lst:\n        # Check if the element is in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    # Return the final count\n    return count", "matching_cluster_idx": 4}]}, "Mbpp/428": {"dps": 84.29752066115702, "dps_norm": 55.55555555555556, "pass@1": 99.0, "profiled": [{"solution": "def shell_sort(arr):\n    # Determine the initial gap size, which is about half the length of the array\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the gap sequence starting with n/2 and reducing by half each time\n    n = len(arr)\n    gap = n // 2\n    \n    # Perform the shell sort\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Insert arr[i] into the sorted subarray arr[0:i-gap]\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap using the length of the array\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Add arr[i] to the elements that have been gap sorted\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size, which is half the length of the array\n    n = len(arr)\n    gap = n // 2\n\n    # Continue sorting with the current gap size until the gap is 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size, which is half the length of the array\n    n = len(arr)\n    gap = n // 2\n    \n    # Continue until the gap is reduced to 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initial gap size\n\n    # Gap reduction loop\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift elements of the array\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2  # Reduce the gap\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size, which is the length of the array divided by 2\n    n = len(arr)\n    gap = n // 2\n    \n    # Continue with the gap sorting until the gap becomes 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initial gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Do a gapped insertion sort for this gap size.\n        for i in range(gap, n):\n            # add arr[i] to the elements that have been gap sorted\n            temp = arr[i]\n            j = i\n            # shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        gap //= 2  # Reduce the gap for the next element\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the gap sequence starting from the length of the array divided by 2\n    n = len(arr)\n    gap = n // 2\n    \n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform insertion sort with the current gap\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2  # Initialize the gap size to half the length of the array\n    \n    # Continue until the gap is reduced to 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    return arr", "matching_cluster_idx": 4}, {"solution": "def shell_sort(arr):\n    # Determine the initial gap size, which is half the length of the array\n    n = len(arr)\n    gap = n // 2\n\n    # Start with a big gap, then reduce the gap\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Save arr[i] in temp and make a hole at position i\n            temp = arr[i]\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Put temp (the original arr[i]) in its correct location\n            arr[j] = temp\n        # Reduce the gap for the next element\n        gap //= 2\n\n    return arr", "matching_cluster_idx": 4}]}, "Mbpp/433": {"dps": 96.38297872340425, "dps_norm": 96.0, "pass@1": 100.0, "profiled": [{"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    return all(x < num for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    return all(num > x for x in arr)", "matching_cluster_idx": 2}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def check_greater(arr, num):\n    # Check if the given number is greater than all elements in the array\n    for element in arr:\n        if num <= element:\n            return False\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/437": {"dps": 70.58823529411765, "dps_norm": 20.0, "pass@1": 64.0, "profiled": [{"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(1, len(s) + 1):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Append the character at the current index (adjusted for 0-based indexing) to the result\n            result += s[i - 1]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through the string using index\n    for i in range(len(s)):\n        # Check if the index is even (since index starts from 0, even index corresponds to odd position)\n        if i % 2 == 1:\n            # Append the character at the even index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through the string using index\n    for i in range(len(input_string)):\n        # Check if the index is odd (considering index starts from 0)\n        if i % 2 == 1:\n            # Append the character at the odd index to the result\n            result += input_string[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate through the string using enumerate to get the index and character\n    for i, char in enumerate(s):\n        # Check if the index is odd (considering index starts from 0)\n        if i % 2 == 1:\n            # Append the character to the result if the index is odd\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using their indices\n    for i in range(len(s)):\n        # Check if the index is even (0-based), which corresponds to odd positions in human terms\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (0-based), which corresponds to odd positions in human counting\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (considering 0-based indexing)\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store even-indexed characters\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (0-based)\n        if i % 2 == 1:\n            # Append the character at the current index to the result string\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (considering 0-based indexing)\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (considering 0-based indexing)\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (considering 0-based indexing)\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string using the index\n    for i in range(len(s)):\n        # Check if the index is even (0-based indexing)\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store even-indexed characters\n    result = ''\n    \n    # Iterate over the string using enumerate to get both index and character\n    for i, char in enumerate(s):\n        # Check if the index is odd (since index starts from 0, odd index means even position)\n        if i % 2 == 1:\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(1, len(s) + 1):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Append the character at the current index (adjusted for 0-based indexing) to the result\n            result += s[i - 1]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store even-indexed characters\n    result = ''\n    \n    # Iterate over the string using their indices\n    for i in range(len(s)):\n        # Check if the index is even (since indices start at 0, even indices correspond to odd positions in 1-based counting)\n        if i % 2 == 1:\n            # Append the character at the even index to the result string\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over the string using index\n    for i in range(len(s)):\n        # Check if the index is even (0-based index)\n        if i % 2 == 1:\n            # Append the character at the current index to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through the string using index\n    for i in range(len(s)):\n        # Check if the index is even (0-based index), meaning the character is in an odd position\n        if i % 2 == 1:\n            # Append the character to the result\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(input_string):\n    # Initialize an empty string to store even indexed characters\n    result = ''\n    # Iterate over the string using its indices\n    for i in range(len(input_string)):\n        # Check if the index is even (0-based index, so even index means odd position)\n        if i % 2 != 0:\n            # Append the character at the current index to the result string\n            result += input_string[i]\n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store even-indexed characters\n    result = ''\n    \n    # Iterate over the string using index and character\n    for index, char in enumerate(s):\n        # Check if the index is even (0-based indexing)\n        if index % 2 == 1:\n            # Append the character to the result string\n            result += char\n    \n    return result", "matching_cluster_idx": 0}, {"solution": "def remove_odd(s):\n    # Initialize an empty string to store even indexed characters\n    result = ''\n    \n    # Iterate through the string using index\n    for i in range(len(s)):\n        # Check if the index is even (since indexing starts at 0, even index means odd character position)\n        if i % 2 == 1:\n            # Append the character at the current index to the result string\n            result += s[i]\n    \n    return result", "matching_cluster_idx": 0}]}, "Mbpp/440": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 45.0, "profiled": [{"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all occurrences of words ending in 'ly'\n    for match in re.finditer(r'\\w+ly', sentence):\n        start = match.start()  # Get the start position of the match\n        end = match.end()      # Get the end position of the match\n        adverb = match.group() # Get the matched adverb\n        return (start, end, adverb)\n    return None  # Return None if no adverb is found", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all adverbs and their positions\n    for match in re.finditer(r'\\w+ly', sentence):\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regex to find the first adverb and its position\n    match = re.search(r'\\w+ly', sentence)\n    if match:\n        return (match.start(), match.end(), match.group(0))\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all adverbs and their start positions\n    for match in re.finditer(r'\\w+ly', sentence):\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first adverb in the sentence\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If an adverb is found, return its start and end positions along with the adverb\n    if match:\n        start, end = match.span()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        # If no adverb is found, return None\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Using regular expression to find the first adverb\n    match = re.search(r'\\w+ly', sentence)\n    if match:\n        # If an adverb is found, return the start and end positions along with the adverb\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # If no adverb is found, return None\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first occurrence of an adverb\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If an adverb is found, return its start and end positions, and the adverb itself\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all adverbs ending in 'ly' and their starting positions\n    for match in re.finditer(r'\\w+ly', sentence):\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group()\n        return (start_pos, end_pos, adverb)\n    # Return None if no adverb is found\n    return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first adverb in the sentence\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If an adverb is found, return its start and end positions and the adverb itself\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        # If no adverb is found, return None\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all adverbs and their starting positions\n    for match in re.finditer(r'\\w+ly', sentence):\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group(0)\n        return (start_pos, end_pos, adverb)\n    return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first adverb in the sentence\n    match = re.search(r'\\w+ly', sentence)\n    \n    if match:\n        # If an adverb is found, return its start and end positions and the adverb itself\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # If no adverb is found, return None\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find adverbs\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If a match is found, return its start and end positions, and the word itself\n    if match:\n        return (match.start(), match.end(), match.group(0))\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Using regular expression to find the first adverb and its position\n    match = re.search(r'\\w+ly', sentence)\n    if match:\n        start, end = match.span()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first adverb in the sentence\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If an adverb is found, return its start position, end position, and the adverb itself\n    if match:\n        start, end = match.span()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        # If no adverb is found, return None\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Find all matches of words ending in 'ly' with their starting positions\n    for match in re.finditer(r'\\w+ly', sentence):\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group()\n        return (start_pos, end_pos, adverb)\n    # Return None if no adverb is found\n    return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Search for the first adverb in the sentence\n    match = re.search(r'\\w+ly', sentence)\n    if match:\n        # Return the start position, end position, and the adverb\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # Return None if no adverb is found\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first adverb and its position\n    match = re.search(r'\\w+ly', sentence)\n    if match:\n        return (match.start(), match.end(), match.group(0))\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find the first occurrence of a word ending in 'ly'\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If a match is found, return the start and end positions, along with the matched adverb\n    if match:\n        return (match.start(), match.end(), match.group(0))\n    else:\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Using regular expression to find adverbs and their positions\n    match = re.search(r'\\w+ly', sentence)\n    \n    # If an adverb is found, return its start and end positions along with the adverb itself\n    if match:\n        return (match.start(), match.end(), match.group(0))\n    else:\n        # Return None if no adverb is found\n        return None", "matching_cluster_idx": 3}, {"solution": "import re\ndef find_adverb_position(sentence):\n    # Use regular expression to find all words ending with 'ly'\n    for match in re.finditer(r'\\w+ly', sentence):\n        start_pos = match.start()\n        end_pos = match.end()\n        adverb = match.group()\n        return (start_pos, end_pos, adverb)\n    return None", "matching_cluster_idx": 3}]}, "Mbpp/446": {"dps": 96.05911330049261, "dps_norm": 60.0, "pass@1": 100.0, "profiled": [{"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of the occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count the occurrences of the item in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # Count the occurrences of the element in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count the occurrences of the element in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate through each element in the list\n    for item in lst:\n        # Add the number of occurrences of the item in the tuple to the counter\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # Count occurrences of the current element in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of the total occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Count how many times the element appears in the tuple\n        count += tup.count(element)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count occurrences of the item in the tuple\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through each element in the list\n    for item in lst:\n        # Add the number of occurrences of the item in the tuple to the counter\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Count how many times the element appears in the tuple\n        count += tup.count(element)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count the occurrences of the element in the tuple and add it to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count how many times the element appears in the tuple\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count how many times the item appears in the tuple\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count the occurrences of the item in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count the occurrences of the item in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count the occurrences of the element in the tuple and add it to the counter\n        count += tup.count(element)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter for occurrences\n    count = 0\n    \n    # Iterate through each element in the list\n    for item in lst:\n        # Count the occurrences of the element in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate over each element in the list\n    for item in lst:\n        # Add the number of occurrences of the item in the tuple to the count\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    \n    # Iterate over each element in the list\n    for item in lst:\n        # Count the occurrences of the element in the tuple and add to the counter\n        count += tup.count(item)\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through each element in the list\n    for item in lst:\n        # Count occurrences of the item in the tuple and add to the counter\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}, {"solution": "def count_Occurrence(tup, lst):\n    # Initialize a counter to zero\n    count = 0\n    # Iterate over each element in the list\n    for item in lst:\n        # Count how many times the item appears in the tuple and add it to the counter\n        count += tup.count(item)\n    return count", "matching_cluster_idx": 2}]}, "Mbpp/451": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 95.0, "profiled": [{"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(s):\n    # Use the replace method to remove all whitespace characters\n    return s.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all whitespace characters\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Using the str.replace() method to remove all spaces\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all whitespace characters\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all whitespace characters\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the str.replace() method to remove all spaces\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all whitespace characters\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the str.replace method to remove all whitespace characters\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_whitespaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}]}, "Mbpp/456": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_string_list(string_list):\n    # Use a list comprehension to reverse each string in the input list\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using list comprehension\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using a list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Reverse each string in the list using a list comprehension\n    return [s[::-1] for s in lst]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using list comprehension\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using a list comprehension\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Initialize an empty list to store the reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for string in string_list:\n        # Reverse the string using slicing and append it to the reversed_list\n        reversed_list.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using a list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Use list comprehension to reverse each string in the list\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Use list comprehension to reverse each string in the list\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using a list comprehension\n    return [s[::-1] for s in strings]", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(lst):\n    # Reverse each string in the list using a list comprehension\n    reversed_list = [s[::-1] for s in lst]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(string_list):\n    # Reverse each string in the list using a list comprehension\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}, {"solution": "def reverse_string_list(strings):\n    # Reverse each string in the list using a list comprehension\n    reversed_strings = [s[::-1] for s in strings]\n    return reversed_strings", "matching_cluster_idx": 4}]}, "Mbpp/460": {"dps": 48.07692307692307, "dps_norm": 80.0, "pass@1": 100.0, "profiled": [{"solution": "def Extract(list_of_lists):\n    # Use list comprehension to extract the first element from each sublist\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    # Use list comprehension to extract the first element of each sublist\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist and extract the first element\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    # Use list comprehension to iterate through each sublist and extract the first element\n    return [sublist[0] for sublist in list_of_lists]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element from each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(list_of_lists):\n    # Initialize an empty list to store the first elements\n    first_elements = []\n    # Iterate through each sublist in the main list\n    for sublist in list_of_lists:\n        # Append the first element of the sublist to the result list\n        first_elements.append(sublist[0])\n    return first_elements", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element from each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Extract the first element from each sublist using list comprehension\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element from each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist and extract the first element\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist in the list and extract the first element\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Using list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element of each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to iterate through each sublist in the list and extract the first element\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}, {"solution": "def Extract(lst):\n    # Use list comprehension to extract the first element from each sublist\n    return [item[0] for item in lst]", "matching_cluster_idx": 3}]}, "Mbpp/474": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    modified_string = string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replaces all occurrences of old_char with new_char in the given string s.\n\n    :param s: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: A new string with the replacements made.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of 'old_char' in the string 's' with 'new_char'.\n\n    :param s: The original string.\n    :param old_char: The character to be replaced.\n    :param new_char: The character to replace with.\n    :return: The modified string.\n    \"\"\"\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old, new):\n    # Replace occurrences of 'old' character with 'new' character in the string 's'\n    return s.replace(old, new)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    modified_string = string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in input_string\n    modified_string = input_string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    modified_string = string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(input_string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in input_string\n    return input_string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    modified_string = string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    return string.replace(old_char, new_char)", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    modified_string = string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(string, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string\n    modified_string = string.replace(old_char, new_char)\n    return modified_string", "matching_cluster_idx": 6}, {"solution": "def replace_char(s, old_char, new_char):\n    # Replace occurrences of old_char with new_char in the string s\n    return s.replace(old_char, new_char)", "matching_cluster_idx": 6}]}, "Mbpp/476": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_sum(arr):\n    # Find the maximum value in the array\n    max_value = max(arr)\n    # Find the minimum value in the array\n    min_value = min(arr)\n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Calculate the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return the sum of the smallest and largest values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Calculate the sum of the maximum and minimum values\n    result = max_value + min_value\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum value in the array\n    max_value = max(arr)\n    # Find the minimum value in the array\n    min_value = min(arr)\n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Calculate the sum of the maximum and minimum values\n    total = max_value + min_value\n    \n    return total", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Calculate the sum of the smallest and largest values\n    result = min_val + max_val\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Check if the array is empty to avoid errors\n    if not arr:\n        return 0\n    \n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Return the sum of the minimum and maximum values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Calculate the sum of the maximum and minimum values\n    result = max_value + min_value\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest value in the array\n    smallest = min(arr)\n    # Find the largest value in the array\n    largest = max(arr)\n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest value in the array\n    min_val = min(arr)\n    # Find the largest value in the array\n    max_val = max(arr)\n    # Return the sum of the smallest and largest values\n    return min_val + max_val", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the smallest and largest values in the array\n    smallest = min(arr)\n    largest = max(arr)\n    \n    # Return the sum of the smallest and largest values\n    return smallest + largest", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the minimum and maximum values in the array\n    min_val = min(arr)\n    max_val = max(arr)\n    \n    # Calculate the sum of the minimum and maximum values\n    result = min_val + max_val\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def big_sum(arr):\n    # Find the maximum and minimum values in the array\n    max_value = max(arr)\n    min_value = min(arr)\n    \n    # Return the sum of the maximum and minimum values\n    return max_value + min_value", "matching_cluster_idx": 5}]}, "Mbpp/477": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case using the `lower()` method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lowercase\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    lower_s = s.lower()\n    return lower_s", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the given string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the input string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case\n    return s.lower()", "matching_cluster_idx": 4}, {"solution": "def is_lower(s):\n    # Convert the string to lower case using the lower() method\n    return s.lower()", "matching_cluster_idx": 4}]}, "Mbpp/563": {"dps": 85.24590163934427, "dps_norm": 81.81818181818181, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings between double quotes\n    values = re.findall(r'\"(.*?)\"', string)\n    return values", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Using regular expression to find all occurrences of text within double quotes\n    matches = re.findall(r'\"(.*?)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Using regular expression to find all substrings between double quotation marks\n    return re.findall(r'\"(.*?)\"', input_string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings between double quotation marks\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all occurrences of text between double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings between double quotation marks\n    matches = re.findall(r'\"(.*?)\"', string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(input_string):\n    # Use regular expression to find all occurrences of text within double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    return matches", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Using regular expression to find all substrings between double quotation marks\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(s):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 8}, {"solution": "import re\ndef extract_values(string):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', string)", "matching_cluster_idx": 8}]}, "Mbpp/572": {"dps": 95.06172839506173, "dps_norm": 85.71428571428571, "pass@1": 100.0, "profiled": [{"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num in nums if freq[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num in nums if frequency[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in frequency.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num, freq in frequency.items() if freq == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Count the occurrence of each number in the list\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out the numbers that appear more than once\n    result = [num for num in nums if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num in nums if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Count the occurrence of each number in the list\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter the numbers that appear exactly once\n    result = [num for num in nums if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter the list to include only numbers that appear exactly once\n    result = [num for num in nums if count[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Filter out numbers that appear more than once\n    result = [num for num in nums if freq[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num in nums if frequency[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num in nums if frequency[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num in nums if frequency[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Filter the list to include only numbers that appear exactly once\n    unique_nums = [num for num, count in count_dict.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number in the list\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num, count in frequency.items() if count == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num, freq in count.items() if freq == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter the numbers that appear exactly once\n    unique_nums = [num for num, freq in count.items() if freq == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Track the frequency of each number in the list\n    frequency = {}\n    for num in nums:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    # Collect numbers that appear exactly once\n    unique_nums = [num for num, count in frequency.items() if count == 1]\n    \n    return unique_nums", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(lst):\n    # Dictionary to keep track of the occurrence of each number\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # List to store numbers that appear exactly once\n    result = [num for num in lst if count_dict[num] == 1]\n    \n    return result", "matching_cluster_idx": 5}, {"solution": "def two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Collect numbers that appear exactly once\n    result = [num for num, freq in count.items() if freq == 1]\n    \n    return result", "matching_cluster_idx": 5}]}, "Mbpp/578": {"dps": 58.41269841269841, "dps_norm": 63.63636363636363, "pass@1": 100.0, "profiled": [{"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    interleaved_list = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list to the interleaved list\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Loop through the lists and interleave their elements\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list in order to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through the lists and interleave their elements\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    result = []\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    interleaved_list = []\n    \n    # Iterate over the index range of the lists\n    for i in range(len(list1)):\n        # Append elements from each list in order\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list in order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate through the lists, assuming they have the same length\n    for i in range(len(list1)):\n        # Append elements from each list to the result list in the desired order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the lists using the range of their length\n    for i in range(len(list1)):\n        # Append elements from each list to the result in order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved result\n    result = []\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append the elements from each list in the desired order\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    interleaved_list = []\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the lists using their index\n    for i in range(len(list1)):\n        # Append elements from each list to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    interleaved_list = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append the i-th element from each list to the interleaved list\n        interleaved_list.append(list1[i])\n        interleaved_list.append(list2[i])\n        interleaved_list.append(list3[i])\n    \n    return interleaved_list", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    result = []\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list at the current index\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append elements from each list to the result list\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/586": {"dps": 98.83040935672514, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def split_Arr(arr, n):\n    # Split the array into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part and the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part and the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(lst, n):\n    # Split the list into two parts at the nth element\n    first_part = lst[:n]\n    second_part = lst[n:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part to get the result\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the array into two parts\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Combine the second part with the first part at the end\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def split_Arr(arr, n):\n    # Split the list into two parts at the nth element\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/587": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple() constructor\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple using the tuple() function\n    converted_tuple = tuple(input_list)\n    return converted_tuple", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(input_list)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(list1):\n    # Convert the list to a tuple\n    return tuple(list1)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(lst):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(lst)", "matching_cluster_idx": 3}, {"solution": "def list_tuple(input_list):\n    # Convert the list to a tuple using the tuple() function\n    result_tuple = tuple(input_list)\n    return result_tuple", "matching_cluster_idx": 3}]}, "Mbpp/588": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Return the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the maximum value in the list\n    max_value = max(nums)\n    # Calculate the minimum value in the list\n    min_value = min(nums)\n    # Return the difference between the maximum and minimum values\n    return max_value - min_value", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Return the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Calculate the difference between the maximum and minimum values in the list\n    return max(nums) - min(nums)", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum value in the list\n    max_val = max(nums)\n    # Find the minimum value in the list\n    min_val = min(nums)\n    # Calculate the difference between the maximum and minimum values\n    return max_val - min_val", "matching_cluster_idx": 5}, {"solution": "def big_diff(nums):\n    # Find the maximum and minimum values in the list\n    max_val = max(nums)\n    min_val = min(nums)\n    \n    # Calculate the difference between the maximum and minimum values\n    difference = max_val - min_val\n    \n    return difference", "matching_cluster_idx": 5}]}, "Mbpp/592": {"dps": 87.46666666666667, "dps_norm": 59.0, "pass@1": 97.0, "profiled": [{"solution": "import math\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    sum_product = 0\n    \n    # Iterate through the range of n to calculate the sum of products of binomial coefficients\n    for k in range(n):\n        # Calculate the product of two consecutive binomial coefficients\n        product = math.comb(n, k) * math.comb(n, k + 1)\n        # Add the product to the sum\n        sum_product += product\n    \n    return sum_product", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to store the result\n    sum_result = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for k in range(1, n + 1):\n        sum_result += comb(n, k - 1) * comb(n, k)\n    \n    return sum_result", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the range from 0 to n-1\n    for i in range(n):\n        # Calculate the product of two consecutive binomial coefficients\n        product = comb(n, i) * comb(n, i + 1)\n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    sum_product = 0\n    \n    # Loop through all pairs of consecutive binomial coefficients\n    for k in range(n + 1):\n        # Calculate the product of C(n, k) and C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the sum\n        sum_product += product\n    \n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum\n    total_sum = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for k in range(1, n + 1):\n        total_sum += comb(n, k - 1) * comb(n, k)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    sum = 0\n    \n    # Loop through the range of n\n    for k in range(n):\n        # Calculate the product of consecutive binomial coefficients\n        product = math.comb(n, k) * math.comb(n, k + 1)\n        # Add the product to the sum\n        sum += product\n    \n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    sum = 0\n    \n    # Loop through the range of n to calculate the sum of the product of consecutive binomial coefficients\n    for k in range(n):\n        sum += comb(n, k) * comb(n, k + 1)\n    \n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to store the result\n    total_sum = 0\n    \n    # Loop through the range to calculate the sum of products of consecutive binomial coefficients\n    for k in range(n + 1):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "import math\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    sum = 0\n    \n    # Loop through the range of n + 1\n    for k in range(n + 1):\n        # Calculate the product of consecutive binomial coefficients\n        product = math.comb(n, k) * math.comb(n, k + 1)\n        # Add the product to the sum\n        sum += product\n    \n    return sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    sum_product = 0\n    \n    # Iterate through the range of n to calculate the sum of products of consecutive binomial coefficients\n    for k in range(n):\n        sum_product += comb(n, k) * comb(n, k + 1)\n    \n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum\n    total_sum = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for k in range(n):\n        total_sum += comb(n, k) * comb(n, k + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through the range from 0 to n (inclusive)\n    for k in range(n + 1):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the range of n + 1 to calculate the sum of the product of consecutive binomial coefficients\n    for i in range(n + 1):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    sum_product = 0\n    \n    # Iterate through the range of n to calculate the sum of the product of consecutive binomial coefficients\n    for k in range(n):\n        sum_product += comb(n, k) * comb(n, k + 1)\n    \n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    sum_product = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for k in range(n):\n        sum_product += comb(n, k) * comb(n, k + 1)\n    \n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through each k from 0 to n-1\n    for k in range(n):\n        # Calculate the product of binomial coefficients C(n, k) * C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate through the range 0 to n\n    for k in range(n + 1):\n        # Calculate the product of binomial coefficients C(n, k) * C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    sum_product = 0\n    \n    # Iterate through the range of n+1 to include all terms\n    for k in range(n + 1):\n        # Calculate the product of consecutive binomial coefficients\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the sum\n        sum_product += product\n    \n    return sum_product", "matching_cluster_idx": 5}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    for i in range(n + 1):\n        total_sum += comb(n, i) * comb(n, i + 1)\n    \n    return total_sum", "matching_cluster_idx": 4}, {"solution": "from math import comb\ndef sum_Of_product(n):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Loop through each value from 0 to n\n    for k in range(n + 1):\n        # Calculate the product of binomial coefficients C(n, k) * C(n, k+1)\n        product = comb(n, k) * comb(n, k + 1)\n        # Add the product to the total sum\n        total_sum += product\n    \n    return total_sum", "matching_cluster_idx": 5}]}, "Mbpp/597": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/604": {"dps": 47.5, "dps_norm": 89.0, "pass@1": 100.0, "profiled": [{"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list of words back into a string\n    reversed_string = ' '.join(reversed_words)\n    return reversed_string", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, then reverse the list of words and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a single string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, then reverse the list of words and join them back into a string\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(s.split()[::-1])", "matching_cluster_idx": 4}, {"solution": "def reverse_words(s):\n    # Split the string into words, reverse the list of words, and join them back with a space\n    return ' '.join(reversed(s.split()))", "matching_cluster_idx": 3}]}, "Mbpp/610": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/611": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find the maximum value in the n-th column\n    max_value = max(column)\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the n'th column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value in the n'th column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column by iterating over each row and selecting the n'th element\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find and return the maximum value in the n'th column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    \n    # Return the maximum value in the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find the maximum value in the extracted column\n    return max(column)", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n-th column from the matrix\n    column = [row[n] for row in matrix]\n    # Find the maximum value in the extracted column\n    max_value = max(column)\n    return max_value", "matching_cluster_idx": 5}, {"solution": "def max_of_nth(matrix, n):\n    # Extract the n'th column from the matrix\n    column = [row[n] for row in matrix]\n    # Return the maximum value from the extracted column\n    return max(column)", "matching_cluster_idx": 5}]}, "Mbpp/631": {"dps": null, "dps_norm": null, "pass@1": 9.0, "profiled": []}, "Mbpp/632": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 99.0, "profiled": [{"solution": "def move_zero(nums):\n    # Initialize a list to hold the non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeros to the end of the non_zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zeros = [num for num in nums if num != 0]\n    # Append zeros to the end of the list\n    non_zeros.extend([0] * (len(nums) - len(non_zeros)))\n    return non_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeros to the end of the non-zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # List comprehension to filter out non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeros to the end of the list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeroes to the end of the non-zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to hold the non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeroes to the end of the list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to keep non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeros to the end of the non_zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeros to the end of the non-zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize pointers for the current position and the position to place the next non-zero element\n    current_pos = 0\n    non_zero_pos = 0\n    \n    # Iterate through the list\n    while current_pos < len(lst):\n        # If the current element is not zero, move it to the non_zero_pos and increment non_zero_pos\n        if lst[current_pos] != 0:\n            lst[non_zero_pos] = lst[current_pos]\n            non_zero_pos += 1\n        current_pos += 1\n    \n    # Fill the remaining positions with zeros\n    while non_zero_pos < len(lst):\n        lst[non_zero_pos] = 0\n        non_zero_pos += 1\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a new list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeros to the end of the list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeroes to the end of the non-zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zeros = [num for num in nums if num != 0]\n    # Append zeros to the end of the non_zeros list\n    non_zeros.extend([0] * (len(nums) - len(non_zeros)))\n    return non_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeroes to the end of the non_zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize pointers for reading and writing\n    read_index = 0\n    write_index = 0\n    \n    # Move all non-zero elements to the front of the list\n    while read_index < len(lst):\n        if lst[read_index] != 0:\n            lst[write_index] = lst[read_index]\n            write_index += 1\n        read_index += 1\n    \n    # Fill the rest of the list with zeroes\n    while write_index < len(lst):\n        lst[write_index] = 0\n        write_index += 1\n    \n    return lst", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize a list to store the non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    # Calculate the number of zeros in the original list\n    num_zeros = lst.count(0)\n    # Extend the non-zero list with the zeros\n    non_zero.extend([0] * num_zeros)\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(lst):\n    # Initialize a new list to store non-zero elements\n    non_zero = [x for x in lst if x != 0]\n    # Append the required number of zeros to the end of the non-zero list\n    non_zero.extend([0] * (len(lst) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeroes to the end of the non_zero list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to keep non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append zeroes to the end of the list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to keep non-zero elements\n    non_zeros = [num for num in nums if num != 0]\n    # Append zeros to the end of the list\n    non_zeros.extend([0] * (len(nums) - len(non_zeros)))\n    return non_zeros", "matching_cluster_idx": 6}, {"solution": "def move_zero(nums):\n    # Initialize a list to store non-zero elements\n    non_zero = [num for num in nums if num != 0]\n    # Append the required number of zeroes to the end of the list\n    non_zero.extend([0] * (len(nums) - len(non_zero)))\n    return non_zero", "matching_cluster_idx": 6}]}, "Mbpp/633": {"dps": 94.3089430894309, "dps_norm": 50.0, "pass@1": 100.0, "profiled": [{"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum of XORs to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result variable to store the sum of XOR of all pairs\n    result = 0\n    \n    # Iterate through each element in the array\n    for i in range(n):\n        # For each element, iterate through the rest of the elements\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the result\n            result += arr[i] ^ arr[j]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result to store the sum of XOR values\n    result = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the pair and add it to the result\n            result += arr[i] ^ arr[j]\n    \n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute XOR of the pair and add to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result variable to store the sum of XORs\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the result\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the list\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum of XORs to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    # Return the total sum of XORs\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the sum of XORs to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    # Return the total sum of XORs\n    return xor_sum", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize the result variable to store the sum of XOR values\n    result = 0\n    \n    # Iterate through each element in the array\n    for i in range(0, n):\n        # For each element, iterate through the remaining elements\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the result\n            result += arr[i] ^ arr[j]\n    \n    # Return the final result\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_xor_Sum(arr, n):\n    # Initialize sum to 0\n    xor_sum = 0\n    \n    # Iterate through each pair of elements in the array\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Compute the XOR of the pair and add it to the sum\n            xor_sum += arr[i] ^ arr[j]\n    \n    return xor_sum", "matching_cluster_idx": 2}]}, "Mbpp/644": {"dps": 96.27659574468083, "dps_norm": 93.33333333333333, "pass@1": 93.0, "profiled": [{"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array from the start up to index k (inclusive)\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements of the array from index 0 to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the array from the start up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from index 0 to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements of the array from index 0 to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements of the array up to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array from index 0 to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements of the array from index 0 to k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements of the array up to index k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array from index 0 to k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array from the start to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array from the start up to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array from the start to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from the start to the k-th position\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the elements of the array from index 0 to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array from index 0 to k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the portion of the array from the start to index k-1\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the first k elements of the array\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}, {"solution": "def reverse_Array_Upto_K(arr, k):\n    # Reverse the sub-array from index 0 to k\n    arr[:k] = arr[:k][::-1]\n    return arr", "matching_cluster_idx": 13}]}, "Mbpp/720": {"dps": 93.84615384615384, "dps_norm": 98.0, "pass@1": 100.0, "profiled": [{"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by combining the original tuple and the dictionary\n    result = tup + (dictionary,)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by concatenating the original tuple with a tuple containing the dictionary\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Convert the tuple to a list, append the dictionary, and convert it back to a tuple\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by combining the existing tuple and the dictionary\n    new_tup = tup + (dictionary,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by adding the dictionary to the existing tuple\n    new_tuple = tup + (dictionary,)\n    return new_tuple", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by adding the dictionary to the existing tuple\n    result = tup + (dictionary,)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by concatenating the original tuple and the dictionary\n    # The dictionary is converted to a tuple containing a single element (the dictionary itself)\n    result = tup + (dictionary,)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by combining the original tuple and the dictionary\n    new_tup = tup + (dictionary,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by adding the dictionary to the end of the existing tuple\n    new_tup = tup + (dictionary,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by adding the dictionary to the existing tuple\n    new_tup = tup + (dictionary,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to add the dictionary\n    temp_list = list(tup)\n    temp_list.append(dictionary)\n    # Convert the list back to a tuple\n    return tuple(temp_list)", "matching_cluster_idx": 3}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by combining the existing tuple and the dictionary\n    result = tup + (dictionary,)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by combining the original tuple and the dictionary\n    result = tup + (dictionary,)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Add the dictionary to the tuple\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(test_tup, test_dict):\n    # Adds the dictionary to the tuple\n    res = test_tup + (test_dict,)\n    return res", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by adding the dictionary to the existing tuple\n    new_tup = tup + (dictionary,)\n    return new_tup", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Add the dictionary to the end of the tuple and return the new tuple\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by concatenating the original tuple with a tuple containing the dictionary\n    return tup + (dictionary,)", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Create a new tuple by adding the dictionary to the existing tuple\n    result = tup + (dictionary,)\n    return result", "matching_cluster_idx": 4}, {"solution": "def add_dict_to_tuple(tup, dictionary):\n    # Convert the tuple to a list to allow modification\n    temp_list = list(tup)\n    \n    # Append the dictionary to the list\n    temp_list.append(dictionary)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    return result_tuple", "matching_cluster_idx": 3}]}, "Mbpp/725": {"dps": 62.73224043715847, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings within double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings between double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 4}, {"solution": "import re\ndef extract_quotation(s):\n    # Using regular expression to find all substrings between double quotes\n    matches = re.findall(r'\"(.*?)\"', s)\n    return matches", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(s):\n    # Use regular expression to find all substrings enclosed in double quotes\n    return re.findall(r'\"(.*?)\"', s)", "matching_cluster_idx": 5}, {"solution": "import re\ndef extract_quotation(text):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', text)\n    return matches", "matching_cluster_idx": 5}]}, "Mbpp/732": {"dps": 5.813953488372094, "dps_norm": 40.0, "pass@1": 89.0, "profiled": [{"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with colons\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use re.sub to replace spaces, commas, or dots with a colon\n    modified_text = re.sub(r'[ ,.]', ':', text)\n    return modified_text", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Replace all occurrences of spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use re.sub to replace spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use the re.sub() function to replace all occurrences of spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use the re.sub function to replace spaces, commas, or dots with colons\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    modified_text = re.sub(r'[ ,.]', ':', text)\n    return modified_text", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Replace all occurrences of spaces, commas, or dots with a colon\n    result = re.sub(r'[ ,.]', ':', text)\n    return result", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, and dots with colons\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, and dots with colons\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Using regular expression to replace spaces, commas, or dots with colons\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}, {"solution": "import re\ndef replace_specialchar(text):\n    # Use regular expression to replace spaces, commas, or dots with a colon\n    return re.sub(r'[ ,.]', ':', text)", "matching_cluster_idx": 3}]}, "Mbpp/740": {"dps": 44.163636363636364, "dps_norm": 57.22222222222222, "pass@1": 100.0, "profiled": [{"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # The current element is the key, and the next element is the value\n        key = input_tuple[i]\n        value = input_tuple[i + 1] if i + 1 < len(input_tuple) else None\n        result_dict[key] = value\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # The current element is the key, and the next element is the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to pair elements\n    for i in range(0, len(input_tuple), 2):\n        # Assign the current element as the key and the next element as the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # The current element is the key, and the next element is the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the result\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # Assign the current element as the key and the next element as the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the result\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # Assign the current element as the key and the next element as the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to use each pair of elements as key and value\n    for i in range(0, len(input_tuple), 2):\n        if i + 1 < len(input_tuple):  # Ensure there is a next element to use as value\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # The key is the current element, and the value is the next element\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # Assign the current element as the key and the next element as the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(test_tup):\n    # Create a dictionary by zipping every second element starting from the first as keys\n    # and every second element starting from the second as values\n    res = dict(zip(test_tup[::2], test_tup[1::2]))\n    return res", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(tup):\n    # Create a dictionary using adjacent elements from the tuple\n    return {tup[i]: tup[i + 1] for i in range(0, len(tup) - 1, 2)}", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create a dictionary by zipping every second element (keys) with the next element (values)\n    return dict(zip(input_tuple[::2], input_tuple[1::2]))", "matching_cluster_idx": 8}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the result\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple) - 1, 2):\n        # Assign the current element as the key and the next element as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the result\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # Use the current element as the key and the next element as the value\n        if i + 1 < len(input_tuple):\n            result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create a dictionary from the tuple by pairing adjacent elements\n    result_dict = {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}\n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the result\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to use every pair of elements as key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # Assign the first element of the pair as the key and the second as the value\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(test_tup):\n    # Create a dictionary by iterating over the tuple in steps of 2\n    res = dict(test_tup[idx : idx + 2] for idx in range(0, len(test_tup), 2))\n    return res", "matching_cluster_idx": 4}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the result\n    result_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to pair adjacent elements\n    for i in range(0, len(input_tuple), 2):\n        # Assign the key-value pair to the dictionary\n        result_dict[input_tuple[i]] = input_tuple[i + 1]\n    \n    return result_dict", "matching_cluster_idx": 5}, {"solution": "def tuple_to_dict(input_tuple):\n    # Initialize an empty dictionary to store the key-value pairs\n    output_dict = {}\n    \n    # Iterate over the tuple in steps of 2 to get key-value pairs\n    for i in range(0, len(input_tuple), 2):\n        # The current element is the key\n        key = input_tuple[i]\n        # The next element is the value, if it exists\n        if i + 1 < len(input_tuple):\n            value = input_tuple[i + 1]\n        else:\n            # If there's no next element, the value is None\n            value = None\n        # Add the key-value pair to the dictionary\n        output_dict[key] = value\n    \n    return output_dict", "matching_cluster_idx": 3}, {"solution": "def tuple_to_dict(input_tuple):\n    # Create a dictionary by iterating over the tuple in steps of 2\n    # The first element in each pair is the key, and the second is the value\n    return {input_tuple[i]: input_tuple[i + 1] for i in range(0, len(input_tuple), 2)}", "matching_cluster_idx": 5}]}, "Mbpp/744": {"dps": 40.99315068493151, "dps_norm": 59.166666666666664, "pass@1": 100.0, "profiled": [{"solution": "def check_none(test_tup):\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the element is None\n        if ele == None:\n            return True\n    # Return False if no None is found\n    return False", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = None in test_tup\n    return res", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = None in test_tup\n    return res", "matching_cluster_idx": 5}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    for elem in test_tup:\n        if elem is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Iterate through each element in the tuple\n    for element in test_tup:\n        # Check if the element is None\n        if element is None:\n            return True\n    # Return False if no None is found\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Iterate through each element in the tuple\n    for ele in test_tup:\n        # Check if the element is None\n        if ele == None:\n            return True\n    # Return False if no None value is found\n    return False", "matching_cluster_idx": 2}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    for elem in test_tup:\n        if elem is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tuple):\n    # Check if any element in the tuple is None\n    for element in test_tuple:\n        if element is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    return any(ele is None for ele in test_tup)", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Iterate through each element in the tuple\n    for elem in test_tup:\n        # Check if the element is None\n        if elem is None:\n            return True\n    # Return False if no None value is found\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    for element in test_tup:\n        if element is None:\n            return True\n    return False", "matching_cluster_idx": 4}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    res = any(ele is None for ele in test_tup)\n    return res", "matching_cluster_idx": 1}, {"solution": "def check_none(test_tup):\n    # Check if any element in the tuple is None\n    for element in test_tup:\n        if element is None:\n            return True\n    return False", "matching_cluster_idx": 4}]}, "Mbpp/750": {"dps": 85.71428571428571, "dps_norm": 85.0, "pass@1": 100.0, "profiled": [{"solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements of the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(test_list, test_tup):\n    # Extend the list with the elements of the tuple\n    test_list.extend(test_tup)\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding all elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements of the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding all elements of the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tple):\n    # Extend the list with the elements of the tuple\n    lst.extend(tple)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements of the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding elements from the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, t):\n    # Extend the list with the elements of the tuple\n    lst.extend(t)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding all elements from the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(test_list, test_tup):\n    # Extend the list with the elements of the tuple\n    test_list.extend(test_tup)\n    return test_list", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list with elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding all elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding all elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements from the tuple\n    lst.extend(tpl)\n    return lst", "matching_cluster_idx": 5}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list by adding elements from the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}, {"solution": "def add_tuple(lst, tpl):\n    # Extend the list with the elements from the tuple\n    return lst + list(tpl)", "matching_cluster_idx": 2}]}, "Mbpp/753": {"dps": 97.31543624161074, "dps_norm": 75.0, "pass@1": 100.0, "profiled": [{"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param tuples_list: List of tuples, where each tuple contains a string and an integer.\n    :param k: The number of minimum records to return.\n    :return: A list of tuples containing the k minimum records.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    Parameters:\n    tuples_list (list of tuples): The list of tuples to process.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list of tuples: A list containing the k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    # Sort the list based on the second element of the tuples\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    This function takes a list of tuples and an integer k, and returns a list of the k tuples with the smallest second elements.\n    \n    :param tuples_list: List of tuples where each tuple is of the form (name, value)\n    :param k: Integer representing the number of smallest elements to return\n    :return: List of k tuples with the smallest second elements\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Extract the first K elements from the sorted list\n    result = sorted_list[:K]\n    return result", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param records: List of tuples, where each tuple contains a name and a number.\n    :param k: Number of minimum records to return.\n    :return: List of tuples containing the k minimum records.\n    \"\"\"\n    # Sort the list of tuples based on the second element (the number)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param tuples_list: List of tuples, where each tuple contains a name and a number.\n    :param k: Number of minimum records to return.\n    :return: List of k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param tuples_list: List of tuples, where each tuple is of the form (name, value)\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest second elements\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param records: List of tuples, where each tuple contains a name and a numeric value.\n    :param k: The number of minimum records to return.\n    :return: A list of tuples containing the k minimum records.\n    \"\"\"\n    # Sort the list of tuples based on the second element (numeric value)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, k):\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list based on the second element of the tuples\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n\n    :param records: List of tuples where each tuple contains a name and a numeric value.\n    :param k: The number of minimum records to return.\n    :return: A list of tuples containing the k minimum records.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    # Sort the list of tuples based on the second element (the integer value) and slice the first k elements\n    return sorted(records, key=lambda x: x[1])[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list based on the second element of each tuple and then slice the first K elements\n    res = sorted(test_list, key=lambda x: x[1])[:K]\n    return res", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    Parameters:\n    tuples_list (list of tuples): The list of tuples to process.\n    k (int): The number of minimum records to return.\n    \n    Returns:\n    list of tuples: A list containing the k tuples with the smallest second elements.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements of the sorted list\n    return sorted_list[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(test_list, K):\n    # Sort the list based on the second element of each tuple\n    sorted_list = sorted(test_list, key=lambda x: x[1])\n    # Return the first K elements from the sorted list\n    return sorted_list[:K]", "matching_cluster_idx": 2}, {"solution": "def min_k(lst, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param lst: List of tuples where each tuple is in the form (name, value)\n    :param k: Number of minimum records to return\n    :return: List of k tuples with the smallest second elements\n    \"\"\"\n    # Sort the list of tuples based on the second element\n    sorted_lst = sorted(lst, key=lambda x: x[1])\n    \n    # Return the first k elements of the sorted list\n    return sorted_lst[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second item (numeric value)\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    # Return the first k elements from the sorted list\n    return sorted_tuples[:k]", "matching_cluster_idx": 2}, {"solution": "def min_k(records, k):\n    \"\"\"\n    Finds the minimum k records from a list of tuples based on the second element of each tuple.\n    \n    :param records: List of tuples, where each tuple contains a name and an integer.\n    :param k: Number of minimum records to return.\n    :return: List of tuples representing the minimum k records.\n    \"\"\"\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_records[:k]", "matching_cluster_idx": 2}]}, "Mbpp/754": {"dps": 89.65517241379311, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the minimum length among the three lists to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the minimum length\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store the common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}, {"solution": "def extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the length of the shortest list to avoid index out of range errors\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate through the lists up to the length of the shortest list\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    return common_elements", "matching_cluster_idx": 6}]}, "Mbpp/755": {"dps": 36.75516224188791, "dps_norm": 68.88888888888889, "pass@1": 15.0, "profiled": [{"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    min1, min2 = float('inf'), float('inf')\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Update min1 and min2 accordingly\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2 and num != min1:\n            min2 = num\n    \n    # Return the second smallest number\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with positive infinity\n    smallest = second_smallest = float('inf')\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # If the current number is smaller than the smallest, update both smallest and second smallest\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        # If the current number is between smallest and second smallest, update second smallest\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    # Return the second smallest number found\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest numbers with positive infinity\n    min1, min2 = float('inf'), float('inf')\n    \n    # Iterate through each number in the list\n    for x in numbers:\n        # Update min1 and min2 accordingly\n        if x < min1:\n            min1, min2 = x, min1\n        elif min1 < x < min2:\n            min2 = x\n    \n    # Return the second smallest number\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with positive infinity\n    first, second = float('inf'), float('inf')\n    \n    for num in numbers:\n        # If the current number is smaller than the first smallest, update both\n        if num < first:\n            second, first = first, num\n        # If the current number is between the first and second smallest, update the second smallest\n        elif first < num < second:\n            second = num\n    \n    # If second is still infinity, there was no second smallest number\n    if second == float('inf'):\n        return None\n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    smallest = second_smallest = float('inf')\n    \n    # Iterate through the list to find the smallest and second smallest numbers\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    # Return the second smallest number\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    smallest = second_smallest = float('inf')\n    \n    # Iterate through the list to find the smallest and second smallest\n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif smallest < num < second_smallest:\n            second_smallest = num\n    \n    # Return the second smallest number\n    return second_smallest if second_smallest != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    first, second = float('inf'), float('inf')\n    \n    for num in numbers:\n        # Update first and second smallest numbers if necessary\n        if num < first:\n            first, second = num, first\n        elif first < num < second:\n            second = num\n    \n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    first, second = float('inf'), float('inf')\n    \n    for num in numbers:\n        # Update the smallest and second smallest numbers\n        if num < first:\n            second, first = first, num\n        elif first < num < second:\n            second = num\n    \n    return second if second != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    smallest = second = float('inf')\n    \n    for num in numbers:\n        # Update smallest and second smallest accordingly\n        if num < smallest:\n            smallest, second = num, smallest\n        elif smallest < num < second:\n            second = num\n    \n    # If second smallest was never updated, return None\n    if second == float('inf'):\n        return None\n    \n    return second", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest numbers with positive infinity\n    min1, min2 = float('inf'), float('inf')\n    \n    # Iterate through each number in the list\n    for num in numbers:\n        # Update the smallest and second smallest numbers if necessary\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif min1 < num < min2:\n            min2 = num\n    \n    # Return the second smallest number\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with positive infinity\n    min1, min2 = float('inf'), float('inf')\n    \n    for num in numbers:\n        # Update the smallest and second smallest if a new smaller number is found\n        if num < min1:\n            min1, min2 = num, min1\n        elif min1 < num < min2:\n            min2 = num\n    \n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with infinity\n    smallest = second_smallest = float('inf')\n    \n    for num in numbers:\n        # Update smallest and second smallest if necessary\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    \n    # If second_smallest is still infinity, it means there was no distinct second smallest number\n    if second_smallest == float('inf'):\n        return None\n    \n    return second_smallest", "matching_cluster_idx": 4}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with positive infinity\n    min1, min2 = float('inf'), float('inf')\n    \n    for num in numbers:\n        # Update the smallest and second smallest numbers\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif min1 < num < min2:\n            min2 = num\n    \n    # Return the second smallest number\n    return min2 if min2 != float('inf') else None", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with positive infinity\n    smallest = second_smallest_num = float('inf')\n    \n    for num in numbers:\n        # Update the smallest and second smallest numbers if a new smaller number is found\n        if num < smallest:\n            second_smallest_num = smallest\n            smallest = num\n        elif smallest < num < second_smallest_num:\n            second_smallest_num = num\n    \n    # If second_smallest_num is still infinity, it means there was no second smallest number\n    if second_smallest_num == float('inf'):\n        return None\n    else:\n        return second_smallest_num", "matching_cluster_idx": 3}, {"solution": "def second_smallest(numbers):\n    # Initialize the smallest and second smallest with positive infinity\n    smallest = second_smallest_num = float('inf')\n    \n    for num in numbers:\n        # Update the smallest and second smallest numbers\n        if num < smallest:\n            second_smallest_num = smallest\n            smallest = num\n        elif smallest < num < second_smallest_num:\n            second_smallest_num = num\n    \n    # Return the second smallest number if it was updated from the initial value\n    return second_smallest_num if second_smallest_num != float('inf') else None", "matching_cluster_idx": 3}]}, "Mbpp/757": {"dps": null, "dps_norm": null, "pass@1": 7.0, "profiled": []}, "Mbpp/758": {"dps": 96.54440154440154, "dps_norm": 86.875, "pass@1": 100.0, "profiled": [{"solution": "from collections import Counter\ndef unique_sublists(lists):\n    # Convert each sublist to a tuple and count occurrences using Counter\n    counts = Counter(tuple(sublist) for sublist in lists)\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Create a dictionary to store the count of each sublist (converted to a tuple)\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts of each sublist\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    # Return the dictionary containing the counts of each unique sublist\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts\n    counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists can't be used as dictionary keys)\n        key = tuple(sublist)\n        \n        # If the key is already in the dictionary, increment its count\n        if key in counts:\n            counts[key] += 1\n        # Otherwise, add the key to the dictionary with a count of 1\n        else:\n            counts[key] = 1\n    \n    return counts", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(list_of_lists):\n    # Convert each sublist into a tuple to make it hashable\n    tuple_list = [tuple(sublist) for sublist in list_of_lists]\n    \n    # Count occurrences of each tuple using Counter\n    count_dict = Counter(tuple_list)\n    \n    # Return the count dictionary\n    return dict(count_dict)", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lst):\n    # Convert each sublist to a tuple to make it hashable and countable\n    tuples = [tuple(sublist) for sublist in lst]\n    # Use Counter to count occurrences of each tuple\n    return dict(Counter(tuples))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts of tuples\n    count_dict = {}\n    \n    # Iterate over each list in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the count of each sublist\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    # Return the dictionary containing the count of each unique sublist\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Create a dictionary to store the counts of each tuple\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "from collections import Counter\ndef unique_sublists(lists):\n    # Convert each sublist to a tuple to make them hashable\n    # Count the occurrences of each tuple using Counter\n    return dict(Counter(tuple(lst) for lst in lists))", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts of each sublist\n    counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be used as dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            counts[tuple_sublist] = 1\n    \n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be dictionary keys)\n        key = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if key in count_dict:\n            count_dict[key] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[key] = 1\n    \n    # Return the dictionary containing the counts of each unique sublist\n    return count_dict", "matching_cluster_idx": 6}, {"solution": "from collections import defaultdict\ndef unique_sublists(lists):\n    # Initialize a default dictionary to store the counts of each sublist\n    sublist_counts = defaultdict(int)\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple and use it as a key in the dictionary\n        sublist_tuple = tuple(sublist)\n        # Increment the count for the tuple in the dictionary\n        sublist_counts[sublist_tuple] += 1\n    \n    # Convert the defaultdict to a regular dictionary before returning\n    return dict(sublist_counts)", "matching_cluster_idx": 5}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the count of each sublist\n    result = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (as lists are not hashable and cannot be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            result[tuple_sublist] = 1\n    \n    return result", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts\n    sublist_count = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be used as dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in sublist_count:\n            sublist_count[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            sublist_count[tuple_sublist] = 1\n    \n    return sublist_count", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Initialize an empty dictionary to store the counts\n    sublist_counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple to make it hashable\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in sublist_counts:\n            sublist_counts[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            sublist_counts[tuple_sublist] = 1\n    \n    return sublist_counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple so it can be used as a dictionary key\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in count_dict:\n            count_dict[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            count_dict[tuple_sublist] = 1\n    \n    return count_dict", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lists):\n    # Create an empty dictionary to store the counts of each sublist\n    counts = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in lists:\n        # Convert the sublist to a tuple (since lists are not hashable and cannot be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in counts:\n            counts[tuple_sublist] += 1\n        # Otherwise, add the tuple to the dictionary with a count of 1\n        else:\n            counts[tuple_sublist] = 1\n    \n    # Return the dictionary with the counts\n    return counts", "matching_cluster_idx": 6}, {"solution": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts of each sublist\n    result = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple (since lists can't be dictionary keys)\n        tuple_sublist = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if tuple_sublist in result:\n            result[tuple_sublist] += 1\n        # If the tuple is not in the dictionary, add it with a count of 1\n        else:\n            result[tuple_sublist] = 1\n    \n    return result", "matching_cluster_idx": 6}]}, "Mbpp/760": {"dps": 99.27007299270073, "dps_norm": 87.5, "pass@1": 100.0, "profiled": [{"solution": "def unique_Element(lst):\n    # Convert the list to a set and check if its length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set and check if its length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicate elements\n    # If the length of the set is 1, then the list contains only one distinct element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if the set has only one element\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    # Convert the list to a set to remove duplicate elements\n    unique_numbers = set(numbers)\n    \n    # Check if the length of the set is 1, indicating all elements in the list were the same\n    return len(unique_numbers) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    # Check if the set has only one element\n    return len(unique_numbers) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    # If the set has only one element, the list contains only one distinct element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, then the list contains only one distinct element\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicate elements\n    unique_set = set(lst)\n    \n    # Check if the set has exactly one element\n    return len(unique_set) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, then all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    # If the length of the set is 1, it means all elements in the list were the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    # Convert the list to a set to remove duplicate elements\n    unique_numbers = set(numbers)\n    # Check if the set has only one element\n    return len(unique_numbers) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if the set has only one element\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(nums):\n    # Convert the list to a set to remove duplicates and check its length\n    return len(set(nums)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicate elements\n    # If the length of the set is 1, then all elements in the list are the same\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates and check its length\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Check if the set contains exactly one element\n    return len(unique_elements) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set to remove duplicates and check its length\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(lst):\n    # Convert the list to a set and check if its length is 1\n    return len(set(lst)) == 1", "matching_cluster_idx": 6}, {"solution": "def unique_Element(numbers):\n    # Convert the list to a set to remove duplicate elements\n    unique_numbers = set(numbers)\n    # Check if the length of the set is 1, indicating all elements in the list are the same\n    return len(unique_numbers) == 1", "matching_cluster_idx": 6}]}, "Mbpp/764": {"dps": 84.4753086419753, "dps_norm": 48.333333333333336, "pass@1": 100.0, "profiled": [{"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the digit count\n            digit_count += 1\n    \n    # Return the final count of digits\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "import re\ndef number_ctr(s):\n    # Use regular expression to find all digits in the string\n    digits = re.findall(r'\\d', s)\n    # Return the count of digits found\n    return len(digits)", "matching_cluster_idx": 0}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to count the digits in the string\n    count = 0\n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it is a digit\n            count += 1\n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            count += 1\n    \n    return count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter to zero\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if the character is a digit\n            digit_count += 1\n    \n    # Return the total count of digits\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(input_string):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in input_string:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the digit counter\n            digit_count += 1\n    \n    # Return the final count of digits\n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}, {"solution": "def number_ctr(s):\n    # Initialize a counter for digits\n    digit_count = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            digit_count += 1\n    \n    return digit_count", "matching_cluster_idx": 2}]}, "Mbpp/766": {"dps": 72.66355140186916, "dps_norm": 66.66666666666667, "pass@1": 100.0, "profiled": [{"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive items\n    result = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Create pairs of consecutive items using zip\n    result = list(zip(lst, lst[1:]))\n    return result", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Create pairs of consecutive items using zip\n    result = list(zip(lst, lst[1:]))\n    return result", "matching_cluster_idx": 5}, {"solution": "def pair_wise(items):\n    # Use list comprehension to create pairs of consecutive items\n    return [(items[i], items[i + 1]) for i in range(len(items) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive elements\n    result = [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create pairs of consecutive elements using zip\n    result = list(zip(lst, lst[1:]))\n    return result", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive items\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]\n    return pairs", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Generate a list of tuples containing consecutive pairs\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(items):\n    # Use list comprehension to create pairs of consecutive items\n    return [(items[i], items[i+1]) for i in range(len(items) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create a list of tuples containing consecutive pairs from the input list\n    result = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive items\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create a list of tuples, each containing a pair of consecutive items\n    result = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items using zip\n    return list(zip(lst, lst[1:]))", "matching_cluster_idx": 5}, {"solution": "def pair_wise(lst):\n    # Create a list of tuples containing each pair of consecutive items\n    result = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive items\n    result = [(lst[i], lst[i+1]) for i in range(len(lst)-1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create a list of tuples, each containing a pair of consecutive elements\n    result = [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Use list comprehension to create pairs of consecutive items\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]", "matching_cluster_idx": 2}, {"solution": "def pair_wise(input_list):\n    # Generate pairs of consecutive items using list comprehension\n    result = [(input_list[i], input_list[i+1]) for i in range(len(input_list) - 1)]\n    return result", "matching_cluster_idx": 2}, {"solution": "def pair_wise(lst):\n    # Create a list of tuples containing each pair of consecutive items\n    return [(lst[i], lst[i + 1]) for i in range(len(lst) - 1)]", "matching_cluster_idx": 3}, {"solution": "def pair_wise(lst):\n    # Generate pairs of consecutive items using zip\n    result = list(zip(lst, lst[1:]))\n    return result", "matching_cluster_idx": 5}]}, "Mbpp/775": {"dps": 92.96, "dps_norm": 70.0, "pass@1": 100.0, "profiled": [{"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # If the number at an odd index is not odd, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, but only check elements at odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the element at the odd index is odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list with index and value\n    for index, value in enumerate(nums):\n        # Check if the index is odd\n        if index % 2 != 0:\n            # Check if the value at the odd index is not odd\n            if value % 2 == 0:\n                return False\n    return True", "matching_cluster_idx": 2}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # If the number at the odd index is not odd, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all odd indices contain odd numbers, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only the odd indices\n    for i in range(1, len(nums), 2):\n        # If the number at the odd index is not odd, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the element at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking only the odd indices\n    for i in range(1, len(nums), 2):\n        # If the number at the odd index is not odd, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:  # Check if the number at the odd index is even\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate through the list, checking only odd indices\n    for i in range(1, len(nums), 2):\n        # If the number at an odd index is not odd, return False\n        if nums[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, but only check elements at odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the element at the odd index is not an odd number\n        if nums[i] % 2 == 0:\n            return False\n    # If all elements at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}, {"solution": "def odd_position(nums):\n    # Iterate over the list, checking only the odd indices\n    for i in range(1, len(nums), 2):\n        # Check if the number at the odd index is not odd\n        if nums[i] % 2 == 0:\n            return False\n    # If all numbers at odd indices are odd, return True\n    return True", "matching_cluster_idx": 4}]}, "Mbpp/777": {"dps": null, "dps_norm": null, "pass@1": 0.0, "profiled": []}, "Mbpp/781": {"dps": 88.03149606299212, "dps_norm": 43.0, "pass@1": 100.0, "profiled": [{"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Increment the divisor count\n    # Return True if the count of divisors is even, otherwise False\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter to count the divisors\n    count = 0\n    # Iterate through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the divisor count\n            count += 1\n    # Return True if the count of divisors is even, otherwise False\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a count variable to keep track of the number of divisors\n    count = 0\n    # Loop through all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through possible divisors from 1 to n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a count variable to keep track of divisors\n    count = 0\n    # Iterate through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for divisors\n    count = 0\n    # Loop through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive) to count the divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Iterate through numbers from 1 to n (inclusive) to count divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize the count of divisors\n    count = 0\n    # Loop through numbers from 1 to n to check if they are divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Return True if the count of divisors is even, otherwise False\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through all numbers from 1 to n to check if they are divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop to find all divisors of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If divisors are equal, count only one\n            if n // i == i:\n                count += 1\n            else:\n                # Otherwise, count both divisors\n                count += 2\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 4}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    \n    # Loop through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter to count the divisors\n    count = 0\n    # Loop through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n to check for divisors\n    for i in range(1, n + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Increment the count\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # If i is a divisor of n, increment the count\n        if n % i == 0:\n            count += 1\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    # Return True if the count of divisors is even, False otherwise\n    return count % 2 == 0", "matching_cluster_idx": 1}, {"solution": "def count_divisors(n):\n    # Initialize a counter for the divisors\n    count = 0\n    # Loop through numbers from 1 to n (inclusive) to find divisors\n    for i in range(1, n + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Increment the count\n    # Check if the count of divisors is even\n    return count % 2 == 0", "matching_cluster_idx": 1}]}, "Mbpp/800": {"dps": 97.31343283582089, "dps_norm": 96.0, "pass@1": 84.0, "profiled": [{"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input_string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the str.replace() method to remove all spaces from the input string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input_string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the str.replace() method to remove all spaces from the input string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input_string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the join() method and a generator expression to filter out spaces\n    return ''.join(char for char in input_string if char != ' ')", "matching_cluster_idx": 0}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces from the input string\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces\n    return input_string.replace(' ', '')", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Using the replace method to remove all spaces from the string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the replace method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}, {"solution": "def remove_all_spaces(input_string):\n    # Use the str.replace() method to remove all spaces from the input string\n    return input_string.replace(\" \", \"\")", "matching_cluster_idx": 4}]}, "Mbpp/805": {"dps": 100.0, "dps_norm": 100.0, "pass@1": 100.0, "profiled": [{"solution": "def max_sum_list(lists):\n    # Use a lambda function to find the list with the maximum sum of elements\n    max_sum = max(lists, key=lambda x: sum(x))\n    return max_sum", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Initialize a variable to keep track of the list with the maximum sum\n    max_list = []\n    # Initialize a variable to keep track of the maximum sum found so far\n    max_sum = float('-inf')\n    \n    # Iterate through each list in the list of lists\n    for lst in lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        # Update the maximum sum and the corresponding list if the current sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    \n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of each list and return the one with the highest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of elements for each list in the list of lists\n    # and return the list with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of each list and return the one with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of each list and return the list with the highest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Use a lambda function to find the list with the highest sum of elements\n    return max(lists, key=lambda x: sum(x))", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum using the key parameter with sum function\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_sum_list = max(lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Use the max function with key parameter to find the list with the highest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the highest sum of elements\n    max_sum_list = max(lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_sum_sublist = max(lists, key=sum)\n    return max_sum_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Use the max function with a key to find the list with the highest sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_list = max(lists, key=sum)\n    return max_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_sum_list = max(lists, key=sum)\n    return max_sum_list", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Find the list with the maximum sum of elements\n    max_sum_sublist = max(lists, key=sum)\n    return max_sum_sublist", "matching_cluster_idx": 4}, {"solution": "def max_sum_list(lists):\n    # Calculate the sum of each list and return the list with the maximum sum\n    return max(lists, key=sum)", "matching_cluster_idx": 4}]}, "Mbpp/808": {"dps": 68.8157894736842, "dps_norm": 92.5, "pass@1": 100.0, "profiled": [{"solution": "def check_K(tup, k):\n    # Check if 'k' is present in the tuple 'tup'\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    # Check if 'k' is in the tuple 'tup'\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    # Check if k is present in the tuple\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple tup\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    # Check if k is in the tuple\n    return k in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    # Check if 'k' is present in the tuple 'tup'\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(test_tup, K):\n    # Check if K is in the tuple\n    res = K in test_tup\n    return res", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    # Check if k is present in the tuple\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, K):\n    # Check if K is in the tuple\n    return K in tup", "matching_cluster_idx": 5}, {"solution": "def check_K(tup, k):\n    # Check if k is present in the tuple\n    return k in tup", "matching_cluster_idx": 4}, {"solution": "def check_K(tup, k):\n    # Check if k is present in the tuple tup\n    return k in tup", "matching_cluster_idx": 5}]}}}
